1701
#method_before
public Iterable<Link> getPatchSetLinks(String project, String commit) {
    List<Link> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getImageUrl(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#method_after
public Iterable<WebLinkInfo> getPatchSetLinks(String project, String commit) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#end_block

#method_before
public Iterable<Link> getProjectLinks(String project) {
    List<Link> links = Lists.newArrayList();
    for (ProjectWebLink webLink : projectLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getImageUrl(), webLink.getProjectUrl(project)));
    }
    return links;
}
#method_after
public Iterable<WebLinkInfo> getProjectLinks(String project) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (ProjectWebLink webLink : projectLinks) {
        links.add(new WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getProjectUrl(project)));
    }
    return links;
}
#end_block

#method_before
private void addWebLink(String href, String name, String imageUrl) {
    Anchor a = new Anchor();
    a.setHref(href);
    if (imageUrl != null && !imageUrl.isEmpty()) {
        Image img = new Image();
        img.setAltText(parenthesize(name));
        img.setUrl(imageUrl);
        img.setTitle(name);
        a.getElement().appendChild(img.getElement());
    } else {
        a.setText(parenthesize(name));
    }
    webLinkPanel.add(a);
}
#method_after
private void addWebLink(String href, String name, String imageUrl) {
    Anchor a = new Anchor();
    a.setHref(href);
    if (imageUrl != null && !imageUrl.isEmpty()) {
        Image img = new Image();
        img.setAltText(name);
        img.setUrl(imageUrl);
        img.setTitle(name);
        a.getElement().appendChild(img.getElement());
    } else {
        a.setText(name);
    }
    webLinkPanel.add(a);
}
#end_block

#method_before
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        AvatarImage avatar;
        if (change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email()));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        AvatarImage avatar;
        if (change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
static ChangeScreen2 get(NativeEvent in) {
    com.google.gwt.user.client.Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#method_after
static ChangeScreen2 get(NativeEvent in) {
    Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new GerritCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.WEB_LINKS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                RevisionInfo revisionInfo = revisions.get(i + offset);
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisionInfo._number(), revisionInfo.edit())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    RevisionInfo revisionInfo = info.revision(revision);
    String currentlyViewedPatchSet = revisionInfo.id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision) {
    String currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision()).id();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1).id();
    }
    String currentlyViewedPatchSet = info.revision(revision).id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectQuery.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            Gerrit.display(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
        }
    }, ClickEvent.getType());
    projectLink.setText(info.project());
    projectLink.setTargetHistoryToken(PageLinks.toProject(info.project_name_key()));
}
#method_after
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.project_name_key()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.project_name_key()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
}
#end_block

#method_before
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), info.topic())));
}
#method_after
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), null)));
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.setRevisions(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()));
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    ChangeApi.revision(changeId.get(), rev.name()).view("commit").get(group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.is_edit()) {
        return;
    }
    ChangeApi.revision(changeId.get(), rev.name()).view("commit").get(group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(r.id())) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#method_after
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    RevisionInfo revisionInfo = info.revision(revision);
    if (revisionInfo.edit()) {
        statusText.setInnerText(Util.C.revisionEdit());
    } else {
        if (!current && info.status() == Change.Status.NEW) {
            statusText.setInnerText(Util.C.notCurrent());
        } else {
            statusText.setInnerText(Util.toLongString(info.status()));
        }
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    quickApprove.set(info, revision, replyAction);
    if (current) {
        loadSubmitType(info.status(), canSubmit);
    } else {
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    String email = info.owner().email() != null ? info.owner().email() : name;
    ownerText.setInnerText(name);
    ownerText.setTitle(email);
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#end_block

#method_before
private void renderSubmitType(String action) {
    try {
        SubmitType type = Project.SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#method_after
private void renderSubmitType(String action) {
    try {
        SubmitType type = SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(r.id())) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    com.google.gwt.user.client.Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#method_after
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        CallbackGroup group = new CallbackGroup();
        if (Gerrit.isSignedIn()) {
            // TODO(davido): It shouldn't be necessary to make this call.
            // PatchSetsBox is constructed via PatchSetsAction which is
            // only initialized by CS2 after loading the EditInfo in that path.
            ChangeApi.edit(changeId.get(), group.add(new GerritCallback<EditInfo>() {

                @Override
                public void onSuccess(EditInfo result) {
                    edit = result;
                }
            }));
        }
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(group.addFinal(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                if (edit != null) {
                    edit.set_name(edit.commit().commit());
                    result.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
                }
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id());
    if (r.draft()) {
        sb.append(Resources.C.draft()).append(' ');
    }
    if (r.has_draft_comments()) {
        sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' ');
    }
    sb.append(r.id());
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : null;
    String cn = c.committer() != null ? c.committer().name() : null;
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#method_after
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id());
    if (r.draft()) {
        sb.append(Resources.C.draft()).append(' ');
    }
    if (r.has_draft_comments()) {
        sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' ');
    }
    sb.append(r._number());
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : "";
    String cn = c.committer() != null ? c.committer().name() : "";
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#end_block

#method_before
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, r.id());
}
#method_after
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, String.valueOf(r._number()));
}
#end_block

#method_before
private IndexedChangeQuery query(Predicate<ChangeData> p) throws QueryParseException {
    return query(p, IndexRewriteImpl.DEFAULT_MAX_LIMIT);
}
#method_after
private IndexedChangeQuery query(Predicate<ChangeData> p) throws QueryParseException {
    return query(p, DEFAULT_MAX_QUERY_LIMIT);
}
#end_block

#method_before
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) throws QueryParseException {
    ChangeIndex index = indexes.getSearchIndex();
    in = basicRewrites.rewrite(in);
    int limit = Objects.firstNonNull(ChangeQueryBuilder.getLimit(in), DEFAULT_MAX_LIMIT);
    // Increase the limit rather than skipping, since we don't know how many
    // skipped results would have been filtered out by the enclosing AndSource.
    limit += start;
    limit = Math.max(limit, 1);
    Predicate<ChangeData> out = rewriteImpl(in, index, limit);
    if (in == out || out instanceof IndexPredicate) {
        return new IndexedChangeQuery(index, out, limit);
    } else if (out == null) /* cannot rewrite */
    {
        return in;
    } else {
        return out;
    }
}
#method_after
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) throws QueryParseException {
    ChangeIndex index = indexes.getSearchIndex();
    in = basicRewrites.rewrite(in);
    int limit = Objects.firstNonNull(ChangeQueryBuilder.getLimit(in), DEFAULT_MAX_QUERY_LIMIT);
    // Increase the limit rather than skipping, since we don't know how many
    // skipped results would have been filtered out by the enclosing AndSource.
    limit += start;
    limit = Math.max(limit, 1);
    Predicate<ChangeData> out = rewriteImpl(in, index, limit);
    if (in == out || out instanceof IndexPredicate) {
        return new IndexedChangeQuery(index, out, limit);
    } else if (out == null) /* cannot rewrite */
    {
        return in;
    } else {
        return out;
    }
}
#end_block

#method_before
@Override
protected Reader wrapReader(String fieldName, Reader reader) {
    NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();
    for (Entry<String, String> e : customMappings.entrySet()) {
        builder.add(e.getKey(), e.getValue());
    }
    NormalizeCharMap normMap = builder.build();
    return new MappingCharFilter(normMap, reader);
}
#method_after
@Override
protected Reader wrapReader(String fieldName, Reader reader) {
    NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();
    for (Map.Entry<String, String> e : customMappings.entrySet()) {
        builder.add(e.getKey(), e.getValue());
    }
    return new MappingCharFilter(builder.build(), reader);
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxNumberLimit = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxNumberLimit != 0 && pending.size() > maxNumberLimit) {
                reject(magicBranch.cmd, "The number of pushed changes in a batch exceeds the max limit " + maxNumberLimit);
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void validate() throws UnloggedFailure {
    if (active && inactive) {
        throw new UnloggedFailure(1, "--active and --inactive options are mutually exclusive.");
    }
    if (clearHttpPassword && !Strings.isNullOrEmpty(httpPassword)) {
        throw new UnloggedFailure(1, "--http-password and --clear-http-password options are mutually " + "exclusive.");
    }
    if (addSshKeys.contains("-") && deleteSshKeys.contains("-")) {
        throw new UnloggedFailure(1, "Only one option may use the stdin");
    }
    if (deleteSshKeys.contains("ALL")) {
        deleteSshKeys = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains("ALL")) {
        deleteEmails = Collections.singletonList("ALL");
    }
}
#method_after
private void validate() throws UnloggedFailure {
    if (active && inactive) {
        throw new UnloggedFailure(1, "--active and --inactive options are mutually exclusive.");
    }
    if (clearHttpPassword && !Strings.isNullOrEmpty(httpPassword)) {
        throw new UnloggedFailure(1, "--http-password and --clear-http-password options are mutually " + "exclusive.");
    }
    if (addSshKeys.contains("-") && deleteSshKeys.contains("-")) {
        throw new UnloggedFailure(1, "Only one option may use the stdin");
    }
    if (deleteSshKeys.contains("ALL")) {
        deleteSshKeys = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains("ALL")) {
        deleteEmails = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains(preferredEmail)) {
        throw new UnloggedFailure(1, "--preferred-email and --delete-email options are mutually " + "exclusive for the same email address.");
    }
}
#end_block

#method_before
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    user = genericUserFactory.create(id);
    rsrc = new AccountResource(user);
    try {
        for (String email : addEmails) {
            addEmail(email);
        }
        for (String email : deleteEmails) {
            deleteEmail(email);
        }
        if (preferred != null && !preferred.isEmpty()) {
            putPreferred(preferred);
        }
        if (fullName != null) {
            PutName.Input in = new PutName.Input();
            in.name = fullName;
            putName.apply(rsrc, in);
        }
        if (httpPassword != null || clearHttpPassword) {
            PutHttpPassword.Input in = new PutHttpPassword.Input();
            in.httpPassword = httpPassword;
            putHttpPassword.apply(rsrc, in);
        }
        if (active) {
            putActive.apply(rsrc, null);
        } else if (inactive) {
            try {
                deleteActive.apply(rsrc, null);
            } catch (ResourceNotFoundException e) {
            // user is already inactive
            }
        }
        addSshKeys = readSshKey(addSshKeys);
        if (!addSshKeys.isEmpty()) {
            addSshKeys(addSshKeys);
        }
        deleteSshKeys = readSshKey(deleteSshKeys);
        if (!deleteSshKeys.isEmpty()) {
            deleteSshKeys(deleteSshKeys);
        }
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#method_after
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    user = genericUserFactory.create(id);
    rsrc = new AccountResource(user);
    try {
        for (String email : addEmails) {
            addEmail(email);
        }
        for (String email : deleteEmails) {
            deleteEmail(email);
        }
        if (preferredEmail != null) {
            putPreferred(preferredEmail);
        }
        if (fullName != null) {
            PutName.Input in = new PutName.Input();
            in.name = fullName;
            putName.apply(rsrc, in);
        }
        if (httpPassword != null || clearHttpPassword) {
            PutHttpPassword.Input in = new PutHttpPassword.Input();
            in.httpPassword = httpPassword;
            putHttpPassword.apply(rsrc, in);
        }
        if (active) {
            putActive.apply(rsrc, null);
        } else if (inactive) {
            try {
                deleteActive.apply(rsrc, null);
            } catch (ResourceNotFoundException e) {
            // user is already inactive
            }
        }
        addSshKeys = readSshKey(addSshKeys);
        if (!addSshKeys.isEmpty()) {
            addSshKeys(addSshKeys);
        }
        deleteSshKeys = readSshKey(deleteSshKeys);
        if (!deleteSshKeys.isEmpty()) {
            deleteSshKeys(deleteSshKeys);
        }
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#end_block

#method_before
private void deleteEmail(String email) throws UnloggedFailure, RestApiException, OrmException {
    if (email.equals("ALL")) {
        List<EmailInfo> emails = getEmails.apply(rsrc);
        ;
        for (EmailInfo e : emails) {
            deleteEmail.apply(new AccountResource.Email(user, e.email), new DeleteEmail.Input());
        }
    } else {
        deleteEmail.apply(new AccountResource.Email(user, email), new DeleteEmail.Input());
    }
}
#method_after
private void deleteEmail(String email) throws UnloggedFailure, RestApiException, OrmException {
    if (email.equals("ALL")) {
        List<EmailInfo> emails = getEmails.apply(rsrc);
        for (EmailInfo e : emails) {
            deleteEmail.apply(new AccountResource.Email(user, e.email), new DeleteEmail.Input());
        }
    } else {
        deleteEmail.apply(new AccountResource.Email(user, email), new DeleteEmail.Input());
    }
}
#end_block

#method_before
private void putPreferred(String email) throws RestApiException, OrmException {
    List<EmailInfo> emails = getEmails.apply(rsrc);
    for (EmailInfo e : emails) {
        if (e.email.equals(email)) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
        }
    }
}
#method_after
private void putPreferred(String email) throws RestApiException, OrmException {
    for (EmailInfo e : getEmails.apply(rsrc)) {
        if (e.email.equals(email)) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            return;
        }
    }
    stderr.println("preferred email not found: " + email);
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo();
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    RestResponse r = session.get(urlGetFiles());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    Map<String, FileInfo> result = toFileInfoMap(r);
    assertEquals(2, result.size());
    List<String> l = Lists.newArrayList(result.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    EditInfo info = toEditInfo(true);
    assertEquals(2, info.files.size());
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Put.Input in = new Put.Input();
    in.restore = true;
    assertEquals(SC_NO_CONTENT, session.post(urlEditFile2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, session.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    Put.Input in = new Put.Input();
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#end_block

#method_before
private EditInfo toEditInfo() throws IOException {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#method_after
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = session.get(files ? urlGetFiles() : urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Create post(ChangeResource parent) throws RestApiException {
    return createFactory.create(parent.getChange(), null);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Post post(ChangeResource parent) throws RestApiException {
    return post;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wipped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new ResourceConflictException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new BadRequestException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc) throws AuthException, IOException, NoSuchChangeException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        if (list) {
            PatchSet basePatchSet = null;
            if (base != null) {
                RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
                basePatchSet = baseResource.getPatchSet();
            }
            try {
                return Response.ok(fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet));
            } catch (PatchListNotAvailableException e) {
                throw new ResourceNotFoundException(e.getMessage());
            }
        } else {
            return Response.ok(editJson.toEditInfo(edit.get()));
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get());
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    String path = rsrc.getPath();
    byte[] content = null;
    if (input.content != null) {
        content = ByteStreams.toByteArray(input.content.getInputStream());
    }
    try {
        if (input.restore) {
            editModifier.restoreFile(rsrc.getChangeEdit(), path);
        } else {
            editModifier.modifyFile(rsrc.getChangeEdit(), path, content);
        }
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public BinaryResult apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException, InvalidChangeOperationException {
    try {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath());
    } catch (ResourceNotFoundException rnfe) {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getBasePatchSet().getRevision().get(), rsrc.getPath());
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    put(FILE_KIND, "content").to(PutContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
        }
    });
}
#end_block

#method_before
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.write()) {
        AtomicBoolean removedAllComments = new AtomicBoolean();
        ObjectId treeId = storeCommentsInNotes(removedAllComments);
        if (treeId != null) {
            if (removedAllComments.get()) {
                batch.removeRef(getRefName());
            } else {
                builder.setTreeId(treeId);
                batch.write(builder);
            }
        }
    }
}
#method_after
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.write()) {
        AtomicBoolean removedAllComments = new AtomicBoolean();
        ObjectId treeId = storeCommentsInNotes(removedAllComments);
        if (treeId != null) {
            if (removedAllComments.get()) {
                batch.removeRef(getRefName());
            } else {
                builder.setTreeId(treeId);
                batch.write(builder);
            }
        }
    }
}
#end_block

#method_before
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.write()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(builder);
}
#method_after
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.write()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(builder);
}
#end_block

#method_before
public BinaryResult getContent(Project.NameKey project, String revstr, String path) throws ResourceNotFoundException, IOException {
    Repository repo = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(repo.resolve(revstr));
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree().getId());
            if (tw == null) {
                throw new ResourceNotFoundException();
            }
            try {
                final ObjectLoader object = repo.open(tw.getObjectId(0));
                @SuppressWarnings("resource")
                BinaryResult result = new BinaryResult() {

                    @Override
                    public void writeTo(OutputStream os) throws IOException {
                        object.copyTo(os);
                    }
                };
                return result.setContentLength(object.getSize()).base64();
            } finally {
                tw.release();
            }
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public BinaryResult getContent(Project.NameKey project, String revstr, String path) throws ResourceNotFoundException, IOException {
    Repository repo = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(repo.resolve(revstr));
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree().getId());
            if (tw == null) {
                throw new ResourceNotFoundException();
            }
            final ObjectLoader object = repo.open(tw.getObjectId(0));
            @SuppressWarnings("resource")
            BinaryResult result = new BinaryResult() {

                @Override
                public void writeTo(OutputStream os) throws IOException {
                    object.copyTo(os);
                }
            };
            return result.setContentLength(object.getSize()).base64();
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    int patchSetId = PatchSet.Id.fromRef(ref, ce);
    if (patchSetId >= 0 || ref.substring(ce).equals(RefNames.META_SUFFIX)) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#method_after
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    if (ref.substring(ce).equals(RefNames.META_SUFFIX) || PatchSet.Id.fromRef(ref, ce) >= 0) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#end_block

#method_before
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#method_after
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(ce) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#end_block

#method_before
@Test
public void parsePatchSetRefNames() {
    assertRef(1, "refs/changes/01/1/1");
    assertRef(1234, "refs/changes/34/1234/56");
    // Invalid characters.
    assertNotRef("refs/changes/0x/1/1");
    assertNotRef("refs/changes/01/x/1");
    assertNotRef("refs/changes/01/1/x");
    // Truncations.
    assertNotRef("refs/changes/");
    assertNotRef("refs/changes/1");
    assertNotRef("refs/changes/01");
    assertNotRef("refs/changes/01/");
    assertNotRef("refs/changes/01/1/");
    assertNotRef("refs/changes/01/1/1/");
    assertNotRef("refs/changes/01//1/1");
    // Leading zeroes.
    assertNotRef("refs/changes/01/01/1");
    assertNotRef("refs/changes/01/1/01");
    // Mismatched last 2 digits.
    assertNotRef("refs/changes/35/1234/56");
}
#method_after
@Test
public void parsePatchSetRefNames() {
    assertRef(1, "refs/changes/01/1/1");
    assertRef(1234, "refs/changes/34/1234/56");
    // Invalid characters.
    assertNotRef("refs/changes/0x/1/1");
    assertNotRef("refs/changes/01/x/1");
    assertNotRef("refs/changes/01/1/x");
    // Truncations.
    assertNotRef("refs/changes/");
    assertNotRef("refs/changes/1");
    assertNotRef("refs/changes/01");
    assertNotRef("refs/changes/01/");
    assertNotRef("refs/changes/01/1/");
    assertNotRef("refs/changes/01/1/1/");
    assertNotRef("refs/changes/01//1/1");
    // Leading zeroes.
    assertNotRef("refs/changes/01/01/1");
    assertNotRef("refs/changes/01/1/01");
    // Mismatched last 2 digits.
    assertNotRef("refs/changes/35/1234/56");
    // Something other than patch set after change.
    assertNotRef("refs/changes/34/1234/0");
    assertNotRef("refs/changes/34/1234/foo");
    assertNotRef("refs/changes/34/1234|56");
    assertNotRef("refs/changes/34/1234foo");
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    boolean ok = true;
    for (final PatchSet patchSet : patchSets) {
        try {
            approveOne(patchSet);
        } catch (UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while approving " + patchSet.getId() + "\n");
            log.error("internal error while approving " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw error("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw error("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw error("json and message are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw error("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void applyReview(PatchSet patchSet, final ReviewInput review) throws Exception {
    gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#method_after
private void applyReview(PatchSet patchSet, final ReviewInput review) throws RestApiException {
    gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#end_block

#method_before
private void audit(Context ctx, Object result, String cmd, Multimap<String, ?> params) {
    final long created = ctx == null ? TimeUtil.nowMs() : ctx.created;
    final SshSession session = ctx == null ? null : ctx.getSession();
    final String sid = session == null ? null : IdGenerator.format(session.getSessionId());
    final CurrentUser user = session == null ? null : session.getCurrentUser();
    auditService.dispatch(new SshAuditEvent(sid, user, cmd, created, params, result));
}
#method_after
private void audit(Context ctx, Object result, String cmd, Multimap<String, ?> params) {
    String sessionId;
    CurrentUser currentUser;
    long created;
    if (ctx == null) {
        sessionId = null;
        currentUser = null;
        created = TimeUtil.nowMs();
    } else {
        SshSession session = ctx.getSession();
        sessionId = IdGenerator.format(session.getSessionId());
        currentUser = session.getCurrentUser();
        created = ctx.created;
    }
    auditService.dispatch(new SshAuditEvent(sessionId, currentUser, cmd, created, params, result));
}
#end_block

#method_before
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    String[] args = dcmd.getArguments();
    if (args.length > 1) {
        return commandName + "." + args[1];
    } else {
        return commandName;
    }
}
#method_after
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    String[] args = dcmd.getArguments();
    if (args.length > 1) {
        return commandName + "." + args[1];
    }
    return commandName;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    install(new FactoryModuleBuilder().build(CreateBranch.Factory.class));
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    install(new FactoryModuleBuilder().build(CreateBranch.Factory.class));
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#end_block

#method_before
@Override
public CommitResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, AuthException, IOException {
    if (!parent.getControl().isOwner()) {
        throw new AuthException("no project owner");
    }
    ObjectId objectId;
    try {
        objectId = ObjectId.fromString(id.get());
    } catch (IllegalArgumentException e) {
        throw new ResourceNotFoundException(id);
    }
    Repository repo = repoManager.openRepository(parent.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(objectId);
            for (int i = 0; i < commit.getParentCount(); i++) {
                rw.parseCommit(commit.getParent(i));
            }
            return new CommitResource(parent.getControl(), commit);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
@Override
public CommitResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException {
    ObjectId objectId;
    try {
        objectId = ObjectId.fromString(id.get());
    } catch (IllegalArgumentException e) {
        throw new ResourceNotFoundException(id);
    }
    Repository repo = repoManager.openRepository(parent.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(objectId);
            if (!parent.getControl().canReadCommit(rw, commit)) {
                throw new ResourceNotFoundException(id);
            }
            for (int i = 0; i < commit.getParentCount(); i++) {
                rw.parseCommit(commit.getParent(i));
            }
            return new CommitResource(parent.getControl(), commit);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Test
public void getCommit() throws IOException {
    RestResponse r = adminSession.get("/projects/" + project.get() + "/branches/" + IdString.fromDecoded("refs/meta/config").encoded());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    BranchInfo branchInfo = newGson().fromJson(r.getReader(), BranchInfo.class);
    r.consume();
    r = adminSession.get("/projects/" + project.get() + "/commits/" + branchInfo.revision);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    CommitInfo commitInfo = newGson().fromJson(r.getReader(), CommitInfo.class);
    assertEquals(branchInfo.revision, commitInfo.commit);
    assertEquals("Created project", commitInfo.subject);
    assertEquals("Created project\n", commitInfo.message);
    assertNotNull(commitInfo.author);
    assertEquals("Administrator", commitInfo.author.name);
    assertNotNull(commitInfo.committer);
    assertEquals("Gerrit Code Review", commitInfo.committer.name);
    assertTrue(commitInfo.parents.isEmpty());
}
#method_after
@Test
public void getCommit() throws IOException {
    RestResponse r = adminSession.get("/projects/" + project.get() + "/branches/" + IdString.fromDecoded(RefNames.REFS_CONFIG).encoded());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    BranchInfo branchInfo = newGson().fromJson(r.getReader(), BranchInfo.class);
    r.consume();
    r = adminSession.get("/projects/" + project.get() + "/commits/" + branchInfo.revision);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    CommitInfo commitInfo = newGson().fromJson(r.getReader(), CommitInfo.class);
    assertEquals(branchInfo.revision, commitInfo.commit);
    assertEquals("Created project", commitInfo.subject);
    assertEquals("Created project\n", commitInfo.message);
    assertNotNull(commitInfo.author);
    assertEquals("Administrator", commitInfo.author.name);
    assertNotNull(commitInfo.committer);
    assertEquals("Gerrit Code Review", commitInfo.committer.name);
    assertTrue(commitInfo.parents.isEmpty());
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key.get()).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append('}');
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append('}');
    return builder.toString();
}
#end_block

#method_before
public List<PatchLineComment> publishedByChangeFile(ReviewDb db, ChangeNotes notes, Change.Id changeId, String file) throws OrmException {
    if (!migration.readPublishedComments()) {
        return db.patchComments().publishedByChangeFile(changeId, file).toList();
    }
    notes.load();
    List<PatchLineComment> commentsOnFile = new ArrayList<PatchLineComment>();
    // We must iterate through all comments to find the ones on this file.
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator);
    return commentsOnFile;
}
#method_after
public List<PatchLineComment> publishedByChangeFile(ReviewDb db, ChangeNotes notes, Change.Id changeId, String file) throws OrmException {
    if (!migration.readPublishedComments()) {
        return db.patchComments().publishedByChangeFile(changeId, file).toList();
    }
    notes.load();
    List<PatchLineComment> commentsOnFile = new ArrayList<PatchLineComment>();
    // We must iterate through all comments to find the ones on this file.
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    addCommentsInFile(commentsOnFile, notes.getPatchSetComments().values(), file);
    Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator);
    return commentsOnFile;
}
#end_block

#method_before
private Collection<PatchLineComment> addCommentsInFile(Collection<PatchLineComment> commentsOnFile, Collection<PatchLineComment> allComments, String file) {
    for (PatchLineComment c : allComments) {
        String currentFilename = c.getKey().getParentKey().getFileName();
        if (currentFilename.equals(file)) {
            commentsOnFile.add(c);
        }
    }
    return commentsOnFile;
}
#method_after
private static Collection<PatchLineComment> addCommentsInFile(Collection<PatchLineComment> commentsOnFile, Collection<PatchLineComment> allComments, String file) {
    for (PatchLineComment c : allComments) {
        String currentFilename = c.getKey().getParentKey().getFileName();
        if (currentFilename.equals(file)) {
            commentsOnFile.add(c);
        }
    }
    return commentsOnFile;
}
#end_block

#method_before
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    ChangeNotes notes = control.getNotes();
    for (final PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user.isIdentifiedUser()) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(changes.parse(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#method_after
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    ChangeNotes notes = control.getNotes();
    for (PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user.isIdentifiedUser()) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(changes.parse(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    @SuppressWarnings("unchecked")
    final DynamicMap<RestView<CommentResource>> views = createMock(DynamicMap.class);
    final TypeLiteral<DynamicMap<RestView<CommentResource>>> viewsType = new TypeLiteral<DynamicMap<RestView<CommentResource>>>() {
    };
    final AccountInfo.Loader.Factory alf = createMock(AccountInfo.Loader.Factory.class);
    final ReviewDb db = createMock(ReviewDb.class);
    final FakeAccountCache accountCache = new FakeAccountCache();
    final PersonIdent serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    @SuppressWarnings("unused")
    InMemoryRepository repo = repoManager.createRepository(project);
    AbstractModule mod = new AbstractModule() {

        @Override
        protected void configure() {
            bind(viewsType).toInstance(views);
            bind(AccountInfo.Loader.Factory.class).toInstance(alf);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(db));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(config);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            install(new GitModule());
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
        }
    };
    injector = Guice.createInjector(mod);
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account.Id ownerId = co.getId();
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    Account.Id otherUserId = ou.getId();
    IdentifiedUser.GenericFactory userFactory = injector.getInstance(IdentifiedUser.GenericFactory.class);
    changeOwner = userFactory.create(ownerId);
    IdentifiedUser otherUser = userFactory.create(otherUserId);
    AccountInfo.Loader accountLoader = createMock(AccountInfo.Loader.class);
    accountLoader.fill();
    expectLastCall().anyTimes();
    expect(accountLoader.get(ownerId)).andReturn(new AccountInfo(ownerId)).anyTimes();
    expect(accountLoader.get(otherUserId)).andReturn(new AccountInfo(otherUserId)).anyTimes();
    expect(alf.create(true)).andReturn(accountLoader).anyTimes();
    replay(accountLoader, alf);
    PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class);
    expect(db.patchComments()).andReturn(plca).anyTimes();
    Change change = newChange();
    PatchSet.Id psId1 = new PatchSet.Id(change.getId(), 1);
    PatchSet ps1 = new PatchSet(psId1);
    PatchSet.Id psId2 = new PatchSet.Id(change.getId(), 2);
    PatchSet ps2 = new PatchSet(psId2);
    long timeBase = TimeUtil.nowMs();
    plc1 = newPatchLineComment(psId1, "Comment1", null, "FileOne.txt", Side.REVISION, 3, ownerId, timeBase, "First Comment", new CommentRange(1, 2, 3, 4));
    plc1.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc2 = newPatchLineComment(psId1, "Comment2", "Comment1", "FileOne.txt", Side.REVISION, 3, otherUserId, timeBase + 1000, "Reply to First Comment", new CommentRange(1, 2, 3, 4));
    plc2.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc3 = newPatchLineComment(psId1, "Comment3", "Comment1", "FileOne.txt", Side.PARENT, 3, ownerId, timeBase + 2000, "First Parent Comment", new CommentRange(1, 2, 3, 4));
    plc3.setRevId(new RevId("CDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEF"));
    expect(plca.publishedByPatchSet(psId1)).andAnswer(results(plc1, plc2, plc3)).anyTimes();
    expect(plca.publishedByPatchSet(psId2)).andAnswer(results()).anyTimes();
    replay(db, plca);
    // Here, we are writing the comments to the notedb so that we can
    // read from and test the notedb when the noteDb config is enabled.
    ChangeUpdate update = newUpdate(change, changeOwner);
    update.setPatchSetId(psId1);
    update.putComment(plc1);
    update.putComment(plc3);
    update.commit();
    update = newUpdate(change, otherUser);
    update.setPatchSetId(psId1);
    update.putComment(plc2);
    update.commit();
    ChangeControl ctl = stubChangeControl(change);
    revRes1 = new RevisionResource(new ChangeResource(ctl), ps1);
    revRes2 = new RevisionResource(new ChangeResource(ctl), ps2);
}
#method_after
@Before
public void setUp() throws Exception {
    @SuppressWarnings("unchecked")
    final DynamicMap<RestView<CommentResource>> views = createMock(DynamicMap.class);
    final TypeLiteral<DynamicMap<RestView<CommentResource>>> viewsType = new TypeLiteral<DynamicMap<RestView<CommentResource>>>() {
    };
    final AccountInfo.Loader.Factory alf = createMock(AccountInfo.Loader.Factory.class);
    final ReviewDb db = createMock(ReviewDb.class);
    final FakeAccountCache accountCache = new FakeAccountCache();
    final PersonIdent serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    @SuppressWarnings("unused")
    InMemoryRepository repo = repoManager.createRepository(project);
    AbstractModule mod = new AbstractModule() {

        @Override
        protected void configure() {
            bind(viewsType).toInstance(views);
            bind(AccountInfo.Loader.Factory.class).toInstance(alf);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(db));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(config);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            install(new GitModule());
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
        }
    };
    injector = Guice.createInjector(mod);
    NotesMigration migration = injector.getInstance(NotesMigration.class);
    plcUtil = new PatchLineCommentsUtil(migration);
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account.Id ownerId = co.getId();
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    Account.Id otherUserId = ou.getId();
    IdentifiedUser.GenericFactory userFactory = injector.getInstance(IdentifiedUser.GenericFactory.class);
    changeOwner = userFactory.create(ownerId);
    IdentifiedUser otherUser = userFactory.create(otherUserId);
    AccountInfo.Loader accountLoader = createMock(AccountInfo.Loader.class);
    accountLoader.fill();
    expectLastCall().anyTimes();
    expect(accountLoader.get(ownerId)).andReturn(new AccountInfo(ownerId)).anyTimes();
    expect(accountLoader.get(otherUserId)).andReturn(new AccountInfo(otherUserId)).anyTimes();
    expect(alf.create(true)).andReturn(accountLoader).anyTimes();
    replay(accountLoader, alf);
    PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class);
    expect(db.patchComments()).andReturn(plca).anyTimes();
    Change change = newChange();
    PatchSet.Id psId1 = new PatchSet.Id(change.getId(), 1);
    PatchSet ps1 = new PatchSet(psId1);
    PatchSet.Id psId2 = new PatchSet.Id(change.getId(), 2);
    PatchSet ps2 = new PatchSet(psId2);
    long timeBase = TimeUtil.nowMs();
    plc1 = newPatchLineComment(psId1, "Comment1", null, "FileOne.txt", Side.REVISION, 3, ownerId, timeBase, "First Comment", new CommentRange(1, 2, 3, 4));
    plc1.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc2 = newPatchLineComment(psId1, "Comment2", "Comment1", "FileOne.txt", Side.REVISION, 3, otherUserId, timeBase + 1000, "Reply to First Comment", new CommentRange(1, 2, 3, 4));
    plc2.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc3 = newPatchLineComment(psId1, "Comment3", "Comment1", "FileOne.txt", Side.PARENT, 3, ownerId, timeBase + 2000, "First Parent Comment", new CommentRange(1, 2, 3, 4));
    plc3.setRevId(new RevId("CDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEF"));
    List<PatchLineComment> commentsByOwner = Lists.newArrayList();
    commentsByOwner.add(plc1);
    commentsByOwner.add(plc3);
    List<PatchLineComment> commentsByReviewer = Lists.newArrayList();
    commentsByReviewer.add(plc2);
    plca.upsert(commentsByOwner);
    expectLastCall().anyTimes();
    plca.upsert(commentsByReviewer);
    expectLastCall().anyTimes();
    expect(plca.publishedByPatchSet(psId1)).andAnswer(results(plc1, plc2, plc3)).anyTimes();
    expect(plca.publishedByPatchSet(psId2)).andAnswer(results()).anyTimes();
    replay(db, plca);
    ChangeUpdate update = newUpdate(change, changeOwner);
    update.setPatchSetId(psId1);
    plcUtil.addPublishedComments(db, update, commentsByOwner);
    update.commit();
    update = newUpdate(change, otherUser);
    update.setPatchSetId(psId1);
    plcUtil.addPublishedComments(db, update, commentsByReviewer);
    update.commit();
    ChangeControl ctl = stubChangeControl(change);
    revRes1 = new RevisionResource(new ChangeResource(ctl), ps1);
    revRes2 = new RevisionResource(new ChangeResource(ctl), ps2);
}
#end_block

#method_before
private ChangeControl stubChangeControl(Change c) throws OrmException {
    return ChangesForTestUtil.stubChangeControl(repoManager, c, changeOwner);
}
#method_after
private ChangeControl stubChangeControl(Change c) throws OrmException {
    return TestChanges.stubChangeControl(repoManager, c, changeOwner);
}
#end_block

#method_before
private Change newChange() {
    return ChangesForTestUtil.newChange(project, changeOwner);
}
#method_after
private Change newChange() {
    return TestChanges.newChange(project, changeOwner);
}
#end_block

#method_before
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return ChangesForTestUtil.newUpdate(injector, repoManager, c, user);
}
#method_after
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return TestChanges.newUpdate(injector, repoManager, c, user);
}
#end_block

#method_before
private static void assertComment(PatchLineComment plc, CommentInfo ci) {
    assertEquals(plc.getKey().get(), ci.id);
    assertEquals(plc.getParentUuid(), ci.inReplyTo);
    assertEquals(plc.getMessage(), ci.message);
    assertNotNull(ci.author);
    assertEquals(plc.getAuthor(), ci.author._id);
    assertEquals(plc.getLine(), (int) ci.line);
    assertEquals(plc.getSide() == 0 ? Side.PARENT : Side.REVISION, Objects.firstNonNull(ci.side, Side.REVISION));
    assertEquals(roundTimestampToSecond(plc.getWrittenOn()), roundTimestampToSecond(ci.updated));
    assertEquals(plc.getRange(), ci.range);
}
#method_after
private static void assertComment(PatchLineComment plc, CommentInfo ci) {
    assertEquals(plc.getKey().get(), ci.id);
    assertEquals(plc.getParentUuid(), ci.inReplyTo);
    assertEquals(plc.getMessage(), ci.message);
    assertNotNull(ci.author);
    assertEquals(plc.getAuthor(), ci.author._id);
    assertEquals(plc.getLine(), (int) ci.line);
    assertEquals(plc.getSide() == 0 ? Side.PARENT : Side.REVISION, Objects.firstNonNull(ci.side, Side.REVISION));
    assertEquals(TimeUtil.roundTimestampToSecond(plc.getWrittenOn()), TimeUtil.roundTimestampToSecond(ci.updated));
    assertEquals(plc.getRange(), ci.range);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("TABLE address_id");
    drop("TABLE addresses");
    drop("TABLE cnt");
    drop("TABLE bar");
    drop("TABLE foo");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("TABLE address_id");
    drop("TABLE addresses");
    drop("TABLE cnt");
    drop("TABLE bar");
    drop("TABLE foo");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
private static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try {
        FileOutputStream out = new FileOutputStream(tmp);
        try {
            byte[] data = new byte[8192];
            int n;
            while ((n = in.read(data)) > 0) {
                out.write(data, 0, n);
            }
            keep = true;
            return tmp;
        } finally {
            out.close();
        }
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#method_after
static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try (FileOutputStream out = new FileOutputStream(tmp)) {
        byte[] data = new byte[8192];
        int n;
        while ((n = in.read(data)) > 0) {
            out.write(data, 0, n);
        }
        keep = true;
        return tmp;
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        /*
       * Pluggable plugin provider may have assigned a plugin name that could be
       * actually different from the initial one assigned during scan. It is
       * safer then to reassign it.
       */
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        name = serverPluginFactory.getPluginName(srcPlugin);
        return loadServerPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private ServerPlugin loadServerPlugin(String name, File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    return serverPluginFactory.get(scriptFile, pluginUserFactory.create(name), snapshot, getPluginCanonicalWebUrl(name), getPluginDataDir(name));
}
#method_after
private ServerPlugin loadServerPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = serverPluginFactory.getPluginName(scriptFile);
    return serverPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getGerritJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#method_after
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(File srcFile, PluginUser pluginUser, FileSnapshot snapshot, String pluginCanonicalWebUrl, File pluginDataDir) throws InvalidPluginException {
    try {
        File tmp;
        String name = getPluginName(srcFile);
        FileInputStream in = new FileInputStream(srcFile);
        String extension = getExtension(srcFile);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, pluginCanonicalWebUrl, pluginUser, pluginDataDir);
        } finally {
            in.close();
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription description) throws InvalidPluginException {
    try {
        String name = getPluginName(srcFile);
        String extension = getExtension(srcFile);
        try (FileInputStream in = new FileInputStream(srcFile)) {
            File tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, description);
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#end_block

#method_before
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, String pluginCanonicalWebUrl, PluginUser pluginUser, File pluginDataDir) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, pluginCanonicalWebUrl, pluginUser, srcJar, snapshot, new JarScanner(srcJar), pluginDataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, PluginDescription description) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, description.canonicalUrl, description.user, srcJar, snapshot, new JarScanner(srcJar), description.dataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Injector getPluginInjector(File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getGerritJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#method_after
private Injector getPluginInjector(final File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    change.revision(revision);
    setWebLinks(change, revision, revInfo);
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
}
#end_block

#method_before
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.linkUrl(), link.linkName());
        }
    }
}
#method_after
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.link_url(), link.link_name());
        }
    }
}
#end_block

#method_before
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    out.webLinks = Lists.newArrayList();
    for (WebLinks.Link link : webLinkFactory.create().getPatchSetLinks(project, in.getRevision().get())) {
        out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        out.webLinks = Lists.newArrayList();
        for (WebLinks.Link link : webLinks.get().getPatchSetLinks(project, in.getRevision().get())) {
            out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
        }
    }
    return out;
}
#end_block

#method_before
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    ArrayList<Link> links = new ArrayList<Link>();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#method_after
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    List<Link> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(WebLinks.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getKey()));
    this.psId = psId;
}
#method_after
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getId()));
    this.psId = psId;
}
#end_block

#method_before
public void putComment(PatchLineComment comment) {
    commentsToAdd.add(comment);
}
#method_after
public void putComment(PatchLineComment comment) {
    checkArgument(psId != null, "setPatchSetId must be called before putComment");
    checkArgument(getCommentPsId(comment).equals(psId), "Comment on %s doesn't match previous patch set %s", getCommentPsId(comment), psId);
    checkArgument(comment.getRevId() != null);
    if (comment.getSide() == 0) {
        commentsForBase.add(comment);
    } else {
        commentsForPs.add(comment);
    }
}
#end_block

#method_before
private void storeCommentsInNotes(RevCommit c) throws OrmException, IOException {
    if (commentsToAdd.isEmpty()) {
        return;
    }
    // assume you can only add comments to one patchset at a time
    PatchSet.Id psId = commentsToAdd.get(0).getKey().getParentKey().getParentKey();
    ChangeNotes notes = ctl.getNotes();
    LinkedListMultimap<PatchSet.Id, PatchLineComment> allComments = LinkedListMultimap.create(notes.getPublishedComments());
    List<PatchLineComment> commentsOnSamePs = allComments.get(psId);
    // add all comments and re-sort list
    commentsOnSamePs.addAll(commentsToAdd);
    commentsOnSamePs = ChangeNotes.COMMENT_ORDERING.sortedCopy(commentsOnSamePs);
    String noteContents = PatchLineCommentsUtil.buildNote(accountCache, commentsOnSamePs);
    AnyObjectId oId = c.getId();
    NoteMap noteMap = notes.getNoteMap();
    noteMap.set(oId, noteContents, this.inserter);
    this.inserter.flush();
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnBases, commentsForBase);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnPs, commentsForPs);
    }
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        batch.write(new CommitBuilder());
        RevCommit c = batch.commit();
        storeCommentsInNotes(c);
        return c;
    } catch (OrmException e) {
        // TODO(yyonas): what to do with this exception?
        return null;
    } finally {
        batch.close();
    }
}
#method_after
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        CommitBuilder builder = new CommitBuilder();
        if (migration.write()) {
            ObjectId treeId = storeCommentsInNotes();
            if (treeId != null) {
                builder.setTreeId(treeId);
            }
        }
        batch.write(builder);
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#end_block

#method_before
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#method_after
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && commentsForBase.isEmpty() && commentsForPs.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#end_block

#method_before
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        publishedCommentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = publishedCommentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes);
        if (result == null) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        publishedComments.putAll(psId, result);
    }
}
#method_after
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        commentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = commentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = CommentsInNotesUtil.parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
}
#end_block

#method_before
private ConfigInvalidException parseException(String fmt, Object... args) {
    return new ConfigInvalidException("Change " + changeId + ": " + String.format(fmt, args));
}
#method_after
private ConfigInvalidException parseException(String fmt, Object... args) {
    return ChangeNotes.parseException(changeId, fmt, args);
}
#end_block

#method_before
public NoteMap getNoteMap() {
    return noteMap;
}
#method_after
NoteMap getNoteMap() {
    return noteMap;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        publishedComments = ImmutableListMultimap.copyOf(parser.publishedComments);
        noteMap = parser.publishedCommentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
    // TODO(yyonas): figure out how to handle this exception
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    publishedComments = ImmutableListMultimap.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    commentsForBase = ImmutableListMultimap.of();
    commentsForPS = ImmutableListMultimap.of();
}
#end_block

#method_before
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("File is not a JAR nor JS plugin and " + "no Plugin provider was found that handles it: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        // Pluggable plugin provider may have assigned
        name = newPlugin.getName();
        // a plugin name that could be actually
        // different from the initial
        // one assigned during scan. It is safer then
        // to reassign it.
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        name = externalPluginFactory.getPluginName(srcPlugin);
        return loadExternalPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        return loadExternalPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new ServerPlugin(name, getPluginCanonicalWebUrl(name), pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), getPluginDataDir(name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private ServerPlugin loadExternalPlugin(String name, File scriptFile, FileSnapshot snapshot) {
    return externalPluginFactory.get(name, scriptFile, pluginUserFactory.create(name), snapshot);
}
#method_after
private ServerPlugin loadExternalPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = externalPluginFactory.getPluginName(scriptFile);
    return externalPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
public static String getGerritJarPluginName(File srcFile) throws IOException {
    JarFile jarFile = new JarFile(srcFile);
    try {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    } finally {
        jarFile.close();
    }
}
#method_after
public static String getGerritJarPluginName(File srcFile) throws IOException {
    try (JarFile jarFile = new JarFile(srcFile)) {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    }
}
#end_block

#method_before
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<InitStep>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#method_after
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(String name, File srcFile, PluginUser pluginUser, FileSnapshot snapshot) {
    return providerOf(srcFile).get(name, srcFile, pluginUser, snapshot);
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription pluginDescription) throws InvalidPluginException {
    return providerOf(srcFile).get(srcFile, snapshot, pluginDescription);
}
#end_block

#method_before
@Override
public boolean handles(File srcFile) {
    for (ServerPluginProvider scriptingFactory : serverPluginProviders) {
        if (scriptingFactory.handles(srcFile)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean handles(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return true;
        case 0:
            return false;
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
private ServerPluginProvider providerOf(File srcFile) {
    for (ServerPluginProvider provider : serverPluginProviders) {
        if (provider.handles(srcFile)) {
            return provider;
        }
    }
    throw new IllegalArgumentException(srcFile.getAbsolutePath() + " is not a supported Gerrit plugin format");
}
#method_after
private ServerPluginProvider providerOf(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return providers.get(0);
        case 0:
            throw new IllegalArgumentException("No ServerPluginProvider found/loaded to handle plugin file " + srcFile.getAbsolutePath());
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (InsertException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, InsertException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, InsertException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (InsertException err) {
        log.error("Can't insert change/patchset for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj, allRefs.values().contains(obj))) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
CheckedFuture<Void, OrmException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<Void, InsertException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, InsertException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        ChangeKind changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        String message = "Uploaded patch set " + newPatchSet.getPatchSetId();
        switch(changeKind) {
            case TRIVIAL_REBASE:
                message += ": Patch Set " + priorPatchSet.get() + " was rebased";
                break;
            case NO_CODE_CHANGE:
                message += ": Commit message was updated";
                break;
        }
        msg.setMessage(message + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(msg));
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(uploadValidatorsFactory.create(project, repo));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
    // UploadValidationException is used by the UploadValidationListener to
    // stop the uploadPack. We do not want this exception to go beyond this
    // point otherwise it would print a stacktrace in the logs and return an
    // internal server error to the client.
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(preUploadHooks)));
    return up;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    up.setPreUploadHook(uploadValidatorsFactory.create(pc.getProject(), repo));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        validator.onPreUpload(repository, project, wants, haves);
    }
}
#method_after
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        try {
            validator.onPreUpload(repository, project, remoteHost, up, wants, haves);
        } catch (ValidationException e) {
            throw new UploadValidationException(e.getMessage());
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    final String database = "gwtorm";
    final String user = "gwtorm";
    final String pass = "gwtorm";
    try {
        db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass);
    } catch (Throwable t) {
        assumeNoException(t);
    }
    executor = new JdbcExecutor(db);
    dialect = new DialectPostgreSQL().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.postgresql.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    final String database = "gwtorm";
    final String user = "gwtorm";
    final String pass = "gwtorm";
    try {
        db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass);
    } catch (Throwable t) {
        assumeNoException(t);
    }
    executor = new JdbcExecutor(db);
    dialect = new DialectPostgreSQL().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.postgresql.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = Lists.newArrayList();
    List<PluginEntry> servlets = Lists.newArrayList();
    List<PluginEntry> restApis = Lists.newArrayList();
    List<PluginEntry> docs = Lists.newArrayList();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<PluginEntry>() {

        @Override
        public int compare(PluginEntry a, PluginEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<PluginEntry>() {

        @Override
        public int compare(PluginEntry a, PluginEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#method_after
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = Lists.newArrayList();
    List<PluginEntry> servlets = Lists.newArrayList();
    List<PluginEntry> restApis = Lists.newArrayList();
    List<PluginEntry> docs = Lists.newArrayList();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.setDateHeader("Last-Modified", lastModifiedTime);
    res.getOutputStream().write(html);
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        if (changeMessage != null) {
            Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
            ChangeControl otherControl = refControl.getProjectControl().controlFor(otherChange);
            ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, change.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
            updateForOtherChange.commit();
        }
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            if (changeMessage != null) {
                Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
                ChangeControl otherControl = ctlFactory.controlFor(otherChange, user);
                ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, updatedChange.getLastUpdatedOn());
                cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
                updateForOtherChange.commit();
            }
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
public static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#method_after
private static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#end_block

#method_before
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    List<ChangeMessage> changeMessages;
    if (!migration.readChangeMessages()) {
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> result = ImmutableListMultimap.builder();
        for (ChangeMessage cm : db.changeMessages().byChange(notes.getChangeId())) {
            result.put(cm.getPatchSetId(), cm);
        }
        changeMessages = sortChangeMessages(result.build().values());
    } else {
        changeMessages = sortChangeMessages(notes.load().getChangeMessages().values());
    }
    return changeMessages;
}
#method_after
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChangeMessages()) {
        return sortChangeMessages(db.changeMessages().byChange(notes.getChangeId()));
    } else {
        return sortChangeMessages(notes.load().getChangeMessages().values());
    }
}
#end_block

#method_before
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    List<ChangeMessage> cms = cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId());
    return Iterables.getFirst(Iterables.filter(Lists.reverse(cms), new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }), null);
}
#method_after
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    return FluentIterable.from(cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId())).filter(new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }).last().orNull();
}
#end_block

#method_before
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    Collections.sort(msgs, new Comparator<ChangeMessage>() {

        @Override
        public int compare(ChangeMessage a, ChangeMessage b) {
            return b.getWrittenOn().compareTo(a.getWrittenOn());
        }
    });
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#method_after
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    msgs = ChangeNotes.MESSAGE_BY_TIME.sortedCopy(msgs);
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO(yyonas): atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = changeControlFactory.controlFor(c, identifiedUserFactory.create(submitter.getAccountId()));
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // I didn't see how this function was going to do anything different
        // if I did what was below or put it in the function and kept the lines in
        // there...I commented out the method below because ATM, it's not used.
        // addMergedMessage(submitter, msg);
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // TODO(yyonas): we need to be able to change the author of the message
        // is not the person for whom the change was made. addMergedMessage
        // did this in the past.
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#end_block

#method_before
// private void addMergedMessage(PatchSetApproval submitter, ChangeMessage msg)
// throws OrmException {
// if (msg != null) {
// if (submitter != null && msg.getAuthor() == null) {
// msg.setAuthor(submitter.getAccountId());
// }
// db.changeMessages().insert(Collections.singleton(msg));
// }
// }
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO: atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#method_after
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO(yyonas): atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#end_block

#method_before
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control, change.getCreatedOn());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#method_after
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    // TODO(dborowitz): support InternalUser in ChangeUpdate
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control);
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO(yyonas): atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#end_block

#method_before
@Override
public void run() {
    try {
        rc.processCommands(commands, progress);
    } catch (NoSuchChangeException e) {
        // TODO(yyonas): Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void run() {
    rc.processCommands(commands, progress);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) throws NoSuchChangeException {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, NoSuchChangeException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException, NoSuchChangeException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result) throws OrmException, IOException, NoSuchChangeException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        ChangeControl control = ctlFactory.controlFor(change, currentUser);
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(TimeUtil.nowTs());
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    final List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
    }
    args.db.changes().beginTransaction(n.change.getId());
    try {
        insertAncestors(args.db, ps.getId(), newCommit);
        args.db.patchSets().insert(Collections.singleton(ps));
        args.db.changes().update(Collections.singletonList(n.change));
        args.db.patchSetApprovals().insert(approvals);
        args.db.commit();
    } finally {
        args.db.rollback();
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(TimeUtil.nowTs());
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    final RefUpdate ru;
    args.db.changes().beginTransaction(n.change.getId());
    try {
        insertAncestors(args.db, ps.getId(), newCommit);
        args.db.patchSets().insert(Collections.singleton(ps));
        n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
        args.db.changes().update(Collections.singletonList(n.change));
        final List<PatchSetApproval> approvals = Lists.newArrayList();
        for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
            approvals.add(new PatchSetApproval(ps.getId(), a));
        }
        args.db.patchSetApprovals().insert(approvals);
        ru = args.repo.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(args.rw) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
        }
        args.db.commit();
    } finally {
        args.db.rollback();
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    wrapper = new ContextMapper(config.getServletContext().getContextPath());
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, base + name);
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, wrapper.getFullPath(name));
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    HttpServletRequest wr = wrapper.create(req, name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        if (holder.plugin.getApiType() == ApiType.JS) {
            sendJsPlugin(holder.plugin, key, req, res);
        } else {
            JarFile jar = new JarFile(holder.plugin.getSrcFile());
            try {
                JarEntry entry = jar.getJarEntry(file);
                if (exists(entry)) {
                    sendResource(jar, entry, key, res);
                } else {
                    resourceCache.put(key, Resource.NOT_FOUND);
                    Resource.NOT_FOUND.send(req, res);
                }
            } finally {
                jar.close();
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix) && holder.plugin.getSrcFile().getName().endsWith(".jar")) {
        JarFile jar = new JarFile(holder.plugin.getSrcFile());
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = jarFileOf(holder.plugin);
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = jarFileOf(holder.plugin);
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res, holder.plugin.getSrcFile().lastModified());
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#method_after
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#end_block

#method_before
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res);
}
#method_after
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res, time);
}
#end_block

#method_before
private static String getPrefix(Plugin plugin, String attr, String def) {
    File srcFile = plugin.getSrcFile();
    if (srcFile == null || !srcFile.getName().endsWith(".jar")) {
        return def;
    }
    try {
        JarFile jarFile = new JarFile(plugin.getSrcFile());
        try {
            String prefix = jarFile.getManifest().getMainAttributes().getValue(attr);
            if (prefix != null) {
                return CharMatcher.is('/').trimFrom(prefix) + "/";
            } else {
                return def;
            }
        } finally {
            jarFile.close();
        }
    } catch (IOException e) {
        log.warn(String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e);
        return null;
    }
}
#method_after
private static String getPrefix(Plugin plugin, String attr, String def) {
    JarFile jarFile = jarFileOf(plugin);
    if (jarFile == null) {
        return def;
    }
    try {
        String prefix = jarFile.getManifest().getMainAttributes().getValue(attr);
        if (prefix != null) {
            return CharMatcher.is('/').trimFrom(prefix) + "/";
        } else {
            return def;
        }
    } catch (IOException e) {
        log.warn(String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e);
        return null;
    }
}
#end_block

#method_before
public static String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public static String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarFile(srcJar), new JarScanner(srcJar), new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\n", changeMessages.get(0).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(0).getAuthor());
    assertEquals(ps1, changeMessages.get(0).getPatchSetId());
}
#method_after
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Just a little code change.\n", cm.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm.getAuthor());
    assertEquals(ps1, cm.getPatchSetId());
}
#end_block

#method_before
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(0).getAuthor());
    assertEquals(ps2, changeMessages.get(0).getPatchSetId());
    assertEquals("This is the change message for the first PS.", changeMessages.get(1).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(1).getAuthor());
    assertEquals(ps1, changeMessages.get(1).getPatchSetId());
}
#method_after
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("This is the change message for the first PS.", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
    ChangeMessage cm2 = Iterables.getOnlyElement(changeMessages.get(ps2));
    assertEquals(ps1, cm1.getPatchSetId());
    assertEquals("This is the change message for the second PS.", cm2.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm2.getAuthor());
    assertEquals(ps2, cm2.getPatchSetId());
}
#end_block

#method_before
@Test
public void noChangeMessage() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(0, changeMessages.size());
}
#method_after
@Test
public void noChangeMessage() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(0, changeMessages.keySet().size());
}
#end_block

#method_before
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing trailing double newline\n" + "\n" + "\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Testing trailing double newline\n" + "\n", changeMessages.get(0).getMessage());
}
#method_after
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing trailing double newline\n" + "\n" + "\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Testing trailing double newline\n" + "\n", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
}
#end_block

#method_before
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3", changeMessages.get(0).getMessage());
}
#method_after
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
}
#end_block

#method_before
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMessageString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, new Timestamp(commit.getCommitterIdent().getWhen().getTime()), psId);
    changeMessage.setMessage(changeMessageString);
    changeMessages.add(changeMessage);
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, new Timestamp(commit.getCommitterIdent().getWhen().getTime()), psId);
    changeMessage.setMessage(changeMsgString);
    changeMessages.put(psId, changeMessage);
}
#end_block

#method_before
public ImmutableList<ChangeMessage> getChangeMessages() {
    return changeMessages;
}
#method_after
public ImmutableListMultimap<PatchSet.Id, ChangeMessage> getChangeMessages() {
    return changeMessages;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change.getId(), rev, walk);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
        changeMessages = ImmutableList.copyOf(parser.changeMessages);
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change.getId(), rev, walk);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> cms = ImmutableListMultimap.builder();
        for (Map.Entry<PatchSet.Id, ChangeMessage> e : parser.changeMessages.entries()) {
            cms.put(e.getKey(), e.getValue());
        }
        this.changeMessages = cms.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableList.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
}
#end_block

#method_before
private void parseChangeMessage(RevCommit commit) {
    final byte[] raw = commit.getRawBuffer();
    final int size = raw.length;
    final Charset enc = RawParseUtils.parseEncoding(raw);
    final int headerStart = RawParseUtils.commitMessage(raw, 0);
    if (headerStart < 0)
        return;
    int headerEnd = RawParseUtils.endOfParagraph(raw, headerStart);
    if (headerEnd == size)
        return;
    int changeMsgStart = headerEnd + 2;
    // 2 is for the \n\n that will be between the subject line and the
    // message we want
    int changeMsgEnd = RawParseUtils.endOfParagraph(raw, changeMsgStart);
    if (changeMsgEnd == size)
        return;
    String str = RawParseUtils.decode(enc, raw, changeMsgStart, changeMsgEnd);
    changeMessages.add(str);
}
#method_after
private void parseChangeMessage(RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMessage = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    changeMessages.add(changeMessage);
}
#end_block

#method_before
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\nTesting new line");
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\nTesting new line", changeMessages.get(0));
}
#method_after
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\n", changeMessages.get(0));
}
#end_block

#method_before
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0));
    assertEquals("This is the change message for the first PS.", changeMessages.get(1));
}
#method_after
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0));
    assertEquals("This is the change message for the first PS.", changeMessages.get(1));
}
#end_block

#method_before
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.get().parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            Ref destRef = git.getRef(refName);
            if (destRef == null) {
                throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
            }
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            RevCommit mergeTip = rw.parseCommit(destRef.getObjectId());
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, destRef.getName()), TimeUtil.nowTs());
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.get().parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            Ref destRef = git.getRef(refName);
            if (destRef == null) {
                throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
            }
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            RevCommit mergeTip = rw.parseCommit(destRef.getObjectId());
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, destRef.getName()), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = control2(cd);
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, cd, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    out.finish();
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, limitToPsId, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, changes.parse(control2(cd)), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, cd, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    out.finish();
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, limitToPsId, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, changes.parse(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#end_block

#method_before
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (Map.Entry<String, Cache<?, ?>> entry : getCaches().entrySet()) {
        cacheInfos.put(entry.getKey(), new CacheInfo(entry.getValue()));
    }
    return cacheInfos;
}
#method_after
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
        cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get()));
    }
    return cacheInfos;
}
#end_block

#method_before
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s";
    }
    return String.format("%4.1f%s", ns, suffix).trim();
}
#end_block

#method_before
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix);
}
#method_after
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix).trim();
}
#end_block

#method_before
@Override
public CacheResource parse(ConfigResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    final CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!(user.isIdentifiedUser())) {
        throw new ResourceNotFoundException();
    }
    if (!user.getCapabilities().canViewCaches()) {
        throw new AuthException("not allowed to view caches");
    }
    String cacheName = id.get();
    String pluginName = "gerrit";
    int i = cacheName.indexOf('.');
    if (i != -1) {
        pluginName = cacheName.substring(0, i);
        cacheName = cacheName.length() > i + 1 ? cacheName.substring(i + 1) : "";
    }
    Provider<Cache<?, ?>> cacheProvider = cacheMap.byPlugin(pluginName).get(cacheName);
    if (cacheProvider == null) {
        throw new ResourceNotFoundException(id);
    }
    return new CacheResource(pluginName, cacheName, cacheProvider);
}
#method_after
@Override
public CacheResource parse(ConfigResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!user.isIdentifiedUser()) {
        throw new ResourceNotFoundException();
    } else if (!user.getCapabilities().canViewCaches()) {
        throw new AuthException("not allowed to view caches");
    }
    String cacheName = id.get();
    String pluginName = "gerrit";
    int i = cacheName.lastIndexOf('-');
    if (i != -1) {
        pluginName = cacheName.substring(0, i);
        cacheName = cacheName.length() > i + 1 ? cacheName.substring(i + 1) : "";
    }
    Provider<Cache<?, ?>> cacheProvider = cacheMap.byPlugin(pluginName).get(cacheName);
    if (cacheProvider == null) {
        throw new ResourceNotFoundException(id);
    }
    return new CacheResource(pluginName, cacheName, cacheProvider);
}
#end_block

#method_before
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsProcent(cache.hitRatio.mem), formatAsProcent(cache.hitRatio.disk)));
}
#method_after
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsPercent(cache.hitRatio.mem), formatAsPercent(cache.hitRatio.disk)));
}
#end_block

#method_before
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (Map.Entry<String, Cache<?, ?>> entry : getCaches().entrySet()) {
        cacheInfos.put(entry.getKey(), new CacheInfo(entry.getValue()));
    }
    return cacheInfos;
}
#method_after
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
        cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get()));
    }
    return cacheInfos;
}
#end_block

#method_before
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "." + name;
    }
}
#method_after
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "-" + name;
    }
}
#end_block

#method_before
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s";
    }
    return String.format("%4.1f%s", ns, suffix).trim();
}
#end_block

#method_before
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix);
}
#method_after
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix).trim();
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId base = projectConfig.getRevision();
            projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(base, projectConfig.getRevision())) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, GitRepositoryManager.REF_CONFIG), base, projectConfig.getRevision(), user.getAccount());
            }
            ;
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, GitRepositoryManager.REF_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
@Override
public Object apply(ProjectResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = (IdentifiedUser) ctl.getCurrentUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = Objects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId base = config.getRevision();
            config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(base, config.getRevision())) {
                hooks.doRefUpdatedHook(new Branch.NameKey(resource.getNameKey(), GitRepositoryManager.REF_CONFIG), base, config.getRevision(), user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.none() : project.getDescription();
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Object apply(ProjectResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = (IdentifiedUser) ctl.getCurrentUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = Objects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId baseRev = config.getRevision();
            ObjectId commitRev = config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                hooks.doRefUpdatedHook(new Branch.NameKey(resource.getNameKey(), GitRepositoryManager.REF_CONFIG), baseRev, commitRev, user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.none() : project.getDescription();
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    return obj instanceof SecureStoreData && storeName.hashCode() == obj.hashCode();
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof SecureStoreData) {
        SecureStoreData o = (SecureStoreData) obj;
        return storeName.equals(o.storeName);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return storeName.hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(storeName);
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    wrapper = new ContextMapper(config.getServletContext().getContextPath());
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, base + name);
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, wrapper.getFullPath(name));
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    HttpServletRequest wr = wrapper.create(req, name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(DataSourceType.class).annotatedWith(Names.named("h2")).to(H2.class);
    bind(DataSourceType.class).annotatedWith(Names.named("jdbc")).to(JDBC.class);
    bind(DataSourceType.class).annotatedWith(Names.named("mysql")).to(MySql.class);
    bind(DataSourceType.class).annotatedWith(Names.named("oracle")).to(Oracle.class);
    bind(DataSourceType.class).annotatedWith(Names.named("postgresql")).to(PostgreSQL.class);
    bind(DataSourceType.class).annotatedWith(Names.named("maxdb")).to(MaxDb.class);
    bind(DataSourceType.class).annotatedWith(Names.named("sap db")).to(MaxDb.class);
}
#method_after
@Override
protected void configure() {
    bind(DataSourceType.class).annotatedWith(Names.named("h2")).to(H2.class);
    bind(DataSourceType.class).annotatedWith(Names.named("jdbc")).to(JDBC.class);
    bind(DataSourceType.class).annotatedWith(Names.named("mysql")).to(MySql.class);
    bind(DataSourceType.class).annotatedWith(Names.named("oracle")).to(Oracle.class);
    bind(DataSourceType.class).annotatedWith(Names.named("postgresql")).to(PostgreSQL.class);
    /*
     * DatabaseMetaData.getDatabaseProductName() returns "sap db" for MaxDB.
     * For auto-detection of the DB type (com.google.gerrit.pgm.util.SiteProgram#getDbType)
     * we have to map "sap db" additionally to "maxdb", which is used for explicit configuration.
     */
    bind(DataSourceType.class).annotatedWith(Names.named("maxdb")).to(MaxDb.class);
    bind(DataSourceType.class).annotatedWith(Names.named("sap db")).to(MaxDb.class);
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.get().put(key.token, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = nowMs();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    Val val = self.get().getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.get().invalidate(key.token);
        return null;
    }
    return val;
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= nowMs()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
void destroy(final Key key) {
    self.get().invalidate(key.token);
}
#method_after
void destroy(final Key key) {
    self.invalidate(key.token);
}
#end_block

#method_before
boolean needsCookieRefresh() {
    return refreshCookieAt <= now();
}
#method_after
boolean needsCookieRefresh() {
    return refreshCookieAt <= nowMs();
}
#end_block

#method_before
@Provides
GitilesUrls getGitilesUrls(@GerritServerConfig Config gerritConfig, @Nullable @CanonicalWebUrl String gerritUrl, @SshAdvertisedAddresses List<String> advertisedSshAddresses) throws MalformedURLException, UnknownHostException {
    URL u;
    String hostName;
    if (gerritUrl != null) {
        u = new URL(gerritUrl);
        hostName = u.getHost() != null ? u.getHost() : getLocalHostName();
    } else {
        u = null;
        hostName = "Gerrit";
    }
    // Arbitrarily prefer SSH, then HTTP, then git.
    // TODO: Use user preferences.
    String gitUrl;
    if (!advertisedSshAddresses.isEmpty()) {
        String addr = advertisedSshAddresses.get(0);
        int index = addr.indexOf(":");
        String port = "";
        if (index != -1) {
            port = addr.substring(index);
        }
        if (addr.startsWith("*:") || "".equals(addr)) {
            if (u != null && u.getHost() != null) {
                addr = u.getHost();
            } else {
                addr = getLocalHostName();
            }
        }
        gitUrl = "ssh://" + addr + port + "/";
    } else {
        gitUrl = gerritConfig.getString("gerrit", null, "gitHttpUrl");
        if (gitUrl == null) {
            gitUrl = gerritConfig.getString("gerrit", null, "canonicalGitUrl");
        }
    }
    if (gitUrl == null) {
        throw new ProvisionException("Unable to determine any canonical git URL from gerrit.config");
    }
    return new DefaultUrls(hostName, gitUrl, gerritUrl);
}
#method_after
@Provides
GitilesUrls getGitilesUrls(@GerritServerConfig Config gerritConfig, @Nullable @CanonicalWebUrl String gerritUrl, @SshAdvertisedAddresses List<String> advertisedSshAddresses) throws MalformedURLException, UnknownHostException {
    URL u;
    String hostName;
    if (gerritUrl != null) {
        u = new URL(gerritUrl);
        hostName = u.getHost() != null ? u.getHost() : getLocalHostName();
    } else {
        u = null;
        hostName = "Gerrit";
    }
    // Arbitrarily prefer SSH, then HTTP, then git.
    // TODO: Use user preferences.
    String gitUrl;
    if (!advertisedSshAddresses.isEmpty()) {
        String addr = advertisedSshAddresses.get(0);
        int index = addr.indexOf(":");
        String port = "";
        if (index != -1) {
            port = addr.substring(index);
        }
        if (addr.startsWith("*:") || "".equals(addr)) {
            if (u != null && u.getHost() != null) {
                addr = u.getHost();
            } else {
                addr = getLocalHostName();
            }
        } else {
            if (index != -1) {
                addr = addr.substring(0, index);
            }
        }
        gitUrl = "ssh://" + addr + port + "/";
    } else {
        gitUrl = gerritConfig.getString("gerrit", null, "gitHttpUrl");
        if (gitUrl == null) {
            gitUrl = gerritConfig.getString("gerrit", null, "canonicalGitUrl");
        }
    }
    if (gitUrl == null) {
        throw new ProvisionException("Unable to determine any canonical git URL from gerrit.config");
    }
    return new DefaultUrls(hostName, gitUrl, gerritUrl);
}
#end_block

#method_before
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String reviewer = Gerrit.getUserAccountInfo().name();
    if (!reviewer.isEmpty()) {
        addReviewer(reviewer, false);
    }
}
#method_after
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccountInfo()._account_id());
    addReviewer(accountId, false);
}
#end_block

#method_before
private void initCommentVisibilityStrategy(Button expandAll, Button collapseAll) {
    CommentVisibilityStrategy commentVisibilityStrategy = CommentVisibilityStrategy.EXPAND_RECENT;
    if (Gerrit.isSignedIn()) {
        commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getCommentVisibilityStrategy();
    }
    long AGE = 7 * 24 * 60 * 60 * 1000L;
    Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    int n = getWidgetCount();
    for (int i = 0; i < n; i++) {
        Message msg = (Message) getWidget(i);
        boolean isRecent;
        if (i == n - 1) {
            isRecent = true;
        } else {
            isRecent = msg.getMessageInfo().date().after(aged);
        }
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
                isOpen = i == n - 1;
                break;
            case EXPAND_RECENT:
            default:
                isOpen = isRecent;
                break;
        }
        msg.setOpen(isOpen);
    }
    if (commentVisibilityStrategy == COLLAPSE_ALL) {
        expandAll.setVisible(true);
        collapseAll.setVisible(false);
    } else if (commentVisibilityStrategy == EXPAND_ALL) {
        expandAll.setVisible(false);
        collapseAll.setVisible(true);
    }
}
#method_after
private void initCommentVisibilityStrategy(Button expandAll, Button collapseAll) {
    CommentVisibilityStrategy commentVisibilityStrategy = CommentVisibilityStrategy.EXPAND_RECENT;
    if (Gerrit.isSignedIn()) {
        commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getCommentVisibilityStrategy();
    }
    Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    int n = getWidgetCount();
    for (int i = 0; i < n; i++) {
        Message msg = (Message) getWidget(i);
        boolean isRecent = (i == n - 1) ? true : msg.getMessageInfo().date().after(aged);
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
                isOpen = i == n - 1;
                break;
            case EXPAND_RECENT:
            default:
                isOpen = isRecent;
                break;
        }
        msg.setOpen(isOpen);
    }
    if (commentVisibilityStrategy == COLLAPSE_ALL) {
        expandAll.setVisible(true);
        collapseAll.setVisible(false);
    } else if (commentVisibilityStrategy == EXPAND_ALL) {
        expandAll.setVisible(false);
        collapseAll.setVisible(true);
    }
}
#end_block

#method_before
public PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    boolean newScrren = Dispatcher.isChangeScreen2();
    if (newScrren && (detail.getPatches().get(index).getPatchType().equals(PatchType.BINARY) || Gerrit.getUserAccount().getGeneralPreferences().getDiffView().equals(DiffView.UNIFIED_DIFF)) || !newScrren && patchType == PatchScreen.Type.UNIFIED) {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
public PatchLink createLink(int index, PatchScreen.Type screenType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (isUnifiedPatchLink(patch, screenType)) {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    boolean admin;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            admin = getCurrentUser().getCapabilities().canAdministrateServer();
            break;
        default:
            owner = false;
            admin = false;
    }
    if (object instanceof RevCommit) {
        return admin || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    config.setGitBasicAuth(authConfig.isGitBasicAuth() && authConfig.isLdapAuthType());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordSettingsEnabled(!authConfig.isGitBasicAuth());
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (!authConfig.isLdapAuthType() && !passwordMatchesTheUserGeneratedOne(who, username, password)) {
        log.warn("Authentication failed for " + username + ": password do not match the ones stored in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        WebSession ws = session.get();
        ws.setUserAccountId(whoAuthResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (!authConfig.isLdapAuthType() && !passwordMatchesTheUserGeneratedOne(who, username, password)) {
        log.warn("Authentication failed for " + username + ": password does not match the one stored in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        WebSession ws = session.get();
        ws.setUserAccountId(whoAuthResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.MERGE_ALWAYS;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.MERGE_ALWAYS;
}
#end_block

#method_before
private void loadProject(ResultSet rs, Project project) throws SQLException, OrmException {
    project.setDescription(rs.getString("description"));
    project.setUseContributorAgreements(asInheritableBoolean(rs, "use_contributor_agreements"));
    switch(rs.getString("submit_type").charAt(0)) {
        case 'F':
            project.setSubmitType(ProjectSubmitType.FAST_FORWARD_ONLY);
            break;
        case 'M':
            project.setSubmitType(ProjectSubmitType.MERGE_IF_NECESSARY);
            break;
        case 'A':
            project.setSubmitType(ProjectSubmitType.MERGE_ALWAYS);
            break;
        case 'C':
            project.setSubmitType(ProjectSubmitType.CHERRY_PICK);
            break;
        default:
            throw new OrmException("Unsupported submit_type=" + rs.getString("submit_type") + " on project " + project.getName());
    }
    project.setUseSignedOffBy(asInheritableBoolean(rs, "use_signed_off_by"));
    project.setRequireChangeID(asInheritableBoolean(rs, "require_change_id"));
    project.setUseContentMerge(asInheritableBoolean(rs, "use_content_merge"));
    project.setParentName(rs.getString("parent_name"));
}
#method_after
private void loadProject(ResultSet rs, Project project) throws SQLException, OrmException {
    project.setDescription(rs.getString("description"));
    project.setUseContributorAgreements(asInheritableBoolean(rs, "use_contributor_agreements"));
    switch(rs.getString("submit_type").charAt(0)) {
        case 'F':
            project.setSubmitType(SubmitType.FAST_FORWARD_ONLY);
            break;
        case 'M':
            project.setSubmitType(SubmitType.MERGE_IF_NECESSARY);
            break;
        case 'A':
            project.setSubmitType(SubmitType.MERGE_ALWAYS);
            break;
        case 'C':
            project.setSubmitType(SubmitType.CHERRY_PICK);
            break;
        default:
            throw new OrmException("Unsupported submit_type=" + rs.getString("submit_type") + " on project " + project.getName());
    }
    project.setUseSignedOffBy(asInheritableBoolean(rs, "use_signed_off_by"));
    project.setRequireChangeID(asInheritableBoolean(rs, "require_change_id"));
    project.setUseContentMerge(asInheritableBoolean(rs, "use_content_merge"));
    project.setParentName(rs.getString("parent_name"));
}
#end_block

#method_before
public boolean canWrite() {
    return getProjectControl().getProject().getState().equals(ProjectStatus.ACTIVE);
}
#method_after
public boolean canWrite() {
    return getProjectControl().getProject().getState().equals(ProjectState.ACTIVE);
}
#end_block

#method_before
public boolean canRead() {
    return getProjectControl().getProject().getState().equals(ProjectStatus.READ_ONLY) || canWrite();
}
#method_after
public boolean canRead() {
    return getProjectControl().getProject().getState().equals(ProjectState.READ_ONLY) || canWrite();
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.WEB_LINKS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    String email = info.owner().email() != null ? info.owner().email() : name;
    ownerText.setInnerText(name);
    ownerText.setTitle(email);
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#end_block

#method_before
private void renderSubmitType(String action) {
    try {
        ProjectSubmitType type = ProjectSubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#method_after
private void renderSubmitType(String action) {
    try {
        SubmitType type = SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    ProjectSubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    SubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.MERGE_IF_NECESSARY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.MERGE_IF_NECESSARY;
}
#end_block

#method_before
public static String toLongString(final ProjectStatus type) {
    if (type == null) {
        return "";
    }
    switch(type) {
        case ACTIVE:
            return C.projectState_ACTIVE();
        case READ_ONLY:
            return C.projectState_READ_ONLY();
        case HIDDEN:
            return C.projectState_HIDDEN();
        default:
            return type.name();
    }
}
#method_after
public static String toLongString(final SubmitType type) {
    if (type == null) {
        return "";
    }
    switch(type) {
        case FAST_FORWARD_ONLY:
            return C.projectSubmitType_FAST_FORWARD_ONLY();
        case MERGE_IF_NECESSARY:
            return C.projectSubmitType_MERGE_IF_NECESSARY();
        case REBASE_IF_NECESSARY:
            return C.projectSubmitType_REBASE_IF_NECESSARY();
        case MERGE_ALWAYS:
            return C.projectSubmitType_MERGE_ALWAYS();
        case CHERRY_PICK:
            return C.projectSubmitType_CHERRY_PICK();
        default:
            return type.name();
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    project = new Project.NameKey("p");
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    project = new Project.NameKey("p2");
}
#end_block

#method_before
private void setSubmitType(ProjectSubmitType submitType) throws IOException {
    PutConfig.Input in = new PutConfig.Input();
    in.submitType = submitType;
    in.useContentMerge = InheritableBoolean.FALSE;
    RestResponse r = adminSession.put("/projects/" + project.get() + "/config", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#method_after
private void setSubmitType(SubmitType submitType) throws IOException {
    PutConfig.Input in = new PutConfig.Input();
    in.submitType = submitType;
    in.useContentMerge = InheritableBoolean.FALSE;
    RestResponse r = adminSession.put("/projects/" + project.get() + "/config", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#end_block

#method_before
@Test
public void testCreateProjectWithProperties() throws IOException {
    final String newProjectName = "newProject";
    ProjectInput in = new ProjectInput();
    in.description = "Test description";
    in.submitType = ProjectSubmitType.CHERRY_PICK;
    in.useContributorAgreements = InheritableBoolean.TRUE;
    in.useSignedOffBy = InheritableBoolean.TRUE;
    in.useContentMerge = InheritableBoolean.TRUE;
    in.requireChangeId = InheritableBoolean.TRUE;
    RestResponse r = adminSession.put("/projects/" + newProjectName, in);
    ProjectInfo p = newGson().fromJson(r.getReader(), ProjectInfo.class);
    assertEquals(newProjectName, p.name);
    Project project = projectCache.get(new Project.NameKey(newProjectName)).getProject();
    assertProjectInfo(project, p);
    assertEquals(in.description, project.getDescription());
    assertEquals(in.submitType, project.getSubmitType());
    assertEquals(in.useContributorAgreements, project.getUseContributorAgreements());
    assertEquals(in.useSignedOffBy, project.getUseSignedOffBy());
    assertEquals(in.useContentMerge, project.getUseContentMerge());
    assertEquals(in.requireChangeId, project.getRequireChangeID());
}
#method_after
@Test
public void testCreateProjectWithProperties() throws IOException {
    final String newProjectName = "newProject";
    ProjectInput in = new ProjectInput();
    in.description = "Test description";
    in.submitType = SubmitType.CHERRY_PICK;
    in.useContributorAgreements = InheritableBoolean.TRUE;
    in.useSignedOffBy = InheritableBoolean.TRUE;
    in.useContentMerge = InheritableBoolean.TRUE;
    in.requireChangeId = InheritableBoolean.TRUE;
    RestResponse r = adminSession.put("/projects/" + newProjectName, in);
    ProjectInfo p = newGson().fromJson(r.getReader(), ProjectInfo.class);
    assertEquals(newProjectName, p.name);
    Project project = projectCache.get(new Project.NameKey(newProjectName)).getProject();
    assertProjectInfo(project, p);
    assertEquals(in.description, project.getDescription());
    assertEquals(in.submitType, project.getSubmitType());
    assertEquals(in.useContributorAgreements, project.getUseContributorAgreements());
    assertEquals(in.useSignedOffBy, project.getUseSignedOffBy());
    assertEquals(in.useContentMerge, project.getUseContentMerge());
    assertEquals(in.requireChangeId, project.getRequireChangeID());
}
#end_block

#method_before
@Test
public void testCreateProjectWithoutCapability_Forbidden() throws OrmException, JSchException, IOException {
    TestAccount user = accounts.create("user", "user@example.com", "User");
    RestResponse r = new RestSession(server, user).put("/projects/newProject");
    assertEquals(HttpStatus.SC_FORBIDDEN, r.getStatusCode());
}
#method_after
@Test
public void testCreateProjectWithoutCapability_Forbidden() throws OrmException, JSchException, IOException {
    RestResponse r = userSession.put("/projects/newProject");
    assertEquals(HttpStatus.SC_FORBIDDEN, r.getStatusCode());
}
#end_block

#method_before
public ProjectStatus getState() {
    return control.getProject().getState();
}
#method_after
public ProjectState getState() {
    return control.getProject().getState();
}
#end_block

#method_before
public final ProjectStatus state() {
    return ProjectStatus.valueOf(getStringState());
}
#method_after
public final ProjectState state() {
    return ProjectState.valueOf(getStringState());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    RestApi call = ChangeApi.detail(patchSetId.getParentKey().get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS));
    call.get(group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            detail = result;
        }
    }));
    ChangeApi.revision(patchSetId).view("submit_type").get(group.add(new GerritCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            submitTypeRecord = SubmitTypeRecord.OK(ProjectSubmitType.valueOf(result.asString()));
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId.getParentKey().get(), "" + patchSetId.get()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            drafts = result;
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId).view("review").get(group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            result.init();
            change = result;
            preDisplay(result);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    RestApi call = ChangeApi.detail(patchSetId.getParentKey().get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS));
    call.get(group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            detail = result;
        }
    }));
    ChangeApi.revision(patchSetId).view("submit_type").get(group.add(new GerritCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            submitTypeRecord = SubmitTypeRecord.OK(SubmitType.valueOf(result.asString()));
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId.getParentKey().get(), "" + patchSetId.get()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            drafts = result;
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId).view("review").get(group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            result.init();
            change = result;
            preDisplay(result);
        }
    }));
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == ProjectSubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
public final ProjectSubmitType submit_type() {
    return ProjectSubmitType.valueOf(submit_typeRaw());
}
#method_after
public final SubmitType submit_type() {
    return SubmitType.valueOf(submit_typeRaw());
}
#end_block

#method_before
public final ProjectStatus state() {
    if (stateRaw() == null) {
        return ProjectStatus.ACTIVE;
    }
    return ProjectStatus.valueOf(stateRaw());
}
#method_after
public final ProjectState state() {
    if (stateRaw() == null) {
        return ProjectState.ACTIVE;
    }
    return ProjectState.valueOf(stateRaw());
}
#end_block

#method_before
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            commentLinks.add(new RawFindReplace(cl.match(), cl.html()));
        }
    }
    return commentLinks;
}
#method_after
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                int index = e.getMessage().indexOf("at Object");
                new ErrorDialog("Invalid commentlink configuration: " + (index == -1 ? e.getMessage() : e.getMessage().substring(0, index))).center();
            }
        }
    }
    return commentLinks;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.CHERRY_PICK;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.CHERRY_PICK;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                if (Strings.emptyToNull(v.getValue()) != null) {
                    if (!v.getValue().equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.getValue());
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.getValue());
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.getValue());
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), v.getValue());
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Test
public void filterOutMoreThanOnePageOfResults() throws Exception {
    TestRepository<InMemoryRepository> repo = createProject("repo");
    Change change = newChange(repo, null, null, userId.get(), null).insert();
    int user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId().get();
    for (int i = 0; i < 5; i++) {
        newChange(repo, null, null, user2, null).insert();
    }
    assertResultEquals(change, queryOne("status:new ownerin:Administrators"));
    assertResultEquals(change, queryOne("status:new ownerin:Administrators limit:2"));
}
#method_after
@Test
public void filterOutMoreThanOnePageOfResults() throws Exception {
    TestRepository<InMemoryRepository> repo = createProject("repo");
    Change change = newChange(repo, null, null, userId.get(), null).insert();
    int user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId().get();
    for (int i = 0; i < 5; i++) {
        newChange(repo, null, null, user2, null).insert();
    }
    // assertResultEquals(change, queryOne("status:new ownerin:Administrators"));
    assertResultEquals(change, queryOne("status:new ownerin:Administrators limit:2"));
}
#end_block

#method_before
private static long lastUpdatedMs(Change c) {
    return c.getLastUpdatedOn().getTime();
}
#method_after
protected static long lastUpdatedMs(Change c) {
    return c.getLastUpdatedOn().getTime();
}
#end_block

#method_before
public static void setConfig(Project.NameKey name, String description, com.google.gerrit.extensions.common.InheritableBoolean useContributorAgreements, com.google.gerrit.extensions.common.InheritableBoolean useContentMerge, com.google.gerrit.extensions.common.InheritableBoolean useSignedOffBy, com.google.gerrit.extensions.common.InheritableBoolean requireChangeId, String maxObjectSizeLimit, com.google.gerrit.extensions.common.ProjectSubmitType submitType, com.google.gerrit.extensions.common.ProjectStatus state, Map<String, Map<String, String>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#method_after
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#end_block

#method_before
final void setUseContributorAgreements(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseContributorAgreementsRaw(v.name());
}
#method_after
final void setUseContributorAgreements(InheritableBoolean v) {
    setUseContributorAgreementsRaw(v.name());
}
#end_block

#method_before
final void setUseContentMerge(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseContentMergeRaw(v.name());
}
#method_after
final void setUseContentMerge(InheritableBoolean v) {
    setUseContentMergeRaw(v.name());
}
#end_block

#method_before
final void setUseSignedOffBy(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseSignedOffByRaw(v.name());
}
#method_after
final void setUseSignedOffBy(InheritableBoolean v) {
    setUseSignedOffByRaw(v.name());
}
#end_block

#method_before
final void setRequireChangeId(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setRequireChangeIdRaw(v.name());
}
#method_after
final void setRequireChangeId(InheritableBoolean v) {
    setRequireChangeIdRaw(v.name());
}
#end_block

#method_before
final void setSubmitType(com.google.gerrit.extensions.common.ProjectSubmitType t) {
    setSubmitTypeRaw(t.name());
}
#method_after
final void setSubmitType(SubmitType t) {
    setSubmitTypeRaw(t.name());
}
#end_block

#method_before
final void setState(com.google.gerrit.extensions.common.ProjectStatus s) {
    setStateRaw(s.name());
}
#method_after
final void setState(ProjectState s) {
    setStateRaw(s.name());
}
#end_block

#method_before
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<StringMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
            StringMap values = StringMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, String> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#method_after
final void setPluginConfigValues(Map<String, Map<String, ConfigParameterValue>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<ConfigParameterValueMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, ConfigParameterValue>> e : pluginConfigValues.entrySet()) {
            ConfigParameterValueMap values = ConfigParameterValueMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, ConfigParameterValue> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    submitType = new ListBox();
    for (final com.google.gerrit.extensions.common.ProjectSubmitType type : com.google.gerrit.extensions.common.ProjectSubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    state = new ListBox();
    for (final com.google.gerrit.extensions.common.ProjectStatus stateValue : com.google.gerrit.extensions.common.ProjectStatus.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    state = new ListBox();
    for (final ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
private static ListBox newInheritedBooleanBox() {
    ListBox box = new ListBox();
    for (com.google.gerrit.extensions.common.InheritableBoolean b : com.google.gerrit.extensions.common.InheritableBoolean.values()) {
        box.addItem(b.name(), b.name());
    }
    return box;
}
#method_after
private static ListBox newInheritedBooleanBox() {
    ListBox box = new ListBox();
    for (InheritableBoolean b : InheritableBoolean.values()) {
        box.addItem(b.name(), b.name());
    }
    return box;
}
#end_block

#method_before
private void setEnabledForUseContentMerge() {
    if (com.google.gerrit.extensions.common.ProjectSubmitType.FAST_FORWARD_ONLY.equals(com.google.gerrit.extensions.common.ProjectSubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())))) {
        contentMerge.setEnabled(false);
        InheritedBooleanInfo b = InheritedBooleanInfo.create();
        b.setConfiguredValue(com.google.gerrit.extensions.common.InheritableBoolean.FALSE);
        setBool(contentMerge, b);
    } else {
        contentMerge.setEnabled(submitType.isEnabled());
    }
}
#method_after
private void setEnabledForUseContentMerge() {
    if (SubmitType.FAST_FORWARD_ONLY.equals(SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())))) {
        contentMerge.setEnabled(false);
        InheritedBooleanInfo b = InheritedBooleanInfo.create();
        b.setConfiguredValue(InheritableBoolean.FALSE);
        setBool(contentMerge, b);
    } else {
        contentMerge.setEnabled(submitType.isEnabled());
    }
}
#end_block

#method_before
private void setSubmitType(final com.google.gerrit.extensions.common.ProjectSubmitType newSubmitType) {
    int index = -1;
    if (submitType != null) {
        for (int i = 0; i < submitType.getItemCount(); i++) {
            if (newSubmitType.name().equals(submitType.getValue(i))) {
                index = i;
                break;
            }
        }
        submitType.setSelectedIndex(index);
        setEnabledForUseContentMerge();
    }
}
#method_after
private void setSubmitType(final SubmitType newSubmitType) {
    int index = -1;
    if (submitType != null) {
        for (int i = 0; i < submitType.getItemCount(); i++) {
            if (newSubmitType.name().equals(submitType.getValue(i))) {
                index = i;
                break;
            }
        }
        submitType.setSelectedIndex(index);
        setEnabledForUseContentMerge();
    }
}
#end_block

#method_before
private void setState(final com.google.gerrit.extensions.common.ProjectStatus newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#method_after
private void setState(final ProjectState newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#end_block

#method_before
private void setBool(ListBox box, InheritedBooleanInfo inheritedBoolean) {
    int inheritedIndex = -1;
    for (int i = 0; i < box.getItemCount(); i++) {
        if (box.getValue(i).startsWith(com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name())) {
            inheritedIndex = i;
        }
        if (box.getValue(i).startsWith(inheritedBoolean.configured_value().name())) {
            box.setSelectedIndex(i);
        }
    }
    if (inheritedIndex >= 0) {
        if (getProjectKey().equals(Gerrit.getConfig().getWildProject())) {
            if (box.getSelectedIndex() == inheritedIndex) {
                for (int i = 0; i < box.getItemCount(); i++) {
                    if (box.getValue(i).equals(com.google.gerrit.extensions.common.InheritableBoolean.FALSE.name())) {
                        box.setSelectedIndex(i);
                        break;
                    }
                }
            }
            box.removeItem(inheritedIndex);
        } else {
            box.setItemText(inheritedIndex, com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name() + " (" + inheritedBoolean.inherited_value() + ")");
        }
    }
}
#method_after
private void setBool(ListBox box, InheritedBooleanInfo inheritedBoolean) {
    int inheritedIndex = -1;
    for (int i = 0; i < box.getItemCount(); i++) {
        if (box.getValue(i).startsWith(InheritableBoolean.INHERIT.name())) {
            inheritedIndex = i;
        }
        if (box.getValue(i).startsWith(inheritedBoolean.configured_value().name())) {
            box.setSelectedIndex(i);
        }
    }
    if (inheritedIndex >= 0) {
        if (getProjectKey().equals(Gerrit.getConfig().getWildProject())) {
            if (box.getSelectedIndex() == inheritedIndex) {
                for (int i = 0; i < box.getItemCount(); i++) {
                    if (box.getValue(i).equals(InheritableBoolean.FALSE.name())) {
                        box.setSelectedIndex(i);
                        break;
                    }
                }
            }
            box.removeItem(inheritedIndex);
        } else {
            box.setItemText(inheritedIndex, InheritableBoolean.INHERIT.name() + " (" + inheritedBoolean.inherited_value() + ")");
        }
    }
}
#end_block

#method_before
private static com.google.gerrit.extensions.common.InheritableBoolean getBool(ListBox box) {
    int i = box.getSelectedIndex();
    if (i >= 0) {
        final String selectedValue = box.getValue(i);
        if (selectedValue.startsWith(com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name())) {
            return com.google.gerrit.extensions.common.InheritableBoolean.INHERIT;
        }
        return com.google.gerrit.extensions.common.InheritableBoolean.valueOf(selectedValue);
    }
    return com.google.gerrit.extensions.common.InheritableBoolean.INHERIT;
}
#method_after
private static InheritableBoolean getBool(ListBox box) {
    int i = box.getSelectedIndex();
    if (i >= 0) {
        final String selectedValue = box.getValue(i);
        if (selectedValue.startsWith(InheritableBoolean.INHERIT.name())) {
            return InheritableBoolean.INHERIT;
        }
        return InheritableBoolean.valueOf(selectedValue);
    }
    return InheritableBoolean.INHERIT;
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            switch(param.type()) {
                case "STRING":
                case "INT":
                case "LONG":
                    w = renderTextBox(g, param);
                    break;
                case "BOOLEAN":
                    w = renderCheckBox(g, param);
                    break;
                case "LIST":
                    w = renderListBox(g, param);
                    break;
                case "ARRAY":
                    w = renderTextArea(g, param);
                    break;
                default:
                    throw new UnsupportedOperationException("unsupported widget type");
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = param.type().equals("STRING") ? new NpTextBox() : new NpIntTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#method_after
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    if (param.permittedValues() == null) {
        return null;
    }
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), com.google.gerrit.extensions.common.ProjectSubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), com.google.gerrit.extensions.common.ProjectStatus.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, ConfigParameterValue>> getPluginConfigValues() {
    Map<String, Map<String, ConfigParameterValue>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, ConfigParameterValue> values = new HashMap<>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(((TextBox) widget).getValue().trim()));
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(Boolean.toString(((CheckBox) widget).getValue())));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), ConfigParameterValue.create().value(value));
            } else if (widget instanceof NpTextArea) {
                String text = ((NpTextArea) widget).getText().trim();
                values.put(e2.getKey(), ConfigParameterValue.create().values(text.split("\n")));
            } else {
                throw new UnsupportedOperationException("unsupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
@Override
public void populateDownloadCommandLinks() {
    if (!urls.isEmpty()) {
        if (allowedCommands.contains(DownloadCommand.CHECKOUT) || allowedCommands.contains(DownloadCommand.DEFAULT_DOWNLOADS)) {
            commands.add(cmdLinkfactory.new CloneCommandLink());
        }
    }
}
#method_after
@Override
public void populateDownloadCommandLinks() {
    if (!urls.isEmpty()) {
        if (allowedCommands.contains(DownloadCommand.CHECKOUT) || allowedCommands.contains(DownloadCommand.DEFAULT_DOWNLOADS)) {
            commands.add(cmdLinkfactory.new CloneCommandLink());
            if (Gerrit.getConfig().getSshdAddress() != null && hasUserName()) {
                commands.add(cmdLinkfactory.new CloneWithCommitMsgHookCommandLink(getProjectKey()));
            }
        }
    }
}
#end_block

#method_before
@Override
public void onValueChange(final ValueChangeEvent<ChangeDetail> event) {
    if (isAttached() && isLastValueChangeHandler()) {
        // Until this screen is fully migrated to the new API, these calls must
        // happen sequentially after the ChangeDetail lookup, because we can't
        // start an async get at the source of every call that might trigger a
        // value change.
        CallbackGroup cbs1 = new CallbackGroup();
        final CallbackGroup cbs2 = new CallbackGroup();
        final PatchSet.Id psId = event.getValue().getCurrentPatchSet().getId();
        final Map<String, Patch> patches = new HashMap<String, Patch>();
        String revId = event.getValue().getCurrentPatchSetDetail().getInfo().getRevId();
        if (event.getValue().getChange().getStatus().isOpen()) {
            ChangeApi.revision(changeId.get(), "current").view("submit_type").get(cbs1.add(new GerritCallback<NativeString>() {

                @Override
                public void onSuccess(NativeString result) {
                    event.getValue().setSubmitTypeRecord(SubmitTypeRecord.OK(ProjectSubmitType.valueOf(result.asString())));
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        if (Gerrit.isSignedIn()) {
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("related").get(cbs1.add(new AsyncCallback<RelatedChanges.RelatedInfo>() {

                @Override
                public void onSuccess(RelatedChanges.RelatedInfo info) {
                    if (info.changes() != null) {
                        dependsOn(info);
                        neededBy(info);
                    }
                }

                private void dependsOn(RelatedChanges.RelatedInfo info) {
                    ChangeAndCommit self = null;
                    Map<String, ChangeAndCommit> m = new HashMap<String, ChangeAndCommit>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (changeId.equals(c.legacy_id())) {
                            self = c;
                        }
                        if (c.commit() != null && c.commit().commit() != null) {
                            m.put(c.commit().commit(), c);
                        }
                    }
                    if (self != null && self.commit() != null && self.commit().parents() != null) {
                        List<ChangeInfo> d = new ArrayList<ChangeInfo>();
                        for (CommitInfo p : Natives.asList(self.commit().parents())) {
                            ChangeAndCommit pc = m.get(p.commit());
                            if (pc != null && pc.has_change_number()) {
                                ChangeInfo i = new ChangeInfo();
                                load(pc, i);
                                d.add(i);
                            }
                        }
                        event.getValue().setDependsOn(d);
                    }
                }

                private void neededBy(RelatedChanges.RelatedInfo info) {
                    Set<String> mine = new HashSet<String>();
                    for (PatchSet ps : event.getValue().getPatchSets()) {
                        mine.add(ps.getRevision().get());
                    }
                    List<ChangeInfo> n = new ArrayList<ChangeInfo>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (c.has_change_number() && c.commit() != null && c.commit().parents() != null) {
                            for (int j = 0; j < c.commit().parents().length(); j++) {
                                CommitInfo p = c.commit().parents().get(j);
                                if (mine.contains(p.commit())) {
                                    ChangeInfo u = new ChangeInfo();
                                    load(c, u);
                                    n.add(u);
                                    break;
                                }
                            }
                        }
                    }
                    event.getValue().setNeededBy(n);
                }

                private void load(final ChangeAndCommit pc, final ChangeInfo i) {
                    RestApi call = ChangeApi.change(pc.legacy_id().get());
                    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.CURRENT_REVISION));
                    call.get(cbs2.add(new AsyncCallback<com.google.gerrit.client.changes.ChangeInfo>() {

                        public void onFailure(Throwable caught) {
                        }

                        public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                            i.set(ChangeDetailCache.toChange(result), pc.patch_set_id());
                            i.setStarred(result.starred());
                            event.getValue().getAccounts().merge(ChangeDetailCache.users(result));
                        }
                    }));
                }

                public void onFailure(Throwable caught) {
                }
            }));
            ChangeApi.revision(changeId.get(), revId).view("files").addParameterTrue("reviewed").get(cbs1.add(new AsyncCallback<JsArrayString>() {

                @Override
                public void onSuccess(JsArrayString result) {
                    for (int i = 0; i < result.length(); i++) {
                        String path = result.get(i);
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setReviewedByCurrentUser(true);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
            final Set<PatchSet.Id> withDrafts = new HashSet<PatchSet.Id>();
            event.getValue().setPatchSetsWithDraftComments(withDrafts);
            for (PatchSet ps : event.getValue().getPatchSets()) {
                if (!ps.getId().equals(psId)) {
                    final PatchSet.Id id = ps.getId();
                    ChangeApi.revision(changeId.get(), "" + id.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                        @Override
                        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                            if (!result.isEmpty()) {
                                withDrafts.add(id);
                            }
                        }

                        public void onFailure(Throwable caught) {
                        }
                    }));
                }
            }
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                @Override
                public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                    for (String path : result.keySet()) {
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setDraftCount(result.get(path).length());
                    }
                    if (!result.isEmpty()) {
                        withDrafts.add(psId);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        ChangeApi.revision(changeId.get(), revId).view("comments").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                for (String path : result.keySet()) {
                    Patch p = patches.get(path);
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, path));
                        patches.put(path, p);
                    }
                    p.setCommentCount(result.get(path).length());
                }
            }

            public void onFailure(Throwable caught) {
            }
        }));
        DiffApi.list(changeId.get(), null, revId, new AsyncCallback<NativeMap<FileInfo>>() {

            @Override
            public void onSuccess(NativeMap<FileInfo> result) {
                JsArray<FileInfo> fileInfos = result.values();
                FileInfo.sortFileInfoByPath(fileInfos);
                List<Patch> list = new ArrayList<Patch>(fileInfos.length());
                for (FileInfo f : Natives.asList(fileInfos)) {
                    Patch p = patches.get(f.path());
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, f.path()));
                        patches.put(f.path(), p);
                    }
                    p.setInsertions(f.lines_inserted());
                    p.setDeletions(f.lines_deleted());
                    p.setPatchType(f.binary() ? PatchType.BINARY : PatchType.UNIFIED);
                    if (f.status() == null) {
                        p.setChangeType(ChangeType.MODIFIED);
                    } else {
                        p.setChangeType(ChangeType.forCode(f.status().charAt(0)));
                    }
                    list.add(p);
                }
                event.getValue().getCurrentPatchSetDetail().setPatches(list);
            }

            public void onFailure(Throwable caught) {
            }
        });
        ConfigInfoCache.get(event.getValue().getChange().getProject(), cbs1.add(new GerritCallback<ConfigInfoCache.Entry>() {

            @Override
            public void onSuccess(ConfigInfoCache.Entry result) {
                commentLinkProcessor = result.getCommentLinkProcessor();
                setTheme(result.getTheme());
            }

            @Override
            public void onFailure(Throwable caught) {
            // Handled by last callback's onFailure.
            }
        }));
        ChangeApi.detail(changeId.get(), cbs1.addFinal(new GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() {

            @Override
            public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                changeInfo = result;
                cbs2.addFinal(new AsyncCallback<Void>() {

                    @Override
                    public void onSuccess(Void result) {
                        display(event.getValue());
                    }

                    public void onFailure(Throwable caught) {
                    }
                }).onSuccess(null);
            }
        }));
    }
}
#method_after
@Override
public void onValueChange(final ValueChangeEvent<ChangeDetail> event) {
    if (isAttached() && isLastValueChangeHandler()) {
        // Until this screen is fully migrated to the new API, these calls must
        // happen sequentially after the ChangeDetail lookup, because we can't
        // start an async get at the source of every call that might trigger a
        // value change.
        CallbackGroup cbs1 = new CallbackGroup();
        final CallbackGroup cbs2 = new CallbackGroup();
        final PatchSet.Id psId = event.getValue().getCurrentPatchSet().getId();
        final Map<String, Patch> patches = new HashMap<String, Patch>();
        String revId = event.getValue().getCurrentPatchSetDetail().getInfo().getRevId();
        if (event.getValue().getChange().getStatus().isOpen()) {
            ChangeApi.revision(changeId.get(), "current").view("submit_type").get(cbs1.add(new GerritCallback<NativeString>() {

                @Override
                public void onSuccess(NativeString result) {
                    event.getValue().setSubmitTypeRecord(SubmitTypeRecord.OK(SubmitType.valueOf(result.asString())));
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        if (Gerrit.isSignedIn()) {
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("related").get(cbs1.add(new AsyncCallback<RelatedChanges.RelatedInfo>() {

                @Override
                public void onSuccess(RelatedChanges.RelatedInfo info) {
                    if (info.changes() != null) {
                        dependsOn(info);
                        neededBy(info);
                    }
                }

                private void dependsOn(RelatedChanges.RelatedInfo info) {
                    ChangeAndCommit self = null;
                    Map<String, ChangeAndCommit> m = new HashMap<String, ChangeAndCommit>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (changeId.equals(c.legacy_id())) {
                            self = c;
                        }
                        if (c.commit() != null && c.commit().commit() != null) {
                            m.put(c.commit().commit(), c);
                        }
                    }
                    if (self != null && self.commit() != null && self.commit().parents() != null) {
                        List<ChangeInfo> d = new ArrayList<ChangeInfo>();
                        for (CommitInfo p : Natives.asList(self.commit().parents())) {
                            ChangeAndCommit pc = m.get(p.commit());
                            if (pc != null && pc.has_change_number()) {
                                ChangeInfo i = new ChangeInfo();
                                load(pc, i);
                                d.add(i);
                            }
                        }
                        event.getValue().setDependsOn(d);
                    }
                }

                private void neededBy(RelatedChanges.RelatedInfo info) {
                    Set<String> mine = new HashSet<String>();
                    for (PatchSet ps : event.getValue().getPatchSets()) {
                        mine.add(ps.getRevision().get());
                    }
                    List<ChangeInfo> n = new ArrayList<ChangeInfo>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (c.has_change_number() && c.commit() != null && c.commit().parents() != null) {
                            for (int j = 0; j < c.commit().parents().length(); j++) {
                                CommitInfo p = c.commit().parents().get(j);
                                if (mine.contains(p.commit())) {
                                    ChangeInfo u = new ChangeInfo();
                                    load(c, u);
                                    n.add(u);
                                    break;
                                }
                            }
                        }
                    }
                    event.getValue().setNeededBy(n);
                }

                private void load(final ChangeAndCommit pc, final ChangeInfo i) {
                    RestApi call = ChangeApi.change(pc.legacy_id().get());
                    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.CURRENT_REVISION));
                    call.get(cbs2.add(new AsyncCallback<com.google.gerrit.client.changes.ChangeInfo>() {

                        public void onFailure(Throwable caught) {
                        }

                        public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                            i.set(ChangeDetailCache.toChange(result), pc.patch_set_id());
                            i.setStarred(result.starred());
                            event.getValue().getAccounts().merge(ChangeDetailCache.users(result));
                        }
                    }));
                }

                public void onFailure(Throwable caught) {
                }
            }));
            ChangeApi.revision(changeId.get(), revId).view("files").addParameterTrue("reviewed").get(cbs1.add(new AsyncCallback<JsArrayString>() {

                @Override
                public void onSuccess(JsArrayString result) {
                    for (int i = 0; i < result.length(); i++) {
                        String path = result.get(i);
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setReviewedByCurrentUser(true);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
            final Set<PatchSet.Id> withDrafts = new HashSet<PatchSet.Id>();
            event.getValue().setPatchSetsWithDraftComments(withDrafts);
            for (PatchSet ps : event.getValue().getPatchSets()) {
                if (!ps.getId().equals(psId)) {
                    final PatchSet.Id id = ps.getId();
                    ChangeApi.revision(changeId.get(), "" + id.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                        @Override
                        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                            if (!result.isEmpty()) {
                                withDrafts.add(id);
                            }
                        }

                        public void onFailure(Throwable caught) {
                        }
                    }));
                }
            }
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                @Override
                public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                    for (String path : result.keySet()) {
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setDraftCount(result.get(path).length());
                    }
                    if (!result.isEmpty()) {
                        withDrafts.add(psId);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        ChangeApi.revision(changeId.get(), revId).view("comments").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                for (String path : result.keySet()) {
                    Patch p = patches.get(path);
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, path));
                        patches.put(path, p);
                    }
                    p.setCommentCount(result.get(path).length());
                }
            }

            public void onFailure(Throwable caught) {
            }
        }));
        DiffApi.list(changeId.get(), null, revId, new AsyncCallback<NativeMap<FileInfo>>() {

            @Override
            public void onSuccess(NativeMap<FileInfo> result) {
                JsArray<FileInfo> fileInfos = result.values();
                FileInfo.sortFileInfoByPath(fileInfos);
                List<Patch> list = new ArrayList<Patch>(fileInfos.length());
                for (FileInfo f : Natives.asList(fileInfos)) {
                    Patch p = patches.get(f.path());
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, f.path()));
                        patches.put(f.path(), p);
                    }
                    p.setInsertions(f.lines_inserted());
                    p.setDeletions(f.lines_deleted());
                    p.setPatchType(f.binary() ? PatchType.BINARY : PatchType.UNIFIED);
                    if (f.status() == null) {
                        p.setChangeType(ChangeType.MODIFIED);
                    } else {
                        p.setChangeType(ChangeType.forCode(f.status().charAt(0)));
                    }
                    list.add(p);
                }
                event.getValue().getCurrentPatchSetDetail().setPatches(list);
            }

            public void onFailure(Throwable caught) {
            }
        });
        ConfigInfoCache.get(event.getValue().getChange().getProject(), cbs1.add(new GerritCallback<ConfigInfoCache.Entry>() {

            @Override
            public void onSuccess(ConfigInfoCache.Entry result) {
                commentLinkProcessor = result.getCommentLinkProcessor();
                setTheme(result.getTheme());
            }

            @Override
            public void onFailure(Throwable caught) {
            // Handled by last callback's onFailure.
            }
        }));
        ChangeApi.detail(changeId.get(), cbs1.addFinal(new GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() {

            @Override
            public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                changeInfo = result;
                cbs2.addFinal(new AsyncCallback<Void>() {

                    @Override
                    public void onSuccess(Void result) {
                        display(event.getValue());
                    }

                    public void onFailure(Throwable caught) {
                    }
                }).onSuccess(null);
            }
        }));
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", ProjectSubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#end_block

#method_before
private boolean isHidden() {
    return getProject().getState().equals(ProjectStatus.HIDDEN);
}
#method_after
private boolean isHidden() {
    return getProject().getState().equals(com.google.gerrit.extensions.api.projects.ProjectState.HIDDEN);
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.REBASE_IF_NECESSARY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.REBASE_IF_NECESSARY;
}
#end_block

#method_before
private boolean refresh(Change change, PatchSet ps, ProjectSubmitType type, Repository git, Map<String, Ref> refs, Ref ref) throws IOException, OrmException {
    RevWalk rw = new RevWalk(git) {

        @Override
        protected CodeReviewCommit createCommit(AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    try {
        ObjectId id;
        try {
            id = ObjectId.fromString(ps.getRevision().get());
        } catch (IllegalArgumentException e) {
            log.error(String.format("Invalid revision on patch set %d of %d", ps.getId().get(), change.getId().get()));
            return false;
        }
        RevFlag canMerge = rw.newFlag("CAN_MERGE");
        CodeReviewCommit rev = parse(rw, id);
        rev.add(canMerge);
        boolean mergeable;
        if (ref == null || ref.getObjectId() == null) {
            // Assume yes on new branch.
            mergeable = true;
        } else {
            CodeReviewCommit tip = parse(rw, ref.getObjectId());
            Set<RevCommit> accepted = alreadyAccepted(rw, refs.values());
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            mergeable = submitStrategyFactory.create(type, db.get(), git, rw, null, /*inserter*/
            canMerge, accepted, change.getDest()).dryRun(tip, rev);
        }
        Change c = db.get().changes().get(change.getId());
        if (c != null) {
            c.setMergeable(mergeable);
            c.setLastSha1MergeTested(toRevId(ref));
            db.get().changes().update(Collections.singleton(c));
            indexer.index(db.get(), c);
        }
        return mergeable;
    } catch (MergeException | IOException | NoSuchProjectException e) {
        log.error(String.format("Cannot merge test change %d", change.getId().get()), e);
        return false;
    } finally {
        rw.release();
    }
}
#method_after
private boolean refresh(Change change, final PatchSet ps, SubmitType type, Repository git, Map<String, Ref> refs, final Ref ref) throws IOException, OrmException {
    RevWalk rw = new RevWalk(git) {

        @Override
        protected CodeReviewCommit createCommit(AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    try {
        ObjectId id;
        try {
            id = ObjectId.fromString(ps.getRevision().get());
        } catch (IllegalArgumentException e) {
            log.error(String.format("Invalid revision on patch set %d of %d", ps.getId().get(), change.getId().get()));
            return false;
        }
        RevFlag canMerge = rw.newFlag("CAN_MERGE");
        CodeReviewCommit rev = parse(rw, id);
        rev.add(canMerge);
        final boolean mergeable;
        if (ref == null || ref.getObjectId() == null) {
            // Assume yes on new branch.
            mergeable = true;
        } else {
            CodeReviewCommit tip = parse(rw, ref.getObjectId());
            Set<RevCommit> accepted = alreadyAccepted(rw, refs.values());
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            mergeable = submitStrategyFactory.create(type, db.get(), git, rw, null, /*inserter*/
            canMerge, accepted, change.getDest()).dryRun(tip, rev);
        }
        Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                    c.setMergeable(mergeable);
                    c.setLastSha1MergeTested(toRevId(ref));
                    return c;
                } else {
                    return null;
                }
            }
        });
        if (c != null) {
            indexer.index(db.get(), c);
        }
        return mergeable;
    } catch (MergeException | IOException | NoSuchProjectException e) {
        log.error(String.format("Cannot merge test change %d", change.getId().get()), e);
        return false;
    } finally {
        rw.release();
    }
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = args.changeDataFactory.create(db.get(), c).currentFilePaths();
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                ProjectSubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            args.conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private ProjectSubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = args.changeControlGenericFactory.controlFor(change, args.userFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = args.changeDataFactory.create(db.get(), c).currentFilePaths();
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            args.conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = args.changeControlGenericFactory.controlFor(change, args.userFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
public ProjectSubmitType getSubmitType() {
    return submitType;
}
#method_after
public SubmitType getSubmitType() {
    return submitType;
}
#end_block

#method_before
public void setSubmitType(final ProjectSubmitType type) {
    submitType = type;
}
#method_after
public void setSubmitType(final SubmitType type) {
    submitType = type;
}
#end_block

#method_before
public ProjectStatus getState() {
    return state;
}
#method_after
public ProjectState getState() {
    return state;
}
#end_block

#method_before
public void setState(final ProjectStatus newState) {
    state = newState;
}
#method_after
public void setState(final ProjectState newState) {
    state = newState;
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    return new ChangeControl(approvalsUtil, changeDataFactory, getRefControl().forUser(who), notes);
}
#method_after
public ChangeControl forUser(final CurrentUser who) {
    if (getCurrentUser().equals(who)) {
        return this;
    }
    return new ChangeControl(approvalsUtil, changeDataFactory, getRefControl().forUser(who), notes);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, getChange(), cd, false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(ProjectSubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, getChange(), cd, false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#end_block

#method_before
@Override
public ProjectSubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db, rsrc.getChange()), false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return ProjectSubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db, rsrc.getChange()), false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#end_block

#method_before
@Override
public ProjectSubmitType apply(RevisionResource resource) throws AuthException, BadRequestException {
    return test.apply(resource, null);
}
#method_after
@Override
public SubmitType apply(RevisionResource resource) throws AuthException, BadRequestException {
    return test.apply(resource, null);
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    try {
        if (!suggestParent) {
            if (projectName == null) {
                throw new UnloggedFailure(1, "fatal: Project name is required.");
            }
            ProjectInput input = new ProjectInput();
            input.name = projectName;
            if (ownerIds != null) {
                input.owners = Lists.transform(ownerIds, new Function<AccountGroup.UUID, String>() {

                    @Override
                    public String apply(AccountGroup.UUID uuid) {
                        return uuid.get();
                    }
                });
            }
            if (newParent != null) {
                input.parent = newParent.getProject().getName();
            }
            input.permissionsOnly = permissionsOnly;
            input.description = projectDescription;
            input.submitType = submitType;
            input.useContributorAgreements = contributorAgreements;
            input.useSignedOffBy = signedOffBy;
            input.useContentMerge = contentMerge;
            input.requireChangeId = requireChangeID;
            input.branches = branch;
            input.createEmptyCommit = createEmptyCommit;
            input.maxObjectSizeLimit = maxObjectSizeLimit;
            if (pluginConfigValues != null) {
                input.pluginConfigValues = parsePluginConfigValues(pluginConfigValues);
            }
            gApi.projects().create(input);
        } else {
            List<Project.NameKey> parentCandidates = suggestParentCandidatesFactory.create().getNameKeys();
            for (Project.NameKey parent : parentCandidates) {
                stdout.print(parent + "\n");
            }
        }
    } catch (RestApiException | OrmException | NoSuchProjectException err) {
        throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        if (!suggestParent) {
            if (projectName == null) {
                throw new UnloggedFailure(1, "fatal: Project name is required.");
            }
            ProjectInput input = new ProjectInput();
            input.name = projectName;
            if (ownerIds != null) {
                input.owners = Lists.transform(ownerIds, new Function<AccountGroup.UUID, String>() {

                    @Override
                    public String apply(AccountGroup.UUID uuid) {
                        return uuid.get();
                    }
                });
            }
            if (newParent != null) {
                input.parent = newParent.getProject().getName();
            }
            input.permissionsOnly = permissionsOnly;
            input.description = projectDescription;
            input.submitType = submitType;
            input.useContributorAgreements = contributorAgreements;
            input.useSignedOffBy = signedOffBy;
            input.useContentMerge = contentMerge;
            input.requireChangeId = requireChangeID;
            input.branches = branch;
            input.createEmptyCommit = createEmptyCommit;
            input.maxObjectSizeLimit = maxObjectSizeLimit;
            if (pluginConfigValues != null) {
                input.pluginConfigValues = parsePluginConfigValues(pluginConfigValues);
            }
            createProjectFactory.get().create(projectName).apply(TopLevelResource.INSTANCE, input);
        } else {
            List<Project.NameKey> parentCandidates = suggestParentCandidatesFactory.create().getNameKeys();
            for (Project.NameKey parent : parentCandidates) {
                stdout.print(parent + "\n");
            }
        }
    } catch (RestApiException | ProjectCreationFailedException | IOException | NoSuchProjectException | OrmException err) {
        throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
    }
}
#end_block

#method_before
private Map<String, Map<String, String>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, String>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        String[] s = pluginConfigValue.split("=");
        String[] s2 = s[0].split("\\.");
        if (s.length != 2 || s2.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'");
        }
        String value = s[1];
        String pluginName = s2[0];
        String paramName = s2[1];
        Map<String, String> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#method_after
@VisibleForTesting
Map<String, Map<String, ConfigValue>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, ConfigValue>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        String[] s = pluginConfigValue.split("=");
        String[] s2 = s[0].split("\\.");
        if (s.length != 2 || s2.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'" + " or '<plugin-name>.<parameter-name>=<value1,value2,...>'");
        }
        ConfigValue value = new ConfigValue();
        String v = s[1];
        if (v.contains(",")) {
            value.values = Lists.newArrayList(Splitter.on(",").split(v));
        } else {
            value.value = v;
        }
        String pluginName = s2[0];
        String paramName = s2[1];
        Map<String, ConfigValue> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#end_block

#method_before
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#method_after
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        RefUpdate branchUpdate = openBranch();
        boolean reopen = false;
        final ListMultimap<ProjectSubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<ProjectSubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<ProjectSubmitType> submitTypes = new HashSet<ProjectSubmitType>(toMerge.keySet());
            for (final ProjectSubmitType submitType : submitTypes) {
                if (reopen) {
                    branchUpdate = openBranch();
                }
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                reopen = true;
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        updateChangeStatus(toUpdate);
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.notes, message(commit.getChange(), capable.getMessage()), false);
            }
        }
    } catch (NoSuchProjectException noProject) {
        log.warn(String.format("Project %s no longer exists, abandoning open changes", destBranch.getParentKey().get()));
        abandonAllOpenChanges();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        RefUpdate branchUpdate = openBranch();
        boolean reopen = false;
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                if (reopen) {
                    branchUpdate = openBranch();
                }
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                RefUpdate update = updateBranch(strategy, branchUpdate);
                reopen = true;
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                if (update != null) {
                    fireRefUpdated(update);
                }
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.setStatusCode(null);
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        updateChangeStatus(toUpdate);
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.notes(), message(commit.change(), capable.getMessage()), false);
            }
        }
    } catch (NoSuchProjectException noProject) {
        log.warn(String.format("Project %s no longer exists, abandoning open changes", destBranch.getParentKey().get()));
        abandonAllOpenChanges();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private boolean containsMissingCommits(final ListMultimap<ProjectSubmitType, CodeReviewCommit> map, final CodeReviewCommit commit) {
    if (!isSubmitForMissingCommitsStillPossible(commit)) {
        return false;
    }
    for (final CodeReviewCommit missingCommit : commit.missing) {
        if (!map.containsValue(missingCommit)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean containsMissingCommits(final ListMultimap<SubmitType, CodeReviewCommit> map, final CodeReviewCommit commit) {
    if (!isSubmitForMissingCommitsStillPossible(commit)) {
        return false;
    }
    for (final CodeReviewCommit missingCommit : commit.missing) {
        if (!map.containsValue(missingCommit)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isSubmitForMissingCommitsStillPossible(final CodeReviewCommit commit) {
    if (commit.missing == null || commit.missing.isEmpty()) {
        return false;
    }
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // 
            return false;
        }
        if (!missingCommit.getChange().currentPatchSetId().equals(missingCommit.patchsetId)) {
            // 
            return false;
        }
    }
    return true;
}
#method_after
private boolean isSubmitForMissingCommitsStillPossible(final CodeReviewCommit commit) {
    if (commit.missing == null || commit.missing.isEmpty()) {
        return false;
    }
    for (CodeReviewCommit missingCommit : commit.missing) {
        try {
            loadChangeInfo(missingCommit);
        } catch (NoSuchChangeException | OrmException e) {
            log.error("Cannot check if missing commits can be submitted", e);
            return false;
        }
        if (missingCommit.getPatchsetId() == null) {
            // 
            return false;
        }
        if (!missingCommit.change().currentPatchSetId().equals(missingCommit.getPatchsetId())) {
            // 
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private SubmitStrategy createStrategy(final ProjectSubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#end_block

#method_before
private ListMultimap<ProjectSubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<ProjectSubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            toUpdate.add(chg);
            continue;
        }
        commit.notes = notesFactory.create(chg);
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final ProjectSubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            toUpdate.add(chg);
            continue;
        }
        try {
            commit.setControl(changeControlFactory.controlFor(chg, identifiedUserFactory.create(chg.getOwner())));
        } catch (NoSuchChangeException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        commit.setPatchsetId(ps.getId());
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        SubmitType submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private ProjectSubmitType getSubmitType(final Change change, final PatchSet ps) {
    try {
        final SubmitTypeRecord r = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())).getSubmitTypeRecord(db, ps);
        if (r.status != SubmitTypeRecord.Status.OK) {
            log.error("Failed to get submit type for " + change.getKey());
            return null;
        }
        return r.type;
    } catch (NoSuchChangeException e) {
        log.error("Failed to get submit type for " + change.getKey(), e);
        return null;
    }
}
#method_after
private SubmitType getSubmitType(ChangeControl ctl, PatchSet ps) {
    SubmitTypeRecord r = ctl.getSubmitTypeRecord(db, ps);
    if (r.status != SubmitTypeRecord.Status.OK) {
        log.error("Failed to get submit type for " + ctl.getChange().getKey());
        return null;
    }
    return r.type;
}
#end_block

#method_before
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getProject().getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject.getProject());
                        destProject = projectCache.get(destProject.getProject().getNameKey());
                        repoManager.setProjectDescription(destProject.getProject().getNameKey(), destProject.getProject().getDescription());
                    }
                    gitRefUpdated.fire(destBranch.getParentKey(), branchUpdate);
                    Account account = null;
                    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, mergeTip.notes, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private RefUpdate updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if (branchTip == mergeTip || mergeTip == null) {
        // nothing to do
        return null;
    }
    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, mergeTip);
        } catch (Exception e) {
            throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getProject().getName(), e);
        }
    }
    branchUpdate.setRefLogIdent(refLogIdent);
    branchUpdate.setForceUpdate(false);
    branchUpdate.setNewObjectId(mergeTip);
    branchUpdate.setRefLogMessage("merged", true);
    try {
        switch(branchUpdate.update(rw)) {
            case NEW:
            case FAST_FORWARD:
                if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                    tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                }
                if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                    projectCache.evict(destProject.getProject());
                    destProject = projectCache.get(destProject.getProject().getNameKey());
                    repoManager.setProjectDescription(destProject.getProject().getNameKey(), destProject.getProject().getDescription());
                }
                return branchUpdate;
            case LOCK_FAILURE:
                String msg;
                if (strategy.retryOnLockFailure()) {
                    mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                    msg = "will retry";
                } else {
                    msg = "will not retry";
                }
                throw new IOException(branchUpdate.getResult().name() + ", " + msg);
            default:
                throw new IOException(branchUpdate.getResult().name());
        }
    } catch (IOException e) {
        throw new MergeException("Cannot update " + branchUpdate.getName(), e);
    }
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(commit, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(commit, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.getChange();
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = TimeUtil.nowMs();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change could not be merged because of a missing dependency.");
        m.append("\n");
        m.append("\n");
        m.append("The following changes must also be submitted:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            m.append("* ");
            m.append(missingCommit.getChange().getKey().get());
            m.append("\n");
        }
        capable = new Capable(m.toString());
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.getChange().getKey().abbreviate());
                if (missingCommit.patchsetId.get() != missingCommit.getChange().currentPatchSetId().get()) {
                    m.append(", however the current patch set is ");
                    m.append(missingCommit.getChange().currentPatchSetId().get());
                }
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#method_after
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change();
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = TimeUtil.nowMs();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change could not be merged because of a missing dependency.");
        m.append("\n");
        m.append("\n");
        m.append("The following changes must also be submitted:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            m.append("* ");
            m.append(missingCommit.change().getKey().get());
            m.append("\n");
        }
        capable = new Capable(m.toString());
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.getPatchsetId() != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.getPatchsetId().get());
                m.append(" of ");
                m.append(missingCommit.change().getKey().abbreviate());
                if (missingCommit.getPatchsetId().get() != missingCommit.change().currentPatchSetId().get()) {
                    m.append(", however the current patch set is ");
                    m.append(missingCommit.change().currentPatchSetId().get());
                }
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#end_block

#method_before
private void loadChangeInfo(final CodeReviewCommit commit) {
    if (commit.notes == null) {
        try {
            List<PatchSet> matches = db.patchSets().byRevision(new RevId(commit.name())).toList();
            if (matches.size() == 1) {
                final PatchSet ps = matches.get(0);
                commit.patchsetId = ps.getId();
                commit.notes = notesFactory.create(db.changes().get(ps.getId().getParentKey()));
            }
        } catch (OrmException e) {
        }
    }
}
#method_after
private void loadChangeInfo(final CodeReviewCommit commit) throws NoSuchChangeException, OrmException {
    if (commit.getControl() == null) {
        List<PatchSet> matches = db.patchSets().byRevision(new RevId(commit.name())).toList();
        if (matches.size() == 1) {
            PatchSet ps = matches.get(0);
            commit.setPatchsetId(ps.getId());
            commit.setControl(changeControl(db.changes().get(ps.getId().getParentKey())));
        }
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.getChange().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
}
#end_block

#method_before
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final ChangeControl control = changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner()));
                final MergedSender cm = mergedSenderFactory.create(control);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void setNew(CodeReviewCommit c, ChangeMessage msg) {
    sendMergeFail(c.notes, msg, true);
}
#method_after
private void setNew(CodeReviewCommit c, ChangeMessage msg) {
    sendMergeFail(c.notes(), msg, true);
}
#end_block

#method_before
public ProjectSubmitType getSubmitType() {
    return submitType;
}
#method_after
public SubmitType getSubmitType() {
    return submitType;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.FAST_FORWARD_ONLY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.FAST_FORWARD_ONLY;
}
#end_block

#method_before
public static SubmitTypeRecord OK(ProjectSubmitType type) {
    SubmitTypeRecord r = new SubmitTypeRecord();
    r.status = Status.OK;
    r.type = type;
    return r;
}
#method_after
public static SubmitTypeRecord OK(SubmitType type) {
    SubmitTypeRecord r = new SubmitTypeRecord();
    r.status = Status.OK;
    r.type = type;
    return r;
}
#end_block

#method_before
@Override
public void stop() {
    if (executor != null) {
        try {
            cleanup.shutdownNow();
            List<Runnable> pending = executor.shutdownNow();
            if (executor.awaitTermination(15, TimeUnit.MINUTES)) {
                if (pending != null && !pending.isEmpty()) {
                    log.info(String.format("Finishing %d disk cache updates", pending.size()));
                    for (Runnable update : pending) {
                        update.run();
                    }
                }
            } else {
                log.info("Timeout waiting for disk cache to close");
            }
        } catch (InterruptedException e) {
            log.warn("Interrupted waiting for disk cache to shutdown");
        }
    }
    for (H2CacheImpl<?, ?> cache : caches) {
        cache.stop();
    }
}
#method_after
@Override
public void stop() {
    if (executor != null) {
        try {
            cleanup.shutdownNow();
            List<Runnable> pending = executor.shutdownNow();
            if (executor.awaitTermination(15, TimeUnit.MINUTES)) {
                if (pending != null && !pending.isEmpty()) {
                    log.info(String.format("Finishing %d disk cache updates", pending.size()));
                    for (Runnable update : pending) {
                        update.run();
                    }
                }
            } else {
                log.info("Timeout waiting for disk cache to close");
            }
        } catch (InterruptedException e) {
            log.warn("Interrupted waiting for disk cache to shutdown");
        }
    }
    synchronized (caches) {
        for (H2CacheImpl<?, ?> cache : caches) {
            cache.stop();
        }
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "cast" })
@Override
public <K, V> Cache<K, V> build(CacheBinding<K, V> def) {
    long limit = config.getLong("cache", def.name(), "diskLimit", 128 << 20);
    if (cacheDir == null || limit <= 0) {
        return defaultFactory.build(def);
    }
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit);
    H2CacheImpl<K, V> cache = new H2CacheImpl<K, V>(executor, store, def.keyType(), (Cache<K, ValueHolder<V>>) defaultFactory.create(def, true).build());
    caches.add(cache);
    return cache;
}
#method_after
@SuppressWarnings({ "unchecked", "cast" })
@Override
public <K, V> Cache<K, V> build(CacheBinding<K, V> def) {
    long limit = config.getLong("cache", def.name(), "diskLimit", 128 << 20);
    if (cacheDir == null || limit <= 0) {
        return defaultFactory.build(def);
    }
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit);
    H2CacheImpl<K, V> cache = new H2CacheImpl<K, V>(executor, store, def.keyType(), (Cache<K, ValueHolder<V>>) defaultFactory.create(def, true).build());
    synchronized (caches) {
        caches.add(cache);
    }
    return cache;
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data = new LogSoyData(req, view).toSoyData(paginator, null, df);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, template_name, data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data = new LogSoyData(req, view).toSoyData(paginator, null, df);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        GitilesConfig.putVariant(getAccess(req).getConfig(), "logEntry", "logEntryVariant", data);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(CommitJsonData.toJsonData(c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    Anchor atag;
    if (item.getUrl() != null && isAbsolute(item.getUrl())) {
        atag = anchor(item.getName(), item.getUrl());
    } else {
        atag = anchor(item.getName(), selfRedirect(item.getUrl()));
    }
    atag.setTarget(item.getTarget());
    if (item.getId() != null) {
        atag.getElement().setAttribute("id", item.getId());
    }
    m.add(atag);
}
#method_after
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    Anchor atag = anchor(item.getName(), isAbsolute(item.getUrl()) ? item.getUrl() : selfRedirect(item.getUrl()));
    atag.setTarget(item.getTarget());
    if (item.getId() != null) {
        atag.getElement().setAttribute("id", item.getId());
    }
    m.add(atag);
}
#end_block

#method_before
private static boolean isAbsolute(String url) {
    String pattern = "^https?://.*";
    return url.matches(pattern);
}
#method_after
private static boolean isAbsolute(String url) {
    return url.matches("^https?://.*");
}
#end_block

#method_before
private void insertPatch() {
    String id = revision.substring(0, 7);
    Anchor patchBase64 = new Anchor(id + ".diff.base64");
    patchBase64.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url());
    Anchor patchZip = new Anchor(id + ".diff.zip");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url());
    patchZip = new Anchor(id + ".tar.gz");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("archive").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(patchBase64);
    InlineLabel spacer = new InlineLabel("|");
    spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
    p.add(spacer);
    p.add(patchZip);
    insertCommand("Patch-File", p);
}
#method_after
private void insertPatch() {
    String id = revision.substring(0, 7);
    Anchor patchBase64 = new Anchor(id + ".diff.base64");
    patchBase64.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url());
    Anchor patchZip = new Anchor(id + ".diff.zip");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(patchBase64);
    InlineLabel spacer = new InlineLabel("|");
    spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
    p.add(spacer);
    p.add(patchZip);
    insertCommand("Patch-File", p);
}
#end_block

#method_before
private void insertArchive() {
    String id = revision.substring(0, 7);
    Anchor archive = new Anchor(id + ".tar.gz");
    archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("archive").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(archive);
    insertCommand("Archive", p);
}
#method_after
private void insertArchive() {
    List<Anchor> formats = new ArrayList<>(ARCHIVE.length);
    for (String f : ARCHIVE) {
        Anchor archive = new Anchor(f);
        archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url());
        formats.add(archive);
    }
    HorizontalPanel p = new HorizontalPanel();
    Iterator<Anchor> it = formats.iterator();
    while (it.hasNext()) {
        Anchor a = it.next();
        p.add(a);
        if (it.hasNext()) {
            InlineLabel spacer = new InlineLabel("|");
            spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
            p.add(spacer);
        }
    }
    insertCommand("Archive", p);
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken);
    self.put(key, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken, expiresAt);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    return self.getIfPresent(key.token);
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 0);
}
#method_after
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 6);
    writeFixInt64(out, expiresAt);
    writeVarInt32(out, 0);
}
#end_block

#method_before
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
}
#method_after
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            case 6:
                expiresAt = readFixInt64(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
    if (expiresAt == 0) {
        expiresAt = refreshCookieAt + TimeUnit.HOURS.toMillis(2);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).memoryLimit(// very large items, cache only a few
            128).populateWith(PatchListLoader.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).memoryLimit(// very large items, cache only a few
            128).populateWith(IntraLineLoader.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).maximumWeight(10 << 20).loader(PatchListLoader.class).weigher(PatchListWeigher.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).maximumWeight(10 << 20).loader(IntraLineLoader.class).weigher(IntraLineWeigher.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#end_block

#method_before
public PatchList get(PatchListKey key) {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        // TODO Handle PatchList errors in callers.
        return null;
    }
}
#method_after
@Override
public PatchList get(PatchListKey key) throws PatchListNotAvailableException {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        throw new PatchListNotAvailableException(e.getCause());
    }
}
#end_block

#method_before
public PatchList get(final Change change, final PatchSet patchSet) {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#method_after
@Override
public PatchList get(final Change change, final PatchSet patchSet) throws PatchListNotAvailableException {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).populateWith(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Inject
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.store = factory;
}
#method_after
@Inject(optional = true)
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.persistentCacheFactory = factory;
}
#end_block

#method_before
CacheBinding<K, V> persist(boolean p) {
    persist = p;
    return this;
}
#method_after
CacheBinding<K, V> persist(boolean p) {
    Preconditions.checkState(!frozen, "binding frozen, cannot be modified");
    persist = p;
    return this;
}
#end_block

#method_before
@Override
public Cache<K, V> get() {
    CacheBuilder<K, V> builder = newCacheBuilder();
    builder.maximumSize(maxSize);
    if (0 < maxAge) {
        builder.expireAfterWrite(maxAge, TimeUnit.SECONDS);
    }
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && store != null) {
            return store.build(name, keyType, valType, builder, ldr);
        }
        return builder.build(ldr);
    } else if (persist && store != null) {
        return store.build(name, keyType, valType, builder);
    } else {
        return builder.build();
    }
}
#method_after
@Override
public Cache<K, V> get() {
    frozen = true;
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && persistentCacheFactory != null) {
            return persistentCacheFactory.build(this, ldr);
        }
        return memoryCacheFactory.build(this, ldr);
    } else if (persist && persistentCacheFactory != null) {
        return persistentCacheFactory.build(this);
    } else {
        return memoryCacheFactory.build(this);
    }
}
#end_block

#method_before
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(name, keyType, valType, this);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.memoryLimit(1024);
}
#method_after
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(this, name, keyType, valType);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.maximumWeight(1024);
}
#end_block

#method_before
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType.getType(), m.valType.getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType.getType(), m.valType.getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType.getType(), m.valType.getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#method_after
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType().getType(), m.valueType().getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType().getType(), m.valueType().getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType().getType(), m.valueType().getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).memoryLimit(// reasonable default for many sites
            1024).maxAge(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).maximumWeight(// reasonable default for many sites
            1024).expireAfterWrite(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#end_block

#method_before
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "");
}
#method_after
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "", 0);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).populateWith(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).memoryLimit(1).populateWith(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).loader(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).maximumWeight(1).loader(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).populateWith(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).loader(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2BackedCache<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2BackedCache<?, ?>> entry : disks.entrySet()) {
        H2BackedCache<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2BackedCache.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#method_after
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2CacheImpl<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2CacheImpl<?, ?>> entry : disks.entrySet()) {
        H2CacheImpl<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2CacheImpl.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#end_block

#method_before
private void printMemoryCaches(Map<String, H2BackedCache<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2BackedCache) {
            disks.put(entry.getKey(), (H2BackedCache<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#method_after
private void printMemoryCaches(Map<String, H2CacheImpl<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2CacheImpl) {
            disks.put(entry.getKey(), (H2CacheImpl<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#end_block

#method_before
private String duration(double ns) {
    if (Math.abs(ns) < 0.01) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private String duration(double ns) {
    if (ns < 0.5) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).populateWith(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).loader(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).populateWith(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).populateWith(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).loader(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).loader(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).populateWith(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).loader(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).maxAge(1, HOURS).populateWith(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).populateWith(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new InMemoryCacheModule());
            install(new H2BackedPersistentCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new DefaultCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).memoryLimit(4096).maxAge(10, TimeUnit.MINUTES);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).maximumWeight(4096).expireAfterWrite(10, TimeUnit.MINUTES);
        }
    });
}
#end_block

#method_before
private void setLabelScores(LabelType type, LabelInfo label, short score, Account.Id accountId) throws OrmException {
    if (label.approved != null || label.rejected != null) {
        return;
    }
    if (type.getMin() == null || type.getMax() == null) {
        // Can't set score for unknown or misconfigured type.
        return;
    }
    if (score != 0) {
        if (score == type.getMin().getValue()) {
            if (type.getFunctionName().equalsIgnoreCase("NoBlock")) {
                label.disliked = accountLoader.get(accountId);
            } else {
                label.rejected = accountLoader.get(accountId);
            }
        } else if (score == type.getMax().getValue()) {
            label.approved = accountLoader.get(accountId);
        } else if (score < 0) {
            label.disliked = accountLoader.get(accountId);
            label.value = score;
        } else if (score > 0 && label.disliked == null) {
            label.recommended = accountLoader.get(accountId);
            label.value = score;
        }
    }
    return;
}
#method_after
private void setLabelScores(LabelType type, LabelInfo label, short score, Account.Id accountId) throws OrmException {
    if (label.approved != null || label.rejected != null) {
        return;
    }
    if (type.getMin() == null || type.getMax() == null) {
        // Can't set score for unknown or misconfigured type.
        return;
    }
    if (score < 0) {
        label.disliked = accountLoader.get(accountId);
        label.value = score;
    } else if (score > 0 && label.disliked == null) {
        label.recommended = accountLoader.get(accountId);
        label.value = score;
    }
}
#end_block

#method_before
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#method_after
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else if ("MULTIPLE".equals(param.type())) {
                w = renderTextArea(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            switch(param.type()) {
                case "STRING":
                case "INT":
                case "LONG":
                    w = renderTextBox(g, param);
                    break;
                case "BOOLEAN":
                    w = renderCheckBox(g, param);
                    break;
                case "LIST":
                    w = renderListBox(g, param);
                    break;
                case "ARRAY":
                    w = renderTextArea(g, param);
                    break;
                default:
                    throw new UnsupportedOperationException("unsupported widget type");
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = param.type().equals("STRING") ? new NpTextBox() : new NpIntTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#method_after
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    if (param.permittedValues() == null) {
        return null;
    }
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#end_block

#method_before
private NpTextArea renderTextArea(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextArea txtArea = new NpTextArea();
    txtArea.setVisibleLines(4);
    txtArea.setCharacterWidth(40);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < param.values().length(); i++) {
        String v = param.values().get(i);
        sb.append(v).append("\n");
    }
    txtArea.setText(sb.toString());
    if (param.editable()) {
        saveEnabler.listenTo(txtArea);
    } else {
        txtArea.setEnabled(false);
    }
    addWidget(g, txtArea, param);
    param.values();
    return txtArea;
}
#method_after
private NpTextArea renderTextArea(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextArea txtArea = new NpTextArea();
    txtArea.setVisibleLines(4);
    txtArea.setCharacterWidth(40);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < param.values().length(); i++) {
        String v = param.values().get(i);
        sb.append(v).append("\n");
    }
    txtArea.setText(sb.toString());
    if (param.editable()) {
        saveEnabler.listenTo(txtArea);
    } else {
        txtArea.setEnabled(false);
    }
    addWidget(g, txtArea, param);
    return txtArea;
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            } else if (widget instanceof NpTextArea) {
                NpTextArea txtArea = (NpTextArea) widget;
                values.put(e2.getKey(), txtArea.getText().trim());
            } else {
                throw new UnsupportedOperationException("unupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, ConfigParameterValue>> getPluginConfigValues() {
    Map<String, Map<String, ConfigParameterValue>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, ConfigParameterValue> values = new HashMap<>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(((TextBox) widget).getValue().trim()));
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(Boolean.toString(((CheckBox) widget).getValue())));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), ConfigParameterValue.create().value(value));
            } else if (widget instanceof NpTextArea) {
                String text = ((NpTextArea) widget).getText().trim();
                values.put(e2.getKey(), ConfigParameterValue.create().values(text.split("\n")));
            } else {
                throw new UnsupportedOperationException("unsupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                }
                if (v.getValue() != null) {
                    if (!v.getValue().equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.getValue());
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.getValue());
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.getValue());
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), v.getValue());
                                    break;
                                case MULTIPLE:
                                    cfg.setStringList(v.getKey(), Lists.newArrayList(Splitter.on("\n").split(v.getValue())));
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Override
public String toString() {
    return "push " + uri;
}
#method_after
@Override
public String toString() {
    if (retryCount == 0) {
        return "push " + uri;
    }
    return "(retry " + retryCount + ") " + "push " + uri;
}
#end_block

#method_before
void setToRetry() {
    retrying = true;
}
#method_after
void setToRetry() {
    retrying = true;
    retryCount++;
}
#end_block

#method_before
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
}
#method_after
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    } finally {
        statesCleanUp();
    }
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            log.error("Cannot replicate " + projectName + "; " + e.getMessage());
        } catch (NoRemoteRepositoryException e) {
            log.error("Cannot replicate to " + uri + "; repository not found");
        } catch (NotSupportedException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else if (e instanceof RemoteRepositoryException && e.getMessage().endsWith("failed to lock")) {
                // The RemoteRepositoryException message contains both URI and reason
                // for this intermediate failure.
                log.error("Cannot replicate to " + e.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (RuntimeException e) {
            log.error("Unexpected error during replication to " + uri, e);
        } catch (Error e) {
            log.error("Unexpected error during replication to " + uri, e);
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#method_after
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        final String msg = e.getMessage();
        if (msg.contains("access denied")) {
            createRepository();
        } else {
            log.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            log.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            } else {
                log.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            log.error("Cannot replicate to " + uri, e);
            // The remote push operation should be retried.
            pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
        }
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    for (RemoteRefUpdate u : res.getRemoteUpdates()) {
        switch(u.getStatus()) {
            case OK:
            case UP_TO_DATE:
            case NON_EXISTING:
                break;
            case NOT_ATTEMPTED:
            case AWAITING_REPORT:
            case REJECTED_NODELETE:
            case REJECTED_NONFASTFORWARD:
            case REJECTED_REMOTE_CHANGED:
                log.error(String.format("Failed replicate of %s to %s: status %s", u.getRemoteName(), uri, u.getStatus()));
                break;
            case REJECTED_OTHER_REASON:
                if ("non-fast-forward".equals(u.getMessage())) {
                    log.error(String.format("Failed replicate of %s to %s" + ", remote rejected non-fast-forward push." + "  Check receive.denyNonFastForwards variable in config file" + " of destination repository.", u.getRemoteName(), uri));
                } else if ("failed to lock".equals(u.getMessage())) {
                    throw new RemoteRepositoryException(uri, u.getMessage());
                } else {
                    log.error(String.format("Failed replicate of %s to %s, reason: %s", u.getRemoteName(), uri, u.getMessage()));
                }
                break;
        }
    }
}
#method_after
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    updateStates(res.getRemoteUpdates());
}
#end_block

#method_before
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#method_after
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    log.info("Push to " + uri + " references: " + todo);
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (noPerms && GitRepositoryManager.REF_CONFIG.equals(src.getName())) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && !(noPerms && GitRepositoryManager.REF_CONFIG.equals(src))) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#end_block

#method_before
Collection<CodeReviewCommit> sort(final Collection<CodeReviewCommit> incoming) throws IOException {
    final Set<CodeReviewCommit> heads = new HashSet<CodeReviewCommit>();
    final Set<CodeReviewCommit> sort = new HashSet<CodeReviewCommit>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            rw.markUninteresting(c);
        }
        RevCommit c;
        final RevCommitList<RevCommit> contents = new RevCommitList<RevCommit>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // 
                if (n.missing == null) {
                    n.statusCode = CommitMergeStatus.MISSING_DEPENDENCY;
                    n.missing = new ArrayList<CodeReviewCommit>();
                }
                n.missing.add((CodeReviewCommit) c);
            } else {
                contents.add(c);
            }
        }
        if (n.statusCode == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        // Anything reachable through us is better merged by just
        // merging us directly. So prune our ancestors out and let
        // us merge instead.
        // 
        sort.removeAll(contents);
        heads.removeAll(contents);
        heads.add(n);
    }
    return heads;
}
#method_after
Collection<CodeReviewCommit> sort(final Collection<CodeReviewCommit> incoming) throws IOException {
    final Set<CodeReviewCommit> heads = new HashSet<CodeReviewCommit>();
    final Set<CodeReviewCommit> sort = new HashSet<CodeReviewCommit>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            rw.markUninteresting(c);
        }
        RevCommit c;
        final RevCommitList<RevCommit> contents = new RevCommitList<RevCommit>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<CodeReviewCommit>();
                }
                n.missing.add((CodeReviewCommit) c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        // Anything reachable through us is better merged by just
        // merging us directly. So prune our ancestors out and let
        // us merge instead.
        // 
        sort.removeAll(contents);
        heads.removeAll(contents);
        heads.add(n);
    }
    return heads;
}
#end_block

#method_before
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<CodeReviewCommit>();
    final Set<CodeReviewCommit> sort = new HashSet<CodeReviewCommit>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<CodeReviewCommit>();
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // 
                if (n.missing == null) {
                    n.statusCode = CommitMergeStatus.MISSING_DEPENDENCY;
                    n.missing = new ArrayList<CodeReviewCommit>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.statusCode == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#method_after
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<CodeReviewCommit>();
    final Set<CodeReviewCommit> sort = new HashSet<CodeReviewCommit>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<CodeReviewCommit>();
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<CodeReviewCommit>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        RefUpdate branchUpdate = openBranch();
        boolean reopen = false;
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<Project.SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                if (reopen) {
                    branchUpdate = openBranch();
                }
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                reopen = true;
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        updateChangeStatus(toUpdate);
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.notes(), message(commit.change(), capable.getMessage()), false);
            }
        }
    } catch (NoSuchProjectException noProject) {
        log.warn(String.format("Project %s no longer exists, abandoning open changes", destBranch.getParentKey().get()));
        abandonAllOpenChanges();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        RefUpdate branchUpdate = openBranch();
        boolean reopen = false;
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<Project.SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                if (reopen) {
                    branchUpdate = openBranch();
                }
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                reopen = true;
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.setStatusCode(null);
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        updateChangeStatus(toUpdate);
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.notes(), message(commit.change(), capable.getMessage()), false);
            }
        }
    } catch (NoSuchProjectException noProject) {
        log.warn(String.format("Project %s no longer exists, abandoning open changes", destBranch.getParentKey().get()));
        abandonAllOpenChanges();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            toUpdate.add(chg);
            continue;
        }
        try {
            commit.setControl(changeControlFactory.controlFor(chg, identifiedUserFactory.create(chg.getOwner())));
        } catch (NoSuchChangeException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        commit.setPatchsetId(ps.getId());
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            toUpdate.add(chg);
            continue;
        }
        try {
            commit.setControl(changeControlFactory.controlFor(chg, identifiedUserFactory.create(chg.getOwner())));
        } catch (NoSuchChangeException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        commit.setPatchsetId(ps.getId());
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(commit, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(commit, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.getPatchsetId()), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
}
#end_block

#method_before
private static CodeReviewCommit failed(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#method_after
private static CodeReviewCommit failed(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.setStatusCode(failure);
    }
    return failed;
}
#end_block

#method_before
public PatchSetApproval markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws MergeException {
    if (mergeTip == null) {
        // 
        return null;
    }
    try {
        PatchSetApproval submitApproval = null;
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.getPatchsetId() != null) {
                c.statusCode = CommitMergeStatus.CLEAN_MERGE;
                if (submitApproval == null) {
                    submitApproval = getSubmitter(c);
                }
            }
        }
        return submitApproval;
    } catch (IOException e) {
        throw new MergeException("Cannot mark clean merges", e);
    }
}
#method_after
public PatchSetApproval markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws MergeException {
    if (mergeTip == null) {
        // 
        return null;
    }
    try {
        PatchSetApproval submitApproval = null;
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.getPatchsetId() != null) {
                c.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
                if (submitApproval == null) {
                    submitApproval = getSubmitter(c);
                }
            }
        }
        return submitApproval;
    } catch (IOException e) {
        throw new MergeException("Cannot mark clean merges", e);
    }
}
#end_block

#method_before
public void setStatusCode(CommitMergeStatus s) {
    statusCode = s;
}
#method_after
public void setStatusCode(CommitMergeStatus statusCode) {
    this.statusCode = statusCode;
}
#end_block

#method_before
public void copyFrom(final CodeReviewCommit src) {
    setControl(src.getControl());
    setPatchsetId(src.getPatchsetId());
    originalOrder = src.originalOrder;
    statusCode = src.statusCode;
    missing = src.missing;
}
#method_after
public void copyFrom(final CodeReviewCommit src) {
    control = src.control;
    patchsetId = src.patchsetId;
    originalOrder = src.originalOrder;
    statusCode = src.statusCode;
    missing = src.missing;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#method_after
@SuppressWarnings("unchecked")
public static Integer getLimit(Predicate<ChangeData> p) {
    IntPredicate<?> ip = (IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT);
    return ip != null ? ip.intValue() : null;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> age(String value) {
    return new AgePredicate(value);
}
#method_after
@Operator
public Predicate<ChangeData> age(String value) {
    return new AgePredicate(schema(args.indexes), value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(BasicChangeRewrites.schema(args.indexes), args.db, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(schema(args.indexes), args.db, sortKey);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(BasicChangeRewrites.schema(args.indexes), args.db, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(schema(args.indexes), args.db, sortKey);
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadGitChecks(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    ResultSet<Account> accounts = db.accounts().all();
    for (Account account : accounts) {
        String out = new StringBuilder().append(account.getId().toString()).append(" |").append(Strings.isNullOrEmpty(account.getFullName()) ? "" : " " + account.getFullName()).append(" |").append(Strings.isNullOrEmpty(account.getPreferredEmail()) ? "" : " " + account.getPreferredEmail()).toString();
        stdout.println(out);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    ResultSet<Account> accounts = db.accounts().iterateAllEntities();
    for (Account account : accounts) {
        String out = new StringBuilder().append(account.getId().toString()).append(" |").append(Strings.isNullOrEmpty(account.getFullName()) ? "" : " " + account.getFullName()).append(" |").append(Strings.isNullOrEmpty(account.getPreferredEmail()) ? "" : " " + account.getPreferredEmail()).toString();
        stdout.println(out);
    }
}
#end_block

#method_before
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (doBind(meta.mode())) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#method_after
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (meta.runsAt().isSupported(slaveMode)) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#end_block

#method_before
static void call(Button b, final Change.Id id, final String revision, String project, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    Gerrit.display(PageLinks.toChange2(id));
                    hide();
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final Change.Id id, final String revision, String project, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    call(id, "detail").get(cb);
}
#method_after
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    detail(id).get(cb);
}
#end_block

#method_before
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    call(id, "detail").get(cb);
}
#method_after
public static void detail(int id, EnumSet<ListChangesOption> options, AsyncCallback<ChangeInfo> cb) {
    RestApi call = detail(id);
    if (!options.isEmpty()) {
        ChangeList.addOptions(call, options);
    }
    call.get(cb);
}
#end_block

#method_before
private static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#method_after
public static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#end_block

#method_before
public final void init() {
    if (labels0() != null) {
        labels0().copyKeysIntoChildren("_name");
    }
}
#method_after
public final void init() {
    if (all_labels() != null) {
        all_labels().copyKeysIntoChildren("_name");
    }
}
#end_block

#method_before
public final Set<String> labels() {
    return labels0().keySet();
}
#method_after
public final Set<String> labels() {
    return all_labels().keySet();
}
#end_block

#method_before
static void call(Button b, final Change.Id id, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    Gerrit.display(PageLinks.toChange2(id));
                    hide();
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final Change.Id id, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
public static String toChange2(final Change.Id c) {
    return "/c2/" + c + "/";
}
#method_after
public static String toChange2(Change.Id c, String p) {
    return "/c2/" + c + "/" + p;
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/c2/", token)) {
        String s = skip(token);
        if (s.endsWith("/")) {
            s = s.substring(0, s.length() - 1);
        }
        Change.Id id = Change.Id.parse(s);
        Gerrit.display(token, new ChangeScreen2(id));
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/c2/", token)) {
        change2(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            loadConfigInfo(info);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ChangeApi.detail(changeId.get(), EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info);
        }
    });
}
#end_block

#method_before
@UiHandler("starIcon")
void onToggleStar(ClickEvent e) {
    boolean newState = !starred;
    StarredChanges.toggleStar(changeId, newState);
    renderStar(newState);
}
#method_after
@UiHandler("star")
void onToggleStar(ValueChangeEvent<Boolean> e) {
    StarredChanges.toggleStar(changeId, e.getValue());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info) {
    CallbackGroup group = new CallbackGroup();
    DiffApi.list(changeId.get(), info.current_revision(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> files) {
            renderFiles(files);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(rev, group);
    loadCommit(rev, group);
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
    group.done();
    if (info.status().isOpen() && rev.name().equals(info.current_revision())) {
        loadSubmitAction(rev);
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    accountCache = new HashMap<String, AccountInfo>();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean canSubmit = renderLabels(info);
    renderStar(info.starred());
    renderOwner(info);
    renderActionTextDate(info);
    renderStandardActions(info, canSubmit);
    renderCommitInfo(info);
    renderHistory(info);
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    topicText.setInnerText(info.topic());
    idText.setInnerText(info.change_id());
    // submit_type?
    submitTypeText.setInnerText("Merge If Necessary");
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean canSubmit = labels.set(info);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision, canSubmit);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    boolean hasConflict = Gerrit.getConfig().testChangeMerge() && !info.mergeable();
    setVisible(notMergeable, hasConflict);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    reply.setVisible(replyAction != null);
    if (canSubmit && !hasConflict && actions.isSubmitEnabled()) {
        statusText.setInnerText(Util.C.readyToSubmit());
    } else if (canSubmit && hasConflict) {
        statusText.setInnerText(Util.C.mergeConflict());
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // info card hover
    ownerText.setInnerText(info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName());
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    ownerText.setInnerText(info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName());
}
#end_block

#method_before
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, List<ConfigValueInput>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, List<ConfigValueInput>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (ConfigValueInput v : e.getValue()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.name);
            if (projectConfigEntry != null) {
                if (!v.name.matches("^[a-zA-Z0-9]*[a-zA-Z0-9-]*$")) {
                    log.warn("The name of the parameter '" + v.name + "' of the plugin '" + pluginName + "' is invalid.");
                    continue;
                }
                if (v.value == null) {
                    cfg.unset(v.name);
                } else {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case BOOLEAN:
                                cfg.setBoolean(v.name, Boolean.parseBoolean(v.value));
                                break;
                            case INT:
                                cfg.setInt(v.name, Integer.parseInt(v.value));
                                break;
                            case LONG:
                                cfg.setLong(v.name, Long.parseLong(v.value));
                                break;
                            case STRING:
                            case LIST:
                            default:
                                cfg.setString(v.name, v.value);
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException("The value '" + v.value + "' of config paramter '" + v.name + "' of plugin '" + pluginName + "' is invalid: " + ex.getMessage());
                    }
                }
            } else {
                throw new BadRequestException("The config paramter '" + v.name + "' of plugin '" + pluginName + "' does not exist.");
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                if (v.getValue() != null) {
                    cfg.setString(v.getKey(), v.getValue());
                } else {
                    cfg.unset(v.getKey());
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    NativeMap<JsArray<ConfigValueInput>> configValues = NativeMap.create().cast();
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        JsArray<ConfigValueInput> values = JsArray.createArray().cast();
        configValues.put(e.getKey(), values);
        for (Entry<String, String> e2 : e.getValue().entrySet()) {
            ConfigValueInput i = ConfigValueInput.create();
            i.setName(e2.getKey());
            i.setValue(e2.getValue());
            values.push(i);
        }
    }
    setPluginConfigValuesRaw(configValues);
}
#method_after
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<StringMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
            StringMap values = StringMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, String> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    submitType.setEnabled(isOwner);
    state.setEnabled(isOwner);
    contentMerge.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, Widget> widgetMap : pluginConfigWidgets.values()) {
            for (Widget widget : widgetMap.values()) {
                ((FocusWidget) widget).setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    submitType.setEnabled(isOwner);
    state.setEnabled(isOwner);
    contentMerge.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, FocusWidget> widgetMap : pluginConfigWidgets.values()) {
            for (FocusWidget widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, Widget>>();
    for (String pluginName : Natives.keys(info.pluginConfigParameters())) {
        Map<String, Widget> widgetMap = new HashMap<String, Widget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        for (ConfigParameterInfo param : Natives.asList(info.pluginConfigParameter(pluginName))) {
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                NpTextBox textBox = new NpTextBox();
                if (param.inheritable()) {
                    textBox.setValue(param.configuredValue());
                    Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
                    inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
                    HorizontalPanel p = new HorizontalPanel();
                    p.add(textBox);
                    p.add(inheritedLabel);
                    g.add(param.displayName() != null ? param.displayName() : param.name(), p);
                } else {
                    textBox.setValue(param.value());
                    g.add(param.displayName() != null ? param.displayName() : param.name(), textBox);
                }
                saveEnabler.listenTo(textBox);
                widgetMap.put(param.name(), textBox);
            } else if ("BOOLEAN".equals(param.type())) {
                CheckBox checkbox = new CheckBox();
                checkbox.setValue(Boolean.parseBoolean(param.value()));
                g.add(param.displayName() != null ? param.displayName() : param.name(), checkbox);
                saveEnabler.listenTo(checkbox);
                widgetMap.put(param.name(), checkbox);
            } else if ("LIST".equals(param.type())) {
                ListBox listBox = new ListBox();
                if (param.inheritable()) {
                    listBox.addItem(Util.C.inheritListValue());
                    if (param.configuredValue() == null) {
                        listBox.setSelectedIndex(0);
                    }
                    for (int i = 0; i < param.supportedValues().length(); i++) {
                        String sv = param.supportedValues().get(i);
                        listBox.addItem(sv);
                        if (sv.equals(param.configuredValue())) {
                            listBox.setSelectedIndex(i + 1);
                        }
                    }
                    Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
                    inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
                    HorizontalPanel p = new HorizontalPanel();
                    p.add(listBox);
                    p.add(inheritedLabel);
                    g.add(param.displayName() != null ? param.displayName() : param.name(), p);
                } else {
                    for (int i = 0; i < param.supportedValues().length(); i++) {
                        String sv = param.supportedValues().get(i);
                        listBox.addItem(sv);
                        if (sv.equals(param.value())) {
                            listBox.setSelectedIndex(i);
                        }
                    }
                    g.add(param.displayName() != null ? param.displayName() : param.name(), listBox);
                }
                saveEnabler.listenTo(listBox);
                widgetMap.put(param.name(), listBox);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, Widget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, Widget> e2 : e.getValue().entrySet()) {
            Widget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                String value = listBox.getValue(listBox.getSelectedIndex());
                if ("INHERIT".equals(value)) {
                    value = null;
                }
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.onProjectCreated(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#end_block

#method_before
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        log.error("Cannot replicate " + projectName + "; " + e.getMessage());
    } catch (NoRemoteRepositoryException e) {
        if (pool.isCreateMissingRepos()) {
            try {
                createRepository();
                log.warn("Missing repository created; retry replication to " + uri);
                pool.reschedule(this, Destination.RetryReason.REPOSITORY_MISSING);
            } catch (IOException ioe) {
                wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
            }
        } else {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        }
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else {
            log.error("Cannot replicate to " + uri, e);
        }
        // The remote push operation should be retried.
        pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#method_after
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        log.error("Cannot replicate " + projectName + "; " + e.getMessage());
    } catch (NoRemoteRepositoryException e) {
        if (pool.isCreateMissingRepos()) {
            try {
                createRepository();
                log.warn("Missing repository created; retry replication to " + uri);
                pool.reschedule(this, Destination.RetryReason.REPOSITORY_MISSING);
            } catch (IOException ioe) {
                wrappedLog.error("Cannot replicate to " + uri + "; failed to create missing repository", ioe, getStatesAsArray());
            }
        } else {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        }
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else {
            log.error("Cannot replicate to " + uri, e);
        }
        // The remote push operation should be retried.
        pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        URL url = ConfigAnnotationParser.class.getResource(CONFIG_DIR + name);
        if (url != null) {
            cfg.fromText(Resources.toString(url, Charsets.UTF_8));
        }
    }
    return cfg;
}
#method_after
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        String resource = CONFIG_DIR + name + ".config";
        URL url = checkNotNull(ConfigAnnotationParser.class.getResource(resource), "test config resource not found: %s", resource);
        cfg.fromText(Resources.toString(url, Charsets.UTF_8));
    }
    return cfg;
}
#end_block

#method_before
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parse(cfg, c);
    }
    return cfg;
}
#method_after
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parseAnnotation(cfg, c);
    }
    return cfg;
}
#end_block

#method_before
private void reloadIfNeeded() {
    if (isAutoReload() && currentConfig.getCfgPath().lastModified() > currentConfigTs) {
        try {
            ReplicationFileBasedConfig newConfig = loadConfig();
            newConfig.startup(workQueue);
            int discarded = currentConfig.shutdown();
            this.currentConfig = newConfig;
            this.currentConfigTs = currentConfig.getCfgPath().lastModified();
            LOG.info("Configuration reloaded: " + currentConfig.getDestinations().size() + " destinations, " + discarded + " replication events discarded");
        } catch (Exception e) {
            LOG.error("Cannot reload replication configuration: keeping existing settings", e);
            return;
        }
    }
}
#method_after
private void reloadIfNeeded() {
    if (isAutoReload() && currentConfig.getCfgPath().lastModified() > currentConfigTs) {
        try {
            ReplicationFileBasedConfig newConfig = loadConfig();
            newConfig.startup(workQueue);
            int discarded = currentConfig.shutdown();
            this.currentConfig = newConfig;
            this.currentConfigTs = currentConfig.getCfgPath().lastModified();
            log.info("Configuration reloaded: " + currentConfig.getDestinations().size() + " destinations, " + discarded + " replication events discarded");
        } catch (Exception e) {
            log.error("Cannot reload replication configuration: keeping existing settings", e);
            return;
        }
    }
}
#end_block

#method_before
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("No " + config.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Empty " + config.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, config, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + "does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, config, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(SecureCredentialsFactory.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
}
#method_after
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalsUtil.copyLabels(db, changeCtl, newPatchSet.getId());
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet.getId());
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(c, patchSet.getCreatedOn(), (IdentifiedUser) ctl.getCurrentUser());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            insertMessage(db);
        }
        if (copyLabels) {
            approvalsUtil.copyLabels(db, ctl, patchSet.getId());
        }
        db.commit();
        update.commit();
        if (!messageIsForChange()) {
            insertMessage(db);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(updatedChange);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(c, patchSet.getCreatedOn(), (IdentifiedUser) ctl.getCurrentUser());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            insertMessage(db);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet.getId());
        }
        db.commit();
        update.commit();
        if (!messageIsForChange()) {
            insertMessage(db);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(updatedChange);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#end_block

#method_before
private static PatchSetApproval copy(PatchSetApproval src, PatchSet.Id psId) {
    if (src.getKey().getParentKey().equals(psId)) {
        return src;
    }
    return new PatchSetApproval(psId, src);
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, psId));
}
#end_block

#method_before
List<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.allApprovalsMap();
        Change.Id cid = cd.change().getId();
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(psId)) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Map<Integer, PatchSet> patchSets = getPatchSets(cd);
        PatchSet currPs = patchSets.get(psId.get());
        if (currPs == null) {
            throw new OrmException("missing patch set " + psId);
        }
        Repository repo = repoManager.openRepository(project.getProject().getNameKey());
        try {
            for (int i = psId.get() - 1; i >= 1; i--) {
                PatchSet.Id prior = new PatchSet.Id(cid, i);
                PatchSet priorPs = patchSets.get(i);
                if (priorPs == null) {
                    throw new OrmException("missing patch set " + prior);
                }
                List<PatchSetApproval> priorApprovals = all.get(prior);
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(currPs.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (!byUser.contains(psa.getLabel(), psa.getAccountId()) && canCopy(project, psa, kind)) {
                        byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, psId));
                    }
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values());
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private List<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.allApprovalsMap();
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(psId)) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        NavigableSet<Integer> allPsIds = patchSets.navigableKeySet();
        PatchSet currPs = patchSets.get(psId.get());
        if (currPs == null) {
            throw new OrmException("missing patch set " + psId);
        }
        Repository repo = repoManager.openRepository(project.getProject().getNameKey());
        try {
            // Walk patch sets strictly less than psId in descending order.
            for (PatchSet priorPs : patchSets.descendingMap().tailMap(psId.get(), false).values()) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(currPs.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (!byUser.contains(psa.getLabel(), psa.getAccountId()) && canCopy(project, psa, psId, allPsIds, kind)) {
                        byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, psId));
                    }
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values());
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private static Map<Integer, PatchSet> getPatchSets(ChangeData cd) throws OrmException {
    Collection<PatchSet> patchSets = cd.patches();
    Map<Integer, PatchSet> result = Maps.newHashMapWithExpectedSize(patchSets.size());
    for (PatchSet ps : patchSets) {
        result.put(ps.getId().get(), ps);
    }
    return result;
}
#method_after
private static TreeMap<Integer, PatchSet> getPatchSets(ChangeData cd) throws OrmException {
    Collection<PatchSet> patchSets = cd.patches();
    TreeMap<Integer, PatchSet> result = Maps.newTreeMap();
    for (PatchSet ps : patchSets) {
        result.put(ps.getId().get(), ps);
    }
    return result;
}
#end_block

#method_before
private static boolean canCopy(ProjectState project, PatchSetApproval psa, ChangeKind kind) throws OrmException {
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa)) {
        return true;
    }
    return (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE);
}
#method_after
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) throws OrmException {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equal(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE);
}
#end_block

#method_before
@Override
protected void configure() {
    super.configure();
    install(ThreadLocalRequestContext.module());
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    cfgInjector = createCfgInjector();
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    // modules.add(new LogFileCompressor.Module());
    // modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModuleBase.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(NoSshKeyCache.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(CurrentUser.class).toProvider(new Provider<CurrentUser>() {

                @Override
                public CurrentUser get() {
                    return null;
                }
            });
            bind(IdentifiedUser.class).toProvider(new Provider<IdentifiedUser>() {

                @Override
                public IdentifiedUser get() {
                    return null;
                }
            });
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new FactoryModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
            factory(ChangeData.Factory.class);
            factory(ProjectState.Factory.class);
            bind(new TypeLiteral<List<CommentLinkInfo>>() {
            }).toProvider(CommentLinkProvider.class).in(SINGLETON);
            bind(CurrentUser.class).toProvider(Providers.<CurrentUser>of(null));
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
            factory(IncludingGroupMembership.Factory.class);
            bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
            DynamicSet.setOf(binder(), GroupBackend.class);
            bind(InternalGroupBackend.class).in(SINGLETON);
            DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
            DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
            factory(InternalUser.Factory.class);
            factory(PatchSetInserter.Factory.class);
            bind(ChangeHooks.class).to(DisabledChangeHooks.class);
            bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
            factory(CapabilityControl.Factory.class);
            factory(MergeUtil.Factory.class);
            DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
            DynamicSet.setOf(binder(), CommitValidationListener.class);
            factory(CommitValidators.Factory.class);
        }
    });
    modules.add(AccountCacheImpl.module());
    modules.add(AccountByEmailCacheImpl.module());
    modules.add(ChangeKindCache.module());
    modules.add(GroupCacheImpl.module());
    modules.add(GroupIncludeCacheImpl.module());
    modules.add(ProjectCacheImpl.module());
    modules.add(SectionSortCache.module());
    modules.add(new AccessControlModule());
    modules.add(new GitModule());
    modules.add(new PrologModule());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @MergeabilityChecksExecutor
        public WorkQueue.Executor createMergeabilityChecksExecutor(WorkQueue queues) {
            return queues.createQueue(1, "MergeabilityChecks");
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(GitRepositoryManager.REF_CONFIG)) {
        executor.submit(new RefUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(RefNames.REFS_CONFIG)) {
        executor.submit(new BranchUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
    if (ref.equals(RefNames.REFS_CONFIG)) {
        Project.NameKey p = new Project.NameKey(event.getProjectName());
        try {
            ProjectConfig oldCfg = parseConfig(p, event.getOldObjectId());
            ProjectConfig newCfg = parseConfig(p, event.getNewObjectId());
            if (recheckMerges(oldCfg, newCfg)) {
                try {
                    new ProjectUpdateTask(schemaFactory, p, true).call();
                } catch (Exception e) {
                    String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
                    log.error(msg, e);
                    Throwables.propagateIfPossible(e);
                    throw new RuntimeException(msg, e);
                }
            }
        } catch (ConfigInvalidException | IOException e) {
            String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
            log.error(msg, e);
            throw new RuntimeException(msg, e);
        }
    }
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return updateAsync(change, false);
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
private CheckedFuture<Boolean, IOException> updateAsync(Change change, boolean force) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change, force)), MAPPER);
}
#end_block

#method_before
public CheckedFuture<?, IOException> updateAndIndexAsync(final Change change) {
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(change);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#method_after
public CheckedFuture<?, IOException> updateAndIndexAsync(Change change) {
    final Change.Id id = change.getId();
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(id);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#end_block

#method_before
public boolean update(Change change) throws IOException {
    try {
        return new ChangeUpdateTask(schemaFactory, change).call();
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#method_after
public void update(Project.NameKey project) throws IOException {
    try {
        for (CheckedFuture<?, IOException> f : new ProjectUpdateTask(schemaFactory, project, false).call()) {
            f.checkedGet();
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#end_block

#method_before
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        MergeableInfo info = mergeable.get().apply(new RevisionResource(new ChangeResource(changeControlFactory.controlFor(change, context.getCurrentUser())), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#method_after
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change, force);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        Mergeable m = mergeable.get();
        m.setForce(force);
        ChangeControl control = changeControlFactory.controlFor(change.getId(), context.getCurrentUser());
        MergeableInfo info = m.apply(new RevisionResource(new ChangeResource(control), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#end_block

#method_before
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
        // TODO(davido): include indexing of mergeable field in MPM above
        for (Project.NameKey project : projects) {
            List<CheckedFuture<?, IOException>> f = checker.reindexProject(project);
            for (CheckedFuture<?, IOException> checkedFuture : f) {
                checkedFuture.checkedGet();
            }
        }
    } catch (ExecutionException | IOException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        try {
            mergeabilityChecker.update(project);
        } catch (IOException e) {
            log.error("Error in mergeability checker", e);
            ok.set(false);
        }
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                for (Change c : db.get().changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), new ChangeData(c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            ReviewDb db = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                db = schemaFactory.open();
                for (Change c : db.changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), changeDataFactory.create(db, c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (db != null) {
                    db.close();
                }
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    user = accounts.user();
    admin = accounts.admin();
    initSsh(admin);
    project = new Project.NameKey("p");
    session = new RestSession(server, user);
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), user.getId())));
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    grant(cfg, Permission.forLabel("Code-Review"), -2, 2, anonymousUsers, "refs/heads/*");
    grant(cfg, Permission.SUBMIT, anonymousUsers, "refs/heads/*");
    codeReview = checkNotNull(cfg.getLabelSections().get("Code-Review"));
    codeReview.setCopyMinScore(false);
    codeReview.setCopyMaxScore(false);
    codeReview.setCopyAllScoresOnTrivialRebase(false);
    codeReview.setCopyAllScoresIfNoCodeChange(false);
    saveProjectConfig(cfg);
}
#method_after
@Before
public void setUp() throws Exception {
    user = accounts.user();
    admin = accounts.admin();
    initSsh(admin);
    project = new Project.NameKey("p");
    session = new RestSession(server, user);
    SshSession sshSession = new SshSession(server, admin);
    try {
        createProject(sshSession, project.get());
        git = cloneProject(sshSession.getUrl() + "/" + project.get());
        db = reviewDbProvider.open();
        atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), user.getId())));
    } finally {
        sshSession.close();
    }
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    grant(cfg, Permission.forLabel("Code-Review"), -2, 2, anonymousUsers, "refs/heads/*");
    grant(cfg, Permission.SUBMIT, anonymousUsers, "refs/heads/*");
    codeReview = checkNotNull(cfg.getLabelSections().get("Code-Review"));
    codeReview.setCopyMinScore(false);
    codeReview.setCopyMaxScore(false);
    codeReview.setCopyAllScoresOnTrivialRebase(false);
    codeReview.setCopyAllScoresIfNoCodeChange(false);
    saveProjectConfig(cfg);
}
#end_block

#method_before
private void merge(PushOneCommit.Result r) throws Exception {
    review(r, 2);
    SubmitInput input = new SubmitInput();
    input.waitForMerge = true;
    revision(r).submit(input);
    Repository repo = repoManager.openRepository(project);
    try {
        assertEquals(r.getCommitId(), repo.getRef("refs/heads/master").getObjectId());
    } finally {
        repo.close();
    }
}
#method_after
private void merge(PushOneCommit.Result r) throws Exception {
    review(r, 2);
    revision(r).submit();
    Repository repo = repoManager.openRepository(project);
    try {
        assertEquals(r.getCommitId(), repo.getRef("refs/heads/master").getObjectId());
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ProjectResource projectResource = new ProjectResource(project);
        CreateBranch.Input input = new CreateBranch.Input();
        input.ref = ref;
        input.revision = revision;
        createBranchFactory.create(ref).apply(projectResource, input);
    } catch (IOException e) {
        throw new RestApiException("Cannot create branch", e);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        BranchInput in = new BranchInput();
        in.revision = revision;
        gApi.projects().name(project.getProject().getNameKey().get()).branch(name).create(in);
    } catch (RestApiException e) {
        throw new UnloggedFailure(1, "fatal: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugUrl = getConfig().getReportBugUrl();
    final String reportBugTitle = getConfig().getReportBugText();
    if (reportBugUrl != null) {
        Anchor a = new Anchor(reportBugTitle == null ? C.reportBug() : reportBugTitle, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugText = getConfig().getReportBugText();
    Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, getConfig().getReportBugUrl());
    a.setTarget("_blank");
    a.setStyleName("");
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(a);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    if (Strings.isNullOrEmpty(config.getReportBugText())) {
        config.setReportBugText(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
public void setReportBugText(String u) {
    reportBugText = u;
}
#method_after
public void setReportBugText(String t) {
    reportBugText = t;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private final PGPEncryptedDataGenerator cpk() throws NoSuchProviderException, PGPException {
    final PGPEncryptedDataGenerator cpk = new PGPEncryptedDataGenerator(PGPEncryptedData.CAST5, true, prng, "BC");
    cpk.addMethod(dest);
    return cpk;
}
#method_after
@SuppressWarnings("deprecation")
private final PGPEncryptedDataGenerator cpk() throws NoSuchProviderException, PGPException {
    PGPEncryptedDataGenerator cpk = new PGPEncryptedDataGenerator(PGPEncryptedData.CAST5, true, prng, "BC");
    cpk.addMethod(dest);
    return cpk;
}
#end_block

#method_before
private ItsAssociationPolicy getItsAssociationPolicy() {
    return gerritConfig.getEnum("commentLink", pluginsName, "association", ItsAssociationPolicy.OPTIONAL);
}
#method_after
private ItsAssociationPolicy getItsAssociationPolicy() {
    return gerritConfig.getEnum("commentLink", pluginName, "association", ItsAssociationPolicy.OPTIONAL);
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + "/plugins/";
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, base + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar == null) {
            String jsFileName = file.replaceFirst("static/", "");
            sendJsPlugin(jsFileName, key, req, res);
        } else {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            if (name.substring(prefix.length()).startsWith("cmd-")) {
                cmds.add(entry);
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (!docs.isEmpty()) {
        md.append("## Documentation ##\n");
        for (JarEntry entry : docs) {
            String rsrc = entry.getName().substring(prefix.length());
            String title;
            if (rsrc.endsWith(".html")) {
                title = rsrc.substring(0, rsrc.length() - 5).replace('-', ' ');
            } else if (rsrc.endsWith(".md")) {
                title = extractTitleFromMarkdown(jar, entry);
                if (Strings.isNullOrEmpty(title)) {
                    title = rsrc.substring(0, rsrc.length() - 3).replace('-', ' ');
                }
                rsrc = rsrc.substring(0, rsrc.length() - 3) + ".html";
            } else {
                title = rsrc.replace('-', ' ');
            }
            md.append(String.format("* [%s](%s)\n", title, rsrc));
        }
        md.append("\n");
    }
    if (!cmds.isEmpty()) {
        md.append("## Commands ##\n");
        for (JarEntry entry : cmds) {
            String rsrc = entry.getName().substring(prefix.length());
            String title;
            if (rsrc.endsWith(".html")) {
                title = rsrc.substring(4, rsrc.length() - 5).replace('-', ' ');
            } else if (rsrc.endsWith(".md")) {
                title = extractTitleFromMarkdown(jar, entry);
                if (Strings.isNullOrEmpty(title)) {
                    title = rsrc.substring(4, rsrc.length() - 3).replace('-', ' ');
                }
                rsrc = rsrc.substring(0, rsrc.length() - 3) + ".html";
            } else {
                title = rsrc.substring(4).replace('-', ' ');
            }
            md.append(String.format("* [%s](%s)\n", title, rsrc));
        }
        md.append("\n");
    }
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#method_after
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#end_block

#method_before
private void sendResource(JarFile jar, JarEntry entry, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] data = null;
    if (entry.getSize() <= SMALL_RESOURCE) {
        data = readWholeEntry(jar, entry);
    }
    String contentType = null;
    String charEnc = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        charEnc = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    if (contentType == null) {
        contentType = mimeUtil.getMimeType(entry.getName(), data).toString();
        if ("application/octet-stream".equals(contentType) && entry.getName().endsWith(".js")) {
            contentType = "application/javascript";
        }
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setHeader("Content-Length", Long.toString(entry.getSize()));
    res.setContentType(contentType);
    if (charEnc != null) {
        res.setCharacterEncoding(charEnc);
    }
    if (data != null) {
        resourceCache.put(key, new SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time));
        res.getOutputStream().write(data);
    } else {
        InputStream in = jar.getInputStream(entry);
        writeToResponse(res, in);
    }
}
#method_after
private void sendResource(JarFile jar, JarEntry entry, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] data = null;
    if (entry.getSize() <= SMALL_RESOURCE) {
        data = readWholeEntry(jar, entry);
    }
    String contentType = null;
    String charEnc = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        charEnc = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    if (contentType == null) {
        contentType = mimeUtil.getMimeType(entry.getName(), data).toString();
        if ("application/octet-stream".equals(contentType) && entry.getName().endsWith(".js")) {
            contentType = "application/javascript";
        }
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setHeader("Content-Length", Long.toString(entry.getSize()));
    res.setContentType(contentType);
    if (charEnc != null) {
        res.setCharacterEncoding(charEnc);
    }
    if (data != null) {
        resourceCache.put(key, new SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time));
        res.getOutputStream().write(data);
    } else {
        writeToResponse(res, jar.getInputStream(entry));
    }
}
#end_block

#method_before
private void sendJsPlugin(String jsFileName, ResourceKey key, HttpServletRequest req, HttpServletResponse res) throws IOException {
    File jsFile = new File(pluginsDir, jsFileName);
    if (jsFile.exists()) {
        res.setHeader("Content-Length", Long.toString(jsFile.length()));
        res.setContentType("application/javascript");
        writeToResponse(res, new FileInputStream(jsFile));
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void sendJsPlugin(Plugin plugin, ResourceKey key, HttpServletRequest req, HttpServletResponse res) throws IOException {
    File pluginFile = plugin.getSrcFile();
    if (req.getPathInfo().equals(getJsPluginPath(plugin)) && pluginFile.exists()) {
        res.setHeader("Content-Length", Long.toString(pluginFile.length()));
        res.setContentType("application/javascript");
        writeToResponse(res, new FileInputStream(pluginFile));
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
@Override
public String getServletPath() {
    return ((HttpServletRequest) getRequest()).getRequestURI().substring(contextPath.length());
}
#method_after
@Override
public String getServletPath() {
    return getRequestURI().substring(contextPath.length());
}
#end_block

#method_before
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    manager = new LifecycleManager();
    String fileName = getSrcFile().getName();
    httpInjector = Guice.createInjector(new StandaloneJsPluginModule(getName(), fileName));
    manager.add(httpInjector);
    manager.start();
}
#method_after
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    manager = new LifecycleManager();
    String fileName = getSrcFile().getName();
    httpInjector = Guice.createInjector(new StandaloneJsPluginModule(getName(), fileName));
    manager.start();
}
#end_block

#method_before
@Override
void stop(PluginGuiceEnvironment env) {
    if (manager != null) {
        manager.stop();
    }
}
#method_after
@Override
void stop(PluginGuiceEnvironment env) {
    if (manager != null) {
        manager.stop();
        httpInjector = null;
    }
}
#end_block

#method_before
@Override
boolean canReload() {
    return false;
}
#method_after
@Override
boolean canReload() {
    return true;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
    bind(WebUiPlugin.class).annotatedWith(UniqueAnnotations.create()).toInstance(new JavaScriptPlugin(fileName));
}
#method_after
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin(fileName));
}
#end_block

#method_before
public void installPluginFromStream(String name, InputStream in) throws IOException, PluginInstallException {
    if (!(name.endsWith(".jar") || name.endsWith(".js"))) {
        throw new ParserInitializationException("Can only install files with '.jar' and '.js' extension");
    }
    File jar = new File(pluginsDir, name);
    name = nameOf(jar);
    File old = new File(pluginsDir, ".last_" + name + ".zip");
    File tmp = asTemp(in, ".next_" + name, ".zip", pluginsDir);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            log.info(String.format("Replacing plugin %s", name));
            old.delete();
            jar.renameTo(old);
        }
        new File(pluginsDir, name + ".jar.disabled").delete();
        tmp.renameTo(jar);
        try {
            runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", name));
            }
        } catch (PluginInstallException e) {
            jar.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#method_after
public void installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    String fileName = originalName;
    if (!(fileName.endsWith(".jar") || fileName.endsWith(".js"))) {
        fileName += ".jar";
    }
    File tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = Objects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>," + " use it instead of the input name: <%s>", name, originalName));
    }
    String fileExtension = getExtension(fileName);
    File dst = new File(pluginsDir, name + fileExtension);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getName();
            log.info(String.format("Replacing plugin %s", active.getName()));
            File old = new File(pluginsDir, ".last_" + fileName);
            old.delete();
            active.getSrcFile().renameTo(old);
        }
        new File(pluginsDir, fileName + ".disabled").delete();
        tmp.renameTo(dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            dst.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public static File storeInTemp(String pluginName, InputStream in, SitePaths sitePaths) throws IOException {
    return asTemp(in, tempNameFor(pluginName), ".jar", sitePaths.tmp_dir);
}
#method_after
public static File storeInTemp(String pluginName, InputStream in, SitePaths sitePaths) throws IOException {
    if (!sitePaths.tmp_dir.exists()) {
        sitePaths.tmp_dir.mkdirs();
    }
    return asTemp(in, tempNameFor(pluginName), ".jar", sitePaths.tmp_dir);
}
#end_block

#method_before
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", name));
            File off = new File(pluginsDir, active.getName() + ".jar.disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", name), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#method_after
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", active.getName()));
            File off = new File(active.getSrcFile() + ".disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", active.getName()), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            File on = new File(pluginsDir, off.getName() + ".jar");
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#method_after
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            String n = off.getSrcFile().getName();
            if (n.endsWith(".disabled")) {
                n = n.substring(0, n.lastIndexOf('.'));
            }
            File on = new File(pluginsDir, n);
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> plugins = scanJarsInPluginsDirectory();
    stopRemovedPlugins(plugins);
    dropRemovedDisabledPlugins(plugins);
    for (File plugin : plugins) {
        if (plugin.getName().endsWith(".disabled")) {
            continue;
        }
        String name = nameOf(plugin);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(plugin)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(plugin)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, plugin, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> jars = prunePlugins(pluginsDir);
    if (jars.isEmpty()) {
        return;
    }
    syncDisabledPlugins(jars);
    Map<String, File> activePlugins = filterDisabled(jars);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File jar = entry.getValue();
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#method_after
private void stopRemovedPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (!file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
synchronized int processPendingCleanups() {
    Iterator<Plugin> iterator = toCleanup.iterator();
    while (iterator.hasNext()) {
        Plugin plugin = iterator.next();
        iterator.remove();
        CleanupHandle cleanupHandle = cleanupHandles.remove(plugin);
        cleanupHandle.cleanup();
    }
    return toCleanup.size();
}
#method_after
synchronized int processPendingCleanups() {
    Iterator<Plugin> iterator = toCleanup.iterator();
    while (iterator.hasNext()) {
        Plugin plugin = iterator.next();
        iterator.remove();
        CleanupHandle cleanupHandle = cleanupHandles.remove(plugin);
        if (cleanupHandle != null) {
            cleanupHandle.cleanup();
        }
    }
    return toCleanup.size();
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
public static String nameOf(File plugin) {
    return nameOf(plugin.getName());
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(String name) {
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#end_block

#method_before
private static String getExtension(File file) {
    String name = file.getName();
    int ext = name.lastIndexOf(".");
    return 0 < ext ? name.substring(ext, name.length()) : "";
}
#method_after
private static String getExtension(File file) {
    return getExtension(file.getName());
}
#end_block

#method_before
private static String getExtension(File file) {
    String name = file.getName();
    int ext = name.lastIndexOf(".");
    return 0 < ext ? name.substring(ext, name.length()) : "";
}
#method_after
private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : "";
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcPlugin);
    String extension = getExtension(srcPlugin);
    try {
        tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
    } finally {
        in.close();
    }
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else {
        throw new RuntimeException("Unsupported plugin type");
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: ", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new JarPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#method_after
private static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (isJarPlugin(n) || isJsPlugin(n)) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private static List<File> scanJarsInPluginsDirectory(File pluginsDir) {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (isJarPlugin(n) || isJsPlugin(n)) && !n.startsWith(".last_") && !n.startsWith(".next_") && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
private boolean isJarPlugin(String name) {
    return isPlugin(name, "jar");
}
#method_after
private static boolean isJarPlugin(String name) {
    return isPlugin(name, "jar");
}
#end_block

#method_before
private boolean isJsPlugin(String name) {
    return isPlugin(name, "js");
}
#method_after
private static boolean isJsPlugin(String name) {
    return isPlugin(name, "js");
}
#end_block

#method_before
private boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#method_after
private static boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#end_block

#method_before
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getChange().getId();
    ReviewDb db = dbProvider.get();
    StringBuilder msg = new StringBuilder();
    msg.append("Remove the following approvals:\n\n");
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
                msg.append("* ").append(a.getLabel()).append(" ").append(a.getValue()).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        db.patchSetApprovals().delete(del);
        db.commit();
        ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(rsrc.getChange().getId(), ChangeUtil.messageUUID(db)), ((IdentifiedUser) control.getCurrentUser()).getAccountId(), TimeUtil.nowTs(), rsrc.getChange().currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        db.changeMessages().insert(Collections.singleton(changeMessage));
    } finally {
        db.rollback();
    }
    indexer.index(rsrc.getChange());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getChange().getId();
    ReviewDb db = dbProvider.get();
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
                if (a.getValue() != 0) {
                    if (msg.length() == 0) {
                        msg.append("Removed the following approvals:\n\n");
                    }
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        db.patchSetApprovals().delete(del);
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(rsrc.getChange().getId(), ChangeUtil.messageUUID(db)), ((IdentifiedUser) control.getCurrentUser()).getAccountId(), TimeUtil.nowTs(), rsrc.getChange().currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(rsrc.getChange());
    return Response.none();
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
        case SSH_COMMAND:
            return getCurrentUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#method_after
public List<PermissionRange> getLabelRanges(boolean isChangeOwner) {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule, isChangeOwner)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission) {
    return getRange(permission, false);
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission, boolean isChangeOwner) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission, isChangeOwner));
    }
    return null;
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName) {
    return access(permissionName, false);
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName, boolean isChangeOwner) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0), isChangeOwner)) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule, isChangeOwner)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#end_block

#method_before
public ChangeControl validateFor(Change.Id id, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(id, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
public ChangeControl validateFor(Change change, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(change, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    return getProjectControl().getLabelTypes();
}
#method_after
public LabelTypes getLabelTypes() {
    String destBranch = getChange().getDest().get();
    List<LabelType> all = getProjectControl().getLabelTypes().getLabelTypes();
    List<LabelType> r = Lists.newArrayListWithCapacity(all.size());
    for (LabelType l : all) {
        List<String> refs = l.getRefPatterns();
        if (refs == null) {
            r.add(l);
        } else {
            for (String refPattern : refs) {
                if (RefConfigSection.isValid(refPattern) && match(destBranch, refPattern)) {
                    r.add(l);
                    break;
                }
            }
        }
    }
    return new LabelTypes(r);
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges();
}
#method_after
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges(isOwner());
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    List<PermissionRule> rules = getRefControl().getRules(permission);
    if (isOwner() && rulesContainGroup(rules, AccountGroup.CHANGE_OWNERS)) {
        return getRefControl().getLabelRange(permission);
    } else {
        return getRefControl().getRange(permission);
    }
}
#method_after
public PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#end_block

#method_before
public boolean isOwner() {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser().isIdentifiedUser()) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("may".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.MAY;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return logInvalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return logInvalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record, String reason) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record + (reason == null ? "" : ". Reason: " + reason));
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logInvalidResult(rule, record, null);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#end_block

#method_before
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owners"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#method_after
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owner"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#end_block

#method_before
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owners"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#method_after
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owner"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#end_block

#method_before
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owners"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#method_after
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owner"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#end_block

#method_before
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwners = newGroup(c, "Change Owners", AccountGroup.CHANGE_OWNERS);
    changeOwners.setDescription("The owners of a change");
    changeOwners.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwners)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#method_after
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwner = newGroup(c, "Change Owner", AccountGroup.CHANGE_OWNER);
    changeOwner.setDescription("The owner of a change");
    changeOwner.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwner.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwner));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwner)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, null);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    });
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(info.revisions().get(base), rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (Gerrit.getConfig().testChangeMerge()) {
                if (canSubmit) {
                    actions.setSubmitEnabled(!Gerrit.getConfig().testChangeDisableSubmit() || changeInfo.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !changeInfo.mergeable());
            }
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled();
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (canSubmit) {
                if (status == Change.Status.NEW) {
                    statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
            }
            setVisible(notMergeable, !changeInfo.mergeable());
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    RevisionInfo rev = revision != null ? info.revision(revision) : null;
    if (rev != null) {
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(diffBase.getItemCount() - 1);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setTestChangeMerge(cfg.getBoolean("changeMerge", "test", false));
    config.setTestChangeDisableSubmit(cfg.getBoolean("changeMerge", "disableSubmit", true));
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setIndex(indexCollection.getSearchIndex() != null);
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setIndex(indexCollection.getSearchIndex() != null);
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (Gerrit.getConfig().testChangeMerge() && !c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergable());
        table.getCellFormatter().addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().notMergable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    table.setWidget(row, C_SIZE, getSizeWidget(c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (Gerrit.getConfig().testChangeMerge() && !c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
        table.getCellFormatter().addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().notMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("projects", null, "newProjectsSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Projects.class).to(ProjectsImpl.class);
    factory(ProjectApiImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(Projects.class).to(ProjectsImpl.class);
    factory(BranchApiImpl.Factory.class);
    factory(ProjectApiImpl.Factory.class);
}
#end_block

#method_before
@Test
public void createBranch() throws GitAPIException, IOException, RestApiException {
    ProjectApi pApi = gApi.projects().forName(project.get());
    BranchInput in = new BranchInput();
    in.ref = "foo";
    pApi.createBranch(in);
}
#method_after
@Test
public void createBranch() throws GitAPIException, IOException, RestApiException {
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (isDuplicate(msg)) {
        return;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    if (isDuplicate(msg)) {
        return;
    }
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    Element element = context.getElement().getFirstChildElement();
    while (element.getPropertyInt("value") != AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        element = element.getNextSiblingElement();
    }
    if (element.getPropertyInt("value") == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        if (enableSmallFileFeatures) {
            element.removeAttribute("disabled");
        } else {
            element.setAttribute("disabled", "disabled");
            if (AccountDiffPreference.CONTEXT_CHOICES[context.getSelectedIndex()] == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
                for (int i = 0; i < AccountDiffPreference.CONTEXT_CHOICES.length; i++) {
                    if (AccountDiffPreference.CONTEXT_CHOICES[i] == PatchScreen.LARGE_FILE_CONTEXT) {
                        context.setSelectedIndex(i);
                        break;
                    }
                }
            }
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    NodeList<OptionElement> options = context.getElement().<SelectElement>cast().getOptions();
    // WHOLE_FILE_CONTEXT is the last option in the list.
    int lastIndex = options.getLength() - 1;
    OptionElement currOption = options.getItem(lastIndex);
    if (enableSmallFileFeatures) {
        currOption.setDisabled(false);
    } else {
        currOption.setDisabled(true);
        if (context.getSelectedIndex() == lastIndex) {
            // Select the next longest context from WHOLE_FILE_CONTEXT
            context.setSelectedIndex(lastIndex - 1);
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Provider<ReviewDb> db, final PatchListCache plc, final SubmitStrategyFactory submitStrategyFactory, final ChangeControl.GenericFactory changeControlFactory, final IdentifiedUser.GenericFactory identifiedUserFactory, final GitRepositoryManager repoManager, final String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> r = Lists.newArrayList();
    for (final Change c : changes) {
        List<Predicate<ChangeData>> r2 = Lists.newArrayList();
        for (String file : (new ChangeData(c)).currentFilePaths(db, plc)) {
            r2.add(new EqualsFilePredicate(db, plc, file));
        }
        List<Predicate<ChangeData>> r3 = Lists.newArrayList();
        r3.add(not(new LegacyChangeIdPredicate(db, c.getId())));
        r3.add(or(r2));
        r3.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change(db);
                try {
                    Repository repo = repoManager.openRepository(otherChange.getProject());
                    try {
                        ObjectInserter inserter = repo.newObjectInserter();
                        try {
                            RevWalk rw = new RevWalk(repo) {

                                @Override
                                protected RevCommit createCommit(final AnyObjectId id) {
                                    return new CodeReviewCommit(id);
                                }
                            };
                            try {
                                RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                                CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(ObjectId.fromString(new ChangeData(c).currentPatchSet(db).getRevision().get()));
                                SubmitStrategy strategy = submitStrategyFactory.create(getSubmitType(object), db.get(), repo, rw, inserter, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                                CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(ObjectId.fromString(object.currentPatchSet(db).getRevision().get()));
                                otherCommit.add(canMergeFlag);
                                return !strategy.dryRun(commit, otherCommit);
                            } catch (MergeException e) {
                                throw new IllegalStateException();
                            } catch (NoSuchProjectException e) {
                                throw new IllegalStateException();
                            } finally {
                                rw.release();
                            }
                        } finally {
                            inserter.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(db), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                final Set<RevCommit> alreadyAccepted = new HashSet<RevCommit>();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (final Ref r : repo.getAllRefs().values()) {
                        if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                            try {
                                alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                            } catch (IncorrectObjectTypeException iote) {
                            // Not a commit? Skip over it.
                            }
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        r.add(and(r3));
    }
    return r;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Provider<ReviewDb> db, final PatchListCache plc, final SubmitStrategyFactory submitStrategyFactory, final ChangeControl.GenericFactory changeControlFactory, final IdentifiedUser.GenericFactory identifiedUserFactory, final GitRepositoryManager repoManager, final ProjectCache projectCache, final ConflictsCache conflictsCache, final String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, projectCache);
        List<String> files = new ChangeData(c).currentFilePaths(db, plc);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsFilePredicate(db, plc, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(db, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(db, c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(db, c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change(db);
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet(db).getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(db), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public boolean hasLimit(Predicate<ChangeData> p) {
    return find(p, IntPredicate.class, FIELD_LIMIT) != null;
}
#method_after
@SuppressWarnings("unchecked")
public static boolean hasLimit(Predicate<ChangeData> p) {
    return find(p, IntPredicate.class, FIELD_LIMIT) != null;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#method_after
@SuppressWarnings("unchecked")
public static int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#end_block

#method_before
public boolean hasSortKey(Predicate<ChangeData> p) {
    return find(p, SortKeyPredicate.class, "sortkey_after") != null || find(p, SortKeyPredicate.class, "sortkey_before") != null;
}
#method_after
public static boolean hasSortKey(Predicate<ChangeData> p) {
    return find(p, SortKeyPredicate.class, "sortkey_after") != null || find(p, SortKeyPredicate.class, "sortkey_before") != null;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for comment:" + value);
    }
    return new CommentPredicate(args.dbProvider, args.index, value);
}
#method_after
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    ChangeIndex index = requireIndex(FIELD_COMMENT, value);
    return new CommentPredicate(args.dbProvider, index, value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for " + FIELD_CONFLICTS + ":" + value);
    }
    return new ConflictsPredicate(args.dbProvider, args.patchListCache, args.submitStrategyFactory, args.changeControlGenericFactory, args.userFactory, args.repoManager, value, parseChange(value));
}
#method_after
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    requireIndex(FIELD_CONFLICTS, value);
    return new ConflictsPredicate(args.dbProvider, args.patchListCache, args.submitStrategyFactory, args.changeControlGenericFactory, args.userFactory, args.repoManager, args.projectCache, args.conflictsCache, value, parseChange(value));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (!allowFileRegex) {
            requireIndex(FIELD_FILE, file);
        }
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    } else {
        requireIndex(FIELD_FILE, file);
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for message:" + text);
    }
    return new MessagePredicate(args.dbProvider, args.index, text);
}
#method_after
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    if (index == null) {
        return new LegacyMessagePredicate(args.dbProvider, args.repoManager, text);
    }
    return new MessagePredicate(args.dbProvider, index, text);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser.isIdentifiedUser() && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
public Predicate<ChangeData> limit(int limit) {
    return new IntPredicate<ChangeData>(FIELD_LIMIT, limit) {

        @Override
        public boolean match(ChangeData object) {
            return true;
        }

        @Override
        public int getCost() {
            return 0;
        }
    };
}
#method_after
public Predicate<ChangeData> limit(int limit) {
    return new LimitPredicate(limit);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(args.dbProvider, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(BasicChangeRewrites.schema(args.indexes), args.dbProvider, sortKey);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(args.dbProvider, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(BasicChangeRewrites.schema(args.indexes), args.dbProvider, sortKey);
}
#end_block

#method_before
private List<Change> parseChange(String value) throws OrmException, QueryParseException {
    if (PAT_LEGACY_ID.matcher(value).matches()) {
        return Collections.singletonList(args.dbProvider.get().changes().get(Change.Id.parse(value)));
    } else if (PAT_CHANGE_ID.matcher(value).matches()) {
        Change.Key a = new Change.Key(parseChangeId(value));
        Change.Key b = a.max();
        List<Change> changes = args.dbProvider.get().changes().byKeyRange(a, b).toList();
        if (changes.isEmpty()) {
            throw error("Change " + value + " not found");
        }
        return changes;
    }
    throw error("Change " + value + " not found");
}
#method_after
private List<Change> parseChange(String value) throws OrmException, QueryParseException {
    if (PAT_LEGACY_ID.matcher(value).matches()) {
        return Collections.singletonList(args.dbProvider.get().changes().get(Change.Id.parse(value)));
    } else if (PAT_CHANGE_ID.matcher(value).matches()) {
        Change.Key a = new Change.Key(parseChangeId(value));
        List<Change> changes = args.dbProvider.get().changes().byKeyRange(a, a.max()).toList();
        if (changes.isEmpty()) {
            throw error("Change " + value + " not found");
        }
        return changes;
    }
    throw error("Change " + value + " not found");
}
#end_block

#method_before
private Account.Id self() {
    if (currentUser instanceof IdentifiedUser) {
        return ((IdentifiedUser) currentUser).getAccountId();
    }
    throw new IllegalArgumentException();
}
#method_after
private Account.Id self() {
    if (currentUser.isIdentifiedUser()) {
        return ((IdentifiedUser) currentUser).getAccountId();
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@NoCostComputation
@Rewrite("sortkey_before:z A=(age:*)")
public Predicate<ChangeData> r00_ageToSortKey(@Named("A") AgePredicate a) {
    String cut = ChangeUtil.sortKey(a.getCut(), Integer.MAX_VALUE);
    return and(new SortKeyPredicate.Before(dbProvider, cut), a);
}
#method_after
@SuppressWarnings("unchecked")
@NoCostComputation
@Rewrite("sortkey_before:z A=(age:*)")
public Predicate<ChangeData> r00_ageToSortKey(@Named("A") AgePredicate a) {
    String cut = ChangeUtil.sortKey(a.getCut(), Integer.MAX_VALUE);
    return and(new SortKeyPredicate.Before(schema(indexes), dbProvider, cut), a);
}
#end_block

#method_before
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing && value.canChangeParent());
        parentProjectBox.setProjectName(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#method_after
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing && value.canChangeParent());
        parentProjectBox.setProject(value.getProjectName());
        parentProjectBox.setParentProject(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(editing && (!value.getOwnerOf().isEmpty() || value.canUpload()));
}
#end_block

#method_before
@Override
public void flush() {
    List<AccessSection> src = local.getList();
    List<AccessSection> keep = new ArrayList<AccessSection>(src.size());
    for (int i = 0; i < src.size(); i++) {
        AccessSectionEditor e = (AccessSectionEditor) localContainer.getWidget(i);
        if (!e.isDeleted() && !src.get(i).getPermissions().isEmpty()) {
            keep.add(src.get(i));
        }
    }
    value.setLocal(keep);
    value.setInheritsFrom(parentProjectBox.getProjectName());
}
#method_after
@Override
public void flush() {
    List<AccessSection> src = local.getList();
    List<AccessSection> keep = new ArrayList<AccessSection>(src.size());
    for (int i = 0; i < src.size(); i++) {
        AccessSectionEditor e = (AccessSectionEditor) localContainer.getWidget(i);
        if (!e.isDeleted() && !src.get(i).getPermissions().isEmpty()) {
            keep.add(src.get(i));
        }
    }
    value.setLocal(keep);
    value.setInheritsFrom(parentProjectBox.getParentProjectName());
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    detail.setCanChangeParent(pc.getCurrentUser().getCapabilities().canAdministrateServer());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    final RefControl metaConfigControl = pc.controlForRef(GitRepositoryManager.REF_CONFIG);
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    detail.setCanChangeParent(pc.getCurrentUser().getCapabilities().canAdministrateServer());
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    detail.setLabelTypes(pc.getLabelTypes());
    return detail;
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, Project.NameKey parentProjectName, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, parentProjectName, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, Project.NameKey parentProjectName, AsyncCallback<ProjectAccess> cb) {
    changeProjectAccessFactory.create(projectName, getBase(baseRevision), sections, parentProjectName, msg).to(cb);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.projectAccess(getProjectKey(), new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ConfigServerApi.capabilities(cbs.add(new AsyncCallback<NativeMap<CapabilityInfo>>() {

        @Override
        public void onSuccess(NativeMap<CapabilityInfo> result) {
            capabilityMap = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.PROJECT_SVC.projectAccess(getProjectKey(), cbs.addFinal(new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    }));
    savedPanel = ACCESS;
}
#end_block

#method_before
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty());
    edit.setEnabled(!access.getOwnerOf().isEmpty());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#method_after
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    Map<String, String> allCapabilities = new HashMap<String, String>();
    for (CapabilityInfo c : Natives.asList(capabilityMap.values())) {
        allCapabilities.put(c.id(), c.name());
    }
    this.access.setCapabilities(allCapabilities);
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty() || access.canUpload());
    edit.setEnabled(!access.getOwnerOf().isEmpty() || access.canUpload());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent event) {
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent event) {
    resetEditors();
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    commit.setVisible(!access.getOwnerOf().isEmpty());
    review.setVisible(access.canUpload());
    accessEditor.setEditing(true);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("commit")
void onCommit(ClickEvent event) {
    ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), // 
    access.getInheritsFrom(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess access) {
            enable(true);
            commitMessage.setText("");
            displayReadOnly(access);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            super.onFailure(caught);
        }
    });
}
#method_after
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), // 
    access.getInheritsFrom(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
                if (access.canUpload()) {
                    error.add(new Label(Gerrit.C.projectAccessProposeForReviewHint()));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final List<AccessSection> wantedSections = mergeSections(removeEmptyPermissionsAndSections(wantedAccess.getLocal()));
            final HashSet<AccessSection> same = new HashSet<AccessSection>(wantedSections);
            final HashSet<AccessSection> different = new HashSet<AccessSection>(wantedSections.size() + newAccess.getLocal().size());
            different.addAll(wantedSections);
            different.addAll(newAccess.getLocal());
            same.retainAll(newAccess.getLocal());
            different.removeAll(same);
            final Set<String> differentNames = new HashSet<String>();
            for (final AccessSection s : different) {
                differentNames.add(s.getName());
            }
            return differentNames;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            if (caught instanceof RemoteJsonException && caught.getMessage().startsWith(UpdateParentFailedException.MESSAGE)) {
                new ErrorDialog(Gerrit.M.parentUpdateFailed(caught.getMessage().substring(UpdateParentFailedException.MESSAGE.length() + 1))).center();
            } else {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void enable(boolean enabled) {
    commitMessage.setEnabled(enabled);
    commit.setEnabled(enabled);
    cancel1.setEnabled(enabled);
    cancel2.setEnabled(enabled);
}
#method_after
private void enable(boolean enabled) {
    commitMessage.setEnabled(enabled);
    commit.setEnabled(enabled ? !access.getOwnerOf().isEmpty() : false);
    review.setEnabled(enabled ? access.canUpload() : false);
    cancel1.setEnabled(enabled);
    cancel2.setEnabled(enabled);
}
#end_block

#method_before
public void setCanChangeParent(final boolean canChangeParent) {
    this.canChangeParent = canChangeParent;
}
#method_after
public void setCanChangeParent(boolean canChangeParent) {
    this.canChangeParent = canChangeParent;
}
#end_block

#method_before
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            for (Entry<String, Ref> entry : repo.getAllRefs().entrySet()) {
                String refName = entry.getKey();
                if (refName.startsWith("refs/changes") || refName.startsWith("refs/cache-automerge")) {
                    continue;
                }
                RevCommit tip;
                try {
                    tip = rw.parseCommit(entry.getValue().getObjectId());
                } catch (IncorrectObjectTypeException e) {
                    continue;
                }
                if (rw.isMergedInto(commit, tip) && controlForRef(entry.getKey()).canPerform(Permission.READ)) {
                    return true;
                }
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return controlForRef("refs/*").canPerform(Permission.READ);
}
#method_after
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            for (Entry<String, Ref> entry : repo.getAllRefs().entrySet()) {
                String refName = entry.getKey();
                if (!refName.startsWith("refs/heads") && !refName.startsWith("refs/tags")) {
                    continue;
                }
                RevCommit tip;
                try {
                    tip = rw.parseCommit(entry.getValue().getObjectId());
                } catch (IncorrectObjectTypeException e) {
                    continue;
                }
                if (rw.isMergedInto(commit, tip) && controlForRef(entry.getKey()).canPerform(Permission.READ)) {
                    return true;
                }
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return controlForRef("refs/*").canPerform(Permission.READ);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(admin.getId())));
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#end_block

#method_before
@Test
public void reviewId() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(approve());
}
#method_after
@Test
public void reviewId() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(approve());
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    RevisionApi rApi = gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name());
    rApi.review(approve());
    rApi.submit(new SubmitInput());
}
#method_after
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    RevisionApi rApi = gApi.changes().id("p~master~" + r.getChangeId()).current();
    rApi.review(approve());
    rApi.submit();
}
#end_block

#method_before
private static ReviewInput approve() {
    ReviewInput in = new ReviewInput();
    in.message = "Looks good!";
    in.labels = Maps.newHashMap();
    in.labels.put("Code-Review", (short) 2);
    return in;
}
#method_after
private static ReviewInput approve() {
    return new ReviewInput().message("Looks good!").label("Code-Review", 2);
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        submit.get().apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot submit change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot submit change", e);
    }
}
#method_after
@Override
public void submit() throws RestApiException {
    SubmitInput in = new SubmitInput();
    in.waitForMerge = true;
    submit(in);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(admin.getId())));
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#end_block

#method_before
@Test
public void abandon() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon(new AbandonInput());
}
#method_after
@Test
public void abandon() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon();
}
#end_block

#method_before
@Test
public void restore() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon(new AbandonInput());
    gApi.changes().id("p~master~" + r.getChangeId()).restore(new RestoreInput());
}
#method_after
@Test
public void restore() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon();
    gApi.changes().id("p~master~" + r.getChangeId()).restore();
}
#end_block

#method_before
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).abandon(input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).restore(input);
                applyReview(patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(patchSet, review);
        }
        if (submitChange) {
            SubmitInput input = new SubmitInput();
            input.waitForMerge = true;
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).submit(input);
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).deleteDraftPatchSet(new DeleteDraftPatchSetInput());
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    } catch (RestApiException e) {
        throw error(e.getMessage());
    }
}
#method_after
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).abandon(input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).restore(input);
                applyReview(patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(patchSet, review);
        }
        if (submitChange) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).submit();
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).delete();
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    } catch (RestApiException e) {
        throw error(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon review", e);
    }
}
#method_after
@Override
public void abandon() throws RestApiException {
    abandon(new AbandonInput());
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon review", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore review", e);
    }
}
#method_after
@Override
public void restore() throws RestApiException {
    restore(new RestoreInput());
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore review", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
private void approve(String changeId) throws IOException {
    ReviewInput in = new ReviewInput();
    in.labels = Maps.newHashMap();
    in.labels.put("Code-Review", (short) 2);
    RestResponse r = session.post("/changes/" + changeId + "/revisions/current/review", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#method_after
private void approve(String changeId) throws IOException {
    RestResponse r = session.post("/changes/" + changeId + "/revisions/current/review", new ReviewInput().label("Code-Review", 2));
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, AbandonInput input) throws BadRequestException, AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    Object result = input.render ? json.format(change) : Response.none();
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public Object apply(ChangeResource req, AbandonInput input) throws BadRequestException, AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, RestoreInput input) throws OrmException, IOException, AuthException, ResourceConflictException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    Object result = input.render ? json.format(change) : Response.none();
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public Object apply(ChangeResource req, RestoreInput input) throws OrmException, IOException, AuthException, ResourceConflictException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
@Override
void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replicate ");
    sb.append(project);
    sb.append(" to ");
    sb.append(resolveNodeName(uri));
    sb.append(", ");
    switch(status) {
        case SUCCEEDED:
            sb.append("Succeeded!");
            break;
        case FAILED:
            sb.append("FAILED!");
            hasError.compareAndSet(false, true);
            break;
        case NOT_ATTEMPTED:
            sb.append("NOT ATTEMPTED!");
            break;
        default:
            sb.append("UNKNOWN RESULT!");
            break;
    }
    writeStdOut(sb.toString());
}
#method_after
@Override
void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replicate ");
    sb.append(project);
    sb.append(" ref ");
    sb.append(ref);
    sb.append(" to ");
    sb.append(resolveNodeName(uri));
    sb.append(", ");
    switch(status) {
        case SUCCEEDED:
            sb.append("Succeeded!");
            break;
        case FAILED:
            sb.append("FAILED!");
            hasError.compareAndSet(false, true);
            break;
        case NOT_ATTEMPTED:
            sb.append("NOT ATTEMPTED!");
            break;
        default:
            sb.append("UNKNOWN RESULT!");
            break;
    }
    writeStdOut(sb.toString());
}
#end_block

#method_before
@Override
void onRefReplicatedToAllNodes(String project, String ref, int nodesCount) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replication of ");
    sb.append(project);
    sb.append(" completed to ");
    sb.append(nodesCount);
    sb.append(" nodes, ");
    writeStdOut(sb.toString());
}
#method_after
@Override
void onRefReplicatedToAllNodes(String project, String ref, int nodesCount) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replication of ");
    sb.append(project);
    sb.append(" ref ");
    sb.append(ref);
    sb.append(" completed to ");
    sb.append(nodesCount);
    sb.append(" nodes, ");
    writeStdOut(sb.toString());
}
#end_block

#method_before
public void increasePushTaskCount(String project, String ref) {
    getRefReplicationInfo(project, ref).nodesToReplicateCount.incrementAndGet();
    totalPushTasksCount.incrementAndGet();
}
#method_after
public void increasePushTaskCount(String project, String ref) {
    countingLock.lock();
    try {
        getRefStatus(project, ref).nodesToReplicateCount++;
        totalPushTasksCount++;
    } finally {
        countingLock.unlock();
    }
}
#end_block

#method_before
public boolean hasPushTask() {
    return totalPushTasksCount.get() != 0;
}
#method_after
public boolean hasPushTask() {
    return totalPushTasksCount != 0;
}
#end_block

#method_before
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status);
    RefReplicationInfo refReplicationInfo = getRefReplicationInfo(project, ref);
    refReplicationInfo.replicatedNodesCount.incrementAndGet();
    if (allScheduled && refReplicationInfo.nodesToReplicateCount.get() == refReplicationInfo.replicatedNodesCount.get()) {
        fireOnRefReplicatedToAllNodes(project, ref);
    }
    finishedPushTasksCount.incrementAndGet();
    verifyAllPushTasksCompleted();
}
#method_after
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status);
    RefReplicationStatus completedRefStatus = null;
    boolean allPushTaksCompleted = false;
    countingLock.lock();
    try {
        RefReplicationStatus refStatus = getRefStatus(project, ref);
        refStatus.replicatedNodesCount++;
        finishedPushTasksCount++;
        if (allScheduled) {
            if (refStatus.allDone()) {
                completedRefStatus = statusByProjectRef.remove(project, ref);
            }
            allPushTaksCompleted = finishedPushTasksCount == totalPushTasksCount;
        }
    } finally {
        countingLock.unlock();
    }
    if (completedRefStatus != null) {
        doRefPushTasksCompleted(completedRefStatus);
    }
    if (allPushTaksCompleted) {
        doAllPushTasksCompleted();
    }
}
#end_block

#method_before
public void markAllPushTasksScheduled() {
    allScheduled = true;
    verifyAllPushTasksCompleted();
}
#method_after
public void markAllPushTasksScheduled() {
    countingLock.lock();
    try {
        allScheduled = true;
        if (finishedPushTasksCount < totalPushTasksCount) {
            return;
        }
    } finally {
        countingLock.unlock();
    }
    doAllPushTasksCompleted();
}
#end_block

#method_before
private void fireRemainingOnRefReplicatedToAllNodes() {
    // Some could be remaining if replication of a ref is completed before all tasks are scheduled
    for (SimpleEntry<String, String> projectRefKey : replicationInfoPerProjectRef.keySet()) {
        fireOnRefReplicatedToAllNodes(projectRefKey.getKey(), projectRefKey.getValue());
    }
}
#method_after
private void fireRemainingOnRefReplicatedToAllNodes() {
    for (RefReplicationStatus refStatus : statusByProjectRef.values()) {
        doRefPushTasksCompleted(refStatus);
    }
}
#end_block

#method_before
@Test
public void shouldFireOneReplicationEventWhenNothingToReplicate() {
    resetToStrict(pushResultProcessingMock);
    // expected event
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(0);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.markAllPushTasksScheduled();
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireOneReplicationEventWhenNothingToReplicate() {
    resetToDefault(pushResultProcessingMock);
    // expected event
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(0);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.markAllPushTasksScheduled();
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Test
public void shouldFireEventsForReplicationOfOneRefToOneNode() throws URISyntaxException {
    resetToStrict(pushResultProcessingMock);
    URIish uri = new URIish("git://someHost/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 1);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(1);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireEventsForReplicationOfOneRefToOneNode() throws URISyntaxException {
    resetToDefault(pushResultProcessingMock);
    URIish uri = new URIish("git://someHost/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 1);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(1);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Test
public void shouldFireEventsForReplicationOfOneRefToMultipleNodes() throws URISyntaxException {
    resetToStrict(pushResultProcessingMock);
    URIish uri1 = new URIish("git://someHost1/someRepo.git");
    URIish uri2 = new URIish("git://someHost2/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri2, RefPushResult.FAILED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 2);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(2);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    replicationState.notifyRefReplicated("someProject", "someRef", uri2, RefPushResult.FAILED);
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireEventsForReplicationOfOneRefToMultipleNodes() throws URISyntaxException {
    resetToDefault(pushResultProcessingMock);
    URIish uri1 = new URIish("git://someHost1/someRepo.git");
    URIish uri2 = new URIish("git://someHost2/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri2, RefPushResult.FAILED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 2);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(2);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    replicationState.notifyRefReplicated("someProject", "someRef", uri2, RefPushResult.FAILED);
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Override
protected Object getRowItemKey(final DocInfo item) {
    return item.url();
}
#method_after
@Override
protected Object getRowItemKey(DocInfo item) {
    return item.url();
}
#end_block

#method_before
@Override
protected void onOpenRow(final int row) {
    final DocInfo d = getRowItem(row);
    Gerrit.display("/" + d.url());
}
#method_after
@Override
protected void onOpenRow(int row) {
    DocInfo d = getRowItem(row);
    Window.Location.assign(d.getFullUrl());
}
#end_block

#method_before
private void insertNoneRow(final int row) {
    insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setColSpan(row, 0, columns);
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#method_after
private void insertNoneRow(int row) {
    table.insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#method_after
@Override
protected void applyDataRowStyle(int row) {
    super.applyDataRowStyle(row);
    CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#end_block

#method_before
private void populateDocRow(final int row, final DocInfo d) {
    String title = com.google.gerrit.client.changes.Util.cropSubject(d.title());
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#method_after
private void populateDocRow(int row, DocInfo d) {
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/doc/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/Documentation/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void docSearch(final String token) {
    Gerrit.display(token, new DocScreen(skip(token)));
}
#method_after
private static void docSearch(final String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, new DocScreen(skip(token)));
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    section = new DocTable.Section();
    table.addSection(section);
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable();
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    docs.query(loadCallback(), query);
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    doQuery();
}
#end_block

#method_before
protected AsyncCallback<DocList> loadCallback() {
    return new GerritCallback<DocList>() {

        @Override
        public final void onSuccess(DocList result) {
            display(result);
            DocScreen.this.display();
        }
    };
}
#method_after
private AsyncCallback<JsArray<DocInfo>> loadCallback() {
    return new GerritCallback<JsArray<DocInfo>>() {

        @Override
        public void onSuccess(JsArray<DocInfo> result) {
            displayResults(result);
            display();
        }
    };
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    resp.setContentType("text/html;charset=UTF-8");
    PrintWriter out = resp.getWriter();
    try {
        String repoName = req.getParameter("p");
        if (repoName == null) {
            resp.sendRedirect("Documentation/index.html");
            return;
        }
        boolean naked = req.getParameter("naked") != null;
        int width = getParam(req, "width", 920);
        int height = getParam(req, "height", 600);
        if (repoName.endsWith(".git")) {
            repoName = repoName.substring(0, repoName.length() - 4);
        }
        final Project.NameKey nameKey = new Project.NameKey(repoName);
        try {
            projectControl.validateFor(nameKey);
        } catch (NoSuchProjectException e) {
            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        Repository repo = null;
        try {
            repo = repoManager.openRepository(nameKey);
        } catch (RepositoryNotFoundException e) {
            getServletContext().log("Cannot open repository", e);
            resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            return;
        } finally {
            if (repo != null) {
                repo.close();
            }
        }
        String networkMetaUrl = String.format("%1$snetwork_meta/%2$s/", canonicalPath, repoName);
        String networkDataChunkUrl = String.format("%1$snetwork_data_chunk/%2$s/?nethash=", canonicalPath, repoName);
        GitWebType type = gitWebConfig.getGitWebType();
        if (type == null) {
            out.println("<html>ERROR: invalid gitweb configuration</html>");
        } else {
            String commitUrlPattern = gitWebConfig.getUrl() + type.getRevision().replaceAll("\\$\\{project\\}", repoName).replaceAll("\\$\\{commit\\}", "{2}");
            String projectPattern = gitWebConfig.getUrl() + type.getProject().replaceAll("\\$\\{project\\}", repoName);
            commitUrlPattern = (commitUrlPattern.startsWith("/") ? commitUrlPattern : canonicalWebUrl + commitUrlPattern);
            projectPattern = (projectPattern.startsWith("/") ? projectPattern : canonicalWebUrl + projectPattern);
            String header = "<html>\n" + "<head>\n" + "<style type=\"text/css\">\n" + "div#progress\n" + "{\n" + "position:absolute;\n" + "left:" + (width - PROGRESS_BAR_WIDTH) / 2 + "px;\n" + "top:" + (height - PROGRESS_BAR_HEIGHT) / 2 + "px;\n" + "z-index:-1;\n" + "}\n" + "div#graph\n" + "{\n" + "position:absolute;\n" + "left:0px;\n" + "top:0px;\n" + "z-index:0;\n" + "}\n" + "</style>\n" + "</head>\n" + "<body>\n" + "<div id=\"progress\" >" + "<img src=\"" + canonicalPath + "static/progress_bar.gif\" />" + "</div>" + "<div id=\"graph\">";
            String javaScript = "<script type=\"text/javascript\" src=\"" + canonicalPath + "static/jquery-1.4.2.min.js\"></script>\n" + "<script type=\"text/javascript\" src=\"" + canonicalPath + "static/network.js\"></script>\n" + "<script type=\"text/javascript\">" + "$(document).ready( function() {\n" + "new NetworkCanvas('network-canvas', " + width + ", " + height + " , null, null, null,\n" + "'" + commitUrlPattern + "',\n" + "'" + projectPattern + "',\n" + "'" + networkMetaUrl + "',\n" + "'" + networkDataChunkUrl + "');\n" + "});\n" + "</script>\n";
            String canvas = "<canvas id=\"network-canvas\" width=\"" + width + "\" height=\"" + height + "\" style=\"cursor: default; \"></canvas>";
            String footer = "</div>" + "</body>\n" + "</html>\n";
            out.println(naked ? (javaScript + canvas) : (header + javaScript + canvas + footer));
        }
    } finally {
        out.close();
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    resp.setContentType("text/html;charset=UTF-8");
    PrintWriter out = resp.getWriter();
    try {
        String repoName = req.getParameter("p");
        if (repoName == null) {
            resp.sendRedirect("Documentation/index.html");
            return;
        }
        boolean naked = req.getParameter("naked") != null;
        int width = getParam(req, "width", 920);
        int height = getParam(req, "height", 600);
        if (repoName.endsWith(".git")) {
            repoName = repoName.substring(0, repoName.length() - 4);
        }
        final Project.NameKey nameKey = new Project.NameKey(repoName);
        try {
            projectControl.validateFor(nameKey);
        } catch (NoSuchProjectException e) {
            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        Repository repo = null;
        try {
            repo = repoManager.openRepository(nameKey);
        } catch (RepositoryNotFoundException e) {
            getServletContext().log("Cannot open repository", e);
            resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            return;
        } finally {
            if (repo != null) {
                repo.close();
            }
        }
        String networkMetaUrl = String.format("%1$snetwork_meta/%2$s/", canonicalPath, repoName);
        String networkDataChunkUrl = String.format("%1$snetwork_data_chunk/%2$s/?nethash=", canonicalPath, repoName);
        GitWebType type = gitWebConfig.getGitWebType();
        if (type == null) {
            out.println("<html>ERROR: invalid gitweb configuration</html>");
        } else {
            String commitUrlPattern = gitWebConfig.getUrl() + type.getRevision().replaceAll("\\$\\{project\\}", repoName).replaceAll("\\$\\{commit\\}", "{2}");
            String projectPattern = gitWebConfig.getUrl() + type.getProject().replaceAll("\\$\\{project\\}", repoName);
            commitUrlPattern = (commitUrlPattern.startsWith("/") ? commitUrlPattern : pluginCanonicalWebUrl + commitUrlPattern);
            projectPattern = (projectPattern.startsWith("/") ? projectPattern : pluginCanonicalWebUrl + projectPattern);
            String header = "<html>\n" + "<head>\n" + "<style type=\"text/css\">\n" + "div#progress\n" + "{\n" + "position:absolute;\n" + "left:" + (width - PROGRESS_BAR_WIDTH) / 2 + "px;\n" + "top:" + (height - PROGRESS_BAR_HEIGHT) / 2 + "px;\n" + "z-index:-1;\n" + "}\n" + "div#graph\n" + "{\n" + "position:absolute;\n" + "left:0px;\n" + "top:0px;\n" + "z-index:0;\n" + "}\n" + "</style>\n" + "</head>\n" + "<body>\n" + "<div id=\"progress\" >" + "<img src=\"" + canonicalPath + "static/progress_bar.gif\" />" + "</div>" + "<div id=\"graph\">";
            String javaScript = "<script type=\"text/javascript\" src=\"" + canonicalPath + "static/jquery-1.4.2.min.js\"></script>\n" + "<script type=\"text/javascript\" src=\"" + canonicalPath + "static/network.js\"></script>\n" + "<script type=\"text/javascript\">" + "$(document).ready( function() {\n" + "new NetworkCanvas('network-canvas', " + width + ", " + height + " , null, null, null,\n" + "'" + commitUrlPattern + "',\n" + "'" + projectPattern + "',\n" + "'" + networkMetaUrl + "',\n" + "'" + networkDataChunkUrl + "');\n" + "});\n" + "</script>\n";
            String canvas = "<canvas id=\"network-canvas\" width=\"" + width + "\" height=\"" + height + "\" style=\"cursor: default; \"></canvas>";
            String footer = "</div>" + "</body>\n" + "</html>\n";
            out.println(naked ? (javaScript + canvas) : (header + javaScript + canvas + footer));
        }
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        dbInjector = createDbInjector(MULTI_USER);
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        shellInjector = createShellInjector();
        manager.add(dbInjector, cfgInjector, sysInjector, shellInjector);
        if (sshd) {
            initSshd();
        }
        if (httpd) {
            initHttpd();
        }
        manager.start();
        RuntimeShutdown.add(new Runnable() {

            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (shell) {
            InteractiveShell interp = shellInjector.getInstance(InteractiveShell.class);
            interp.set("m", manager);
            interp.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    manager.add(GarbageCollectionLogFile.start(getSitePath()));
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        dbInjector = createDbInjector(MULTI_USER);
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        sysInjector.getInstance(PluginGuiceEnvironment.class).setCfgInjector(cfgInjector);
        manager.add(dbInjector, cfgInjector, sysInjector);
        if (sshd) {
            initSshd();
        }
        if (httpd) {
            initHttpd();
        }
        manager.start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new EhcachePoolImpl.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private void initSshd() {
    sshInjector = createSshInjector();
    manager.add(sshInjector);
}
#method_after
private void initSshd() {
    sshInjector = createSshInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setSshInjector(sshInjector);
    manager.add(sshInjector);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new SshModule());
        if (slave) {
            modules.add(new SlaveCommandModule());
        } else {
            modules.add(new MasterCommandModule());
        }
    } else {
        modules.add(new NoSshModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(sysInjector.getInstance(SshModule.class));
        if (slave) {
            modules.add(new SlaveCommandModule());
        } else {
            modules.add(new MasterCommandModule());
        }
    } else {
        modules.add(new NoSshModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private void initHttpd() {
    webInjector = createWebInjector();
    sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
    httpdInjector = createHttpdInjector();
    manager.add(webInjector, httpdInjector);
}
#method_after
private void initHttpd() {
    webInjector = createWebInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setHttpInjector(webInjector);
    sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
    httpdInjector = createHttpdInjector();
    manager.add(webInjector, httpdInjector);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
protected Object runMethod0(Class klazz, Object instance, String name, Class[] sig, Object[] args) throws InvocationTargetException {
    Method interpMethod;
    try {
        interpMethod = klazz.getMethod(name, sig);
        return interpMethod.invoke(instance, args);
    } catch (NoSuchMethodException e) {
        throw cannotStart(e);
    } catch (SecurityException e) {
        throw cannotStart(e);
    } catch (IllegalArgumentException e) {
        throw cannotStart(e);
    } catch (IllegalAccessException e) {
        throw cannotStart(e);
    }
}
#method_after
protected Object runMethod0(Class<?> klazz, Object instance, String name, Class<?>[] sig, Object[] args) throws InvocationTargetException {
    try {
        Method m;
        m = klazz.getMethod(name, sig);
        return m.invoke(instance, args);
    } catch (NoSuchMethodException e) {
        throw cannotStart(e);
    } catch (SecurityException e) {
        throw cannotStart(e);
    } catch (IllegalArgumentException e) {
        throw cannotStart(e);
    } catch (IllegalAccessException e) {
        throw cannotStart(e);
    }
}
#end_block

#method_before
protected Object runMethod(Class klazz, Object instance, String name, Class[] sig, Object[] args) {
    try {
        return runMethod0(klazz, instance, name, sig, args);
    } catch (InvocationTargetException e) {
        throw cannotStart(e);
    }
}
#method_after
protected Object runMethod(Class<?> klazz, Object instance, String name, Class<?>[] sig, Object[] args) {
    try {
        return runMethod0(klazz, instance, name, sig, args);
    } catch (InvocationTargetException e) {
        throw cannotStart(e);
    }
}
#end_block

#method_before
protected Object runInterpreter(String name, Class[] sig, Object[] args) {
    return runMethod(console, interp, name, sig, args);
}
#method_after
protected Object runInterpreter(String name, Class<?>[] sig, Object[] args) {
    return runMethod(console, shell, name, sig, args);
}
#end_block

#method_before
private static Class findClass(String klazzname) {
    try {
        return Class.forName(klazzname);
    } catch (ClassNotFoundException e) {
        throw noShell("Class " + klazzname + " not found", e);
    }
}
#method_after
private static Class<?> findClass(String klazzname) {
    try {
        return Class.forName(klazzname);
    } catch (ClassNotFoundException e) {
        throw noShell("Class " + klazzname + " not found", e);
    }
}
#end_block

#method_before
protected void execFile(final File parent, final String p) {
    try {
        File script = new File(parent, p);
        if (script.canExecute()) {
            runMethod0(console, interp, "execfile", new Class[] { String.class }, new Object[] { script.getAbsolutePath() });
        } else {
            log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable");
        }
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading file " + p + " : ", e);
    } catch (SecurityException e) {
        log.error("SecurityException occured while loading file " + p + " : ", e);
    }
}
#method_after
protected void execFile(final File parent, final String p) {
    try {
        File script = new File(parent, p);
        if (script.canExecute()) {
            runMethod0(console, shell, "execfile", new Class[] { String.class }, new Object[] { script.getAbsolutePath() });
        } else {
            log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable");
        }
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading file " + p + " : ", e);
    } catch (SecurityException e) {
        log.error("SecurityException occured while loading file " + p + " : ", e);
    }
}
#end_block

#method_before
protected void execStream(final InputStream in, final String p) {
    try {
        runMethod0(console, interp, "execfile", new Class[] { InputStream.class, String.class }, new Object[] { in, p });
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading " + p + " : ", e);
    }
}
#method_after
protected void execStream(final InputStream in, final String p) {
    try {
        runMethod0(console, shell, "execfile", new Class[] { InputStream.class, String.class }, new Object[] { in, p });
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading " + p + " : ", e);
    }
}
#end_block

#method_before
private static ClassLoader libClassLoader() throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED == e.getMessage()) {
            // 
            return GerritLauncher.class.getClassLoader();
        }
        throw e;
    }
    final ArrayList<URL> jars = new ArrayList<URL>();
    try {
        final ZipFile zf = new ZipFile(path);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                if (ze.getName().startsWith("WEB-INF/lib/")) {
                    final File tmp = createTempFile(safeName(ze), ".jar");
                    final FileOutputStream out = new FileOutputStream(tmp);
                    try {
                        final InputStream in = zf.getInputStream(ze);
                        try {
                            final byte[] buf = new byte[4096];
                            int n;
                            while ((n = in.read(buf, 0, buf.length)) > 0) {
                                out.write(buf, 0, n);
                            }
                        } finally {
                            in.close();
                        }
                    } finally {
                        out.close();
                    }
                    jars.add(tmp.toURI().toURL());
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    Collections.sort(jars, new Comparator<URL>() {

        public int compare(URL o1, URL o2) {
            return o1.toString().compareTo(o2.toString());
        }
    });
    return new URLClassLoader(jars.toArray(new URL[jars.size()]));
}
#method_after
private static ClassLoader libClassLoader() throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED == e.getMessage()) {
            // 
            return GerritLauncher.class.getClassLoader();
        }
        throw e;
    }
    final SortedMap<String, URL> jars = new TreeMap<String, URL>();
    try {
        final ZipFile zf = new ZipFile(path);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                } else if (ze.getName().startsWith("WEB-INF/lib/")) {
                    extractJar(zf, ze, jars);
                } else if (ze.getName().startsWith("WEB-INF/pgm-lib/")) {
                    extractJar(zf, ze, jars);
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    // The extension API needs to be its own ClassLoader, along
    // with a few of its dependencies. Try to construct this first.
    List<URL> extapi = new ArrayList<URL>();
    move(jars, "gerrit-extension-api-", extapi);
    move(jars, "guice-", extapi);
    move(jars, "javax.inject-1.jar", extapi);
    move(jars, "aopalliance-1.0.jar", extapi);
    move(jars, "guice-servlet-", extapi);
    move(jars, "tomcat-servlet-api-", extapi);
    ClassLoader parent = ClassLoader.getSystemClassLoader();
    if (!extapi.isEmpty()) {
        parent = new URLClassLoader(extapi.toArray(new URL[extapi.size()]), parent);
    }
    return new URLClassLoader(jars.values().toArray(new URL[jars.size()]), parent);
}
#end_block

#method_before
private static File tmproot() {
    // Use $HOME/.gerritcodereview/tmp for our temporary file area.
    // 
    final File tmp = new File(getHomeDirectory(), "tmp");
    if (!tmp.exists() && !tmp.mkdirs()) {
        System.err.println("warning: cannot create " + tmp.getAbsolutePath());
        System.err.println("warning: using system temporary directory instead");
        return null;
    }
    // Try to clean up any stale empty directories. Assume any empty
    // directory that is older than 7 days is one of these dead ones
    // that we can clean up.
    // 
    final File[] tmpEntries = tmp.listFiles();
    if (tmpEntries != null) {
        final long now = System.currentTimeMillis();
        final long expired = now - MILLISECONDS.convert(7, DAYS);
        for (final File tmpEntry : tmpEntries) {
            if (tmpEntry.isDirectory() && tmpEntry.lastModified() < expired) {
                final String[] all = tmpEntry.list();
                if (all == null || all.length == 0) {
                    tmpEntry.delete();
                }
            }
        }
    }
    try {
        return tmp.getCanonicalFile();
    } catch (IOException e) {
        return tmp;
    }
}
#method_after
private static File tmproot() {
    File tmp;
    String gerritTemp = System.getenv("GERRIT_TMP");
    if (gerritTemp != null && gerritTemp.length() > 0) {
        tmp = new File(gerritTemp);
    } else {
        tmp = new File(getHomeDirectory(), "tmp");
    }
    if (!tmp.exists() && !tmp.mkdirs()) {
        System.err.println("warning: cannot create " + tmp.getAbsolutePath());
        System.err.println("warning: using system temporary directory instead");
        return null;
    }
    // Try to clean up any stale empty directories. Assume any empty
    // directory that is older than 7 days is one of these dead ones
    // that we can clean up.
    // 
    final File[] tmpEntries = tmp.listFiles();
    if (tmpEntries != null) {
        final long now = System.currentTimeMillis();
        final long expired = now - MILLISECONDS.convert(7, DAYS);
        for (final File tmpEntry : tmpEntries) {
            if (tmpEntry.isDirectory() && tmpEntry.lastModified() < expired) {
                final String[] all = tmpEntry.list();
                if (all == null || all.length == 0) {
                    tmpEntry.delete();
                }
            }
        }
    }
    try {
        return tmp.getCanonicalFile();
    } catch (IOException e) {
        return tmp;
    }
}
#end_block

#method_before
@Override
public void run() throws Exception {
    List<QueryDocumentationExecutor.DocResult> res = searcher.doQuery(q);
    for (DocResult docResult : res) {
        stdout.println(String.format("%s: %s", docResult.title, docResult.url));
    }
}
#method_after
@Override
public void run() throws Exception {
    List<QueryDocumentationExecutor.DocResult> res = searcher.doQuery(q);
    for (DocResult docResult : res) {
        stdout.println(String.format("%s:\n%s%s\n", docResult.title, url, docResult.url));
    }
}
#end_block

#method_before
public List<DocResult> doQuery(String q) throws DocQueryException {
    if (parser == null || searcher == null) {
        throw new DocQueryException("Not initialized");
    }
    try {
        Query query = parser.parse(q);
        TopDocs results = searcher.search(query, Integer.MAX_VALUE);
        ScoreDoc[] hits = results.scoreDocs;
        int totalHits = results.totalHits;
        List<DocResult> out = Lists.newArrayListWithCapacity(totalHits);
        for (int i = 0; i < totalHits; i++) {
            DocResult result = new DocResult();
            Document doc = searcher.doc(hits[i].doc);
            result.url = doc.get(Constants.URL_FIELD);
            result.title = doc.get(Constants.TITLE_FIELD);
            out.add(result);
        }
        return out;
    } catch (IOException e) {
        throw new DocQueryException(e);
    } catch (ParseException e) {
        throw new DocQueryException(e);
    }
}
#method_after
public List<DocResult> doQuery(String q) throws DocQueryException {
    if (parser == null || searcher == null) {
        throw new DocQueryException("Documentation search not available");
    }
    try {
        Query query = parser.parse(q);
        TopDocs results = searcher.search(query, Integer.MAX_VALUE);
        ScoreDoc[] hits = results.scoreDocs;
        int totalHits = results.totalHits;
        List<DocResult> out = Lists.newArrayListWithCapacity(totalHits);
        for (int i = 0; i < totalHits; i++) {
            DocResult result = new DocResult();
            Document doc = searcher.doc(hits[i].doc);
            result.url = doc.get(Constants.URL_FIELD);
            result.title = doc.get(Constants.TITLE_FIELD);
            out.add(result);
        }
        return out;
    } catch (IOException e) {
        throw new DocQueryException(e);
    } catch (ParseException e) {
        throw new DocQueryException(e);
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    bind(DocQueryProcessor.class).to(DocQueryLucene.class);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?docsearch/(.*)$").with(DocSearchRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DocQueryLucene.DOC_FIELD, reader));
        doc.add(new StringField(DocQueryLucene.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(DocQueryLucene.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#end_block

#method_before
@Nullable
String getPluginName() {
    return pluginName;
}
#method_after
@Nullable
protected String getPluginName() {
    return pluginName;
}
#end_block

#method_before
String[] getArguments() {
    return argv;
}
#method_after
public String[] getArguments() {
    return argv;
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectControl ctrl = projectControlFactory.controlFor(projectName, currentUser.get());
        return new ConfigInfo(ctrl, projectStateFactory.create(projectConfig), config, views, currentUser);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } catch (NoSuchProjectException err) {
        throw new ResourceConflictException("Cannot find project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), state, config, views, currentUser);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new FileReader(file));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DOC_FIELD, reader));
        doc.add(new StringField(URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new StringField(TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DOC_FIELD, reader));
        doc.add(new StringField(URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            ReviewDb db = schemaFactory.open();
            try {
                Repository repo = repoManager.openRepository(project);
                try {
                    Map<String, Ref> refs = repo.getAllRefs();
                    for (Change c : db.changes().byProject(project)) {
                        Ref r = refs.get(c.currentPatchSetId().toRefName());
                        if (r != null) {
                            byId.put(r.getObjectId(), new ChangeData(c));
                        }
                    }
                    new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
                } finally {
                    repo.close();
                // TODO(dborowitz): Opening all repositories in a live server may be
                // wasteful; see if we can determine which ones it is safe to close
                // with RepositoryCache.close(repo).
                }
            } finally {
                db.close();
            }
            return null;
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = repoManager.openRepository(project);
            try {
                Map<String, Ref> refs = repo.getAllRefs();
                for (Change c : db.get().changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), new ChangeData(c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } finally {
                repo.close();
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                        indexer.indexAsync(chg);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(c, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(c, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.indexAsync(c);
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(c);
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, boolean makeNew) {
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            Change change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            db.changeMessages().insert(Collections.singleton(msg));
            db.commit();
            indexer.indexAsync(change);
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, boolean makeNew) {
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    Change change = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            db.changeMessages().insert(Collections.singleton(msg));
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change);
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, Input input) throws BadRequestException, AuthException, ResourceConflictException, Exception {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to \"" + newTopicName + "\".";
        } else if (newTopicName.isEmpty()) {
            summary = "Topic \"" + oldTopicName + "\" removed.";
        } else {
            summary = String.format("Topic updated from \"%s\" to \"%s\".", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.currentPatchSetId());
        StringBuilder msgBuf = new StringBuilder(summary);
        if (!Strings.isNullOrEmpty(input.message)) {
            msgBuf.append("\n\n");
            msgBuf.append(input.message);
        }
        cmsg.setMessage(msgBuf.toString());
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        indexer.indexAsync(change);
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.none() : newTopicName;
}
#method_after
@Override
public Object apply(ChangeResource req, Input input) throws BadRequestException, AuthException, ResourceConflictException, Exception {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to \"" + newTopicName + "\".";
        } else if (newTopicName.isEmpty()) {
            summary = "Topic \"" + oldTopicName + "\" removed.";
        } else {
            summary = String.format("Topic updated from \"%s\" to \"%s\".", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.currentPatchSetId());
        StringBuilder msgBuf = new StringBuilder(summary);
        if (!Strings.isNullOrEmpty(input.message)) {
            msgBuf.append("\n\n");
            msgBuf.append(input.message);
        }
        cmsg.setMessage(msgBuf.toString());
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.none() : newTopicName;
}
#end_block

#method_before
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException, UnprocessableEntityException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        dirty |= insertComments(revision, input.comments, input.drafts);
        dirty |= updateLabels(revision, input.labels);
        dirty |= insertMessage(revision, input.message);
        if (dirty) {
            db.changes().update(Collections.singleton(change));
            db.commit();
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change);
    } else {
        indexWrite = null;
    }
    if (input.notify.compareTo(NotifyHandling.NONE) > 0 && message != null) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
        fireCommentAddedHook(revision);
    }
    Output output = new Output();
    output.labels = input.labels;
    if (input.waitForCommit && dirty) {
        indexWrite.checkedGet();
    }
    return output;
}
#method_after
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException, UnprocessableEntityException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        dirty |= insertComments(revision, input.comments, input.drafts);
        dirty |= updateLabels(revision, input.labels);
        dirty |= insertMessage(revision, input.message);
        if (dirty) {
            db.changes().update(Collections.singleton(change));
            db.commit();
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change);
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (input.notify.compareTo(NotifyHandling.NONE) > 0 && message != null) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
        fireCommentAddedHook(revision);
    }
    Output output = new Output();
    output.labels = input.labels;
    if (input.waitForCommit) {
        indexWrite.checkedGet();
    }
    return output;
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            if (indexes != null) {
                for (ChangeIndex i : indexes.getWriteIndexes()) {
                    apply(i, cd);
                }
            } else {
                apply(index, cd);
            }
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    Provider<ReviewDb> db = dbRef.get();
                    if (db == null) {
                        try {
                            db = Providers.of(schemaFactory.open());
                        } catch (OrmException e) {
                            ProvisionException pe = new ProvisionException("error opening ReviewDb");
                            pe.initCause(e);
                            throw pe;
                        }
                        dbRef.set(db);
                    }
                    return db;
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            if (indexes != null) {
                for (ChangeIndex i : indexes.getWriteIndexes()) {
                    apply(i, cd);
                }
            } else {
                apply(index, cd);
            }
            return null;
        } finally {
            context.setContext(null);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#end_block

#method_before
private SafeHtml formatList(JsArrayString l) {
    SafeHtmlBuilder sb = new SafeHtmlBuilder();
    int size = l.length();
    for (int i = 0; i < size; i++) {
        sb.openSpan().addStyleName(style.includedInElement()).append(l.get(i)).closeSpan();
        if (i < size - 1) {
            sb.append(", ");
        }
    }
    return sb;
}
#method_after
private SafeHtml formatList(JsArrayString l) {
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    int size = l.length();
    for (int i = 0; i < size; i++) {
        html.openSpan().addStyleName(style.includedInElement()).append(l.get(i)).closeSpan();
        if (i < size - 1) {
            html.append(", ");
        }
    }
    return html;
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status().isClosed()) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource) {
    return Iterables.filter(Iterables.transform(views, new Function<DynamicMap.Entry<RestView<R>>, UiAction.Description>() {

        @Override
        @Nullable
        public UiAction.Description apply(DynamicMap.Entry<RestView<R>> e) {
            int d = e.getExportName().indexOf('.');
            if (d < 0) {
                return null;
            }
            RestView<R> view;
            try {
                view = e.getProvider().get();
            } catch (RuntimeException err) {
                log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
                return null;
            }
            if (!(view instanceof UiAction)) {
                return null;
            }
            UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
            if (dsc == null || dsc.isVisible()) {
                return null;
            }
            String name = e.getExportName().substring(d + 1);
            PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
            PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
            return dsc;
        }
    }), Predicates.notNull());
}
#method_after
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource) {
    return Iterables.filter(Iterables.transform(views, new Function<DynamicMap.Entry<RestView<R>>, UiAction.Description>() {

        @Override
        @Nullable
        public UiAction.Description apply(DynamicMap.Entry<RestView<R>> e) {
            int d = e.getExportName().indexOf('.');
            if (d < 0) {
                return null;
            }
            RestView<R> view;
            try {
                view = e.getProvider().get();
            } catch (RuntimeException err) {
                log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
                return null;
            }
            if (!(view instanceof UiAction)) {
                return null;
            }
            UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
            if (dsc == null || !dsc.isVisible()) {
                return null;
            }
            String name = e.getExportName().substring(d + 1);
            PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
            PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
            return dsc;
        }
    }), Predicates.notNull());
}
#end_block

#method_before
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button();
        b.setText(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button();
        b.setText(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                        Gerrit.display(PageLinks.toChange(patchSet.getId()));
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
public static void copyLabels(ReviewDb db, LabelTypes labelTypes, Iterable<PatchSetApproval> sourceApprovals, PatchSet.Id source, PatchSet dest, ChangeKind changeKind) throws OrmException {
    List<PatchSetApproval> copied = Lists.newArrayList();
    List<String> labelsCopiedForTrivialRebase = Lists.newArrayList();
    List<String> labelsCopiedForCommitMessageOnlyChange = Lists.newArrayList();
    for (PatchSetApproval a : sourceApprovals) {
        if (source.equals(a.getPatchSetId())) {
            LabelType type = labelTypes.byLabel(a.getLabelId());
            if (type == null) {
                continue;
            } else if (type.isCopyMinScore() && type.isMaxNegative(a)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyMaxScore() && type.isMaxPositive(a)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyAllScoresOnTrivialRebase() && ChangeKind.TRIVIAL_REBASE.equals(changeKind)) {
                labelsCopiedForTrivialRebase.add(type.getName());
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyAllScoresOnCommitMessageOnlyChange() && ChangeKind.COMMIT_MESSAGE_ONLY.equals(changeKind)) {
                labelsCopiedForCommitMessageOnlyChange.add(type.getName());
                copied.add(new PatchSetApproval(dest.getId(), a));
            }
        }
    }
    addMessageForCopiedLabels(db, labelsCopiedForTrivialRebase, dest, "trivial rebase");
    addMessageForCopiedLabels(db, labelsCopiedForCommitMessageOnlyChange, dest, "commit message only change");
    db.patchSetApprovals().insert(copied);
}
#method_after
public static void copyLabels(ReviewDb db, LabelTypes labelTypes, Iterable<PatchSetApproval> sourceApprovals, PatchSet.Id source, PatchSet dest, ChangeKind changeKind) throws OrmException {
    List<PatchSetApproval> copied = Lists.newArrayList();
    for (PatchSetApproval a : sourceApprovals) {
        if (source.equals(a.getPatchSetId())) {
            LabelType type = labelTypes.byLabel(a.getLabelId());
            if (type == null) {
                continue;
            } else if (type.isCopyMinScore() && type.isMaxNegative(a)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyMaxScore() && type.isMaxPositive(a)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyAllScoresOnTrivialRebase() && ChangeKind.TRIVIAL_REBASE.equals(changeKind)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyAllScoresIfNoCodeChange() && ChangeKind.NO_CODE_CHANGE.equals(changeKind)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            }
        }
    }
    db.patchSetApprovals().insert(copied);
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        rp.getRevWalk().parseBody(priorCommit);
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    changeKind = PatchSetInserter.getChangeKind(project.getNameKey(), repo, priorCommit, newCommit);
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        rp.getRevWalk().parseBody(priorCommit);
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    changeKind = PatchSetInserter.getChangeKind(mergeUtilFactory, projectControl.getProjectState(), repo, priorCommit, newCommit);
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, false));
        label.setCopyAllScoresOnCommitMessageOnlyChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_COMMIT_MESSAGE_ONLY_CHANGE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, false));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        if (!LabelType.defaultAbbreviation(name).equals(label.getAbbreviation())) {
            rc.setString(LABEL, name, KEY_ABBREVIATION, label.getAbbreviation());
        } else {
            rc.unset(LABEL, name, KEY_ABBREVIATION);
        }
        if (label.isCopyMinScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MIN_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MIN_SCORE);
        }
        if (label.isCopyMaxScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MAX_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MAX_SCORE);
        }
        if (label.isCopyAllScoresOnTrivialRebase()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        }
        if (label.isCopyAllScoresOnCommitMessageOnlyChange()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_COMMIT_MESSAGE_ONLY_CHANGE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_ON_COMMIT_MESSAGE_ONLY_CHANGE);
        }
        if (!label.canOverride()) {
            rc.setBoolean(LABEL, name, KEY_CAN_OVERRIDE, false);
        } else {
            rc.unset(LABEL, name, KEY_CAN_OVERRIDE);
        }
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#method_after
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        if (!LabelType.defaultAbbreviation(name).equals(label.getAbbreviation())) {
            rc.setString(LABEL, name, KEY_ABBREVIATION, label.getAbbreviation());
        } else {
            rc.unset(LABEL, name, KEY_ABBREVIATION);
        }
        if (label.isCopyMinScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MIN_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MIN_SCORE);
        }
        if (label.isCopyMaxScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MAX_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MAX_SCORE);
        }
        if (label.isCopyAllScoresOnTrivialRebase()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        }
        if (label.isCopyAllScoresIfNoCodeChange()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE);
        }
        if (!label.canOverride()) {
            rc.setBoolean(LABEL, name, KEY_CAN_OVERRIDE, false);
        } else {
            rc.unset(LABEL, name, KEY_CAN_OVERRIDE);
        }
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        final List<PatchSetApproval> oldPatchSetApprovals = db.patchSetApprovals().byChange(change.getId()).toList();
        final Set<Account.Id> oldReviewers = Sets.newHashSet();
        final Set<Account.Id> oldCC = Sets.newHashSet();
        for (PatchSetApproval a : oldPatchSetApprovals) {
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            PatchSet priorPatchSet = db.patchSets().get(currentPatchSetId);
            ObjectId priorCommitId = ObjectId.fromString(priorPatchSet.getRevision().get());
            RevCommit priorCommit = revWalk.parseCommit(priorCommitId);
            ChangeKind changeKind = getChangeKind(change.getProject(), git, priorCommit, commit);
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, patchSet, changeKind);
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, updatedChange, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
        indexer.index(updatedChange);
        if (runHooks) {
            hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
        }
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        final List<PatchSetApproval> oldPatchSetApprovals = db.patchSetApprovals().byChange(change.getId()).toList();
        final Set<Account.Id> oldReviewers = Sets.newHashSet();
        final Set<Account.Id> oldCC = Sets.newHashSet();
        for (PatchSetApproval a : oldPatchSetApprovals) {
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            PatchSet priorPatchSet = db.patchSets().get(currentPatchSetId);
            ObjectId priorCommitId = ObjectId.fromString(priorPatchSet.getRevision().get());
            RevCommit priorCommit = revWalk.parseCommit(priorCommitId);
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            ChangeKind changeKind = getChangeKind(mergeUtilFactory, projectState, git, priorCommit, commit);
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, patchSet, changeKind);
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, updatedChange, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
        indexer.index(updatedChange);
        if (runHooks) {
            hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
        }
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#end_block

#method_before
public static ChangeKind getChangeKind(Project.NameKey project, Repository git, RevCommit prior, RevCommit next) {
    if (!next.getFullMessage().equals(prior.getFullMessage())) {
        if (next.getTree() == prior.getTree()) {
            return ChangeKind.COMMIT_MESSAGE_ONLY;
        } else {
            return ChangeKind.REWORK;
        }
    }
    if (next.getTree() == prior.getTree()) {
        return ChangeKind.TRIVIAL_REBASE;
    }
    if (next.getParentCount() != 1) {
        // Trivial rebases done by machine only work well on 1 parent.
        return ChangeKind.REWORK;
    }
    // cherry-picked onto the next commit's new first parent.
    try {
        ThreeWayMerger merger = MergeStrategy.RESOLVE.newMerger(git, true);
        merger.setBase(prior.getParent(0));
        if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
            return ChangeKind.TRIVIAL_REBASE;
        } else {
            return ChangeKind.REWORK;
        }
    } catch (IOException err) {
        log.warn("Cannot check trivial rebase of new patch set " + next.name() + " in " + project.get(), err);
        return ChangeKind.REWORK;
    }
}
#method_after
public static ChangeKind getChangeKind(MergeUtil.Factory mergeUtilFactory, ProjectState project, Repository git, RevCommit prior, RevCommit next) {
    if (!next.getFullMessage().equals(prior.getFullMessage())) {
        if (next.getTree() == prior.getTree() && prior.getParent(0).equals(next.getParent(0))) {
            return ChangeKind.NO_CODE_CHANGE;
        } else {
            return ChangeKind.REWORK;
        }
    }
    if (prior.getParentCount() != 1 || next.getParentCount() != 1) {
        // Trivial rebases done by machine only work well on 1 parent.
        return ChangeKind.REWORK;
    }
    if (next.getTree() == prior.getTree() && prior.getParent(0).equals(next.getParent(0))) {
        return ChangeKind.TRIVIAL_REBASE;
    }
    // cherry-picked onto the next commit's new first parent.
    try {
        MergeUtil mergeUtil = mergeUtilFactory.create(project);
        ThreeWayMerger merger = mergeUtil.newThreeWayMerger(git, mergeUtil.createDryRunInserter());
        merger.setBase(prior.getParent(0));
        if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
            return ChangeKind.TRIVIAL_REBASE;
        } else {
            return ChangeKind.REWORK;
        }
    } catch (IOException err) {
        log.warn("Cannot check trivial rebase of new patch set " + next.name() + " in " + project.getProject().getName(), err);
        return ChangeKind.REWORK;
    }
}
#end_block

#method_before
public void installPluginFromStream(String name, InputStream in) throws IOException, PluginInstallException {
    if (!name.endsWith(".jar")) {
        name += ".jar";
    }
    File jar = new File(pluginsDir, name);
    name = nameOf(jar);
    File old = new File(pluginsDir, ".last_" + name + ".zip");
    File tmp = asTemp(in, ".next_" + name, ".zip", pluginsDir);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            log.info(String.format("Replacing plugin %s", name));
            old.delete();
            jar.renameTo(old);
        }
        // TODO(davido): the name-owned plugins can be renamed here,
        // do we care?
        new File(pluginsDir, name + ".jar.disabled").delete();
        tmp.renameTo(jar);
        try {
            Plugin plugin = runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            jar.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#method_after
public void installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    String fileName = originalName;
    if (!fileName.endsWith(".jar")) {
        fileName += ".jar";
    }
    File tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = Objects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>," + " use it instead of the input name: <%s>", name, originalName));
    }
    File dst = new File(pluginsDir, name + ".jar");
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getName();
            log.info(String.format("Replacing plugin %s", active.getName()));
            File old = new File(pluginsDir, ".last_" + fileName);
            old.delete();
            active.getSrcFile().renameTo(old);
        }
        new File(pluginsDir, fileName + ".disabled").delete();
        tmp.renameTo(dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            dst.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
    files.remove(name);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", name));
            File off = new File(pluginsDir, active.getName() + ".jar.disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", name), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#method_after
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", active.getName()));
            File off = new File(active.getSrcFile() + ".disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", active.getName()), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            File on = new File(pluginsDir, off.getName() + ".jar");
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#method_after
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            String n = off.getSrcFile().getName();
            if (n.endsWith(".disabled")) {
                n = n.substring(0, n.lastIndexOf('.'));
            }
            File on = new File(pluginsDir, n);
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            continue;
        }
        String name = nameOf(jar);
        if (files.containsKey(name)) {
            name = files.get(name);
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", loadedPlugin.getName()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> jars = prunePlugins(pluginsDir);
    if (jars.isEmpty()) {
        return;
    }
    syncDisabledPlugins(jars);
    Map<String, File> activePlugins = filterDisabled(jars);
    for (String name : activePlugins.keySet()) {
        File jar = activePlugins.get(name);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        if (!newPlugin.getName().equals(name)) {
            files.put(name, newPlugin.getName());
        }
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(newPlugin.getName(), newPlugin);
        } else {
            disabled.put(newPlugin.getName(), newPlugin);
        }
        broken.remove(newPlugin.getName());
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            String name = nameOf(jar);
            unload.remove(files.containsKey(name) ? files.get(name) : name);
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#method_after
private void stopRemovedPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (!file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(File jar) {
    return nameOf(jar.getName());
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(String name) {
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcJar, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcJar);
    try {
        tmp = asTemp(in, tempNameFor(name), ".jar", tmpDir);
    } finally {
        in.close();
    }
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String pluginName = main.getValue("Gerrit-PluginName");
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        if (!Strings.isNullOrEmpty(pluginName)) {
            name = pluginName;
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadPlugin(String name, File srcJar, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcJar);
    try {
        tmp = asTemp(in, tempNameFor(name), ".jar", tmpDir);
    } finally {
        in.close();
    }
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#method_after
private static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private static List<File> scanJarsInPluginsDirectory(File pluginsDir) {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && !n.startsWith(".last_") && !n.startsWith(".next_") && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (receiveEvent.commit.getParentCount() > 1 && !refControl.canUploadMerges(receiveEvent.command)) {
        throw new CommitValidationException("you are not allowed to upload merges");
    }
    return Collections.<CommitValidationMessage>emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (receiveEvent.commit.getParentCount() > 1) {
        if (MagicBranch.isForReview(receiveEvent.command.getRefName())) {
            if (!refControl.canUploadMerges()) {
                throw new CommitValidationException("you are not allowed to upload merges for review");
            }
        } else {
            if (!refControl.canPushMerges()) {
                throw new CommitValidationException("you are not allowed to push merges directly bypassing code review");
            }
        }
    }
    return Collections.<CommitValidationMessage>emptyList();
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges(cmd) && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && (MagicBranch.isForReview(cmd.getRefName()) ? ctl.canUploadMerges() : ctl.canPushMerges()) && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
public boolean canUploadMerges(ReceiveCommand c) {
    String ref = getRefName();
    if (MagicBranch.isMagicBranch(c.getRefName())) {
        ref = "refs/for/" + ref;
    }
    return projectControl.controlForRef(ref).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void loadPluginSections(Config rc) {
    pluginConfigs = Maps.newHashMap();
    Set<String> pluginSubsections = rc.getSubsections(PLUGIN);
    for (String plugin : pluginSubsections) {
        LinkedListMultimap<String, String> pluginConfig = LinkedListMultimap.create();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            pluginConfig.putAll(name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#method_after
private void loadPluginSections(Config rc) {
    pluginConfigs = Maps.newHashMap();
    for (String plugin : rc.getSubsections(PLUGIN)) {
        Config pluginConfig = new Config();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            pluginConfig.setStringList(PLUGIN, plugin, name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public LinkedListMultimap<String, String> getPluginConfig(String pluginName) {
    LinkedListMultimap<String, String> pluginConfig = pluginConfigs.get(pluginName);
    if (pluginConfig == null) {
        pluginConfig = LinkedListMultimap.create();
        pluginConfigs.put(pluginName, pluginConfig);
    }
    return pluginConfig;
}
#method_after
public PluginConfig getPluginConfig(String pluginName) {
    Config pluginConfig = pluginConfigs.get(pluginName);
    if (pluginConfig == null) {
        pluginConfig = new Config();
        pluginConfigs.put(pluginName, pluginConfig);
    }
    return new PluginConfig(pluginName, pluginConfig);
}
#end_block

#method_before
private void savePluginSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, LinkedListMultimap<String, String>> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        LinkedListMultimap<String, String> pluginConfig = e.getValue();
        for (String name : pluginConfig.keySet()) {
            rc.setStringList(PLUGIN, plugin, name, pluginConfig.get(name));
        }
    }
}
#method_after
private void savePluginSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, Config> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        Config pluginConfig = e.getValue();
        for (String name : pluginConfig.getNames(PLUGIN, plugin)) {
            rc.setStringList(PLUGIN, plugin, name, Arrays.asList(pluginConfig.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public static void createProject(SshSession s, String name, Project.NameKey parent) throws JSchException, IOException {
    StringBuilder b = new StringBuilder();
    b.append("gerrit create-project --empty-commit --name \"");
    b.append(name);
    b.append("\"");
    if (parent != null) {
        b.append(" --parent \"");
        b.append(parent.get());
        b.append("\"");
    }
    s.exec(b.toString());
}
#method_after
public static void createProject(SshSession s, String name, Project.NameKey parent) throws JSchException, IOException {
    createProject(s, name, parent, true);
}
#end_block

#method_before
public static void createProject(SshSession s, String name, Project.NameKey parent) throws JSchException, IOException {
    StringBuilder b = new StringBuilder();
    b.append("gerrit create-project --empty-commit --name \"");
    b.append(name);
    b.append("\"");
    if (parent != null) {
        b.append(" --parent \"");
        b.append(parent.get());
        b.append("\"");
    }
    s.exec(b.toString());
}
#method_after
public static void createProject(SshSession s, String name, Project.NameKey parent, boolean emptyCommit) throws JSchException, IOException {
    StringBuilder b = new StringBuilder();
    b.append("gerrit create-project");
    if (emptyCommit) {
        b.append(" --empty-commit");
    }
    b.append(" --name \"");
    b.append(name);
    b.append("\"");
    if (parent != null) {
        b.append(" --parent \"");
        b.append(parent.get());
        b.append("\"");
    }
    s.exec(b.toString());
}
#end_block

#method_before
public static PushResult pushHead(Git git, String ref, boolean tags) throws GitAPIException {
    PushCommand pushCmd = git.push();
    pushCmd.setRefSpecs(new RefSpec("HEAD:" + ref));
    if (tags) {
        pushCmd.setPushTags();
    }
    Iterable<PushResult> r = pushCmd.call();
    return Iterables.getOnlyElement(r);
}
#method_after
public static PushResult pushHead(Git git, String ref, boolean pushTags) throws GitAPIException {
    PushCommand pushCmd = git.push();
    pushCmd.setRefSpecs(new RefSpec("HEAD:" + ref));
    if (pushTags) {
        pushCmd.setPushTags();
    }
    Iterable<PushResult> r = pushCmd.call();
    return Iterables.getOnlyElement(r);
}
#end_block

#method_before
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip, toMerge.get(submitType)), destBranch);
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(final CodeReviewCommit branchTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    final Set<RevCommit> alreadyAccepted = new HashSet<RevCommit>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    Set<String> toMergeSha1 = new HashSet<String>();
    for (CodeReviewCommit rvc : toMerge) {
        toMergeSha1.add(rvc.getName());
    }
    try {
        for (final Ref r : repo.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || (r.getName().startsWith(Constants.R_TAGS) && !toMergeSha1.contains(r.getObjectId().getName()))) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Failed to determine already accepted commits.", e);
    }
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(final CodeReviewCommit branchTip) throws MergeException {
    final Set<RevCommit> alreadyAccepted = new HashSet<RevCommit>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (final Ref r : repo.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Failed to determine already accepted commits.", e);
    }
    return alreadyAccepted;
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
            final Project.NameKey newParent;
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
                cfg.load(repo, commit);
                newParent = cfg.getProject().getParent(allProjectsName);
            } catch (Exception e) {
                commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION));
                continue;
            }
            final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
            if (oldParent == null) {
                // update of the 'All-Projects' project
                if (newParent != null) {
                    commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT));
                    continue;
                }
            } else {
                if (!oldParent.equals(newParent)) {
                    final PatchSetApproval psa = getSubmitter(db, ps.getId());
                    if (psa == null) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN));
                        continue;
                    }
                    final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                    if (!submitter.getCapabilities().canAdministrateServer()) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN));
                        continue;
                    }
                    if (projectCache.get(newParent) == null) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND));
                        continue;
                    }
                }
            }
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMergedPatchSet(chg.getId(), ps.getId());
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.create("admin", "admin@example.com", "Administrator", "Administrators");
    project = new Project.NameKey("p");
    initSsh(admin);
    SshSession sshSession = new SshSession(admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    sshSession.close();
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.create("admin", "admin@example.com", "Administrator", "Administrators");
    project = new Project.NameKey("p");
    initSsh(admin);
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    sshSession.close();
    db = reviewDbProvider.open();
}
#end_block

#method_before
@Test
public void submitOnPushWithTag() throws GitAPIException, OrmException, IOException, ConfigInvalidException {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    grant(Permission.CREATE, project, "refs/tags/*");
    PushOneCommit.Result r = pushWithTagTo("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", PushOneCommit.TAG);
}
#method_after
@Test
public void submitOnPushWithTag() throws GitAPIException, OrmException, IOException, ConfigInvalidException {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    grant(Permission.CREATE, project, "refs/tags/*");
    final String tag = "v1.0";
    PushOneCommit push = new PushOneCommit(db, admin.getIdent());
    push.setTag(tag);
    PushOneCommit.Result r = push.to(git, "refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#end_block

#method_before
private void assertTag(Project.NameKey project, String branch, String tagName) throws IOException {
    Repository r = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(r);
        try {
            String commitSha1 = r.getRef(branch).getObjectId().getName();
            String tag = r.getRef(tagName).getObjectId().getName();
            assertEquals(commitSha1, tag);
        } finally {
            rw.release();
        }
    } finally {
        r.close();
    }
}
#method_after
private void assertTag(Project.NameKey project, String branch, String tagName) throws IOException {
    Repository r = repoManager.openRepository(project);
    try {
        ObjectId headCommit = r.getRef(branch).getObjectId();
        ObjectId taggedCommit = r.getRef(tagName).getObjectId();
        assertEquals(headCommit, taggedCommit);
    } finally {
        r.close();
    }
}
#end_block

#method_before
public Result to(Git git, String ref) throws GitAPIException, IOException {
    _to(git, ref);
    return new Result(db, ref, pushHead(git, ref, false), changeId, subject);
}
#method_after
public Result to(Git git, String ref) throws GitAPIException, IOException {
    add(git, fileName, content);
    if (changeId != null) {
        amendCommit(git, i, subject, changeId);
    } else {
        changeId = createCommit(git, i, subject);
    }
    if (tagName != null) {
        git.tag().setName(tagName).setAnnotated(false).call();
    }
    return new Result(db, ref, pushHead(git, ref, tagName != null), changeId, subject);
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (cd.getSubmitRecordLabels() != null && standard && !detailed) {
        // them.
        return labelsFromSavedState(cd.getSubmitRecordLabels());
    }
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    if (cd.getChange().getStatus().isOpen()) {
        return labelsForOpenChange(cd, labelTypes, standard, detailed);
    } else {
        return labelsForClosedChange(cd, labelTypes, standard, detailed);
    }
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (cd.getSubmitRecordLabels() != null && standard && !detailed) {
        // Use saved labels to avoid recomputing on the fly.
        return labelsFromSavedState(cd.getSubmitRecordLabels());
    }
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    if (cd.getChange().getStatus().isOpen()) {
        return labelsForOpenChange(cd, labelTypes, standard, detailed);
    } else {
        return labelsForClosedChange(cd, labelTypes, standard, detailed);
    }
}
#end_block

#method_before
@Override
public byte[] get(ChangeData input, FieldDef.FillArgs args) throws OrmException {
    return toProto(CODEC, input.change(args.db));
}
#method_after
@Override
public byte[] get(ChangeData input, FieldDef.FillArgs args) throws OrmException {
    return CODEC.encodeToByteArray(input.change(args.db));
}
#end_block

#method_before
private static <T> List<byte[]> toProtos(ProtobufCodec<T> codec, Collection<T> objs) throws OrmException {
    List<byte[]> result = Lists.newArrayListWithCapacity(objs.size());
    ByteArrayOutputStream out = new ByteArrayOutputStream(256);
    for (T obj : objs) {
        out.reset();
        result.add(toProto(codec, obj, out));
    }
    return result;
}
#method_after
private static <T> List<byte[]> toProtos(ProtobufCodec<T> codec, Collection<T> objs) throws OrmException {
    List<byte[]> result = Lists.newArrayListWithCapacity(objs.size());
    ByteArrayOutputStream out = new ByteArrayOutputStream(256);
    try {
        for (T obj : objs) {
            out.reset();
            CodedOutputStream cos = CodedOutputStream.newInstance(out);
            codec.encode(obj, cos);
            cos.flush();
            result.add(out.toByteArray());
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return result;
}
#end_block

#method_before
private PersonIdent createPersonIdent() {
    return ((IdentifiedUser) currentUser).newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
}
#method_after
private PersonIdent createPersonIdent() {
    return identifiedUser.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(((IdentifiedUser) currentUser.get()).newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            post(PROJECT_KIND, "delete-project").to(UiDeleteAction.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            delete(PROJECT_KIND).to(DeleteProject.class);
            post(PROJECT_KIND, "delete").to(DeleteProject.class);
        }
    });
}
#end_block

#method_before
private Class<? extends DatabaseDeleteHandler> registerDatabaseHandler() {
    int schemaVersion = SchemaVersion.guessVersion(SchemaVersion.C);
    // Injection of version dependent database handlers
    Class<? extends DatabaseDeleteHandler> databaseDeleteHandlerClass = null;
    switch(schemaVersion) {
        case 73:
        case 74:
        case 75:
        case 76:
            databaseDeleteHandlerClass = Schema73DatabaseDeleteHandler.class;
            break;
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
            databaseDeleteHandlerClass = Schema77DatabaseDeleteHandler.class;
            break;
        default:
            throw new RuntimeException("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: " + schemaVersion + "). Please update the plugin.");
    }
    assert databaseDeleteHandlerClass != null : "No database handler set";
    return databaseDeleteHandlerClass;
}
#method_after
private Class<? extends DatabaseDeleteHandler> registerDatabaseHandler() {
    int schemaVersion = SchemaVersion.guessVersion(SchemaVersion.C);
    // Injection of version dependent database handlers
    Class<? extends DatabaseDeleteHandler> databaseDeleteHandlerClass = null;
    switch(schemaVersion) {
        case 73:
        case 74:
        case 75:
        case 76:
            databaseDeleteHandlerClass = Schema73DatabaseDeleteHandler.class;
            break;
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
            databaseDeleteHandlerClass = Schema77DatabaseDeleteHandler.class;
            break;
        default:
            throw new RuntimeException("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: " + schemaVersion + "). Please update the plugin.");
    }
    assert databaseDeleteHandlerClass != null : "No database handler set";
    return databaseDeleteHandlerClass;
}
#end_block

#method_before
private void initEditMessageAction() {
    NativeMap<ActionInfo> actions = changeInfo.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(changeInfo.legacy_id(), revision, changeInfo.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#method_after
private void initEditMessageAction(ChangeInfo info, String revision) {
    NativeMap<ActionInfo> actions = info.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    downloadPatch.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction();
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderDownload(info, revision);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderRevisions(ChangeInfo info) {
    if (info.revisions().size() == 1) {
        UIObject.setVisible(revisionParent, false);
        return;
    }
    JsArray<RevisionInfo> list = info.revisions().values();
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            return a._number() - b._number();
        }
    });
    int selected = -1;
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        revisionList.addItem(r._number() + ": " + r.name().substring(0, 6), "" + r._number());
        if (revision.equals(r.name())) {
            selected = i;
        }
    }
    if (0 <= selected) {
        revisionList.setSelectedIndex(selected);
    }
}
#method_after
private void renderRevisions(ChangeInfo info) {
    if (info.revisions().size() == 1) {
        UIObject.setVisible(revisionParent, false);
        return;
    }
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isReversePatchSetOrder()) {
        Collections.reverse(Natives.asList(list));
    }
    int selected = -1;
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        revisionList.addItem(r._number() + ": " + r.name().substring(0, 6), "" + r._number());
        if (revision.equals(r.name())) {
            selected = i;
        }
    }
    if (0 <= selected) {
        revisionList.setSelectedIndex(selected);
    }
}
#end_block

#method_before
public static String toOpenSshPublicKey(final String keyStr) {
    try {
        final StringBuilder strBuf = new StringBuilder();
        final BufferedReader br = new BufferedReader(new StringReader(keyStr));
        // BEGIN SSH2 line...
        String line = br.readLine();
        if (line != null && !line.equals("---- BEGIN SSH2 PUBLIC KEY ----")) {
            return keyStr;
        }
        while ((line = br.readLine()) != null) {
            if (line.indexOf(':') == -1) {
                strBuf.append(line);
                break;
            }
        }
        while ((line = br.readLine()) != null) {
            if (line.startsWith("---- ")) {
                break;
            }
            strBuf.append(line);
        }
        final PublicKey key = new Buffer(Base64.decodeBase64(Constants.encodeASCII(strBuf.toString()))).getRawPublicKey();
        if (key instanceof RSAPublicKey) {
            strBuf.insert(0, KeyPairProvider.SSH_RSA + " ");
        } else if (key instanceof DSAPublicKey) {
            strBuf.insert(0, KeyPairProvider.SSH_DSS + " ");
        } else {
            return keyStr;
        }
        strBuf.append(' ');
        strBuf.append("converted-key");
        return strBuf.toString();
    } catch (IOException e) {
        return keyStr;
    } catch (RuntimeException re) {
        return keyStr;
    }
}
#method_after
public static String toOpenSshPublicKey(final String keyStr) {
    try {
        final StringBuilder strBuf = new StringBuilder();
        final BufferedReader br = new BufferedReader(new StringReader(keyStr));
        // BEGIN SSH2 line...
        String line = br.readLine();
        if (line == null || !line.equals("---- BEGIN SSH2 PUBLIC KEY ----")) {
            return keyStr;
        }
        while ((line = br.readLine()) != null) {
            if (line.indexOf(':') == -1) {
                strBuf.append(line);
                break;
            }
        }
        while ((line = br.readLine()) != null) {
            if (line.startsWith("---- ")) {
                break;
            }
            strBuf.append(line);
        }
        final PublicKey key = new Buffer(Base64.decodeBase64(Constants.encodeASCII(strBuf.toString()))).getRawPublicKey();
        if (key instanceof RSAPublicKey) {
            strBuf.insert(0, KeyPairProvider.SSH_RSA + " ");
        } else if (key instanceof DSAPublicKey) {
            strBuf.insert(0, KeyPairProvider.SSH_DSS + " ");
        } else {
            return keyStr;
        }
        strBuf.append(' ');
        strBuf.append("converted-key");
        return strBuf.toString();
    } catch (IOException e) {
        return keyStr;
    } catch (RuntimeException re) {
        return keyStr;
    }
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, InterruptedException, ExecutionException {
    CurrentUser caller = rsrc.getControl().getCurrentUser();
    if (!caller.getCapabilities().canAdministrateServer()) {
        throw new AuthException("index not permitted");
    }
    indexer.index(rsrc.getChange()).get();
    return Response.none();
}
#method_after
@Override
public Object apply(ChangeResource rsrc, Input input) throws InterruptedException, ExecutionException {
    indexer.index(rsrc.getChange()).get();
    return Response.none();
}
#end_block

#method_before
@Override
public String apply(RevisionResource rev, Input input) {
    final String greeting = input.french ? "Bonjour" : "Hello";
    return String.format("%s %s!", greeting, Strings.isNullOrEmpty(input.message) ? Objects.firstNonNull(user.get().getUserName(), "world") : input.message);
}
#method_after
@Override
public String apply(RevisionResource rev, Input input) {
    final String greeting = input.french ? "Bonjour" : "Hello";
    return String.format("%s %s from change %s, patch set %d!", greeting, Strings.isNullOrEmpty(input.message) ? Objects.firstNonNull(user.get().getUserName(), "world") : input.message, rev.getChange().getId().toString(), rev.getPatchSet().getPatchSetId());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DeleteProjectCapability.DELETE_PROJECT_CAPABILITY)).to(DeleteProjectCapability.class);
}
#method_after
@Override
protected void configure() {
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
}
#end_block

#method_before
@UiHandler("editCommitMessage")
void onEditMessage(ClickEvent e) {
    if (Gerrit.isSignedIn()) {
        editCommitMessageAction.onEdit();
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#method_after
@UiHandler("editMessage")
void onEditMessage(ClickEvent e) {
    editMessageAction.onEdit();
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    initEditCommitMessageAction();
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction();
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "edit_commit_message").to(EditCommitMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serve("/say-hello").with(HelloWorldServlet.class);
    serve("/say-hello/*").with(HelloWorldServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    serve("/say-hello/*").with(HelloWorldServlet.class);
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding("UTF-8");
    final Writer out = rsp.getWriter();
    out.write("<html>");
    out.write("<body>");
    out.write("<h2>Hello world!</h2>");
    out.write("</body>");
    out.write("</html>");
    out.close();
}
#end_block

#method_before
@Test
public void testList() throws Exception {
    Map<String, CapabilityInfo> m = injector.getInstance(ListCapabilities.class).apply(new ConfigResource());
    for (String id : GlobalCapability.getAllNames()) {
        assertTrue("contains " + id, m.containsKey(id));
        assertEquals(id, m.get(id).id);
        assertNotNull(id + " has name", m.get(id).name);
    }
    String pluginCapability = "gerrit-printHello";
    assertTrue("contains " + pluginCapability, m.containsKey(pluginCapability));
}
#method_after
@Test
public void testList() throws Exception {
    Map<String, CapabilityInfo> m = injector.getInstance(ListCapabilities.class).apply(new ConfigResource());
    for (String id : GlobalCapability.getAllNames()) {
        assertTrue("contains " + id, m.containsKey(id));
        assertEquals(id, m.get(id).id);
        assertNotNull(id + " has name", m.get(id).name);
    }
    String pluginCapability = "gerrit-printHello";
    assertTrue("contains " + pluginCapability, m.containsKey(pluginCapability));
    assertEquals(pluginCapability, m.get(pluginCapability).id);
    assertEquals("Print Hello", m.get(pluginCapability).name);
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(getName(), cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
private void checkRequiresCapability(String baseName, Command cmd) throws UnloggedFailure {
    RequiresCapability rc = cmd.getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            // then it must be a plugin-owned capability
            if (!GlobalCapability.isCapability(rc.value())) {
                if (ctl.canPerform(String.format("%s-%s", baseName, rc.value()))) {
                    return;
                }
            }
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value());
            throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
        }
    }
}
#method_after
private void checkRequiresCapability(Command cmd) throws UnloggedFailure {
    RequiresCapability rc = cmd.getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        String capability = rc.value();
        if (cmd instanceof BaseCommand) {
            String pluginName = ((BaseCommand) cmd).getPluginName();
            if (pluginName != null && !"gerrit".equals(pluginName) && (rc.scope() == CapabilityScope.PLUGIN || rc.scope() == CapabilityScope.CONTEXT)) {
                capability = String.format("%s-%s", pluginName, rc.value());
            } else if (rc.scope() == CapabilityScope.PLUGIN) {
                log.error(String.format("Class %s uses @%s(scope=%s), but is not within a plugin", cmd.getClass().getName(), RequiresCapability.class.getSimpleName(), CapabilityScope.PLUGIN.name()));
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, "fatal: cannot check capability");
            }
        }
        if (!ctl.canPerform(capability) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), capability);
            throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        // because it might be provided by plugin
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
private static LabelValue parseLabelValue(String src) {
    List<String> parts = ImmutableList.copyOf(Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().limit(2).split(src));
    if (parts.isEmpty()) {
        throw new IllegalArgumentException("empty value");
    }
    return new LabelValue(Shorts.checkedCast(PermissionRule.parseInt(parts.get(0))), parts.get(1));
}
#method_after
private static LabelValue parseLabelValue(String src) {
    List<String> parts = ImmutableList.copyOf(Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().limit(2).split(src));
    if (parts.isEmpty()) {
        throw new IllegalArgumentException("empty value");
    }
    String valueText = parts.size() > 1 ? parts.get(1) : "";
    return new LabelValue(Shorts.checkedCast(PermissionRule.parseInt(parts.get(0))), valueText);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            // because it might be provided by plugin
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#method_after
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#end_block

#method_before
@Override
public Response<CommentInfo> apply(RevisionResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    if (Strings.isNullOrEmpty(in.path)) {
        throw new BadRequestException("path must be non-empty");
    } else if (in.message == null || in.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (in.line != null && in.line <= 0) {
        throw new BadRequestException("line must be > 0");
    }
    PatchLineComment c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), ChangeUtil.messageUUID(db.get())), in.line != null ? in.line : 0, rsrc.getAccountId(), Url.decode(in.inReplyTo));
    c.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    c.setMessage(in.message.trim());
    c.setRange(in.range);
    db.get().patchComments().insert(Collections.singleton(c));
    return Response.created(new CommentInfo(c, null));
}
#method_after
@Override
public Response<CommentInfo> apply(RevisionResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    if (Strings.isNullOrEmpty(in.path)) {
        throw new BadRequestException("path must be non-empty");
    } else if (in.message == null || in.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (in.line != null && in.line <= 0) {
        throw new BadRequestException("line must be > 0");
    } else if (in.line != null && in.range != null && in.line != in.range.getEndLine()) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    int line = in.line != null ? in.line : in.range != null ? in.range.getEndLine() : 0;
    PatchLineComment c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), ChangeUtil.messageUUID(db.get())), line, rsrc.getAccountId(), Url.decode(in.inReplyTo));
    c.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    c.setMessage(in.message.trim());
    c.setRange(in.range);
    db.get().patchComments().insert(Collections.singleton(c));
    return Response.created(new CommentInfo(c, null));
}
#end_block

#method_before
@Override
public Object apply(DraftResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    PatchLineComment c = rsrc.getComment();
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.get().apply(rsrc, null);
    } else if (in.kind != null && !"gerritcodereview#comment".equals(in.kind)) {
        throw new BadRequestException("expected kind gerritcodereview#comment");
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        db.get().patchComments().delete(Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid());
        db.get().patchComments().insert(Collections.singleton(update(c, in)));
    } else {
        db.get().patchComments().update(Collections.singleton(update(c, in)));
    }
    return new CommentInfo(c, null);
}
#method_after
@Override
public Object apply(DraftResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    PatchLineComment c = rsrc.getComment();
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.get().apply(rsrc, null);
    } else if (in.kind != null && !"gerritcodereview#comment".equals(in.kind)) {
        throw new BadRequestException("expected kind gerritcodereview#comment");
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.getEndLine()) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        db.get().patchComments().delete(Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid());
        db.get().patchComments().insert(Collections.singleton(update(c, in)));
    } else {
        db.get().patchComments().update(Collections.singleton(update(c, in)));
    }
    return new CommentInfo(c, null);
}
#end_block

#method_before
private PatchLineComment update(PatchLineComment e, Input in) {
    if (in.side != null) {
        e.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    }
    if (in.line != null) {
        e.setLine(in.line);
    }
    if (in.inReplyTo != null) {
        e.setParentUuid(Url.decode(in.inReplyTo));
    }
    e.setMessage(in.message.trim());
    e.setRange(in.range);
    e.updated();
    return e;
}
#method_after
private PatchLineComment update(PatchLineComment e, Input in) {
    if (in.side != null) {
        e.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    }
    if (in.inReplyTo != null) {
        e.setParentUuid(Url.decode(in.inReplyTo));
    }
    e.setMessage(in.message.trim());
    if (in.range != null || in.line != null) {
        e.setRange(in.range);
        e.setLine(in.range != null ? in.range.getEndLine() : in.line);
    }
    e.updated();
    return e;
}
#end_block

#method_before
@Override
public PatchLineComment call() throws NoSuchChangeException, OrmException {
    if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
        throw new IllegalStateException("Comment published");
    }
    final Patch.Key patchKey = comment.getKey().getParentKey();
    final PatchSet.Id patchSetId = patchKey.getParentKey();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    db.changes().beginTransaction(changeId);
    try {
        changeControlFactory.validateFor(changeId);
        if (db.patchSets().get(patchSetId) == null) {
            throw new NoSuchChangeException(changeId);
        }
        final Account.Id me = currentUser.getAccountId();
        if (comment.getKey().get() == null) {
            if (comment.getLine() < 0) {
                throw new IllegalStateException("Comment line must be >= 0, not " + comment.getLine());
            }
            if (comment.getParentUuid() != null) {
                final PatchLineComment parent = db.patchComments().get(new PatchLineComment.Key(patchKey, comment.getParentUuid()));
                if (parent == null || parent.getSide() != comment.getSide()) {
                    throw new IllegalStateException("Parent comment must be on same side");
                }
            }
            final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patchKey, ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
            nc.setSide(comment.getSide());
            nc.setMessage(comment.getMessage());
            nc.setRange(comment.getRange());
            db.patchComments().insert(Collections.singleton(nc));
            db.commit();
            return nc;
        } else {
            if (!me.equals(comment.getAuthor())) {
                throw new NoSuchChangeException(changeId);
            }
            comment.updated();
            db.patchComments().update(Collections.singleton(comment));
            db.commit();
            return comment;
        }
    } finally {
        db.rollback();
    }
}
#method_after
@Override
public PatchLineComment call() throws NoSuchChangeException, OrmException {
    if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
        throw new IllegalStateException("Comment published");
    }
    final Patch.Key patchKey = comment.getKey().getParentKey();
    final PatchSet.Id patchSetId = patchKey.getParentKey();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    db.changes().beginTransaction(changeId);
    try {
        changeControlFactory.validateFor(changeId);
        if (db.patchSets().get(patchSetId) == null) {
            throw new NoSuchChangeException(changeId);
        }
        final Account.Id me = currentUser.getAccountId();
        if (comment.getKey().get() == null) {
            if (comment.getLine() < 0) {
                throw new IllegalStateException("Comment line must be >= 0, not " + comment.getLine());
            }
            if (comment.getParentUuid() != null) {
                final PatchLineComment parent = db.patchComments().get(new PatchLineComment.Key(patchKey, comment.getParentUuid()));
                if (parent == null || parent.getSide() != comment.getSide()) {
                    throw new IllegalStateException("Parent comment must be on same side");
                }
            }
            if (comment.getRange() != null && comment.getLine() != comment.getRange().getEndLine()) {
                throw new IllegalStateException("Range endLine must be on the same line as the comment");
            }
            final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patchKey, ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
            nc.setSide(comment.getSide());
            nc.setMessage(comment.getMessage());
            nc.setRange(comment.getRange());
            db.patchComments().insert(Collections.singleton(nc));
            db.commit();
            return nc;
        } else {
            if (!me.equals(comment.getAuthor())) {
                throw new NoSuchChangeException(changeId);
            }
            comment.updated();
            db.patchComments().update(Collections.singleton(comment));
            db.commit();
            return comment;
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj instanceof CommentRange) {
        CommentRange other = (CommentRange) obj;
        return startLine == other.startLine && startCh == other.startCh && endLine == other.endLine && endCh == other.endCh;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof CommentRange) {
        CommentRange other = (CommentRange) obj;
        return startLine == other.startLine && startCharacter == other.startCharacter && endLine == other.endLine && endCharacter == other.endCharacter;
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return "Range [startLine=" + startLine + ", startCh=" + startCh + ", endLine=" + endLine + ", endCh=" + endCh + "]";
}
#method_after
@Override
public String toString() {
    return "Range[startLine=" + startLine + ", startCharacter=" + startCharacter + ", endLine=" + endLine + ", endCharacter=" + endCharacter + "]";
}
#end_block

#method_before
public static CommentInfo createRange(String path, Side side, int line, String in_reply_to, String message, CommentRange range) {
    CommentInfo info = createFile(path, side, in_reply_to, message);
    info.setLine(line);
    info.setRange(range);
    return info;
}
#method_after
public static CommentInfo createRange(String path, Side side, int line, String in_reply_to, String message, CommentRange range) {
    CommentInfo info = createFile(path, side, in_reply_to, message);
    info.setRange(range);
    info.setLine(range == null ? line : range.end_line());
    return info;
}
#end_block

#method_before
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.setStartLine(sl);
    r.setStartCh(sc);
    r.setEndLine(el);
    r.setEndCh(ec);
    return r;
}
#method_after
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.set(sl, sc, el, ec);
    return r;
}
#end_block

#method_before
private void setupNav(Nav nav, FileInfo info) {
    final String url = url(info);
    if (info != null) {
        String fileName = getFileNameOnly(info.path());
        if (nav == Nav.PREV) {
            prevUrl = url;
            prevLink.setHTML(Util.C.prevPatchLinkIcon() + fileName);
        } else {
            nextUrl = url;
            nextLink.setHTML(fileName + Util.C.nextPatchLinkIcon());
        }
    }
    if (keys != null) {
        if (cmds[nav.cmd] != null) {
            keys.remove(cmds[nav.cmd]);
        }
        if (url != null) {
            cmds[nav.cmd] = new KeyCommand(0, nav.key, nav.help) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    Gerrit.display(url);
                }
            };
        } else {
            cmds[nav.cmd] = new UpToChangeCommand2(patchSetId, 0, nav.key);
        }
        keys.add(cmds[nav.cmd]);
    }
}
#method_after
private void setupNav(Anchor anchor, int key, String help, FileInfo info) {
    final String url = url(info);
    if (info != null) {
        String fileName = getFileNameOnly(info.path());
        anchor.setHref("#" + url);
        if (anchor == prevLink) {
            anchor.setHTML(new SafeHtmlBuilder().append(SafeHtml.asis(Util.C.prevPatchLinkIcon())).append(SafeHtml.asis(fileName)).toSafeHtml());
        } else {
            anchor.setHTML(new SafeHtmlBuilder().append(SafeHtml.asis(fileName)).append(SafeHtml.asis(Util.C.nextPatchLinkIcon())).toSafeHtml());
        }
    }
    if (url != null) {
        keys.add(new KeyCommand(0, key, help) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                Gerrit.display(url);
            }
        });
    } else {
        keys.add(new UpToChangeCommand2(patchSetId, 0, key));
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    Gerrit.display(PageLinks.toChange2(revision.getParentKey(), String.valueOf(revision)));
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    Gerrit.display(PageLinks.toChange2(revision.getParentKey(), String.valueOf(revision.get())));
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
            resizeCodeMirror();
        }
    });
    (cmB != null ? cmB : cmA).focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    resizeCodeMirror();
    Window.enableScrolling(false);
    cmA.setOption("viewportMargin", 10);
    cmB.setOption("viewportMargin", 10);
    cmB.focus();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    cmA.getWrapperElement().removeFromParent();
    cmB.getWrapperElement().removeFromParent();
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
            resizeBoxPaddings();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
            if (aLength == 0 || bLength == 0) {
                diffTable.sidePanel.addGutter(cmB, origLineB, aLength == 0 ? SidePanel.GutterType.INSERT : SidePanel.GutterType.DELETE);
            } else {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.EDIT);
            }
        }
    }
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        box.setOpen(true);
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    final DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (getDiffChunk(getSideFromCm(other), lineToPad) == null) {
        box.setDiffChunkInfo(getDiffChunk(mySide, line));
    }
    allBoxes.add(box);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(mySide, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#end_block

#method_before
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
    allBoxes.remove(box);
}
#method_after
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            int oLine = info.getLine();
            LineHandle oLineHandle = other.getLineHandle(oLine);
            if (info.isAligned()) {
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            if (info.isAligned()) {
                LineHandle oLineHandle = other.getLineHandle(info.getLine());
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, MouseDownEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#end_block

#method_before
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        myChunkHeight -= myPadding.getOffsetHeight();
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPadding.getOffsetHeight();
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            setHeightInPx(myPadding, 0);
            setHeightInPx(otherPadding, delta);
        } else {
            setHeightInPx(myPadding, -delta);
            setHeightInPx(otherPadding, 0);
        }
        myWrapper.getWidget().changed();
    } else {
        setHeightInPx(otherPadding, myChunkHeight);
    }
    otherWrapper.getWidget().changed();
}
#method_after
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#end_block

#method_before
void resizeCodeMirror() {
    // TODO: Probably need horizontal resize
    int h = Gerrit.getHeaderFooterHeight() + reviewed.getOffsetHeight() + navLinks.getOffsetHeight() + diffTable.getHeaderHeight() + // Estimate
    5;
    if (cmA != null) {
        cmA.setHeight(Window.getClientHeight() - h);
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.setHeight(Window.getClientHeight() - h);
        cmB.refresh();
    }
}
#method_after
void resizeCodeMirror() {
    if (cmA == null) {
        return;
    }
    int h = Gerrit.getHeaderFooterHeight() + reviewed.getOffsetHeight() + navLinks.getOffsetHeight() + diffTable.getHeaderHeight() + // Estimate
    10;
    cmA.setHeight(Window.getClientHeight() - h);
    cmA.refresh();
    cmB.setHeight(Window.getClientHeight() - h);
    cmB.refresh();
    diffTable.sidePanel.adjustGutters(cmB);
}
#end_block

#method_before
void createOrEditFileComment() {
    if (boxes.isEmpty()) {
        CommentInfo info = CommentInfo.create(path, side, null, null, null);
        addFileComment(host.addDraftBox(info, false));
    } else {
        CommentBox box = boxes.get(boxes.size() - 1);
        if (box.isDraft()) {
            ((DraftBox) box).setEdit(true);
        } else {
            addFileComment(((PublishedBox) box).addReplyBox("", false));
        }
    }
}
#method_after
void createOrEditFileComment() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
        return;
    }
    if (boxes.isEmpty()) {
        CommentInfo info = CommentInfo.createFile(path, side, null, null);
        addFileComment(parent.addDraftBox(info));
    } else {
        CommentBox box = boxes.get(boxes.size() - 1);
        if (box instanceof DraftBox) {
            ((DraftBox) box).setEdit(true);
        } else {
            addFileComment(((PublishedBox) box).addReplyBox());
        }
    }
}
#end_block

#method_before
void addFileComment(CommentBox box) {
    boxes.add(box);
    table.updateVisibility(false);
    ((HTMLPanel) getWidget()).add(box);
    box.registerDiffTable(table);
}
#method_after
void addFileComment(CommentBox box) {
    boxes.add(box);
    body.add(box);
    table.updateFileCommentVisibility(false);
}
#end_block

#method_before
void onRemoveDraftBox(DraftBox box) {
    boxes.remove(box);
    table.updateVisibility(false);
}
#method_after
void onRemoveDraftBox(DraftBox box) {
    boxes.remove(box);
    table.updateFileCommentVisibility(false);
}
#end_block

#method_before
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    patchSelectBoxA.toggleVisible(true);
}
#method_after
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#end_block

#method_before
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getText().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#method_after
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getValue().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#end_block

#method_before
void setEdit(boolean edit) {
    if (edit) {
        setOpen(true);
        removeStyleName(draftStyle.view());
        addStyleName(draftStyle.edit());
        editArea.setText(getOriginal().message());
        expandText();
        editArea.setReadOnly(false);
        editArea.setFocus(true);
        disableClickFocusHandler();
    } else {
        expandTimer.cancel();
        editArea.setReadOnly(true);
        removeStyleName(draftStyle.edit());
        addStyleName(draftStyle.view());
        enableClickFocusHandler();
    }
    resizePaddingWidget();
}
#method_after
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    if (edit) {
        final String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        editArea.setFocus(true);
        cancel.setVisible(!isNew());
        expandText();
        if (msg.length() > 0) {
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    editArea.setCursorPos(msg.length());
                    return false;
                }
            }, 0);
        }
    } else {
        expandTimer.cancel();
    }
    resizePaddingWidget();
}
#end_block

#method_before
private void removeUI() {
    setEdit(false);
    expandTimer.cancel();
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    removeFromParent();
    getCm().focus();
    if (isFileComment()) {
        getDiffTable().onRemoveDraftBox(this, getSide());
        return;
    }
    CommentInfo info = getOriginal();
    getDiffView().removeDraft(this, getSide(), info.line() - 1);
    getSelfWidget().clear();
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    manager.resizePaddingWidget();
}
#method_after
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    Side side = comment.side();
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this, side);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, side, comment.line() - 1);
    cm.focus();
    getSelfWidgetWrapper().getWidget().clear();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent e) {
    setEdit(true);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent e) {
    e.stopPropagation();
    setEdit(true);
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    onSave();
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
private void onSave() {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            if (result.message().length() < 70) {
                UIObject.setVisible(p_edit, false);
                setOpen(false);
            } else {
                setEdit(false);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, original.id(), input, cb);
    }
    cm.focus();
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    setEdit(false);
    getCm().focus();
}
#method_after
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    e.stopPropagation();
    if (isNew() && !isDirty()) {
        removeUI();
    } else {
        setEdit(false);
        cm.focus();
    }
}
#end_block

#method_before
@UiHandler("discard")
void onDiscard(ClickEvent e) {
    if (isNew) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(getPatchSetId(), getOriginal().id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#method_after
@UiHandler({ "discard1", "discard2" })
void onDiscard(ClickEvent e) {
    e.stopPropagation();
    if (isNew()) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(psId, comment.id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#end_block

#method_before
DraftBox addReplyBox(String initMessage, boolean doSave) {
    DraftBox box = getDiffView().addReply(getOriginal(), initMessage, doSave);
    registerReplyBox(box);
    return box;
}
#method_after
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment));
    registerReplyBox(box);
    return box;
}
#end_block

#method_before
@UiHandler("reply")
void onReply(ClickEvent e) {
    checkAndAddReply("", false);
}
#method_after
@UiHandler("reply")
void onReply(ClickEvent e) {
    e.stopPropagation();
    doReply();
}
#end_block

#method_before
@UiHandler("replyDone")
void onReplyDone(ClickEvent e) {
    checkAndAddReply(PatchUtil.C.cannedReplyDone(), true);
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result);
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box, comment.side());
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
        }
    });
    resizeBoxPaddings();
    (cmB != null ? cmB : cmA).focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
            resizeCodeMirror();
        }
    });
    (cmB != null ? cmB : cmA).focus();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(cm));
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    CodeMirror.defineVimEx("up", "u", upToChange());
    CodeMirror.defineVimEx("mark", "m", toggleReviewed());
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    /**
     * TODO: Work on a better way for customizing keybindings and remove
     * temporary navigation hacks.
     */
    for (String s : new String[] { "C", "J", "K", "O", "R", "U", "Ctrl-C", "Enter" }) {
        CodeMirror.disableUnwantedKey("vim", s);
    }
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'm', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    handlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        handlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingWidgetMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    lineElementMap = new HashMap<LineHandle, Element>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
            resizeBoxPaddings();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
            resizeBoxPaddings();
        }
    });
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    int h = Gerrit.getHeaderFooterHeight() + 18;
    CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - h);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), mapper.getLineB(), insertCnt, false);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), mapper.getLineA(), deleteCnt, false);
                mapper.appendDelete(deleteCnt);
            }
            insertEmptyLines(cmA, mapper.getLineA(), origLineB, commonCnt, true);
            insertEmptyLines(cmB, mapper.getLineB(), origLineA, commonCnt, true);
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private DraftBox addNewDraft(CodeMirror cm, int line) {
    Side side = getSideFromCm(cm);
    CommentInfo info = CommentInfo.create(path, side, line + 1, null, null);
    return addDraftBox(info, false);
}
#method_after
private DraftBox addNewDraft(CodeMirror cm, int line) {
    return addDraftBox(CommentInfo.createLine(path, getSideFromCm(cm), line + 1, null, null));
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info, boolean doSave) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, revision, info, commentLinkProcessor, true, doSave);
    if (!doSave) {
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        box.setOpen(true);
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 28, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 28, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    allBoxes.add(box);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (getDiffChunk(getSideFromCm(other), lineToPad) == null) {
        box.setDiffChunkInfo(getDiffChunk(mySide, line));
    }
    allBoxes.add(box);
    return box;
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, revision, info, commentLinkProcessor);
        box.setOpen(false);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        publishedMap.put(info.id(), box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), revision, info, commentLinkProcessor, false, false);
        box.setOpen(false);
        box.setEdit(false);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getCommentInfo();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.isScrollSetByOther()) {
                return;
            }
            other.scrollToY(cm.getScrollInfo().getTop());
            other.setScrollSetByOther(true);
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    other.setScrollSetByOther(false);
                    return false;
                }
            }, 0);
        }
    };
}
#method_after
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.getScrollSetAt() + 50 > System.currentTimeMillis()) {
                return;
            }
            ScrollInfo si = cm.getScrollInfo();
            if (si.getTop() == 0 && !Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(true);
                diffTable.updateFileCommentVisibility(false);
                resizeCodeMirror();
            } else if (si.getTop() > 0.5 * si.getClientHeight() && Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(false);
                diffTable.updateFileCommentVisibility(true);
                resizeCodeMirror();
            }
            /**
             * Since CM doesn't always take the height of line widgets into
             * account when calculating scrollInfo when scrolling too fast
             * (e.g. throw-scrolling), simply setting scrollTop to be the same
             * doesn't guarantee alignment, but should work in most cases. See the
             * hack in fixScroll();
             */
            other.scrollToY(si.getTop());
            other.setScrollSetAt(System.currentTimeMillis());
            (cm == cmA ? scrollTimerA : scrollTimerB).schedule(50);
        }
    };
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            int oLine = info.getLine();
            LineHandle oLineHandle = other.getLineHandle(oLine);
            if (info.isAligned()) {
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box.isDraft()) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).onReply(null);
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#end_block

#method_before
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewedTop.setReviewed(!reviewedTop.isReviewed());
        }
    };
}
#method_after
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewed.setReviewed(!reviewed.isReviewed());
        }
    };
}
#end_block

#method_before
private RenderLineHandler resizeEmptyLine(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, final Element element) {
            if (linePaddingWidgetMap.containsKey(handle)) {
                /**
                 * This needs to be deferred because CM fires "renderLine" **before**
                 * the line is actually added to the DOM.
                 */
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        LinePaddingWidgetWrapper otherWrapper = linePaddingWidgetMap.get(handle);
                        int myLineHeight = element.getOffsetHeight();
                        Element otherPadding = otherWrapper.getElement();
                        if (!otherWrapper.isCommon() && myLineHeight > 0) {
                            setHeightInPx(otherPadding, myLineHeight);
                        } else {
                            /**
                             * We have to pay the cost of keeping track of the actual DOM
                             * elements ourselves, because CM doesn't provide an interface
                             * to query for them, and the only place we can ever have legit
                             * access to the line element is in this event handler.
                             */
                            lineElementMap.put(handle, element);
                            if (myLineHeight == 0) {
                                return;
                            }
                            // The lines are always aligned since they are in a common region.
                            int otherLine = mapper.lineOnOther(side, instance.getLineNumber(handle)).getLine();
                            LineHandle other = otherCm(instance).getLineHandle(otherLine);
                            LinePaddingWidgetWrapper myWrapper = linePaddingWidgetMap.get(other);
                            if (lineElementMap.containsKey(other)) {
                                Element otherElement = lineElementMap.get(other);
                                int otherLineHeight = otherElement.getOffsetHeight();
                                if (otherLineHeight == 0) {
                                    return;
                                }
                                Element myPadding = myWrapper.getElement();
                                int delta = myLineHeight - otherLineHeight;
                                if (delta >= 0) {
                                    setHeightInPx(otherPadding, delta);
                                    setHeightInPx(myPadding, 0);
                                } else {
                                    setHeightInPx(otherPadding, 0);
                                    setHeightInPx(myPadding, -delta);
                                }
                                myWrapper.getWidget().changed();
                                otherWrapper.getWidget().changed();
                            }
                        }
                    }
                });
            }
        }
    };
}
#method_after
private RenderLineHandler resizeEmptyLine(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#end_block

#method_before
void resizePaddingWidget() {
    if (fileComment) {
        cm.refresh();
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        public void execute() {
            if (selfWidget == null || widgetManager == null) {
                throw new IllegalStateException("resizePaddingWidget() called before setting up widgets");
            }
            selfWidget.changed();
            widgetManager.resizePaddingWidget();
        }
    });
}
#method_after
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(getCommentInfo().side(), diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#end_block

#method_before
void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
    resizePaddingWidget();
}
#method_after
void setOpen(boolean open) {
    resizePaddingWidget();
}
#end_block

#method_before
public String getGitSshUrl() {
    if (sshdListenAddressString == null) {
        return "";
    }
    if (downloadSchemes.length != 0) {
        if (!Arrays.asList(downloadSchemes).contains("ssh")) {
            return "";
        }
    }
    String[] urlParts = sshdListenAddressString.split(":");
    if (urlParts.length < 2) {
        log.error("Invalid SSHD listenUrl: " + sshdListenAddressString);
        return "";
    }
    try {
        String hostname = getHost(urlParts[0]);
        int port = getPort(urlParts[1]);
        return "ssh://" + GITBLIT_USER + "@" + hostname + (port == SSH_DEF_PORT ? "" : ":" + port) + "/" + GITBLIT_REPO + "";
    } catch (UnknownHostException e) {
        log.error("Cannot detect localhostname");
        return "";
    }
}
#method_after
public String getGitSshUrl() {
    if (sshdListenAddressString == null) {
        return "";
    }
    if (!downloadSchemes.isEmpty() && !downloadSchemes.contains("ssh")) {
        return "";
    }
    String[] urlParts = sshdListenAddressString.split(":");
    if (urlParts.length < 2) {
        log.error("Invalid SSHD listenUrl: " + sshdListenAddressString);
        return "";
    }
    try {
        String hostname = getHost(urlParts[0]);
        int port = getPort(urlParts[1]);
        return "ssh://" + GITBLIT_USER + "@" + hostname + (port == SSH_DEF_PORT ? "" : ":" + port) + "/" + GITBLIT_REPO + "";
    } catch (UnknownHostException e) {
        log.error("Cannot detect localhostname");
        return "";
    }
}
#end_block

#method_before
public String getGitHttpUrl() throws UnknownHostException {
    String httpListenUrl = getHttpListenUrl();
    if (httpListenUrl == null) {
        return "";
    }
    if (downloadSchemes.length != 0) {
        if (!Arrays.asList(downloadSchemes).contains("http")) {
            return "";
        }
    }
    String httpUrl = Objects.firstNonNull(canonicalWebUrlString, httpListenUrl);
    httpUrl = httpUrl.replace("://", "://" + GITBLIT_USER + "@");
    httpUrl += (httpUrl.endsWith("/") ? "" : "/") + GITBLIT_REPO;
    return httpUrl;
}
#method_after
public String getGitHttpUrl() throws UnknownHostException {
    String httpListenUrl = getHttpListenUrl();
    if (httpListenUrl == null) {
        return "";
    }
    if (!downloadSchemes.isEmpty() && !downloadSchemes.contains("http")) {
        return "";
    }
    String httpUrl = Objects.firstNonNull(canonicalWebUrlString, httpListenUrl);
    httpUrl = httpUrl.replace("://", "://" + GITBLIT_USER + "@");
    httpUrl += (httpUrl.endsWith("/") ? "" : "/") + GITBLIT_REPO;
    return httpUrl;
}
#end_block

#method_before
private void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
@Override
protected void onUnload() {
    if (availableUpdate != null) {
        availableUpdate.hide(true);
        availableUpdate = null;
    }
    if (poller != null) {
        poller.cancel();
        poller = null;
    }
    for (HandlerRegistration h : keys) {
        h.removeHandler();
    }
    keys.clear();
    super.onUnload();
}
#method_after
@Override
protected void onUnload() {
    if (updateAvailable != null) {
        updateAvailable.hide(true);
        updateAvailable = null;
    }
    if (updateCheck != null) {
        updateCheck.cancel();
        updateCheck = null;
    }
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
    super.onUnload();
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keys.add(GlobalKey.add(this, keysNavigation));
    keys.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void loadMergeable(final boolean canSubmit) {
    if (Gerrit.getConfig().testChangeMerge()) {
        ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new AsyncCallback<MergeableInfo>() {

            @Override
            public void onSuccess(MergeableInfo result) {
                if (canSubmit) {
                    actions.setSubmitEnabled(result.mergeable());
                    statusText.setInnerText(result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
                setVisible(notMergeable, !result.mergeable());
                renderSubmitType(result.submit_type());
            }

            @Override
            public void onFailure(Throwable caught) {
                loadSubmitType(canSubmit);
            }
        });
    } else {
        loadSubmitType(canSubmit);
    }
}
#method_after
private void loadMergeable(final Change.Status status, final boolean canSubmit) {
    if (Gerrit.getConfig().testChangeMerge()) {
        ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new AsyncCallback<MergeableInfo>() {

            @Override
            public void onSuccess(MergeableInfo result) {
                if (canSubmit) {
                    actions.setSubmitEnabled(result.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !result.mergeable());
                renderSubmitType(result.submit_type());
            }

            @Override
            public void onFailure(Throwable caught) {
                loadSubmitType(status, canSubmit);
            }
        });
    } else {
        loadSubmitType(status, canSubmit);
    }
}
#end_block

#method_before
private void loadSubmitType(final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        statusText.setInnerText(Util.C.readyToSubmit());
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(canSubmit);
    }
    reply.setVisible(replyAction != null);
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    reply.setVisible(replyAction != null);
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void showUpdates(ChangeInfo newInfo) {
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (availableUpdate == null) {
        availableUpdate = new UpdatedBar() {

            @Override
            void onShow() {
                // TODO Avoid RPC and use newInfo.
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
        availableUpdate.addCloseHandler(new CloseHandler<PopupPanel>() {

            @Override
            public void onClose(CloseEvent<PopupPanel> event) {
                availableUpdate = null;
            }
        });
    }
    availableUpdate.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!availableUpdate.isShowing()) {
        availableUpdate.popup();
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
        updateAvailable.addCloseHandler(new CloseHandler<PopupPanel>() {

            @Override
            public void onClose(CloseEvent<PopupPanel> event) {
                updateAvailable = null;
            }
        });
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isShowing()) {
        updateAvailable.popup();
    }
}
#end_block

#method_before
private void startPoller() {
    poller = new Timer() {

        private int delay = REFRESH_POLL_PERIOD;

        @Override
        public void run() {
            if (!isAttached()) {
                // onUnload() should have removed this.
                return;
            } else if (!UserActivityMonitor.isActive()) {
                cancel();
                delay = REFRESH_IDLE_PERIOD;
                scheduleRepeating(delay);
            }
            loadChangeInfo(false, new AsyncCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo info) {
                    if (isAttached() && !info.updated().equals(lastDisplayedUpdate)) {
                        showUpdates(info);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    // but place an upper bound on the delay.
                    if (isAttached()) {
                        cancel();
                        delay = (int) Math.max(delay * (1.5 + Math.random()), REFRESH_MAX_PERIOD);
                        scheduleRepeating(delay);
                    }
                }
            });
        }
    };
    poller.scheduleRepeating(REFRESH_POLL_PERIOD);
}
#method_after
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.getConfig().getChangeUpdateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#end_block

#method_before
public static RootPanel getBottomMenu() {
    return gBottomMenu;
}
#method_after
public static RootPanel getBottomMenu() {
    return bottomMenu;
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(topMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#end_block

#method_before
public static boolean isActive() {
    return impl.recent || impl.active;
}
#method_after
public static boolean isActive() {
    return impl.active || impl.recent;
}
#end_block

#method_before
@Override
public void onKeyPress(KeyPressEvent event) {
    active = true;
}
#method_after
@Override
public void onKeyPress(KeyPressEvent event) {
    recent = true;
}
#end_block

#method_before
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    active = true;
}
#method_after
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    recent = true;
}
#end_block

#method_before
@Override
public boolean execute() {
    long now = System.currentTimeMillis();
    if (active) {
        recent = true;
        active = false;
        last = now;
    } else if ((now - last) > TIMEOUT) {
        recent = false;
    }
    return true;
}
#method_after
@Override
public boolean execute() {
    long now = System.currentTimeMillis();
    if (recent) {
        if (!active) {
            ValueChangeEvent.fire(this, active);
        }
        recent = false;
        active = true;
        last = now;
    } else if (active && (now - last) > TIMEOUT) {
        active = false;
        ValueChangeEvent.fire(this, false);
    }
    return true;
}
#end_block

#method_before
@Override
public void run() {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    PatchList patchList;
    if (// Ignore merges and initial commit.
    commit.getParentCount() == 1 && (patchList = getPatchList(change, ps)) != null) {
        for (PatchListEntry entry : patchList.getPatches()) {
            BlameResult blameResult;
            if ((entry.getChangeType() == ChangeType.MODIFIED || entry.getChangeType() == ChangeType.DELETED) && (blameResult = computeBlame(entry, commit.getParent(0))) != null) {
                List<Edit> edits = entry.getEdits();
                reviewers.putAll(getReviewersForPatch(edits, blameResult));
            }
        }
        Set<Account.Id> topReviewers = findTopReviewers(Collections.unmodifiableSet(reviewers.entrySet()), maxReviewers);
        addReviewers(topReviewers, change);
    }
}
#method_after
@Override
public void run() {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    PatchList patchList;
    try {
        patchList = patchListCache.get(change, ps);
    } catch (PatchListNotAvailableException ex) {
        log.error("Couldn't load patchlist for change {}", change.getKey(), ex);
        return;
    }
    // Ignore merges and initial commit.
    if (commit.getParentCount() != 1) {
        return;
    }
    for (PatchListEntry entry : patchList.getPatches()) {
        BlameResult blameResult;
        if ((entry.getChangeType() == ChangeType.MODIFIED || entry.getChangeType() == ChangeType.DELETED) && (blameResult = computeBlame(entry, commit.getParent(0))) != null) {
            List<Edit> edits = entry.getEdits();
            reviewers.putAll(getReviewersForPatch(edits, blameResult));
        }
    }
    Set<Account.Id> topReviewers = findTopReviewers(reviewers);
    addReviewers(topReviewers, change);
}
#end_block

#method_before
private Set<Account.Id> findTopReviewers(final Set<Entry<Account, Integer>> reviewers, final int max) {
    Set<Account.Id> topReviewers = Sets.newHashSet();
    Queue<Entry<Account, Integer>> pq = new PriorityQueue<Map.Entry<Account, Integer>>(reviewers.size(), new Comparator<Entry<Account, Integer>>() {

        public int compare(Entry<Account, Integer> first, Entry<Account, Integer> second) {
            return second.getValue() - first.getValue();
        }
    });
    pq.addAll(reviewers);
    int curr = 0;
    while (!pq.isEmpty() && curr < max) {
        topReviewers.add(pq.poll().getKey().getId());
        ++curr;
    }
    return topReviewers;
}
#method_after
private Set<Account.Id> findTopReviewers(final Map<Account, Integer> reviewers) {
    Set<Account.Id> topReviewers = Sets.newHashSet();
    List<Entry<Account, Integer>> entries = Ordering.from(new Comparator<Entry<Account, Integer>>() {

        public int compare(Entry<Account, Integer> first, Entry<Account, Integer> second) {
            return first.getValue() - second.getValue();
        }
    }).greatestOf(reviewers.entrySet(), this.maxReviewers);
    for (Entry<Account, Integer> entry : entries) {
        topReviewers.add(entry.getKey().getId());
    }
    return topReviewers;
}
#end_block

#method_before
private Map<Account, Integer> getReviewersForPatch(final List<Edit> edits, final BlameResult blameResult) {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    for (Edit edit : edits) {
        for (int i = edit.getBeginA(); i <= edit.getEndA(); i++) {
            RevCommit commit = blameResult.getSourceCommit(i);
            Set<Account.Id> ids = byEmailCache.get(commit.getAuthorIdent().getEmailAddress());
            for (Account.Id id : ids) {
                Account account = accountCache.get(id).getAccount();
                if (account.isActive() && !change.getOwner().equals(account.getId())) {
                    Integer count = reviewers.get(account);
                    reviewers.put(account, count == null ? 1 : count.intValue() + 1);
                }
            }
        }
    }
    return reviewers;
}
#method_after
private Map<Account, Integer> getReviewersForPatch(final List<Edit> edits, final BlameResult blameResult) {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    for (Edit edit : edits) {
        for (int i = edit.getBeginA(); i < edit.getEndA(); i++) {
            RevCommit commit = blameResult.getSourceCommit(i);
            Set<Account.Id> ids = byEmailCache.get(commit.getAuthorIdent().getEmailAddress());
            for (Account.Id id : ids) {
                Account account = accountCache.get(id).getAccount();
                if (account.isActive() && !change.getOwner().equals(account.getId())) {
                    Integer count = reviewers.get(account);
                    reviewers.put(account, count == null ? 1 : count.intValue() + 1);
                }
            }
        }
    }
    return reviewers;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(final Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    try {
        reviewDb = schemaFactory.open();
        try {
            for (Update u : e.getUpdates()) {
                if (!u.getRefName().startsWith("refs/changes/")) {
                    continue;
                }
                final Change change = reviewDb.changes().get(Change.Id.fromRef(u.getRefName()));
                List<PatchSet> patchSets = reviewDb.patchSets().byChange(change.getId()).toList();
                // only compute for the first patch set
                if (patchSets.size() > 1) {
                    continue;
                }
                final PatchSet ps = patchSets.get(0);
                RevWalk rw = new RevWalk(git);
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
                // FIXME Convert to
                int maxReviewers = 3;
                // project.getMaxReviewersByBlame();
                final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git);
                workQueue.getDefaultQueue().submit(new Runnable() {

                    public void run() {
                        RequestContext old = tl.setContext(new RequestContext() {

                            @Override
                            public CurrentUser getCurrentUser() {
                                return identifiedUserFactory.create(change.getOwner());
                            }

                            @Override
                            public Provider<ReviewDb> getReviewDbProvider() {
                                return new Provider<ReviewDb>() {

                                    @Override
                                    public ReviewDb get() {
                                        if (db == null) {
                                            try {
                                                db = schemaFactory.open();
                                            } catch (OrmException e) {
                                                throw new ProvisionException("Cannot open ReviewDb", e);
                                            }
                                        }
                                        return db;
                                    }
                                };
                            }
                        });
                        try {
                            task.run();
                        } finally {
                            tl.setContext(old);
                            if (db != null) {
                                db.close();
                                db = null;
                            }
                        }
                    }
                });
            }
        } catch (OrmException x) {
            log.error(x.getMessage(), x);
        } catch (MissingObjectException x) {
            log.error(x.getMessage(), x);
        } catch (IncorrectObjectTypeException x) {
            log.error(x.getMessage(), x);
        } catch (IOException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        git.close();
    }
}
#method_after
@Override
public void onGitReferenceUpdated(final Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            for (Update u : e.getUpdates()) {
                if (!u.getRefName().startsWith("refs/changes/")) {
                    continue;
                }
                PatchSet.Id psId = PatchSet.Id.fromRef(u.getRefName());
                PatchSet ps = reviewDb.patchSets().get(psId);
                final Change change = reviewDb.changes().get(psId.getParentKey());
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(u.getNewObjectId()));
                // TODO Move to config
                int maxReviewers = 3;
                final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git);
                workQueue.getDefaultQueue().submit(new Runnable() {

                    public void run() {
                        RequestContext old = tl.setContext(new RequestContext() {

                            @Override
                            public CurrentUser getCurrentUser() {
                                return identifiedUserFactory.create(change.getOwner());
                            }

                            @Override
                            public Provider<ReviewDb> getReviewDbProvider() {
                                return new Provider<ReviewDb>() {

                                    @Override
                                    public ReviewDb get() {
                                        if (db == null) {
                                            try {
                                                db = schemaFactory.open();
                                            } catch (OrmException e) {
                                                throw new ProvisionException("Cannot open ReviewDb", e);
                                            }
                                        }
                                        return db;
                                    }
                                };
                            }
                        });
                        try {
                            task.run();
                        } finally {
                            tl.setContext(old);
                            if (db != null) {
                                db.close();
                                db = null;
                            }
                        }
                    }
                });
            }
        } catch (OrmException x) {
            log.error(x.getMessage(), x);
        } catch (MissingObjectException x) {
            log.error(x.getMessage(), x);
        } catch (IncorrectObjectTypeException x) {
            log.error(x.getMessage(), x);
        } catch (IOException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#end_block

#method_before
@UiHandler("editArea")
void onEsc(KeyDownEvent e) {
    if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        if (isNew) {
            removeUI();
        } else {
            onCancel(null);
        }
        e.preventDefault();
    }
}
#method_after
void onEsc(KeyDownEvent e) {
    if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        if (isNew) {
            removeUI();
        } else {
            onCancel(null);
        }
        e.preventDefault();
    }
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    if (regNavigation != null) {
        regNavigation.removeHandler();
        regNavigation = null;
    }
    if (regAction != null) {
        regAction.removeHandler();
        regAction = null;
    }
    if (regOpenByEnter != null) {
        regOpenByEnter.removeHandler();
        regOpenByEnter = null;
    }
    if (regComment != null) {
        regComment.removeHandler();
        regComment = null;
    }
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(otherCM(cm)));
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
}
#method_after
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(otherCM(cm)));
    /**
     * TODO: Trying to prevent right click from updating the cursor.
     * Doesn't seem to work for now.
     */
    cm.on("mousedown", ignoreRightClick());
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    // TODO: Examine if a better way exists.
    for (String c : new String[] { "A", "C", "D", "I", "O", "P", "R", "S", "U", "X", "Y", "~" }) {
        CodeMirror.disableUnwantedKey("vim", c);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    regNavigation = GlobalKey.add(this, keysNavigation);
    regAction = GlobalKey.add(this, keysAction);
    regOpenByEnter = GlobalKey.add(this, keysOpenByEnter);
    if (keysComment != null) {
        regComment = GlobalKey.add(this, keysComment);
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new NoOpKeyCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("styleSelectedText", true).set("showTrailingSpace", true).set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? DiffTable.style.diff() : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, diffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, diffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#end_block

#method_before
private void renderSkips() {
    hiddenSkipMap = new HashMap<LineHandle, Integer>();
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    hiddenSkipMap.put(cm.getLineHandle(markEnd), size);
    SkipBar bar = new SkipBar(cm, hiddenSkipMap);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), Configuration.create().set("collapsed", true));
    /**
     * TODO: Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely. The current approach leaves an empty line
     * with line number "1" still showing, and CodeMirror doesn't like manually
     * setting the display of a line to "none". A workaround may be to use
     * inline widget for the first line and regular line widgets for others.
     */
    boolean isZero = markStart == -1;
    Configuration config = Configuration.create().set("coverGutter", true).set("above", isZero);
    LineWidget widget = cm.addLineWidget(isZero ? markEnd + 1 : markStart, bar.getElement(), config);
    bar.setWidget(widget);
    bar.setMarker(marker, size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    /**
     * Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely, and CodeMirror doesn't like manually
     * setting the display of a line to "none". The workaround here uses
     * inline widget for the first line and regular line widgets for others.
     */
    Configuration markerConfig;
    if (markStart == -1) {
        markerConfig = Configuration.create().set("inclusiveLeft", true).set("inclusiveRight", true).set("replacedWith", bar.getElement());
        cm.addLineClass(0, LineClassWhere.WRAP, DiffTable.style.hideNumber());
    } else {
        markerConfig = Configuration.create().set("collapsed", true);
        Configuration config = Configuration.create().set("coverGutter", true);
        bar.setWidget(cm.addLineWidget(markStart, bar.getElement(), config));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#end_block

#method_before
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#method_after
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", DiffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", DiffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.diff());
        }
    }
}
#end_block

#method_before
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#method_after
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, DiffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            int line = getCursorLine(cm);
            LineHandle handle = cm.getLineHandle(line);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    skipNum.setText(Integer.toString(length));
    if (!checkAndUpdateArrows()) {
        upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
}
#method_after
void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    skipNum.setText(Integer.toString(length));
    if (checkAndUpdateArrows()) {
        upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
}
#end_block

#method_before
private void updateSkipNum() {
    numSkipLines -= NUM_ROWS_TO_EXPAND;
    skipNum.setText(Integer.toString(numSkipLines));
    checkAndUpdateArrows();
}
#method_after
private void updateSkipNum() {
    numSkipLines -= NUM_ROWS_TO_EXPAND;
    skipNum.setText(String.valueOf(numSkipLines));
    checkAndUpdateArrows();
}
#end_block

#method_before
private boolean checkAndUpdateArrows() {
    if (numSkipLines <= UP_DOWN_THRESHOLD) {
        upArrow.addStyleName(style.noExpand());
        downArrow.addStyleName(style.noExpand());
        return true;
    }
    return false;
}
#method_after
private boolean checkAndUpdateArrows() {
    if (numSkipLines <= UP_DOWN_THRESHOLD) {
        upArrow.addStyleName(style.noExpand());
        downArrow.addStyleName(style.noExpand());
        return false;
    }
    return true;
}
#end_block

#method_before
private void expandAll() {
    marker.clear();
    removeFromParent();
}
#method_after
private void expandAll() {
    hiddenSkipMap.remove(cm.getLineHandle(marker.find().getTo().getLine()));
    marker.clear();
    widget.clear();
    removeFromParent();
}
#end_block

#method_before
private void expandBefore() {
    FromTo fromTo = marker.find();
    marker.clear();
    marker = cm.markText(CodeMirror.Pos(fromTo.getFrom().getLine() + NUM_ROWS_TO_EXPAND), CodeMirror.Pos(fromTo.getTo().getLine()), Configuration.getReplaceConfig(getElement()));
    updateSkipNum();
}
#method_after
private void expandBefore() {
    FromTo fromTo = marker.find();
    marker.clear();
    int oldStart = fromTo.getFrom().getLine();
    int newStart = oldStart + NUM_ROWS_TO_EXPAND;
    int end = fromTo.getTo().getLine();
    marker = cm.markText(CodeMirror.pos(newStart), CodeMirror.pos(end), COLLAPSED);
    Configuration config = Configuration.create().set("coverGutter", true);
    LineWidget newWidget = cm.addLineWidget(newStart, getElement(), config);
    widget.clear();
    setWidget(newWidget);
    updateSkipNum();
    hiddenSkipMap.put(cm.getLineHandle(end), numSkipLines);
}
#end_block

#method_before
private void expandAfter() {
    FromTo fromTo = marker.find();
    marker.clear();
    marker = cm.markText(CodeMirror.Pos(fromTo.getFrom().getLine()), CodeMirror.Pos(fromTo.getTo().getLine() - NUM_ROWS_TO_EXPAND), Configuration.getReplaceConfig(getElement()));
    updateSkipNum();
}
#method_after
private void expandAfter() {
    FromTo fromTo = marker.find();
    marker.clear();
    int oldEnd = fromTo.getTo().getLine();
    int newEnd = oldEnd - NUM_ROWS_TO_EXPAND;
    marker = cm.markText(CodeMirror.pos(fromTo.getFrom().getLine()), CodeMirror.pos(newEnd), COLLAPSED);
    updateSkipNum();
    hiddenSkipMap.remove(cm.getLineHandle(oldEnd));
    hiddenSkipMap.put(cm.getLineHandle(newEnd), numSkipLines);
}
#end_block

#method_before
public final void addLineClass(int line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void addLineClass(LineHandle line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#end_block

#method_before
@Test
public void testSimpleAdvance() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0), iter.advance(1));
}
#method_after
@Test
public void testSimpleAdvance() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0, 1), iter.advance(1));
}
#end_block

#method_before
@Test
public void testEndsBeforeNewline() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0), iter.advance(3));
}
#method_after
@Test
public void testEndsBeforeNewline() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0, 3), iter.advance(3));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    CommentApi.comments(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            published = m.get(path);
        }
    }));
    CommentApi.drafts(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            drafts = m.get(path);
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Project.NameKey project = result.project_name_key();
            ConfigInfoCache.get(project, group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(CodeMirrorDemo.this) {

                @Override
                protected void preDisplay(ConfigInfoCache.Entry result) {
                    commentLinkProcessor = result.getCommentLinkProcessor();
                    setTheme(result.getTheme());
                    DiffInfo diffInfo = diff;
                    diff = null;
                    display(diffInfo);
                }
            }));
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    CommentApi.comments(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            published = m.get(path);
        }
    }));
    if (Gerrit.isSignedIn()) {
        CommentApi.drafts(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                drafts = m.get(path);
            }
        }));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ChangeApi.detail(revision.getParentKey().get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Project.NameKey project = result.project_name_key();
            ConfigInfoCache.get(project, group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(CodeMirrorDemo.this) {

                @Override
                protected void preDisplay(ConfigInfoCache.Entry result) {
                    commentLinkProcessor = result.getCommentLinkProcessor();
                    setTheme(result.getTheme());
                    DiffInfo diffInfo = diff;
                    diff = null;
                    display(diffInfo);
                }
            }));
        }
    });
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            for (Runnable r : resizeCallbacks) {
                r.run();
            }
            resizeCallbacks = null;
        }
    });
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    for (CommentBox box : initialBoxes) {
        box.resizePaddingWidget();
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    skips = new ArrayList<SkippedLine>();
    render(diffInfo);
    renderSkips();
    skips = null;
    resizeCallbacks = new ArrayList<Runnable>();
    renderComments(published, false);
    renderComments(drafts, true);
    published = null;
    drafts = null;
    mapper = null;
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    skips = new ArrayList<SkippedLine>();
    render(diffInfo);
    initialBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    if (Gerrit.isSignedIn()) {
        cmA.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmA)));
        cmB.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmB)));
    }
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    int context = pref == null ? DFLT_CONTEXT : pref.getContext();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            colorLines(cmA, origLineA, aLength);
            colorLines(cmB, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private void renderSkips() {
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    hiddenSkipMap = new HashMap<LineHandle, Integer>();
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int start = cm == cmA ? skip.getStartA() : skip.getStartB();
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.Pos(start), CodeMirror.Pos(start + size), Configuration.getReplaceConfig(bar.getElement()));
    bar.setMarker(marker, size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    hiddenSkipMap.put(cm.getLineHandle(markEnd), size);
    SkipBar bar = new SkipBar(cm, hiddenSkipMap);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), Configuration.create().set("collapsed", true));
    /**
     * TODO: Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely. The current approach leaves an empty line
     * with line number "1" still showing, and CodeMirror doesn't like manually
     * setting the display of a line to "none". A workaround may be to use
     * inline widget for the first line and regular line widgets for others.
     */
    boolean isZero = markStart == -1;
    Configuration config = Configuration.create().set("coverGutter", true).set("above", isZero);
    LineWidget widget = cm.addLineWidget(isZero ? markEnd + 1 : markStart, bar.getElement(), config);
    bar.setWidget(widget);
    bar.setMarker(marker, size);
    return bar;
}
#end_block

#method_before
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    Configuration editOpt = Configuration.create().set("className", diffTable.style.intraline()).set("readOnly", true);
    LineCharacter last = CodeMirror.Pos(0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, diffOpt);
        } else {
            cm.markText(CodeMirror.Pos(fromLine), from, diffOpt);
        }
        cm.markText(from, to, editOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.intraline());
        }
    }
}
#method_after
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#end_block

#method_before
private void colorLines(CodeMirror cm, int line, int cnt) {
    for (int i = 0; i < cnt; i++) {
        cm.addLineClass(line + i, LineClassWhere.WRAP, diffTable.style.diff());
    }
}
#method_after
private void colorLines(CodeMirror cm, String color, int line, int cnt) {
    for (int i = 0; i < cnt; i++) {
        cm.addLineClass(line + i, LineClassWhere.WRAP, color);
    }
}
#end_block

#method_before
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM);
}
#method_after
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#end_block

#method_before
private Element addPaddingWidget(CodeMirror cm, String style, int line, int height, Unit unit) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return div;
}
#method_after
private LineWidgetElementPair addPaddingWidget(CodeMirror cm, String style, int line, int height, Unit unit, Integer index) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    if (index != null) {
        config = config.set("insertAt", index);
    }
    LineWidget widget = cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return new LineWidgetElementPair(widget, div);
}
#end_block

#method_before
LineCharacter advance(int numOfChar) {
    while (currLineIndex < lines.length()) {
        int lengthWithNewline = lines.get(currLineIndex).length() - currLineOffset + 1;
        if (numOfChar < lengthWithNewline) {
            LineCharacter at = CodeMirror.Pos(startLine + currLineIndex, numOfChar + currLineOffset);
            currLineOffset += numOfChar;
            return at;
        }
        numOfChar -= lengthWithNewline;
        advanceLine();
    }
    throw new IllegalStateException("EditIterator index out of bound");
}
#method_after
LineCharacter advance(int numOfChar) {
    while (currLineIndex < lines.length()) {
        int lengthWithNewline = lines.get(currLineIndex).length() - currLineOffset + 1;
        if (numOfChar < lengthWithNewline) {
            LineCharacter at = LineCharacter.create(startLine + currLineIndex, numOfChar + currLineOffset);
            currLineOffset += numOfChar;
            return at;
        }
        numOfChar -= lengthWithNewline;
        advanceLine();
        if (numOfChar == 0) {
            return LineCharacter.create(startLine + currLineIndex, 0);
        }
    }
    throw new IllegalStateException("EditIterator index out of bound");
}
#end_block

#method_before
@Override
public void onUnload() {
    super.onUnload();
    if (messageClick != null) {
        messageClick.removeHandler();
        messageClick = null;
    }
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    if (messageClick != null) {
        messageClick.removeHandler();
        messageClick = null;
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    headerClick = header.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setOpen(!isOpen());
            if (clickCallback != null) {
                clickCallback.run();
            }
        }
    }, ClickEvent.getType());
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    headerClick = header.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setOpen(!isOpen());
            if (clickCallback != null) {
                clickCallback.run();
            }
        }
    }, ClickEvent.getType());
    res.style().ensureInjected();
}
#end_block

#method_before
private void setOpen(boolean open) {
    if (open) {
        removeStyleName(style.close());
        addStyleName(style.open());
    } else {
        removeStyleName(style.open());
        addStyleName(style.close());
    }
}
#method_after
private void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
}
#end_block

#method_before
private boolean isOpen() {
    return getStyleName().contains(style.open());
}
#method_after
private boolean isOpen() {
    return getStyleName().contains(res.style().open());
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.getChange().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.getChange().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void deleteAll() throws IOException {
    try {
        openIndex.deleteByQuery("*:*");
        closedIndex.deleteByQuery("*:*");
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void deleteAll() throws IOException {
    try {
        openIndex.deleteByQuery("*:*");
        closedIndex.deleteByQuery("*:*");
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SolrServer> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, toQuery(p));
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SolrServer> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, QueryBuilder.toQuery(p));
}
#end_block

#method_before
private void commit(SolrServer server) throws IOException {
    try {
        server.commit();
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
private void commit(SolrServer server) throws IOException {
    try {
        server.commit();
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = null;
        SolrDocumentList docs = new SolrDocumentList();
        query.setParam("shards.tolerant", true);
        for (SolrServer index : indexes) {
            QueryResponse rsp = index.query(query);
            docs.addAll(rsp.getResults());
        }
        result = Lists.newArrayListWithCapacity(docs.size());
        for (SolrDocument doc : docs) {
            Integer v = (Integer) doc.getFieldValue(FIELD_CHANGE);
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = null;
        SolrDocumentList docs = new SolrDocumentList();
        query.setParam("shards.tolerant", true);
        for (SolrServer index : indexes) {
            QueryResponse rsp = index.query(query);
            docs.addAll(rsp.getResults());
        }
        result = Lists.newArrayListWithCapacity(docs.size());
        for (SolrDocument doc : docs) {
            Integer v = (Integer) doc.getFieldValue(FIELD_CHANGE);
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (SolrServerException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
public static IndexImplementation getChangeIndexImpl(Injector injector) {
    if (isEnabled(injector)) {
        Config config = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String implementation = config.getString("index", null, "implementation");
        if ("solr".equals(implementation)) {
            return IndexImplementation.SOLR;
        } else {
            return IndexImplementation.LUCENE;
        }
    }
    return IndexImplementation.NONE;
}
#method_after
public static IndexType getChangeIndexImpl(Injector injector) {
    if (isEnabled(injector)) {
        Config config = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        return config.getEnum("index", null, "type", IndexType.LUCENE);
    }
    return IndexType.NONE;
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(cfgInjector));
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = cfgInjector.getInstance(SolrIndexModule.class);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    install(new IndexModule(threads));
    bind(String.class).annotatedWith(Names.named("url")).toInstance(url);
    bind(ChangeIndex.class).to(SolrChangeIndex.class);
    listener().to(SolrChangeIndex.class);
    if (checkVersion) {
        listener().to(SolrIndexVersionCheck.class);
    }
}
#method_after
@Override
protected void configure() {
    install(new IndexModule(threads));
    bind(String.class).annotatedWith(SolrIndexUrl.class).toInstance(url);
    bind(ChangeIndex.class).to(SolrChangeIndex.class);
    listener().to(SolrChangeIndex.class);
    if (checkVersion) {
        listener().to(IndexVersionCheck.class);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any LuceneChangeIndex may be created.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    // Delete before any LuceneChangeIndex may be created.
    deleteAll();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(false, threads, dryRun);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(dbInjector), false, threads);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(false, threads, dryRun);
            break;
        case SOLR:
            Config config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
            changeIndexModule = new SolrIndexModule(config, false, threads);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private void writeVersion() throws IOException, ConfigInvalidException {
    if (dryRun) {
        return;
    }
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            LuceneIndexVersionCheck.writeVersion(sitePaths);
            break;
        case SOLR:
            SolrIndexVersionCheck.writeVersion(sitePaths);
            break;
        default:
            return;
    }
}
#method_after
private void writeVersion() throws IOException, ConfigInvalidException {
    if (dryRun) {
        return;
    }
    ChangeIndex index = sysInjector.getInstance(ChangeIndex.class);
    index.finishIndex();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(cfgInjector));
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = cfgInjector.getInstance(SolrIndexModule.class);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, toQuery(p));
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, QueryBuilder.toQuery(p));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return QueryBuilder.intTerm(FIELD_CHANGE, cd.getId().get());
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw QueryBuilder.badFieldType(f.getType());
    }
}
#end_block

#method_before
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    try {
                        cd.setCurrentFilePaths(paths);
                        indexer.indexTask(cd).call();
                        done.update(1);
                        if (verbose) {
                            System.out.println("Reindexed change " + cd.getId());
                        }
                    } catch (Exception e) {
                        log.warn("Failed to index change " + cd.getId(), e);
                        if (verbose) {
                            System.out.println("Failed to index change " + cd.getId());
                        }
                        failed.update(1);
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        if (verbose) {
            System.out.println("Failed to index changes for commit " + bCommit.name());
        }
        failed.update(1);
    }
}
#method_after
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                    if (verbose) {
                        System.out.println("Reindexed change " + cd.getId());
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        fail("Failed to index commit " + bCommit.name(), e);
    }
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        return object.commitMessage(repoManager, db).contains(value);
    } catch (IOException e) {
        return false;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        for (ChangeData cData : index.getSource(Predicate.and(new LegacyChangeIdPredicate(db, object.getId()), this)).read()) {
            if (cData.getId().equals(object.getId())) {
                return true;
            }
        }
    } catch (QueryParseException e) {
        throw new OrmException(e);
    }
    return false;
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.insert(doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.insert(doc));
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.replace(id, doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.replace(id, doc));
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    return allOf(openIndex.delete(id), closedIndex.delete(id));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return intTerm(ID_FIELD, cd.getId().get());
}
#end_block

#method_before
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#method_after
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        if (p.getChild(0) instanceof TimestampRangePredicate) {
            return notTimestampQuery((TimestampRangePredicate<ChangeData>) p.getChild(0));
        }
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.TIMESTAMP) {
        return timestampQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.PREFIX) {
        return prefixQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else if (p instanceof SortKeyPredicate) {
        return sortKeyQuery((SortKeyPredicate) p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getOperator(), value));
}
#method_after
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getField().getName(), value));
}
#end_block

#method_before
private Query exactQuery(IndexPredicate<ChangeData> p) {
    return new TermQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query exactQuery(IndexPredicate<ChangeData> p) {
    if (p instanceof RegexPredicate<?>) {
        return regexQuery(p);
    } else {
        return new TermQuery(new Term(p.getField().getName(), p.getValue()));
    }
}
#end_block

#method_before
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getField().getName(), p.getValue()));
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    Sort sort = new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.INT, true));
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT, sort);
        }
        TopDocs docs = TopDocs.merge(sort, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc, FIELDS);
            Number v = doc.getField(ID_FIELD).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                Object val = f.get(cd, fillArgs);
                if (val != null) {
                    add(result, f, Collections.singleton(val));
                }
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    String name = f.getName();
    Store store = store(f);
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (f.getType() == FieldType.LONG) {
        for (Object value : values) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (f.getType() == FieldType.TIMESTAMP) {
        for (Object v : values) {
            doc.add(new IntField(name, toIndexTime((Timestamp) v), store));
        }
    } else if (f.getType() == FieldType.EXACT || f.getType() == FieldType.PREFIX) {
        for (Object value : values) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch) {
    if (!running) {
        log.warn("Replication plugin did not finish startup before event");
        return;
    }
    for (Destination cfg : configs) {
        for (URIish uri : cfg.getURIs(project, urlMatch)) {
            cfg.schedule(project, PushOne.ALL_REFS, uri);
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch) {
    if (!running) {
        log.warn("Replication plugin did not finish startup before event");
        return;
    }
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri);
            }
        }
    }
}
#end_block

#method_before
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, internalUserFactory, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    if (projectMatch != null) {
        if (projectMatch.endsWith("/*")) {
            // special case
            return project.get().startsWith(projectMatch.substring(0, projectMatch.length() - 1));
        } else {
            String projectPattern;
            if (isRE(projectMatch)) {
                projectPattern = projectMatch.substring(1);
            } else {
                projectPattern = projectMatch;
            }
            return (new RegExp(projectPattern)).toAutomaton().run(project.get());
        }
    }
    return true;
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return new RegexBranchPredicate(args.dbProvider, name);
    return new BranchPredicate(args.dbProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return ref("^" + branchToRef(name.substring(1)));
    return ref(branchToRef(name));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (!allowsFile) {
        throw error("operator not permitted here: file:" + file);
    }
    if (file.startsWith("^")) {
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    String[] splitReviewer = name.split("~");
    name = splitReviewer[0];
    if (splitReviewer.length > 2) {
        throw new QueryParseException("more than one user specified");
    } else if (splitReviewer.length == 2) {
        accounts = parseAccount(splitReviewer[1]);
    }
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, name, accounts);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.dbProvider, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id)));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
public Builder copyFrom(GitilesView other) {
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
            path = other.path;
        // Fallthrough.
        case REVISION:
        case TAR:
        case ZIP:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    // Don't copy params.
    return this;
}
#method_after
public Builder copyFrom(GitilesView other) {
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
            path = other.path;
        // Fallthrough.
        case REVISION:
        case ARCHIVE:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    if (type == Type.ARCHIVE) {
        extension = other.extension;
    }
    // Don't copy params.
    return this;
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            this.oldRevision = checkNotNull(revision);
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set old revision on %s view", type));
    }
}
#method_after
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            this.oldRevision = revision;
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set old revision on %s view", type));
    }
}
#end_block

#method_before
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case TAR:
        case ZIP:
            checkArchive();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, params, anchor);
}
#method_after
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case ARCHIVE:
            checkArchive();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, extension, params, anchor);
}
#end_block

#method_before
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case TAR:
            url.append(repositoryName).append("/+tar/").append(revision.getName());
            break;
        case ZIP:
            url.append(repositoryName).append("/+zip/").append(revision.getName());
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url.toString();
}
#method_after
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case ARCHIVE:
            url.append(repositoryName).append("/+archive/").append(revision.getName()).append(Objects.firstNonNull(extension, DEFAULT_ARCHIVE_EXTENSION));
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url.toString();
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    Repository repo = ServletUtils.getRepository(req);
    // Check object type before starting the archive. If we just caught the
    // exception from cmd.call() below, we wouldn't know whether it was because
    // the input object is not a tree or something broke later.
    RevWalk walk = new RevWalk(repo);
    try {
        walk.parseTree(rev.getId());
    } catch (IncorrectObjectTypeException e) {
        res.sendError(SC_NOT_FOUND);
        return;
    } finally {
        walk.release();
    }
    String filename = getFilename(view, rev);
    setRawHeaders(req, res, filename, format.mimeType);
    res.setStatus(SC_OK);
    try {
        new ArchiveCommand(repo).setFormat(format.name).setTree(rev.getId()).setOutputStream(res.getOutputStream()).call();
    } catch (GitAPIException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    Repository repo = ServletUtils.getRepository(req);
    // Check object type before starting the archive. If we just caught the
    // exception from cmd.call() below, we wouldn't know whether it was because
    // the input object is not a tree or something broke later.
    RevWalk walk = new RevWalk(repo);
    try {
        walk.parseTree(rev.getId());
    } catch (IncorrectObjectTypeException e) {
        res.sendError(SC_NOT_FOUND);
        return;
    } finally {
        walk.release();
    }
    Format format = FORMATS_BY_EXTENSION.get(view.getExtension());
    String filename = getFilename(view, rev, view.getExtension());
    setDownloadHeaders(req, res, filename, format.mimeType);
    res.setStatus(SC_OK);
    try {
        new ArchiveCommand(repo).setFormat(format.name()).setTree(rev.getId()).setOutputStream(res.getOutputStream()).call();
    } catch (GitAPIException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private String getFilename(GitilesView view, Revision rev) {
    return new StringBuilder().append(view.getRepositoryName().replace('/', '-')).append('-').append(rev.getName()).append(format.format.suffixes().iterator().next()).toString();
}
#method_after
private String getFilename(GitilesView view, Revision rev, String ext) {
    return new StringBuilder().append(Paths.basename(view.getRepositoryName())).append('-').append(rev.getName()).append(ext).toString();
}
#end_block

#method_before
public void testPath() throws Exception {
    RevCommit master = repo.branch("refs/heads/master").commit().create();
    GitilesView view;
    view = getView("/repo/+show/master/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("", view.getPathPart());
    view = getView("/repo/+show/master/foo");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/bar");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo/bar", view.getPathPart());
}
#method_after
public void testPath() throws Exception {
    RevCommit master = repo.branch("refs/heads/master").commit().create();
    repo.branch("refs/heads/stable").commit().create();
    GitilesView view;
    view = getView("/repo/+show/master/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("", view.getPathPart());
    view = getView("/repo/+show/master/foo");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/bar");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo/bar", view.getPathPart());
    assertNull(getView("/repo/+show/stable..master/foo"));
}
#end_block

#method_before
static String trimLeadingSlash(String str) {
    checkArgument(str.startsWith("/"), "expected string starting with a slash: %s", str);
    return str.substring(1);
}
#method_after
static String trimLeadingSlash(String str) {
    return checkLeadingSlash(str).substring(1);
}
#end_block

#method_before
private GitilesView.Builder parse(HttpServletRequest req) throws IOException {
    String repoName = trimLeadingSlash(getRegexGroup(req, 1));
    String command = getRegexGroup(req, 2);
    String path = getRegexGroup(req, 3);
    boolean emptyPath = (path.isEmpty() || path.equals("/"));
    // Non-path cases.
    if (repoName.isEmpty()) {
        return GitilesView.hostIndex();
    } else if (command.equals(CMD_REFS)) {
        return GitilesView.refs().setRepositoryName(repoName).setPathPart(path);
    } else if (command.equals(CMD_LOG) && emptyPath) {
        return GitilesView.log().setRepositoryName(repoName);
    } else if (command.equals(CMD_DESCRIBE) && !emptyPath) {
        return GitilesView.describe().setRepositoryName(repoName).setPathPart(path);
    } else if (command.isEmpty()) {
        return GitilesView.repositoryIndex().setRepositoryName(repoName);
    } else if (path.isEmpty()) {
        // Command that requires a path, but no path.
        return null;
    }
    path = trimLeadingSlash(path);
    RevisionParser revParser = new RevisionParser(ServletUtils.getRepository(req), accessFactory.forRequest(req), visibilityCache);
    RevisionParser.Result result = revParser.parse(path);
    if (result == null) {
        return null;
    }
    path = path.substring(result.getPathStart());
    command = getCommand(command, result, path);
    GitilesView.Builder view;
    if (CMD_LOG.equals(command)) {
        view = GitilesView.log().setPathPart(path);
    } else if (CMD_SHOW.equals(command)) {
        if (path.isEmpty()) {
            view = GitilesView.revision();
        } else {
            view = GitilesView.path().setPathPart(path);
        }
    } else if (CMD_DIFF.equals(command)) {
        view = GitilesView.diff().setPathPart(path);
    } else if (CMD_REFS.equals(command)) {
        view = GitilesView.repositoryIndex();
    } else if (command.equals(CMD_TAR)) {
        view = GitilesView.tar();
    } else if (command.equals(CMD_ZIP)) {
        view = GitilesView.zip();
    } else {
        // Bad command.
        return null;
    }
    if (result.getOldRevision() != null) {
        // May be NULL.
        view.setOldRevision(result.getOldRevision());
    }
    view.setRepositoryName(repoName).setRevision(result.getRevision());
    return view;
}
#method_after
private GitilesView.Builder parse(HttpServletRequest req) throws IOException {
    String repoName = trimLeadingSlash(getRegexGroup(req, 1));
    if (repoName.isEmpty()) {
        return GitilesView.hostIndex();
    }
    String command = getRegexGroup(req, 2);
    String path = getRegexGroup(req, 3);
    if (command.isEmpty()) {
        return parseNoCommand(req, repoName, path);
    } else if (command.equals(CMD_ARCHIVE)) {
        return parseArchiveCommand(req, repoName, path);
    } else if (command.equals(CMD_AUTO)) {
        return parseAutoCommand(req, repoName, path);
    } else if (command.equals(CMD_DESCRIBE)) {
        return parseDescribeCommand(req, repoName, path);
    } else if (command.equals(CMD_DIFF)) {
        return parseDiffCommand(req, repoName, path);
    } else if (command.equals(CMD_LOG)) {
        return parseLogCommand(req, repoName, path);
    } else if (command.equals(CMD_REFS)) {
        return parseRefsCommand(req, repoName, path);
    } else if (command.equals(CMD_SHOW)) {
        return parseShowCommand(req, repoName, path);
    } else {
        return null;
    }
}
#end_block

#method_before
public synchronized BaseServlet getDefaultHandler(GitilesView.Type view) {
    checkNotInitialized();
    switch(view) {
        case HOST_INDEX:
            return new HostIndexServlet(renderer, urls, accessFactory);
        case REPOSITORY_INDEX:
            return new RepositoryIndexServlet(renderer, accessFactory, timeCache);
        case REFS:
            return new RefServlet(renderer, timeCache);
        case REVISION:
            return new RevisionServlet(renderer, linkifier());
        case PATH:
            return new PathServlet(renderer, urls);
        case DIFF:
            return new DiffServlet(renderer, linkifier());
        case LOG:
            return new LogServlet(renderer, linkifier());
        case DESCRIBE:
            return new DescribeServlet();
        case TAR:
            return new ArchiveServlet(ArchiveServlet.Format.TGZ);
        case ZIP:
            return new ArchiveServlet(ArchiveServlet.Format.ZIP);
        default:
            throw new IllegalArgumentException("Invalid view type: " + view);
    }
}
#method_after
public synchronized BaseServlet getDefaultHandler(GitilesView.Type view) {
    checkNotInitialized();
    switch(view) {
        case HOST_INDEX:
            return new HostIndexServlet(renderer, urls, accessFactory);
        case REPOSITORY_INDEX:
            return new RepositoryIndexServlet(renderer, accessFactory, timeCache);
        case REFS:
            return new RefServlet(renderer, timeCache);
        case REVISION:
            return new RevisionServlet(renderer, linkifier());
        case PATH:
            return new PathServlet(renderer, urls);
        case DIFF:
            return new DiffServlet(renderer, linkifier());
        case LOG:
            return new LogServlet(renderer, linkifier());
        case DESCRIBE:
            return new DescribeServlet();
        case ARCHIVE:
            return new ArchiveServlet();
        default:
            throw new IllegalArgumentException("Invalid view type: " + view);
    }
}
#end_block

#method_before
private Query exactQuery(IndexPredicate<ChangeData> p) {
    return new TermQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query exactQuery(IndexPredicate<ChangeData> p) {
    if (p instanceof RegexPredicate<?>) {
        return regexQuery(p);
    } else {
        return new TermQuery(new Term(p.getOperator(), p.getValue()));
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    for (AccountGroup.Id groupId : groups) {
        GroupResource resource = toResource(groupId);
        if (!accountsToRemove.isEmpty()) {
            deleteMembers.apply(resource, fromMembers(accountsToRemove));
        }
        if (!groupsToRemove.isEmpty()) {
            deleteIncludedGroups.apply(resource, fromGroups(groupsToRemove));
        }
        if (!accountsToAdd.isEmpty()) {
            reportMembersAdded(resource.getName(), addMembers.apply(resource, fromMembers(accountsToAdd)));
        }
        if (!groupsToInclude.isEmpty()) {
            reportGroupsAdded(resource.getName(), addIncludedGroups.apply(resource, fromGroups(groupsToInclude)));
        }
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    for (AccountGroup.UUID groupUuid : groups) {
        GroupResource resource = groupsCollection.parse(TopLevelResource.INSTANCE, IdString.fromUrl(groupUuid.get()));
        if (!accountsToRemove.isEmpty()) {
            deleteMembers.get().apply(resource, fromMembers(accountsToRemove));
            reportMembersAction("removed from", resource, accountsToRemove);
        }
        if (!groupsToRemove.isEmpty()) {
            deleteIncludedGroups.get().apply(resource, fromGroups(groupsToRemove));
            reportGroupsAction("excluded from", resource, groupsToRemove);
        }
        if (!accountsToAdd.isEmpty()) {
            addMembers.get().apply(resource, fromMembers(accountsToAdd));
            reportMembersAction("added to", resource, accountsToAdd);
        }
        if (!groupsToInclude.isEmpty()) {
            addIncludedGroups.get().apply(resource, fromGroups(groupsToInclude));
            reportGroupsAction("included to", resource, groupsToInclude);
        }
    }
}
#end_block

#method_before
private AddIncludedGroups.Input fromGroups(List<AccountGroup.Id> accounts) {
    return AddIncludedGroups.Input.fromGroups(Lists.newArrayList(Iterables.transform(accounts, new Function<AccountGroup.Id, String>() {

        @Override
        public String apply(AccountGroup.Id id) {
            return id.toString();
        }
    })));
}
#method_after
private AddIncludedGroups.Input fromGroups(List<AccountGroup.UUID> accounts) {
    return AddIncludedGroups.Input.fromGroups(Lists.newArrayList(Iterables.transform(accounts, new Function<AccountGroup.UUID, String>() {

        @Override
        public String apply(AccountGroup.UUID uuid) {
            return uuid.toString();
        }
    })));
}
#end_block

#method_before
protected int getInsertRow(Comparator<RowItem> comparator, RowItem item) {
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        RowItem i = getRowItem(middle);
        int cmp = comparator.compare(i, item);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return -1;
        }
    }
    return left;
}
#method_after
protected int getInsertRow(Comparator<RowItem> comparator, RowItem item) {
    int row = lookupRowItem(comparator, item);
    if (row >= table.getRowCount() || comparator.compare(item, getRowItem(row)) != 0) {
        return row;
    }
    return -1;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new BecomeAnyAccountModule());
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, uiOptions));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    install(new CmdLineParserModule());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#end_block

#method_before
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
}
#end_block

#method_before
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null);
    user = null;
}
#method_after
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null, null);
    user = null;
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    try {
        int status = SC_OK;
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        Multimap<String, String> params = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        Object result;
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        handleException(e, req, res);
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req, rsrc);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, r);
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (UnprocessableEntityException e) {
        replyError(res, status = 422, Objects.firstNonNull(e.getMessage(), "Unprocessable Entity"));
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (MalformedJsonException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            json.setLenient(true);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if (("PUT".equals(req.getMethod()) || "POST".equals(req.getMethod())) && acceptsRawInput(type)) {
        return parseRawInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder();
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, Splitter.on(',').omitEmptyStrings().trimResults().split(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = NAMING.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#method_after
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, OptionUtil.splitOptionValue(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = // 
                        FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#end_block

#method_before
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.isBase64()) {
            bin = stackBase64(res, bin);
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        OutputStream dst = res.getOutputStream();
        try {
            bin.writeTo(dst);
        } finally {
            dst.close();
        }
    } finally {
        appResult.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#method_after
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method. In order to authenticate, prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#end_block

#method_before
static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    replyText(null, res, msg);
}
#method_after
public static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    CacheHeaders.setNotCacheable(res);
    replyText(null, res, msg);
}
#end_block

#method_before
public static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static TemporaryBuffer.Heap compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.finish();
    gz.flush();
    return buf;
}
#method_after
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.close();
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser user = session.get().getCurrentUser();
        if (!user.getCapabilities().canAdministrateServer()) {
            error(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            error(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            error(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            RestApiServlet.replyError((HttpServletResponse) res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#end_block

#method_before
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    final String ref = receiveEvent.command.getRefName();
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(ref).matches() || ReceiveCommits.NEW_PATCHSET.matcher(ref).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, labelTypes, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, labelTypes, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        // TODO: Handle empty contents
        return null;
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setWidth("100%");
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setWidth("100%");
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            padLines(cmA, delta, lineA - 1);
            lineB = colorLine(delta, lineA, lineB, true);
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            padLines(cmB, delta, lineB - 1);
            lineA = colorLine(delta, lineA, lineB, false);
        } else {
            lineA = colorLine(current.a().length(), lineA, lineB, false);
            lineB = colorLine(current.b().length(), lineA, lineB, true);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            insertEmptyLines(cmA, lineA, delta);
            lineB = colorLines(cmB, lineB, delta);
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            insertEmptyLines(cmB, lineB, delta);
            lineA = colorLines(cmA, lineA, delta);
        } else {
            // TODO: Implement intraline
            int aLength = current.a().length();
            int bLength = current.b().length();
            lineA = colorLines(cmA, lineA, aLength);
            lineB = colorLines(cmB, lineB, bLength);
            if (aLength < bLength) {
                insertEmptyLines(cmA, lineA, bLength - aLength);
            } else if (aLength > bLength) {
                insertEmptyLines(cmB, lineB, aLength - bLength);
            }
        }
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^")) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^") && args.index != ChangeIndex.DISABLED) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    Provider<ReviewDb> dbProvider = Providers.of(db);
    PatchListCache plc = sysInjector.getInstance(PatchListCache.class);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    index.getWriter().deleteAll();
    int i = 0;
    for (Change change : db.changes().all()) {
        ChangeData cd = new ChangeData(change);
        cd.fillIndexFields(dbProvider, plc);
        index.insert(cd);
        i++;
    }
    index.getWriter().commit();
    System.out.println("Reindexed " + i + " changes");
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!LuceneIndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    sitePaths = dbInjector.getInstance(SitePaths.class);
    deleteAll();
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    dbRef.set(db);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    Stopwatch sw = new Stopwatch().start();
    int i = 0;
    for (Change change : db.changes().all()) {
        index.insert(new ChangeData(change));
        i++;
    }
    index.getWriter().commit();
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Reindexed %d changes in %.02fms", i, elapsed);
    manager.stop();
    return 0;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new LifecycleModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(new LuceneIndexModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            bind(ReviewDb.class).toProvider(new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    return dbRef.get();
                }
            });
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    switch(p.getType()) {
        case INTEGER:
            return intQuery(p);
        case EXACT_REPEATABLE:
            return exactQuery(p);
        default:
            throw badFieldType(p.getType());
    }
}
#method_after
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    cd.checkIndexFields();
    org.apache.lucene.document.Document result = new Document();
    for (ChangeField f : ChangeField.values()) {
        switch(f.getType()) {
            case INTEGER:
                result.add(new IntField(f.getName(), (Integer) f.get(cd), store(f)));
                break;
            case EXACT_REPEATABLE:
                // Type checked in ChangeField.
                @SuppressWarnings("unchecked")
                Iterable<String> values = (Iterable<String>) f.get(cd);
                for (String value : values) {
                    result.add(new StringField(f.getName(), value, store(f)));
                }
                break;
        }
    }
    return result;
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private Field.Store store(ChangeField f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#method_after
private static Field.Store store(FieldDef<?, ?> f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#end_block

#method_before
private static IllegalArgumentException badFieldType(FieldType t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#method_after
private static IllegalArgumentException badFieldType(FieldType<?> t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
public FieldType getType() {
    return type;
}
#method_after
public FieldType<?> getType() {
    return def.getType();
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        workQueue.getDefaultQueue().submit(indexerFactory.create(change));
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        indexer.index(change);
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(changeIndexerFactory.create(change)));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ins.setReviewers(recipients.getReviewers()).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void addPadding(int line, CodeMirror cm) {
    Element div = DOM.createDiv();
    div.setAttribute("style", "background-color: #E6E6E6");
    div.appendChild(DOM.createElement("br"));
    cm.addLineWidget(line, div, null);
}
#method_after
private void addPadding(CodeMirror cm, int line) {
    Element div = DOM.createDiv();
    div.setClassName(diffTable.style.padding());
    cm.addLineWidget(line, div, null);
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    Configuration insertOpt = Configuration.create().set("className", "insert").set("readOnly", "true");
    Configuration deleteOpt = Configuration.create().set("className", "delete").set("readOnly", "true");
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            for (int j = 0; j < delta; j++) {
                addPadding(lineA - 1, cmA);
            }
            for (int j = 0; j < delta; j++) {
                cmB.addLineClass(lineB, "wrap", "insert");
                LineCharacter from = LineCharacter.create(lineB, 0).setLine(lineB).setCh(0);
                cmB.markText(from, from, insertOpt);
                lineB++;
            }
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            for (int j = 0; j < delta; j++) {
                addPadding(lineB - 1, cmB);
            }
            for (int j = 0; j < delta; j++) {
                cmA.addLineClass(lineA, "wrap", "delete");
                LineCharacter from = LineCharacter.create(lineA, 0).setLine(lineA).setCh(0);
                cmA.markText(from, from, deleteOpt);
                lineA++;
            }
        } else {
            // TODO: Handle intraline edit.
            lineA += current.a().length();
            lineB += current.a().length();
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    Configuration insertOpt = Configuration.create().set("className", diffTable.style.insert()).set("readOnly", true);
    Configuration deleteOpt = Configuration.create().set("className", diffTable.style.delete()).set("readOnly", true);
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            for (int j = 0; j < delta; j++) {
                addPadding(cmA, lineA - 1);
            }
            for (int j = 0; j < delta; j++) {
                cmB.addLineClass(lineB, LineClassWhere.WRAP, diffTable.style.insert());
                LineCharacter from = LineCharacter.create(lineB, 0);
                cmB.markText(from, from, insertOpt);
                lineB++;
            }
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            for (int j = 0; j < delta; j++) {
                addPadding(cmB, lineB - 1);
            }
            for (int j = 0; j < delta; j++) {
                cmA.addLineClass(lineA, LineClassWhere.WRAP, diffTable.style.delete());
                LineCharacter from = LineCharacter.create(lineA, 0);
                cmA.markText(from, from, deleteOpt);
                lineA++;
            }
        } else {
            // TODO: Handle intraline edit.
            lineA += current.a().length();
            lineB += current.a().length();
        }
    }
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, OrmException {
    Account a = dbProvider.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("No such account: " + rsrc.getUser().getAccountId());
    }
    if (a.isActive()) {
        return Response.ok("");
    }
    a.setActive(true);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Response.created("");
}
#method_after
@Override
public Object apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, OrmException {
    Account a = dbProvider.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (a.isActive()) {
        return Response.ok("");
    }
    a.setActive(true);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Response.created("");
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "state").to(GetState.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    put(ACCOUNT_KIND, "inactive").to(PutInactive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#end_block

#method_before
public void display(final ChangeDetail detail, final PatchSet.Id diffBaseId) {
    clear();
    final PatchSet currps = detail.getCurrentPatchSet();
    currentPatchSetId = currps.getId();
    patchSets = detail.getPatchSets();
    if (Gerrit.isSignedIn()) {
        final AccountGeneralPreferences p = Gerrit.getUserAccount().getGeneralPreferences();
        if (p.isReversePatchSetOrder()) {
            Collections.reverse(patchSets);
        }
    }
    patchSetPanelsList = new ArrayList<PatchSetComplexDisclosurePanel>();
    for (final PatchSet ps : patchSets) {
        final PatchSetComplexDisclosurePanel p = new PatchSetComplexDisclosurePanel(ps, ps == currps, detail.getPatchSetsWithDraftComments().contains(ps.getId()));
        if (diffBaseId != null) {
            p.setDiffBaseId(diffBaseId);
            if (ps == currps) {
                p.refresh();
            }
        }
        add(p);
        patchSetPanelsList.add(p);
    }
}
#method_after
public void display(final ChangeDetail detail, final PatchSet.Id diffBaseId) {
    clear();
    final PatchSet currps = detail.getCurrentPatchSet();
    currentPatchSetId = currps.getId();
    patchSets = detail.getPatchSets();
    if (Gerrit.isSignedIn()) {
        final AccountGeneralPreferences p = Gerrit.getUserAccount().getGeneralPreferences();
        if (p.isReversePatchSetOrder()) {
            Collections.reverse(patchSets);
        }
    }
    patchSetPanelsList = new ArrayList<PatchSetComplexDisclosurePanel>();
    for (final PatchSet ps : patchSets) {
        final PatchSetComplexDisclosurePanel p = new PatchSetComplexDisclosurePanel(ps, ps == currps, detail.hasDraftComments(ps.getId()));
        if (diffBaseId != null) {
            p.setDiffBaseId(diffBaseId);
            if (ps == currps) {
                p.refresh();
            }
        }
        add(p);
        patchSetPanelsList.add(p);
    }
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    Set<PatchSet.Id> patchesWithDraftComments = new HashSet<PatchSet.Id>();
    final CurrentUser user = control.getCurrentUser();
    final Account.Id me = user instanceof IdentifiedUser ? ((IdentifiedUser) user).getAccountId() : null;
    for (PatchSet ps : source) {
        final PatchSet.Id id = ps.getId();
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
            if (me != null && db.patchComments().draftByPatchSetAuthor(id, me).iterator().hasNext()) {
                patchesWithDraftComments.add(id);
            }
        }
        patchsetsById.put(id, ps);
    }
    detail.setPatchSets(patches);
    detail.setPatchSetsWithDraftComments(patchesWithDraftComments);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    Set<PatchSet.Id> patchesWithDraftComments = new HashSet<PatchSet.Id>();
    final CurrentUser user = control.getCurrentUser();
    final Account.Id me = user instanceof IdentifiedUser ? ((IdentifiedUser) user).getAccountId() : null;
    for (PatchSet ps : source) {
        final PatchSet.Id psId = ps.getId();
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
            if (me != null && db.patchComments().draftByPatchSetAuthor(psId, me).iterator().hasNext()) {
                patchesWithDraftComments.add(psId);
            }
        }
        patchsetsById.put(psId, ps);
    }
    detail.setPatchSets(patches);
    detail.setPatchSetsWithDraftComments(patchesWithDraftComments);
}
#end_block

#method_before
public void loadActionPanel(final PatchSetDetail detail) {
    if (!patchSet.getId().equals(diffBaseId)) {
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        actionsPanel.setVisible(true);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        body.add(actionsPanel);
    }
}
#method_after
public void loadActionPanel(final PatchSetDetail detail) {
    if (!patchSet.getId().equals(diffBaseId)) {
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        actionsPanel.setVisible(true);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
                populateCommands(detail);
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        body.add(actionsPanel);
    }
}
#end_block

#method_before
public void setPatchSetsWithDraftComments(Set<PatchSet.Id> patchSetsWithDraftComments) {
    this.patchSetsWithDraftComments = patchSetsWithDraftComments;
}
#method_after
public void setPatchSetsWithDraftComments(Set<PatchSet.Id> pwdc) {
    this.patchSetsWithDraftComments = pwdc;
}
#end_block

#method_before
private static void asyncInjectCss(ExternalTextResource css) {
    try {
        css.getText(new ResourceCallback<TextResource>() {

            @Override
            public void onSuccess(TextResource resource) {
                StyleInjector.inject(resource.getText());
            }

            @Override
            public void onError(ResourceException e) {
            }
        });
    } catch (ResourceException e) {
    }
}
#method_after
private static void asyncInjectCss(ExternalTextResource css) {
    try {
        css.getText(new ResourceCallback<TextResource>() {

            @Override
            public void onSuccess(TextResource resource) {
                StyleInjector.inject(resource.getText());
            }

            @Override
            public void onError(ResourceException e) {
                error(e);
            }
        });
    } catch (ResourceException e) {
        error(e);
    }
}
#end_block

#method_before
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws OrmException {
    List<EmailInfo> emails = Lists.newArrayList();
    ResultSet<AccountExternalId> ids = dbProvider.get().accountExternalIds().byAccount(rsrc.getUser().getAccountId());
    for (AccountExternalId extId : ids) {
        if (extId.isScheme(AccountExternalId.SCHEME_MAILTO)) {
            EmailInfo e = new EmailInfo();
            e.email = extId.getEmailAddress();
            e.setPreferred(extId.getEmailAddress().equals(rsrc.getUser().getAccount().getPreferredEmail()));
            emails.add(e);
        }
    }
    return emails;
}
#method_after
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws AuthException, OrmException {
    if (!(self.get() instanceof IdentifiedUser)) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() != rsrc.getUser().getAccountId().get() && !s.getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to list email addresses");
    }
    List<EmailInfo> emails = Lists.newArrayList();
    ResultSet<AccountExternalId> ids = dbProvider.get().accountExternalIds().byAccount(rsrc.getUser().getAccountId());
    for (AccountExternalId extId : ids) {
        String email = extId.getEmailAddress();
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.setPreferred(email.equals(rsrc.getUser().getAccount().getPreferredEmail()));
            emails.add(e);
        }
    }
    return emails;
}
#end_block

#method_before
private void sendForm(HttpServletRequest req, HttpServletResponse res, @Nullable String errorMessage) throws IOException {
    String self = req.getRequestURI();
    String cancel = Objects.firstNonNull(urlProvider.get(), "/");
    String token = getToken(req);
    if (!token.equals("/")) {
        cancel += "#" + token;
    }
    Document doc = HtmlDomUtil.parseFile(LdapLoginServlet.class, "LoginForm.html");
    injectCssFile(doc, "gerrit_sitecss", sitePaths.site_css);
    injectXmlFile(doc, "gerrit_header", sitePaths.site_header);
    injectXmlFile(doc, "gerrit_footer", sitePaths.site_footer);
    HtmlDomUtil.find(doc, "hostName").setTextContent(req.getServerName());
    HtmlDomUtil.find(doc, "login_form").setAttribute("action", self);
    HtmlDomUtil.find(doc, "cancel_link").setAttribute("href", cancel);
    Element emsg = HtmlDomUtil.find(doc, "error_message");
    if (Strings.isNullOrEmpty(errorMessage)) {
        emsg.getParentNode().removeChild(emsg);
    } else {
        emsg.setTextContent(errorMessage);
    }
    byte[] bin = HtmlDomUtil.toUTF8(doc);
    res.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(bin.length);
    ServletOutputStream out = res.getOutputStream();
    try {
        out.write(bin);
    } finally {
        out.close();
    }
}
#method_after
private void sendForm(HttpServletRequest req, HttpServletResponse res, @Nullable String errorMessage) throws IOException {
    String self = req.getRequestURI();
    String cancel = Objects.firstNonNull(urlProvider.get(req), "/");
    String token = getToken(req);
    if (!token.equals("/")) {
        cancel += "#" + token;
    }
    Document doc = headers.parse(LdapLoginServlet.class, "LoginForm.html");
    HtmlDomUtil.find(doc, "hostName").setTextContent(req.getServerName());
    HtmlDomUtil.find(doc, "login_form").setAttribute("action", self);
    HtmlDomUtil.find(doc, "cancel_link").setAttribute("href", cancel);
    Element emsg = HtmlDomUtil.find(doc, "error_message");
    if (Strings.isNullOrEmpty(errorMessage)) {
        emsg.getParentNode().removeChild(emsg);
    } else {
        emsg.setTextContent(errorMessage);
    }
    byte[] bin = HtmlDomUtil.toUTF8(doc);
    res.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(bin.length);
    ServletOutputStream out = res.getOutputStream();
    try {
        out.write(bin);
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String username = Strings.nullToEmpty(req.getParameter("username")).trim();
    String password = Strings.nullToEmpty(req.getParameter("password"));
    String remember = Strings.nullToEmpty(req.getParameter("rememberme"));
    if (username.isEmpty() || password.isEmpty()) {
        sendForm(req, res, "Invalid username or password.");
        return;
    }
    AuthRequest areq = AuthRequest.forUser(username);
    areq.setPassword(password);
    AuthResult ares;
    try {
        ares = accountManager.authenticate(areq);
    } catch (AccountUserNameException e) {
        sendForm(req, res, e.getMessage());
        return;
    } catch (AuthenticationUnavailableException e) {
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    } catch (AccountException e) {
        log.info(String.format("'%s' failed to sign in: %s", username, e.getMessage()));
        sendForm(req, res, "Invalid username or password.");
        return;
    } catch (RuntimeException e) {
        log.error("LDAP authentication failed", e);
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    }
    String token = getToken(req);
    StringBuilder dest = new StringBuilder();
    String url = urlProvider == null ? null : urlProvider.get();
    if (url == null) {
        url = guessCanonicalUrl(req);
    }
    dest.append(url);
    dest.append('#');
    dest.append(token);
    CacheHeaders.setNotCacheable(res);
    webSession.get().login(ares, "1".equals(remember));
    res.sendRedirect(dest.toString());
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String username = Strings.nullToEmpty(req.getParameter("username")).trim();
    String password = Strings.nullToEmpty(req.getParameter("password"));
    String remember = Strings.nullToEmpty(req.getParameter("rememberme"));
    if (username.isEmpty() || password.isEmpty()) {
        sendForm(req, res, "Invalid username or password.");
        return;
    }
    AuthRequest areq = AuthRequest.forUser(username);
    areq.setPassword(password);
    AuthResult ares;
    try {
        ares = accountManager.authenticate(areq);
    } catch (AccountUserNameException e) {
        sendForm(req, res, e.getMessage());
        return;
    } catch (AuthenticationUnavailableException e) {
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    } catch (AccountException e) {
        log.info(String.format("'%s' failed to sign in: %s", username, e.getMessage()));
        sendForm(req, res, "Invalid username or password.");
        return;
    } catch (RuntimeException e) {
        log.error("LDAP authentication failed", e);
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    }
    StringBuilder dest = new StringBuilder();
    dest.append(urlProvider.get(req));
    dest.append('#');
    dest.append(getToken(req));
    CacheHeaders.setNotCacheable(res);
    webSession.get().login(ares, "1".equals(remember));
    res.sendRedirect(dest.toString());
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = getToken(req);
    if ("/logout".equals(token) || "/signout".equals(token)) {
        req.getRequestDispatcher("/logout").forward(req, rsp);
        return;
    }
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    final StringBuilder rdr = new StringBuilder();
    String url = urlProvider == null ? null : urlProvider.get();
    if (url == null) {
        url = guessCanonicalUrl(req);
    }
    rdr.append(url);
    rdr.append('#');
    if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
        rdr.append(PageLinks.REGISTER);
    }
    rdr.append(token);
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = getToken(req);
    if ("/logout".equals(token) || "/signout".equals(token)) {
        req.getRequestDispatcher("/logout").forward(req, rsp);
        return;
    }
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    final StringBuilder rdr = new StringBuilder();
    rdr.append(urlProvider.get(req));
    rdr.append('#');
    if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
        rdr.append(PageLinks.REGISTER);
    }
    rdr.append(token);
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListGroupMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#end_block

#method_before
private void displayUserIdentity(final int row, final UserIdentity who) {
    if (who == null) {
        infoTable.clearCell(row, 1);
        return;
    }
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().patchSetUserIdentity());
    if (who.getName() != null) {
        if (who.getAccount() != null) {
            fp.add(new InlineHyperlink(who.getName(), PageLinks.toAccountQuery(who.getName())));
        } else {
            final InlineLabel lbl = new InlineLabel(who.getName());
            lbl.setStyleName(Gerrit.RESOURCES.css().accountName());
            fp.add(lbl);
        }
    }
    if (who.getEmail() != null) {
        fp.add(new InlineLabel("<" + who.getEmail() + ">"));
    }
    if (who.getDate() != null) {
        fp.add(new InlineLabel(FormatUtil.mediumFormat(who.getDate())));
    }
    infoTable.setWidget(row, 1, fp);
}
#method_after
private void displayUserIdentity(final int row, final UserIdentity who) {
    if (who == null) {
        infoTable.clearCell(row, 1);
        return;
    }
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().patchSetUserIdentity());
    if (who.getName() != null) {
        if (who.getAccount() != null) {
            fp.add(new AccountLinkPanel(who));
        } else {
            final InlineLabel lbl = new InlineLabel(who.getName());
            lbl.setStyleName(Gerrit.RESOURCES.css().accountName());
            fp.add(lbl);
        }
    }
    if (who.getEmail() != null) {
        fp.add(new InlineLabel("<" + who.getEmail() + ">"));
    }
    if (who.getDate() != null) {
        fp.add(new InlineLabel(FormatUtil.mediumFormat(who.getDate())));
    }
    infoTable.setWidget(row, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                ChangeApi.submit(patchSet.getId().getParentKey().get(), patchSet.getRevision().get(), new GerritCallback<SubmitInfo>() {

                    public void onSuccess(SubmitInfo result) {
                        redisplay();
                    }

                    public void onFailure(Throwable err) {
                        if (SubmitFailureDialog.isConflict(err)) {
                            new SubmitFailureDialog(err.getMessage()).center();
                            redisplay();
                        } else {
                            b.setEnabled(true);
                            super.onFailure(err);
                        }
                    }

                    private void redisplay() {
                        Gerrit.display(PageLinks.toChange(patchSet.getId().getParentKey()), new ChangeScreen(patchSet.getId().getParentKey()));
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canCherryPick()) {
        final Button b = new Button(Util.C.buttonCherryPickChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CherryPickDialog(b, changeDetail.getChange().getProject()) {

                    {
                        sendButton.setText(Util.C.buttonCherryPickChangeSend());
                        message.setText(Util.M.cherryPickedChangeDefaultMessage(detail.getInfo().getMessage().trim(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        CherryPickInput cherryPickInput = CherryPickInput.create();
                        cherryPickInput.setMessage(getMessageText());
                        cherryPickInput.setDestination(getDestinationBranch());
                        new RestApi("/changes/" + changeDetail.getChange().getId() + "/revisions/" + patchSet.getRevision().get() + "/cherrypick").data(cherryPickInput).post(new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                ChangeApi.submit(patchSet.getId().getParentKey().get(), patchSet.getRevision().get(), new GerritCallback<SubmitInfo>() {

                    public void onSuccess(SubmitInfo result) {
                        redisplay();
                    }

                    public void onFailure(Throwable err) {
                        if (SubmitFailureDialog.isConflict(err)) {
                            new SubmitFailureDialog(err.getMessage()).center();
                            redisplay();
                        } else {
                            b.setEnabled(true);
                            super.onFailure(err);
                        }
                    }

                    private void redisplay() {
                        Gerrit.display(PageLinks.toChange(patchSet.getId().getParentKey()), new ChangeScreen(patchSet.getId().getParentKey()));
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canCherryPick()) {
        final Button b = new Button(Util.C.buttonCherryPickChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CherryPickDialog(b, changeDetail.getChange().getProject()) {

                    {
                        sendButton.setText(Util.C.buttonCherryPickChangeSend());
                        message.setText(Util.M.cherryPickedChangeDefaultMessage(detail.getInfo().getMessage().trim(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.cherrypick(changeDetail.getChange().getChangeId(), patchSet.getRevision().get(), getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
@Override
public StreamingResponse apply(RevisionResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(project);
        try {
            RevWalk rw = new RevWalk(repo);
            try {
                RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
                RevCommit[] parents = commit.getParents();
                if (parents.length > 1) {
                    throw new ResourceConflictException("Revision has more than 1 parent.");
                } else if (parents.length == 0) {
                    throw new ResourceConflictException("Revision has no parent.");
                }
                rw.parseBody(parents[0]);
                return new PatchResponse(project, commit, parents[0], gerritIdent.getTimeZone());
            } finally {
                rw.release();
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException();
    }
}
#method_after
@Override
public String apply(RevisionResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(project);
        try {
            RevWalk rw = new RevWalk(repo);
            try {
                RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
                RevCommit[] parents = commit.getParents();
                if (parents.length > 1) {
                    throw new ResourceConflictException("Revision has more than 1 parent.");
                } else if (parents.length == 0) {
                    throw new ResourceConflictException("Revision has no parent.");
                }
                rw.parseBody(parents[0]);
                StringBuilder b = new StringBuilder();
                appendHeader(b, commit);
                ByteArrayOutputStream out = new ByteArrayOutputStream();
                DiffFormatter f = new DiffFormatter(out);
                f.setRepository(repo);
                f.format(parents[0].getTree(), commit.getTree());
                f.flush();
                b.append(out.toString(UTF_8.name()));
                return b.toString();
            } finally {
                rw.release();
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException();
    }
}
#end_block

#method_before
public boolean canStreamEvents() {
    return canPerform(GlobalCapability.STREAM_EVENTS);
}
#method_after
public boolean canStreamEvents() {
    return canPerform(GlobalCapability.STREAM_EVENTS) || canAdministrateServer();
}
#end_block

#method_before
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = new ArrayList<NamedFactory<UserAuth>>();
    if (kerberosKeytab != null) {
        authFactories.add(new UserAuthGSS.Factory());
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            log.error("Keytab " + kerberosKeytab + " does not exist or is not readable; furhter errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        log.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            log.warn("Host principal does not start with host/ which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(new UserAuthPublicKey.Factory());
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#method_after
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = Lists.newArrayList();
    if (kerberosKeytab != null) {
        authFactories.add(new UserAuthGSS.Factory());
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            log.error("Keytab " + kerberosKeytab + " does not exist or is not readable; further errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        log.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            log.warn("Host principal does not start with host/ " + "which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(new UserAuthPublicKey.Factory());
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#end_block

#method_before
@Override
public boolean validateIdentity(final ServerSession session, final String identity) {
    final SshSession sd = session.getAttribute(SshSession.KEY);
    int at = identity.indexOf('@');
    String username;
    if (at == -1) {
        username = identity;
    } else {
        username = identity.substring(0, at);
    }
    AccountState state = accounts.getByUsername(username);
    Account account = state == null ? null : state.getAccount();
    boolean active = account != null && account.isActive();
    if (active) {
        return SshUtil.success(username, session, sd, SshUtil.createUser(sd, account, userFactory), sshScope, sshLog);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean validateIdentity(final ServerSession session, final String identity) {
    final SshSession sd = session.getAttribute(SshSession.KEY);
    int at = identity.indexOf('@');
    String username;
    if (at == -1) {
        username = identity;
    } else {
        username = identity.substring(0, at);
    }
    AccountState state = accounts.getByUsername(username);
    Account account = state == null ? null : state.getAccount();
    boolean active = account != null && account.isActive();
    if (active) {
        return SshUtil.success(username, session, sshScope, sshLog, sd, SshUtil.createUser(sd, userFactory, account.getId()));
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public Object apply(CommentResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#method_after
@Override
public Object apply(CommentResource rsrc) throws OrmException {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#end_block

#method_before
@Override
public Object apply(RevisionResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = useAccountLoader() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#method_after
@Override
public Object apply(RevisionResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = includeAuthorInfo() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#end_block

#method_before
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final GarbageCollectionProgressMonitor pm) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        pm.startGarbageCollection(projectName);
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(pm, (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            pm.endGarbageCollection();
        }
    }
    return result;
}
#method_after
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final PrintWriter writer) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        writer.print("collecting garbage for \"" + projectName + "\":\n");
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(new TextProgressMonitor(writer), (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            writer.print("done.\n\n");
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                collectGarbage();
            } finally {
                stdout.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                runGC();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
@Override
public Object apply(AccountResource resource) throws BadRequestException, Exception {
    if (self.get() != resource.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    CapabilityControl cc = resource.getUser().getCapabilities();
    Map<String, Object> have = Maps.newLinkedHashMap();
    for (String name : GlobalCapability.getAllNames()) {
        if (!name.equals(PRIORITY) && want(name) && cc.canPerform(name)) {
            if (GlobalCapability.hasRange(name)) {
                have.put(name, new Range(cc.getRange(name)));
            } else {
                have.put(name, true);
            }
        }
    }
    have.put(CREATE_ACCOUNT, cc.canCreateAccount());
    have.put(CREATE_GROUP, cc.canCreateGroup());
    have.put(CREATE_PROJECT, cc.canCreateProject());
    have.put(KILL_TASK, cc.canKillTask());
    have.put(VIEW_CACHES, cc.canViewCaches());
    have.put(FLUSH_CACHES, cc.canFlushCaches());
    have.put(VIEW_CONNECTIONS, cc.canViewConnections());
    have.put(VIEW_QUEUE, cc.canViewQueue());
    have.put(START_REPLICATION, cc.canStartReplication());
    have.put(RAW_QUERY, cc.canPerformRawQuery());
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
    Iterator<Map.Entry<String, Object>> itr = have.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Object> e = itr.next();
        if (!want(e.getKey())) {
            itr.remove();
        } else if (e.getValue() instanceof Boolean && !((Boolean) e.getValue())) {
            itr.remove();
        }
    }
    if (format == OutputFormat.TEXT) {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, Object> e : have.entrySet()) {
            sb.append(e.getKey());
            if (!(e.getValue() instanceof Boolean)) {
                sb.append(": ");
                sb.append(e.getValue().toString());
            }
            sb.append('\n');
        }
        return BinaryResult.create(sb.toString());
    } else {
        return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
        }.getType());
    }
}
#method_after
@Override
public Object apply(AccountResource resource) throws BadRequestException, Exception {
    if (self.get() != resource.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    CapabilityControl cc = resource.getUser().getCapabilities();
    Map<String, Object> have = Maps.newLinkedHashMap();
    for (String name : GlobalCapability.getAllNames()) {
        if (!name.equals(PRIORITY) && want(name) && cc.canPerform(name)) {
            if (GlobalCapability.hasRange(name)) {
                have.put(name, new Range(cc.getRange(name)));
            } else {
                have.put(name, true);
            }
        }
    }
    have.put(CREATE_ACCOUNT, cc.canCreateAccount());
    have.put(CREATE_GROUP, cc.canCreateGroup());
    have.put(CREATE_PROJECT, cc.canCreateProject());
    have.put(EMAIL_REVIEWERS, cc.canEmailReviewers());
    have.put(KILL_TASK, cc.canKillTask());
    have.put(VIEW_CACHES, cc.canViewCaches());
    have.put(FLUSH_CACHES, cc.canFlushCaches());
    have.put(VIEW_CONNECTIONS, cc.canViewConnections());
    have.put(VIEW_QUEUE, cc.canViewQueue());
    have.put(START_REPLICATION, cc.canStartReplication());
    have.put(ACCESS_DATABASE, cc.canAccessDatabase());
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
    Iterator<Map.Entry<String, Object>> itr = have.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Object> e = itr.next();
        if (!want(e.getKey())) {
            itr.remove();
        } else if (e.getValue() instanceof Boolean && !((Boolean) e.getValue())) {
            itr.remove();
        }
    }
    if (format == OutputFormat.TEXT) {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, Object> e : have.entrySet()) {
            sb.append(e.getKey());
            if (!(e.getValue() instanceof Boolean)) {
                sb.append(": ");
                sb.append(e.getValue().toString());
            }
            sb.append('\n');
        }
        return BinaryResult.create(sb.toString());
    } else {
        return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
        }.getType());
    }
}
#end_block

#method_before
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getProject().getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
List<SectionMatcher> getAllSections() {
    if (isAllProjects) {
        return getLocalAccessSections();
    }
    List<SectionMatcher> all = new ArrayList<SectionMatcher>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    ProjectState allProjects = projectCache.getAllProjects();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        all.addAll(s.getLocalAccessSections());
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    if (seen.add(allProjects.getProject().getNameKey())) {
        all.addAll(allProjects.getLocalAccessSections());
    }
    return all;
}
#method_after
List<SectionMatcher> getAllSections() {
    if (isAllProjects) {
        return getLocalAccessSections();
    }
    List<SectionMatcher> all = Lists.newArrayList();
    for (ProjectState s : tree()) {
        all.addAll(s.getLocalAccessSections());
    }
    return all;
}
#end_block

#method_before
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isAllProjects) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#method_after
public Set<AccountGroup.UUID> getOwners() {
    for (ProjectState p : tree()) {
        if (!p.localOwners.isEmpty()) {
            return p.localOwners;
        }
    }
    return Collections.emptySet();
}
#end_block

#method_before
boolean isOwner(GroupMembership groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (groups.containsAnyOf(s.localOwners)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#method_after
boolean isOwner(final GroupMembership groups) {
    return Iterables.any(tree(), new Predicate<ProjectState>() {

        @Override
        public boolean apply(ProjectState in) {
            return groups.containsAnyOf(in.localOwners);
        }
    });
}
#end_block

#method_before
private boolean getInheritableBoolean(Function<Project, InheritableBoolean> func) {
    Set<Project.NameKey> seen = Sets.newHashSet();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        switch(func.apply(s.getProject())) {
            case TRUE:
                return true;
            case FALSE:
                return false;
            case INHERIT:
            default:
                Project.NameKey parent = s.getProject().getParent(allProjectsName);
                if (parent != null && seen.add(parent)) {
                    s = projectCache.get(parent);
                } else {
                    s = null;
                }
        }
    } while (s != null);
    return false;
}
#method_after
private boolean getInheritableBoolean(Function<Project, InheritableBoolean> func) {
    for (ProjectState s : tree()) {
        switch(func.apply(s.getProject())) {
            case TRUE:
                return true;
            case FALSE:
                return false;
            case INHERIT:
            default:
                continue;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    command(gerrit, TestSubmitRuleCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, Receive.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, ReviewCommand.class);
    // deprecated alias to review command
    alias(gerrit, "approve", ReviewCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, Receive.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, ReviewCommand.class);
    // deprecated alias to review command
    alias(gerrit, "approve", ReviewCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#end_block

#method_before
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps == null) {
            throw new ResourceNotFoundException(id);
        }
        return new RevisionResource(change, ps);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, id.get())) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && change.getControl().isPatchVisible(ps, dbProvider.get())) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0));
}
#method_after
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps);
        }
        throw new ResourceNotFoundException(id);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, id.get())) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && visible(change, ps)) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0));
}
#end_block

#method_before
public final Set<String> values() {
    return Natives.keys(values0());
}
#method_after
public final Set<String> values() {
    return Natives.keys(_values());
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    if (!accounts.isEmpty()) {
        for (Account account : db.get().accounts().get(accounts.keySet())) {
            AccountAttribute a = accounts.get(account.getId());
            a.name = Strings.emptyToNull(account.getFullName());
        }
    }
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    if (options.contains(LABELS) || options.contains(DETAILED_LABELS)) {
        out.labels = labelsFor(cd, options.contains(DETAILED_LABELS));
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                if (detailed) {
                    ApprovalType at = approvalTypes.byLabel(r.label);
                    if (at != null) {
                        PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
                        n.category = at.getCategory().getName();
                        n.id = at.getCategory().getId().get();
                        n.values = Maps.newLinkedHashMap();
                        for (ApprovalCategoryValue acv : at.getValues()) {
                            if (range.contains(acv.getValue())) {
                                n.values.put(acv.formatValue(), acv.getName());
                            }
                        }
                        if (n.values.size() == 1 && " 0".equals(Iterables.getOnlyElement(n.values.keySet()))) {
                            n.values = ImmutableMap.of();
                        }
                    }
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    initLabels(cd, labels, standard);
    Collection<PatchSetApproval> approvals = null;
    if (detailed) {
        approvals = cd.currentApprovals(db);
        setAllApprovals(labels, approvals);
    }
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null) {
            // TODO: Support arbitrary labels.
            continue;
        }
        if (standard) {
            approvals = setRecommendedAndDisliked(cd, approvals, type, e.getValue());
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountInfoCache = new AccountInfo.Cache(db, !options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountInfoCache.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountInfoCache.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountInfoCache.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountInfoCache.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountLoader.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountLoader.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForRevertCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForRevertCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
void insert(GroupInfo info) {
    Comparator<GroupInfo> c = new Comparator<GroupInfo>() {

        @Override
        public int compare(GroupInfo a, GroupInfo b) {
            int cmp = Strings.nullToEmpty(a.name()).compareTo(Strings.nullToEmpty(b.name()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getGroupUUID().compareTo(b.getGroupUUID());
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        int middle = (left + right) >>> 1;
        GroupInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#method_after
void insert(GroupInfo info) {
    Comparator<GroupInfo> c = new Comparator<GroupInfo>() {

        @Override
        public int compare(GroupInfo a, GroupInfo b) {
            int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getGroupUUID().compareTo(b.getGroupUUID());
        }

        private String nullToEmpty(@Nullable String str) {
            return (str == null) ? "" : str;
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        GroupInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(uuid.toString());
    sb.append("|");
    sb.append(sessionId);
    sb.append('|');
    sb.append(who);
    sb.append('|');
    sb.append(when);
    sb.append('|');
    sb.append(what);
    sb.append('|');
    sb.append(elapsed);
    sb.append('|');
    if (params != null) {
        sb.append('[');
        for (int i = 0; i < params.size(); i++) {
            if (i > 0)
                sb.append(',');
            if (params != null) {
                Set<String> paramNames = params.keySet();
                for (String paramName : paramNames) {
                    sb.append("name=");
                    sb.append(paramName);
                    int numValues = 0;
                    Collection<?> paramValues = params.get(paramName);
                    for (Object paramValue : paramValues) {
                        sb.append(Objects.firstNonNull(paramValue, "null"));
                        if (numValues++ > 0) {
                            sb.append(",");
                        }
                    }
                }
            }
        }
        sb.append(']');
    }
    sb.append('|');
    if (result != null) {
        sb.append(result);
    }
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return String.format("AuditEvent UUID:%s, SID:%s, TS:%d, who:%s, what:%s", uuid.get(), sessionId, when, who, what);
}
#end_block

#method_before
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
        } else {
            if (paramName == null) {
                parms.put("$" + argPos++, arg);
            } else {
                parms.put(paramName, arg);
                paramName = null;
            }
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#method_after
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        // -- stop parameters parsing
        if (arg.equals("--")) {
            for (i++; i < cmdArgs.length; i++) {
                parms.put("$" + argPos++, cmdArgs[i]);
            }
            break;
        }
        // --param=value
        int eqPos = arg.indexOf('=');
        if (arg.startsWith("--") && eqPos > 0) {
            parms.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));
            continue;
        }
        // -p value or --param value
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
            continue;
        }
        // value
        if (paramName == null) {
            parms.put("$" + argPos++, arg);
        } else {
            parms.put(paramName, arg);
            paramName = null;
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#end_block

#method_before
void audit(Context ctx, Object result, String cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + cmd, created, null, result));
}
#method_after
void audit(Context ctx, Object result, String cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new SshAuditEvent(sid, extractCurrentUser(ctx), cmd, created, null, result));
}
#end_block

#method_before
void audit(Context ctx, Object result, DispatchCommand cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + extractWhat(cmd), created, extractParameters(cmd), result));
}
#method_after
void audit(Context ctx, Object result, DispatchCommand cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new SshAuditEvent(sid, extractCurrentUser(ctx), extractWhat(cmd), created, extractParameters(cmd), result));
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    int status = SC_OK;
    Object result = "";
    Multimap<String, String> params = LinkedHashMultimap.create();
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        res.setStatus(status);
        if (result instanceof BinaryResult) {
            replyBinaryResult(req, res, (BinaryResult) result);
        } else {
            replyJson(req, res, config, result);
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (InvalidMethodException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new AuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getMethod() + " " + req.getRequestURI(), auditStartTs, params, status + " " + result));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    CacheHeaders.setNotCacheable(res);
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                checkPreconditions(req, rsrc);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        } else if (result instanceof Response.Redirect) {
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, InvalidMethodException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (isEmptyType(type) && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private static boolean hasNoBody(HttpServletRequest req) {
    int len = req.getContentLength();
    String type = req.getContentType();
    return (len <= 0 && type == null) || (len == 0 && isType("application/x-www-form-urlencoded", type));
}
#method_after
private static boolean hasNoBody(HttpServletRequest req) {
    int len = req.getContentLength();
    String type = req.getContentType();
    return (len <= 0 && type == null) || (len == 0 && isType(FORM_TYPE, type));
}
#end_block

#method_before
private static boolean acceptsPutInput(Class<Object> type) {
    for (Field f : type.getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            return true;
        }
    }
    return false;
}
#method_after
@SuppressWarnings("rawtypes")
private static boolean acceptsPutInput(Type type) {
    if (type instanceof Class) {
        for (Field f : ((Class) type).getDeclaredFields()) {
            if (f.getType() == PutInput.class) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private Object parsePutInput(final HttpServletRequest req, Class<Object> type) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, InvalidMethodException {
    Object obj = createInstance(type);
    for (Field f : type.getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            f.setAccessible(true);
            f.set(obj, new PutInput() {

                @Override
                public String getContentType() {
                    return req.getContentType();
                }

                @Override
                public long getContentLength() {
                    return req.getContentLength();
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return req.getInputStream();
                }
            });
            return obj;
        }
    }
    throw new InvalidMethodException();
}
#method_after
private Object parsePutInput(final HttpServletRequest req, Type type) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, MethodNotAllowedException {
    Object obj = createInstance(type);
    for (Field f : obj.getClass().getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            f.setAccessible(true);
            f.set(obj, new PutInput() {

                @Override
                public String getContentType() {
                    return req.getContentType();
                }

                @Override
                public long getContentLength() {
                    return req.getContentLength();
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return req.getInputStream();
                }
            });
            return obj;
        }
    }
    throw new MethodNotAllowedException();
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#method_after
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, @Nullable HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null && req != null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#end_block

#method_before
private static void replyBinaryResult(HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                res.setContentLength((int) buf.length());
                res.setHeader("Content-Encoding", "gzip");
                buf.writeTo(dst, null);
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                if (0 <= len && len < Integer.MAX_VALUE) {
                    res.setContentLength((int) len);
                } else if (0 <= len) {
                    res.setHeader("Content-Length", Long.toString(len));
                }
                bin.writeTo(dst);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, InvalidMethodException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if (!text.endsWith("\n")) {
        text += "\n";
    }
    replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static boolean acceptsJson(HttpServletRequest req) {
    return req != null && isType(JSON_TYPE, req.getHeader("Accept"));
}
#method_after
private static boolean acceptsJson(HttpServletRequest req) {
    return req != null && isType(JSON_TYPE, req.getHeader(HttpHeaders.ACCEPT));
}
#end_block

#method_before
private static boolean acceptsGzip(HttpServletRequest req) {
    return req != null && RPCServletUtils.acceptsGzipEncoding(req);
}
#method_after
private static boolean acceptsGzip(HttpServletRequest req) {
    if (req != null) {
        String accepts = req.getHeader(HttpHeaders.ACCEPT_ENCODING);
        return accepts != null && accepts.indexOf("gzip") != -1;
    }
    return false;
}
#end_block

#method_before
@Override
protected GerritCall createActiveCall(final HttpServletRequest req, final HttpServletResponse rsp) {
    final GerritCall call = new GerritCall(session.get(), req, rsp);
    currentCall.set(call);
    return call;
}
#method_after
@Override
protected GerritCall createActiveCall(final HttpServletRequest req, final HttpServletResponse rsp) {
    final GerritCall call = new GerritCall(session.get(), req, new AuditedHttpServletResponse(rsp));
    currentCall.set(call);
    return call;
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = (Audit) method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, method.getName());
            final Object result = call.getResult();
            audit.dispatch(new AuditEvent(sid, username, what, call.getWhen(), args, result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = (Audit) method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, call);
            final Object result = call.getResult();
            audit.dispatch(new RpcAuditEvent(sid, username, what, call.getWhen(), args, call.getHttpServletRequest().getMethod(), call.getHttpServletRequest().getMethod(), ((AuditedHttpServletResponse) (call.getHttpServletResponse())).getStatus(), result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (ccase && !Character.isLowerCase(c)) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#method_after
private String extractWhat(final Audit note, final GerritCall call) {
    String methodClass = call.getMethodClass().getName();
    methodClass = methodClass.substring(methodClass.lastIndexOf(".") + 1);
    String what = note.action();
    if (what.length() == 0) {
        what = call.getMethod().getName();
    }
    return methodClass + "." + what;
}
#end_block

#method_before
@Override
public boolean xsrfValidate() {
    final String keyIn = getXsrfKeyIn();
    if (keyIn == null || "".equals(keyIn)) {
        // 
        return !session.isSignedIn();
    } else {
        // 
        return session.isSignedIn() && session.isValidAuthorization(keyIn);
    }
}
#method_after
@Override
public boolean xsrfValidate() {
    final String keyIn = getXsrfKeyIn();
    if (keyIn == null || "".equals(keyIn)) {
        // 
        return !session.isSignedIn();
    } else if (session.isSignedIn() && session.isValidAuthorization(keyIn)) {
        // The session must exist, and must be using this token.
        // 
        session.getCurrentUser().setAccessPath(AccessPath.JSON_RPC);
        return true;
    }
    return false;
}
#end_block

#method_before
public void setReviewedByCurrentUser(boolean reviewed) {
    if (fileList != null) {
        fileList.updateReviewedStatus(patchKey, reviewed);
    }
    MarkReviewedInput in = MarkReviewedInput.create();
    in.reviewed(reviewed);
    PatchSet.Id ps = patchKey.getParentKey();
    new RestApi("/changes/").id(ps.getParentKey().get()).view("revisions").id(ps.get()).view("files").id(patchKey.getFileName()).view("reviewed").post(in, new AsyncCallback<VoidResult>() {

        @Override
        public void onFailure(Throwable arg0) {
        // nop
        }

        @Override
        public void onSuccess(VoidResult result) {
        // nop
        }
    });
}
#method_after
public void setReviewedByCurrentUser(boolean reviewed) {
    if (fileList != null) {
        fileList.updateReviewedStatus(patchKey, reviewed);
    }
    PatchSet.Id ps = patchKey.getParentKey();
    RestApi api = new RestApi("/changes/").id(ps.getParentKey().get()).view("revisions").id(ps.get()).view("files").id(patchKey.getFileName()).view("reviewed");
    AsyncCallback<VoidResult> cb = new AsyncCallback<VoidResult>() {

        @Override
        public void onFailure(Throwable arg0) {
        // nop
        }

        @Override
        public void onSuccess(VoidResult result) {
        // nop
        }
    };
    if (reviewed) {
        api.put(cb);
    } else {
        api.delete(cb);
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    post(PATCH_KIND, "reviewed").to(MarkReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Patches.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    put(PATCH_KIND, "reviewed").to(PutReviewed.class);
    delete(PATCH_KIND, "reviewed").to(DeleteReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    try {
        // Try to mark interested owners with TO and CC or BCC line.
        Watchers matching = getWatches(NotifyType.NEW_CHANGES);
        for (Account.Id user : Iterables.concat(matching.to.accounts, matching.cc.accounts, matching.bcc.accounts)) {
            if (isOwnerOfProjectOrBranch(user)) {
                add(RecipientType.TO, user);
            }
        }
        // Add everyone else. Owners added above will not be duplicated.
        add(RecipientType.TO, matching.to);
        add(RecipientType.CC, matching.cc);
        add(RecipientType.BCC, matching.bcc);
    } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot notify watchers for new change", err);
    }
    includeWatchers(NotifyType.NEW_PATCHSETS);
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    try {
        // Try to mark interested owners with TO and CC or BCC line.
        Watchers matching = getWatchers(NotifyType.NEW_CHANGES);
        for (Account.Id user : Iterables.concat(matching.to.accounts, matching.cc.accounts, matching.bcc.accounts)) {
            if (isOwnerOfProjectOrBranch(user)) {
                add(RecipientType.TO, user);
            }
        }
        // Add everyone else. Owners added above will not be duplicated.
        add(RecipientType.TO, matching.to);
        add(RecipientType.CC, matching.cc);
        add(RecipientType.BCC, matching.bcc);
    } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot notify watchers for new change", err);
    }
    includeWatchers(NotifyType.NEW_PATCHSETS);
}
#end_block

#method_before
private void add(Watchers matching, NotifyConfig nc, Project.NameKey project) throws OrmException, QueryParseException {
    for (GroupReference ref : nc.getGroups()) {
        CurrentUser user = new SingleGroupUser(args.capabilityControlFactory, ref.getUUID());
        if (filterMatch(user, nc.getFilter())) {
            deliverToMembers(matching.list(nc.getHeader()), ref.getUUID());
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (filterMatch(args.anonymousUser, nc.getFilter())) {
            matching.list(nc.getHeader()).emails.addAll(nc.getAddresses());
        }
    }
}
#method_after
private void add(Watchers matching, NotifyConfig nc, Project.NameKey project) throws OrmException, QueryParseException {
    for (GroupReference ref : nc.getGroups()) {
        CurrentUser user = new SingleGroupUser(args.capabilityControlFactory, ref.getUUID());
        if (filterMatch(user, nc.getFilter())) {
            deliverToMembers(matching.list(nc.getHeader()), ref.getUUID());
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (filterMatch(null, nc.getFilter())) {
            matching.list(nc.getHeader()).emails.addAll(nc.getAddresses());
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private boolean filterMatch(CurrentUser user, String filter) throws OrmException, QueryParseException {
    ChangeQueryBuilder qb = args.queryBuilder.create(user);
    Predicate<ChangeData> p = null;
    if (!(user instanceof AnonymousUser)) {
        p = qb.is_visible();
    }
    if (filter != null) {
        qb.setAllowFile(true);
        Predicate<ChangeData> filterPredicate = qb.parse(filter);
        if (p == null) {
            p = filterPredicate;
        } else {
            p = Predicate.and(filterPredicate, p);
        }
        p = args.queryRewriter.get().rewrite(p);
    }
    return p == null ? true : p.match(changeData);
}
#method_after
@SuppressWarnings("unchecked")
private boolean filterMatch(CurrentUser user, String filter) throws OrmException, QueryParseException {
    ChangeQueryBuilder qb;
    Predicate<ChangeData> p = null;
    if (user == null) {
        qb = args.queryBuilder.create(args.anonymousUser);
    } else {
        qb = args.queryBuilder.create(user);
        p = qb.is_visible();
    }
    if (filter != null) {
        qb.setAllowFile(true);
        Predicate<ChangeData> filterPredicate = qb.parse(filter);
        if (p == null) {
            p = filterPredicate;
        } else {
            p = Predicate.and(filterPredicate, p);
        }
        p = args.queryRewriter.get().rewrite(p);
    }
    return p == null ? true : p.match(changeData);
}
#end_block

#method_before
@Override
public void onKeyPress(KeyPressEvent event) {
    if (event.getSource() == newTopic && event.getCharCode() == KeyCodes.KEY_ENTER) {
        doTopicEdit();
    }
}
#method_after
@Override
public void onKeyPress(KeyPressEvent event) {
    if (event.getSource() == newTopic && event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
        doTopicEdit();
    }
}
#end_block

#method_before
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    return Lists.newLinkedList(getMembers(resource.getGroupUUID(), recursive, new HashSet<AccountGroup.UUID>()).values());
}
#method_after
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final Map<Account.Id, MemberInfo> members = getMembers(resource.getGroupUUID(), new HashSet<AccountGroup.UUID>());
    return Lists.newArrayList(members.values());
}
#end_block

#method_before
private Map<Account.Id, MemberInfo> getMembers(final AccountGroup.UUID groupUUID, final boolean recursive, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException {
    seenGroups.add(groupUUID);
    final Map<Account.Id, MemberInfo> members = Maps.newHashMap();
    final AccountGroup group = groupCache.get(groupUUID);
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            final Account account = accountCache.get(member.getAccountId()).getAccount();
            members.put(account.getId(), MembersCollection.parse(account));
        }
    }
    if (recursive) {
        if (groupDetail.includes != null) {
            for (final AccountGroupIncludeByUuid includedGroup : groupDetail.includes) {
                if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                    members.putAll(getMembers(includedGroup.getIncludeUUID(), recursive, seenGroups));
                }
            }
        }
    }
    return members;
}
#method_after
private Map<Account.Id, MemberInfo> getMembers(final AccountGroup.UUID groupUUID, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException {
    seenGroups.add(groupUUID);
    final Map<Account.Id, MemberInfo> members = Maps.newHashMap();
    final AccountGroup group = groupCache.get(groupUUID);
    if (group == null) {
        // the included group is an external group and can't be resolved
        return Collections.emptyMap();
    }
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember m : groupDetail.members) {
            if (!members.containsKey(m.getAccountId())) {
                final Account account = accountCache.get(m.getAccountId()).getAccount();
                members.put(account.getId(), MembersCollection.parse(account));
            }
        }
    }
    if (recursive) {
        if (groupDetail.includes != null) {
            for (final AccountGroupIncludeByUuid includedGroup : groupDetail.includes) {
                if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                    members.putAll(getMembers(includedGroup.getIncludeUUID(), seenGroups));
                }
            }
        }
    }
    return members;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    final Grid addGrid = new Grid(2, 2);
    addGrid.setStyleName(Gerrit.RESOURCES.css().addBranch());
    int texBoxLength = 50;
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(texBoxLength);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(texBoxLength);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    add(delBranch);
    add(addPanel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    final Grid addGrid = new Grid(2, 2);
    addGrid.setStyleName(Gerrit.RESOURCES.css().addBranch());
    final int texBoxLength = 50;
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(texBoxLength);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(texBoxLength);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    add(delBranch);
    add(addPanel);
}
#end_block

#method_before
public DynamicItem<T> get() {
    return new DynamicItem<T>(find(injector, type));
}
#method_after
public DynamicItem<T> get() {
    return new DynamicItem<T>(key, find(injector, type), "gerrit");
}
#end_block

#method_before
private static <T> AtomicReference<Provider<T>> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null) {
        for (Binding<T> b : bindings) {
            if (b.getKey().getAnnotation() != null) {
                // TODO: throw exception if > 1 match?
                return new AtomicReference<Provider<T>>(b.getProvider());
            }
        }
    }
    return new AtomicReference<Provider<T>>();
}
#method_after
private static <T> Provider<T> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null && bindings.size() == 1) {
        return bindings.get(0).getProvider();
    } else if (bindings != null && bindings.size() > 1) {
        throw new ProvisionException(String.format("Multiple providers bound for DynamicItem<%s>\n" + "This is not allowed; check the server configuration.", type));
    } else {
        return null;
    }
}
#end_block

#method_before
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider()));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#method_after
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items, String pluginName) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider(), pluginName));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#end_block

#method_before
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member)).in(Scopes.SINGLETON);
}
#method_after
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member, key)).in(Scopes.SINGLETON);
}
#end_block

#method_before
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type).annotatedWith(UniqueAnnotations.create());
}
#method_after
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type);
}
#end_block

#method_before
public T get() {
    Provider<T> p = item.get();
    T t = null;
    if (p != null) {
        t = p.get();
    }
    return t;
}
#method_after
public T get() {
    NamedProvider<T> item = ref.get();
    return item != null ? item.impl.get() : null;
}
#end_block

#method_before
public ReloadableRegistrationHandle<T> set(Key<T> key, Provider<T> item) {
    if (!this.item.compareAndSet(null, item)) {
        // We already have an item bound.
        throw new RuntimeException("Type already provided by " + this.item.get());
    }
    return new ReloadableHandle(key, item);
}
#method_after
public RegistrationHandle set(T item, String pluginName) {
    return set(Providers.of(item), pluginName);
}
#end_block

#method_before
@Override
public void remove() {
    DynamicItem.this.item.compareAndSet(item, null);
}
#method_after
@Override
public void remove() {
    ref.compareAndSet(item, null);
}
#end_block

#method_before
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    if (DynamicItem.this.item.compareAndSet(item, newItem)) {
        return new ReloadableHandle(newKey, newItem);
    }
    return null;
}
#method_after
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    NamedProvider<T> n = new NamedProvider<T>(newItem, item.pluginName);
    if (ref.compareAndSet(item, n)) {
        return new ReloadableHandle(newKey, n);
    }
    return null;
}
#end_block

#method_before
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items)) {
        plugin.add(h);
    }
}
#method_after
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items, plugin.getName())) {
        plugin.add(h);
    }
}
#end_block

#method_before
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        // Index all old handles that match this DynamicItem<T> keyed by
        // annotations. Ignore the unique annotations, thereby favoring
        // the @Named annotations or some other non-unique naming.
        Map<Annotation, ReloadableRegistrationHandle<?>> am = Maps.newHashMap();
        List<ReloadableRegistrationHandle<?>> old = oldHandles.get(type);
        Iterator<ReloadableRegistrationHandle<?>> oi = old.iterator();
        while (oi.hasNext()) {
            ReloadableRegistrationHandle<?> h = oi.next();
            Annotation a = h.getKey().getAnnotation();
            if (a != null && !UNIQUE_ANNOTATION.isInstance(a)) {
                am.put(a, h);
                oi.remove();
            }
        }
        // Replace old handles with new bindings, favoring cases where there
        // is an exact match on an @Named annotation. If there is no match
        // pick any handle and replace it. We generally expect only one
        // handle of each DynamicItem type when using unique annotations, but
        // possibly multiple ones if @Named was used. Plugin authors that want
        // atomic replacement across reloads should use @Named annotations with
        // stable names that do not change across plugin versions to ensure the
        // handles are swapped correctly.
        oi = old.iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            Key<Object> key = b.getKey();
            if (key.getAnnotation() == null) {
                continue;
            }
            @SuppressWarnings("unchecked")
            ReloadableRegistrationHandle<Object> h1 = (ReloadableRegistrationHandle<Object>) am.remove(key.getAnnotation());
            if (h1 != null) {
                replace(newPlugin, h1, b);
            } else if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h2 = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h2, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider()));
            }
        }
    }
}
#method_after
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        Iterator<ReloadableRegistrationHandle<?>> oi = oldHandles.get(type).iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider(), newPlugin.getName()));
            }
        }
    }
}
#end_block

#method_before
void doAuth(final HttpServletRequest req, final HttpServletResponse rsp) throws Exception {
    if (OMODE_CANCEL.equals(req.getParameter(OPENID_MODE))) {
        cancel(req, rsp);
        return;
    }
    // Process the authentication response.
    // 
    final SignInMode mode = signInMode(req);
    final String openidIdentifier = req.getParameter("openid.identity");
    final String claimedIdentifier = req.getParameter(P_CLAIMED);
    final String returnToken = req.getParameter(P_TOKEN);
    final boolean remember = "1".equals(req.getParameter(P_REMEMBER));
    final String rediscoverIdentifier = claimedIdentifier != null ? claimedIdentifier : openidIdentifier;
    final State state;
    if (!isAllowedOpenID(rediscoverIdentifier) || !isAllowedOpenID(openidIdentifier) || (claimedIdentifier != null && !isAllowedOpenID(claimedIdentifier))) {
        cancelWithError(req, rsp, "Provider not allowed");
        return;
    }
    state = init(rediscoverIdentifier, mode, remember, returnToken);
    if (state == null) {
        // Re-discovery must have failed, we can't run a login.
        // 
        cancel(req, rsp);
        return;
    }
    final String returnTo = req.getParameter("openid.return_to");
    if (returnTo != null && returnTo.contains("openid.rpnonce=")) {
        // Some providers (claimid.com) seem to embed these request
        // parameters into our return_to URL, and then give us them
        // in the return_to request parameter. But not all.
        // 
        state.retTo.put("openid.rpnonce", req.getParameter("openid.rpnonce"));
        state.retTo.put("openid.rpsig", req.getParameter("openid.rpsig"));
    }
    final VerificationResult result = manager.verify(state.retTo.toString(), new ParameterList(req.getParameterMap()), state.discovered);
    if (result.getVerifiedId() == null) /* authentication failure */
    {
        if ("Nonce verification failed.".equals(result.getStatusMsg())) {
            // We might be suffering from clock skew on this system.
            // 
            log.error("OpenID failure: " + result.getStatusMsg() + "  Likely caused by clock skew on this server," + " install/configure NTP.");
            cancelWithError(req, rsp, result.getStatusMsg());
        } else if (result.getStatusMsg() != null) {
            // Authentication failed.
            // 
            log.error("OpenID failure: " + result.getStatusMsg());
            cancelWithError(req, rsp, result.getStatusMsg());
        } else {
            // Assume authentication was canceled.
            // 
            cancel(req, rsp);
        }
        return;
    }
    final Message authRsp = result.getAuthResponse();
    SRegResponse sregRsp = null;
    FetchResponse fetchRsp = null;
    if (0 <= papeMaxAuthAge) {
        PapeResponse ext;
        boolean unsupported = false;
        try {
            ext = (PapeResponse) authRsp.getExtension(PapeMessage.OPENID_NS_PAPE);
        } catch (MessageException err) {
            // Far too many providers are unable to provide PAPE extensions
            // right now. Instead of blocking all of them log the error and
            // let the authentication complete anyway.
            // 
            log.error("Invalid PAPE response " + openidIdentifier + ": " + err);
            unsupported = true;
            ext = null;
        }
        if (!unsupported && ext == null) {
            log.error("No PAPE extension response from " + openidIdentifier);
            cancelWithError(req, rsp, "OpenID provider does not support PAPE.");
            return;
        }
    }
    if (authRsp.hasExtension(SRegMessage.OPENID_NS_SREG)) {
        final MessageExtension ext = authRsp.getExtension(SRegMessage.OPENID_NS_SREG);
        if (ext instanceof SRegResponse) {
            sregRsp = (SRegResponse) ext;
        }
    }
    if (authRsp.hasExtension(AxMessage.OPENID_NS_AX)) {
        final MessageExtension ext = authRsp.getExtension(AxMessage.OPENID_NS_AX);
        if (ext instanceof FetchResponse) {
            fetchRsp = (FetchResponse) ext;
        }
    }
    final com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(openidIdentifier);
    if (sregRsp != null) {
        areq.setDisplayName(sregRsp.getAttributeValue("fullname"));
        areq.setEmailAddress(sregRsp.getAttributeValue("email"));
    } else if (fetchRsp != null) {
        final String firstName = fetchRsp.getAttributeValue("FirstName");
        final String lastName = fetchRsp.getAttributeValue("LastName");
        final StringBuilder n = new StringBuilder();
        if (firstName != null && firstName.length() > 0) {
            n.append(firstName);
        }
        if (lastName != null && lastName.length() > 0) {
            if (n.length() > 0) {
                n.append(' ');
            }
            n.append(lastName);
        }
        areq.setDisplayName(n.length() > 0 ? n.toString() : null);
        areq.setEmailAddress(fetchRsp.getAttributeValue("Email"));
    }
    if (openIdDomains != null && openIdDomains.size() > 0) {
        // Administrator limited email domains, which can be used for OpenID.
        // and login process will only work if the passed email matches one
        // of these domains.
        // 
        String email = areq.getEmailAddress();
        int emailAtIndex = email.lastIndexOf("@");
        String emailDomain;
        if (emailAtIndex >= 0 && emailAtIndex < email.length() - 1) {
            emailDomain = email.substring(emailAtIndex);
        } else {
            emailDomain = "";
        }
        boolean match = false;
        for (String domain : openIdDomains) {
            if (emailDomain.equalsIgnoreCase(domain)) {
                match = true;
                break;
            }
        }
        if (!match) {
            log.error("Domain disallowed: " + emailDomain);
            cancelWithError(req, rsp, "Domain disallowed");
            return;
        }
    }
    if (claimedIdentifier != null) {
        // The user used a claimed identity which has delegated to the verified
        // identity we have in our AuthRequest above. We still should have a
        // link between the two, so set one up if not present.
        // 
        Account.Id claimedId = accountManager.lookup(claimedIdentifier);
        Account.Id actualId = accountManager.lookup(areq.getExternalId());
        if (claimedId != null && actualId != null) {
            if (claimedId.equals(actualId)) {
            // Both link to the same account, that's what we expected.
            } else {
                // This is (for now) a fatal error. There are two records
                // for what might be the same user.
                // 
                log.error("OpenID accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + areq.getExternalId());
                cancelWithError(req, rsp, "Contact site administrator");
                return;
            }
        } else if (claimedId == null && actualId != null) {
            // Older account, the actual was already created but the claimed
            // was missing due to a bug in Gerrit. Link the claimed.
            // 
            final com.google.gerrit.server.account.AuthRequest linkReq = new com.google.gerrit.server.account.AuthRequest(claimedIdentifier);
            linkReq.setDisplayName(areq.getDisplayName());
            linkReq.setEmailAddress(areq.getEmailAddress());
            accountManager.link(actualId, linkReq);
        } else if (claimedId != null && actualId == null) {
            // Claimed account already exists, but it smells like the user has
            // changed their delegate to point to a different provider. Link
            // the new provider.
            // 
            accountManager.link(claimedId, areq);
        } else {
        // Both are null, we are going to create a new account below.
        }
    }
    try {
        final com.google.gerrit.server.account.AuthResult arsp;
        switch(mode) {
            case REGISTER:
            case SIGN_IN:
                arsp = accountManager.authenticate(areq);
                final Cookie lastId = new Cookie(OpenIdUrls.LASTID_COOKIE, "");
                lastId.setPath(req.getContextPath() + "/");
                if (remember) {
                    lastId.setValue(rediscoverIdentifier);
                    lastId.setMaxAge(LASTID_AGE);
                } else {
                    lastId.setMaxAge(0);
                }
                rsp.addCookie(lastId);
                webSession.get().login(arsp, remember);
                if (arsp.isNew() && claimedIdentifier != null) {
                    final com.google.gerrit.server.account.AuthRequest linkReq = new com.google.gerrit.server.account.AuthRequest(claimedIdentifier);
                    linkReq.setDisplayName(areq.getDisplayName());
                    linkReq.setEmailAddress(areq.getEmailAddress());
                    accountManager.link(arsp.getAccountId(), linkReq);
                }
                callback(arsp.isNew(), req, rsp);
                break;
            case LINK_IDENTIY:
                {
                    arsp = accountManager.link(identifiedUser.get().getAccountId(), areq);
                    webSession.get().login(arsp, remember);
                    callback(false, req, rsp);
                    break;
                }
        }
    } catch (AccountException e) {
        log.error("OpenID authentication failure", e);
        cancelWithError(req, rsp, "Contact site administrator");
    }
}
#method_after
void doAuth(final HttpServletRequest req, final HttpServletResponse rsp) throws Exception {
    if (OMODE_CANCEL.equals(req.getParameter(OPENID_MODE))) {
        cancel(req, rsp);
        return;
    }
    // Process the authentication response.
    // 
    final SignInMode mode = signInMode(req);
    final String openidIdentifier = req.getParameter("openid.identity");
    final String claimedIdentifier = req.getParameter(P_CLAIMED);
    final String returnToken = req.getParameter(P_TOKEN);
    final boolean remember = "1".equals(req.getParameter(P_REMEMBER));
    final String rediscoverIdentifier = claimedIdentifier != null ? claimedIdentifier : openidIdentifier;
    final State state;
    if (!isAllowedOpenID(rediscoverIdentifier) || !isAllowedOpenID(openidIdentifier) || (claimedIdentifier != null && !isAllowedOpenID(claimedIdentifier))) {
        cancelWithError(req, rsp, "Provider not allowed");
        return;
    }
    state = init(rediscoverIdentifier, mode, remember, returnToken);
    if (state == null) {
        // Re-discovery must have failed, we can't run a login.
        // 
        cancel(req, rsp);
        return;
    }
    final String returnTo = req.getParameter("openid.return_to");
    if (returnTo != null && returnTo.contains("openid.rpnonce=")) {
        // Some providers (claimid.com) seem to embed these request
        // parameters into our return_to URL, and then give us them
        // in the return_to request parameter. But not all.
        // 
        state.retTo.put("openid.rpnonce", req.getParameter("openid.rpnonce"));
        state.retTo.put("openid.rpsig", req.getParameter("openid.rpsig"));
    }
    final VerificationResult result = manager.verify(state.retTo.toString(), new ParameterList(req.getParameterMap()), state.discovered);
    if (result.getVerifiedId() == null) /* authentication failure */
    {
        if ("Nonce verification failed.".equals(result.getStatusMsg())) {
            // We might be suffering from clock skew on this system.
            // 
            log.error("OpenID failure: " + result.getStatusMsg() + "  Likely caused by clock skew on this server," + " install/configure NTP.");
            cancelWithError(req, rsp, result.getStatusMsg());
        } else if (result.getStatusMsg() != null) {
            // Authentication failed.
            // 
            log.error("OpenID failure: " + result.getStatusMsg());
            cancelWithError(req, rsp, result.getStatusMsg());
        } else {
            // Assume authentication was canceled.
            // 
            cancel(req, rsp);
        }
        return;
    }
    final Message authRsp = result.getAuthResponse();
    SRegResponse sregRsp = null;
    FetchResponse fetchRsp = null;
    if (0 <= papeMaxAuthAge) {
        PapeResponse ext;
        boolean unsupported = false;
        try {
            ext = (PapeResponse) authRsp.getExtension(PapeMessage.OPENID_NS_PAPE);
        } catch (MessageException err) {
            // Far too many providers are unable to provide PAPE extensions
            // right now. Instead of blocking all of them log the error and
            // let the authentication complete anyway.
            // 
            log.error("Invalid PAPE response " + openidIdentifier + ": " + err);
            unsupported = true;
            ext = null;
        }
        if (!unsupported && ext == null) {
            log.error("No PAPE extension response from " + openidIdentifier);
            cancelWithError(req, rsp, "OpenID provider does not support PAPE.");
            return;
        }
    }
    if (authRsp.hasExtension(SRegMessage.OPENID_NS_SREG)) {
        final MessageExtension ext = authRsp.getExtension(SRegMessage.OPENID_NS_SREG);
        if (ext instanceof SRegResponse) {
            sregRsp = (SRegResponse) ext;
        }
    }
    if (authRsp.hasExtension(AxMessage.OPENID_NS_AX)) {
        final MessageExtension ext = authRsp.getExtension(AxMessage.OPENID_NS_AX);
        if (ext instanceof FetchResponse) {
            fetchRsp = (FetchResponse) ext;
        }
    }
    final com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(openidIdentifier);
    if (sregRsp != null) {
        areq.setDisplayName(sregRsp.getAttributeValue("fullname"));
        areq.setEmailAddress(sregRsp.getAttributeValue("email"));
    } else if (fetchRsp != null) {
        final String firstName = fetchRsp.getAttributeValue("FirstName");
        final String lastName = fetchRsp.getAttributeValue("LastName");
        final StringBuilder n = new StringBuilder();
        if (firstName != null && firstName.length() > 0) {
            n.append(firstName);
        }
        if (lastName != null && lastName.length() > 0) {
            if (n.length() > 0) {
                n.append(' ');
            }
            n.append(lastName);
        }
        areq.setDisplayName(n.length() > 0 ? n.toString() : null);
        areq.setEmailAddress(fetchRsp.getAttributeValue("Email"));
    }
    if (openIdDomains != null && openIdDomains.size() > 0) {
        // Administrator limited email domains, which can be used for OpenID.
        // Login process will only work if the passed email matches one
        // of these domains.
        // 
        final String email = areq.getEmailAddress();
        int emailAtIndex = email.lastIndexOf("@");
        if (emailAtIndex >= 0 && emailAtIndex < email.length() - 1) {
            final String emailDomain = email.substring(emailAtIndex);
            boolean match = false;
            for (String domain : openIdDomains) {
                if (emailDomain.equalsIgnoreCase(domain)) {
                    match = true;
                    break;
                }
            }
            if (!match) {
                log.error("Domain disallowed: " + emailDomain);
                cancelWithError(req, rsp, "Domain disallowed");
                return;
            }
        }
    }
    if (claimedIdentifier != null) {
        // The user used a claimed identity which has delegated to the verified
        // identity we have in our AuthRequest above. We still should have a
        // link between the two, so set one up if not present.
        // 
        Account.Id claimedId = accountManager.lookup(claimedIdentifier);
        Account.Id actualId = accountManager.lookup(areq.getExternalId());
        if (claimedId != null && actualId != null) {
            if (claimedId.equals(actualId)) {
            // Both link to the same account, that's what we expected.
            } else {
                // This is (for now) a fatal error. There are two records
                // for what might be the same user.
                // 
                log.error("OpenID accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + areq.getExternalId());
                cancelWithError(req, rsp, "Contact site administrator");
                return;
            }
        } else if (claimedId == null && actualId != null) {
            // Older account, the actual was already created but the claimed
            // was missing due to a bug in Gerrit. Link the claimed.
            // 
            final com.google.gerrit.server.account.AuthRequest linkReq = new com.google.gerrit.server.account.AuthRequest(claimedIdentifier);
            linkReq.setDisplayName(areq.getDisplayName());
            linkReq.setEmailAddress(areq.getEmailAddress());
            accountManager.link(actualId, linkReq);
        } else if (claimedId != null && actualId == null) {
            // Claimed account already exists, but it smells like the user has
            // changed their delegate to point to a different provider. Link
            // the new provider.
            // 
            accountManager.link(claimedId, areq);
        } else {
        // Both are null, we are going to create a new account below.
        }
    }
    try {
        final com.google.gerrit.server.account.AuthResult arsp;
        switch(mode) {
            case REGISTER:
            case SIGN_IN:
                arsp = accountManager.authenticate(areq);
                final Cookie lastId = new Cookie(OpenIdUrls.LASTID_COOKIE, "");
                lastId.setPath(req.getContextPath() + "/");
                if (remember) {
                    lastId.setValue(rediscoverIdentifier);
                    lastId.setMaxAge(LASTID_AGE);
                } else {
                    lastId.setMaxAge(0);
                }
                rsp.addCookie(lastId);
                webSession.get().login(arsp, remember);
                if (arsp.isNew() && claimedIdentifier != null) {
                    final com.google.gerrit.server.account.AuthRequest linkReq = new com.google.gerrit.server.account.AuthRequest(claimedIdentifier);
                    linkReq.setDisplayName(areq.getDisplayName());
                    linkReq.setEmailAddress(areq.getEmailAddress());
                    accountManager.link(arsp.getAccountId(), linkReq);
                }
                callback(arsp.isNew(), req, rsp);
                break;
            case LINK_IDENTIY:
                {
                    arsp = accountManager.link(identifiedUser.get().getAccountId(), areq);
                    webSession.get().login(arsp, remember);
                    callback(false, req, rsp);
                    break;
                }
        }
    } catch (AccountException e) {
        log.error("OpenID authentication failure", e);
        cancelWithError(req, rsp, "Contact site administrator");
    }
}
#end_block

#method_before
public void addGroupInclude(final AccountGroup.Id groupId, final String groupName, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final AccountGroup a = findGroup(groupName);
            if (!control.canAddGroup(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupInclude.Key key = new AccountGroupInclude.Key(groupId, a.getGroupUUID());
            AccountGroupInclude m = db.accountGroupIncludes().get(key);
            if (m == null) {
                m = new AccountGroupInclude(key);
                db.accountGroupIncludesAudit().insert(Collections.singleton(new AccountGroupIncludeAudit(m, getAccountId())));
                db.accountGroupIncludes().insert(Collections.singleton(m));
                groupIncludeCache.evictInclude(a.getGroupUUID());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#method_after
public void addGroupInclude(final AccountGroup.Id groupId, final AccountGroup.UUID incGroupUUID, final String incGroupName, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            if (incGroupUUID == null) {
                throw new Failure(new NoSuchGroupException(incGroupName));
            }
            if (!control.canAddGroup(incGroupUUID)) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupIncludeByUuid.Key key = new AccountGroupIncludeByUuid.Key(groupId, incGroupUUID);
            AccountGroupIncludeByUuid m = db.accountGroupIncludesByUuid().get(key);
            if (m == null) {
                m = new AccountGroupIncludeByUuid(key);
                db.accountGroupIncludesByUuidAudit().insert(Collections.singleton(new AccountGroupIncludeByUuidAudit(m, getAccountId())));
                db.accountGroupIncludesByUuid().insert(Collections.singleton(m));
                groupIncludeCache.evictInclude(incGroupUUID);
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#end_block

#method_before
public void deleteGroupIncludes(final AccountGroup.Id groupId, final Set<AccountGroupInclude.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupInclude.Key k : keys) {
                if (!groupId.equals(k.getGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            final Set<AccountGroup.Id> groupsToEvict = new HashSet<AccountGroup.Id>();
            for (final AccountGroupInclude.Key k : keys) {
                final AccountGroupInclude m = db.accountGroupIncludes().get(k);
                if (m != null) {
                    if (!control.canRemoveGroup(m.getIncludeId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupIncludeAudit audit = null;
                    for (AccountGroupIncludeAudit a : db.accountGroupIncludesAudit().byGroupInclude(m.getGroupId(), m.getIncludeId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupIncludesAudit().update(Collections.singleton(audit));
                    }
                    db.accountGroupIncludes().delete(Collections.singleton(m));
                    groupsToEvict.add(k.getIncludeId());
                }
            }
            for (AccountGroup group : db.accountGroups().get(groupsToEvict)) {
                groupIncludeCache.evictInclude(group.getGroupUUID());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteGroupIncludes(final AccountGroup.Id groupId, final Set<AccountGroupIncludeByUuid.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupIncludeByUuid.Key k : keys) {
                if (!groupId.equals(k.getGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            final Set<AccountGroup.UUID> groupsToEvict = new HashSet<AccountGroup.UUID>();
            for (final AccountGroupIncludeByUuid.Key k : keys) {
                final AccountGroupIncludeByUuid m = db.accountGroupIncludesByUuid().get(k);
                if (m != null) {
                    if (!control.canRemoveGroup(m.getIncludeUUID())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupIncludeByUuidAudit audit = null;
                    for (AccountGroupIncludeByUuidAudit a : db.accountGroupIncludesByUuidAudit().byGroupInclude(m.getGroupId(), m.getIncludeUUID())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupIncludesByUuidAudit().update(Collections.singleton(audit));
                    }
                    db.accountGroupIncludesByUuid().delete(Collections.singleton(m));
                    groupsToEvict.add(k.getIncludeUUID());
                }
            }
            for (AccountGroup.UUID uuid : groupsToEvict) {
                groupIncludeCache.evictInclude(uuid);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Option(name = "--group", aliases = "-g", metaVar = "GROUP", usage = "initial set of groups to be included in the group")
void addGroup(final AccountGroup.UUID uuid) {
    initialGroups.add(uuid);
}
#method_after
@Option(name = "--group", aliases = "-g", metaVar = "GROUP", usage = "initial set of groups to be included in the group")
void addGroup(final AccountGroup.UUID id) {
    initialGroups.add(id);
}
#end_block

#method_before
private void addGroups(final AccountGroup.Id groupId, final Collection<? extends AccountGroup.UUID> groups) throws OrmException {
    final List<AccountGroupInclude> includeList = new ArrayList<AccountGroupInclude>();
    final List<AccountGroupIncludeAudit> includesAudit = new ArrayList<AccountGroupIncludeAudit>();
    for (AccountGroup.UUID includeUUID : groups) {
        final AccountGroupInclude groupInclude = new AccountGroupInclude(new AccountGroupInclude.Key(groupId, includeUUID));
        includeList.add(groupInclude);
        final AccountGroupIncludeAudit audit = new AccountGroupIncludeAudit(groupInclude, currentUser.getAccountId());
        includesAudit.add(audit);
    }
    db.accountGroupIncludes().insert(includeList);
    db.accountGroupIncludesAudit().insert(includesAudit);
    for (AccountGroup.UUID groupUUID : groups) {
        groupIncludeCache.evictInclude(groupUUID);
    }
}
#method_after
private void addGroups(final AccountGroup.Id groupId, final Collection<? extends AccountGroup.UUID> groups) throws OrmException {
    final List<AccountGroupIncludeByUuid> includeList = new ArrayList<AccountGroupIncludeByUuid>();
    final List<AccountGroupIncludeByUuidAudit> includesAudit = new ArrayList<AccountGroupIncludeByUuidAudit>();
    for (AccountGroup.UUID includeUUID : groups) {
        final AccountGroupIncludeByUuid groupInclude = new AccountGroupIncludeByUuid(new AccountGroupIncludeByUuid.Key(groupId, includeUUID));
        includeList.add(groupInclude);
        final AccountGroupIncludeByUuidAudit audit = new AccountGroupIncludeByUuidAudit(groupInclude, currentUser.getAccountId());
        includesAudit.add(audit);
    }
    db.accountGroupIncludesByUuid().insert(includeList);
    db.accountGroupIncludesByUuidAudit().insert(includesAudit);
    for (AccountGroup.UUID uuid : groups) {
        groupIncludeCache.evictInclude(uuid);
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
    factory(NotesBranchUtil.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
    factory(NotesBranchUtil.Factory.class);
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            boolean validCommit = CommitUtil.validateCommit(destBranchCtl, newChange, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    boolean validCommit = CommitUtil.validateCommit(changeCtl.getRefControl(), inputCommand, newCommit, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

        public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
            reject(newChange, rejectReason);
        }

        @Override
        public void onAccepted(List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
        }
    });
    if (!validCommit) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            boolean validCommit = CommitUtil.validateCommit(ctl, cmd, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    for (PatchSetApproval a : getApprovalsForCommit(args.db, n)) {
                        args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(newPatchSet.getId(), a)));
                    }
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    List<PatchSetApproval> approvals = Lists.newArrayList();
                    for (PatchSetApproval a : getApprovalsForCommit(args.db, n)) {
                        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
                    }
                    args.db.patchSetApprovals().insert(approvals);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#end_block

#method_before
protected final Watchers getWatches(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    if (changeData == null) {
        return matching;
    }
    Set<Account.Id> projectWatchers = new HashSet<Account.Id>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(change.getProject())) {
        projectWatchers.add(w.getAccountId());
        if (w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    ProjectState state = projectState;
    while (state != null) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\": %s", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage()));
                }
            }
        }
        state = state.getParentState();
    }
    return matching;
}
#method_after
protected final Watchers getWatches(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<Account.Id>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(change.getProject())) {
        projectWatchers.add(w.getAccountId());
        if (w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    ProjectState state = projectState;
    while (state != null) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\": %s", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage()));
                }
            }
        }
        state = state.getParentState();
    }
    return matching;
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
boolean validate(boolean ignoreNoChanges) throws IOException {
    if (inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !ignoreNoChanges) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    warnMalformedMessage(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (newProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    warnMalformedMessage(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                return change;
            }
        });
        if (change == null) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToLatestPatchSet(db, change);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : patchSetApprovals) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        approvalsUtil.addReviewers(db, change, newPatchSet, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    replication.fire(project.getNameKey(), newPatchSet.getRefName());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, newPatchSet.getId());
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : patchSetApprovals) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        approvalsUtil.addReviewers(db, change, newPatchSet, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    replication.fire(project.getNameKey(), newPatchSet.getRefName());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    // Execute commit validation plugins
    for (CommitValidationListener validator : commitValidators) {
        try {
            List<CommitValidationMessage> results = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
            messages.addAll(results);
        } catch (CommitValidationException error) {
            reject(cmd, error.getMessage());
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    // Execute commit validation plugins
    for (CommitValidationListener validator : commitValidators) {
        try {
            messages.addAll(validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser)));
        } catch (CommitValidationException error) {
            reject(cmd, error.getMessage());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = new PatchSet.Id(change.getId(), Change.INITIAL_PATCH_SET_ID);
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public String getUnifiedDiff() {
    PatchList patchList;
    try {
        patchList = getPatchList();
        if (patchList.getOldId() == null) {
            // Currently these always have a null oldId in the PatchList.
            return "[There is no diff output.\n" + " Reason: This change has more than two parents.\n" + " Gerrit does not support for generating diff output\n" + " between this kind change and its parents by far.]\n";
        }
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot format patch", e);
        return "";
    }
    TemporaryBuffer.Heap buf = new TemporaryBuffer.Heap(args.settings.maximumDiffSize);
    DiffFormatter fmt = new DiffFormatter(buf);
    Repository git;
    try {
        git = args.server.openRepository(change.getProject());
    } catch (IOException e) {
        log.error("Cannot open repository to format patch", e);
        return "";
    }
    try {
        fmt.setRepository(git);
        fmt.setDetectRenames(true);
        fmt.format(patchList.getOldId(), patchList.getNewId());
        return RawParseUtils.decode(buf.toByteArray());
    } catch (IOException e) {
        if (JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) {
            return "";
        }
        log.error("Cannot format patch", e);
        return "";
    } finally {
        fmt.release();
        git.close();
    }
}
#method_after
public String getUnifiedDiff() {
    PatchList patchList;
    try {
        patchList = getPatchList();
        if (patchList.getOldId() == null) {
            // Currently these always have a null oldId in the PatchList.
            return "[Octopus merge; cannot be formatted as a diff.]\n";
        }
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot format patch", e);
        return "";
    }
    TemporaryBuffer.Heap buf = new TemporaryBuffer.Heap(args.settings.maximumDiffSize);
    DiffFormatter fmt = new DiffFormatter(buf);
    Repository git;
    try {
        git = args.server.openRepository(change.getProject());
    } catch (IOException e) {
        log.error("Cannot open repository to format patch", e);
        return "";
    }
    try {
        fmt.setRepository(git);
        fmt.setDetectRenames(true);
        fmt.format(patchList.getOldId(), patchList.getNewId());
        return RawParseUtils.decode(buf.toByteArray());
    } catch (IOException e) {
        if (JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) {
            return "";
        }
        log.error("Cannot format patch", e);
        return "";
    } finally {
        fmt.release();
        git.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (RepositoryNotFoundException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(openRepository(change), patchsetCreatedHook, args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(openRepository(change), commentAddedHook, args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<ApprovalCategory.Id, ApprovalCategoryValue.Id> approval : approvals.entrySet()) {
        addArg(args, "--" + approval.getKey().get(), Short.toString(approval.getValue().get()));
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(openRepository(change), changeMergedHook, args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(openRepository(change), changeAbandonedHook, args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(openRepository(refName.getParentKey()), refUpdatedHook, args);
}
#method_after
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-id", cla.getId().toString());
        runHook(claSignedHook, args);
    }
}
#method_after
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<String>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, File hook, List<String> args) {
    if (project != null && hook.exists()) {
        hookQueue.execute(new AsyncHookTask(project, hook, args));
    }
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new HookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Repository repo, File hook, List<String> args) throws TimeoutException {
    if (hook.exists()) {
        SyncHookTask syncHook = new SyncHookTask(repo, hook, args);
        FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
        syncHookThreadPool.execute(task);
        try {
            return task.get(syncHookTimeout, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (ExecutionException e) {
            log.error("Error running hook " + hook.getAbsolutePath(), e);
        } catch (TimeoutException e) {
            log.error("Synchronous hook timed out " + hook.getAbsolutePath());
            throw e;
        }
    }
    return null;
}
#method_after
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) throws TimeoutException {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<HookResult>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public HookResult call() throws Exception {
    HookResult result = null;
    StringBuilder output = new StringBuilder();
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (repo != null) {
            pb.directory(repo.getDirectory());
            final Map<String, String> env = pb.environment();
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        Process ps = pb.start();
        ps.getOutputStream().close();
        BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
        try {
            String line = br.readLine();
            while (line != null) {
                output.append(line);
                line = br.readLine();
                if (line != null) {
                    output.append(System.getProperty("line.separator"));
                }
            }
        } finally {
            try {
                br.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output.toString());
        }
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return result;
}
#method_after
@Override
public HookResult call() throws Exception {
    return super.runHook();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        // Run the update hook, if it returns output then reject the push
        // passing the output back to the user
        String output = hooks.doUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (output != null) {
            reject(cmd, output);
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        Map<String, Ref> refs = repo.getAllRefs();
        existingObjects = new ArrayList<ObjectId>(refs.size());
        for (Ref r : refs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#method_after
private Collection<ObjectId> existingObjects() {
    if (existingObjects == null) {
        existingObjects = new ArrayList<ObjectId>(allRefs.size());
        for (Ref r : allRefs.values()) {
            existingObjects.add(r.getObjectId());
        }
    }
    return existingObjects;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        final String message = validationResult.getValidationReason();
        if (!validationResult.isValidated()) {
            reject(cmd, message);
            return false;
        } else if (!Strings.isNullOrEmpty(message)) {
            addMessage(String.format("(W) %s", message));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.nextPatchSetId();
        change.setTopic(changeToRevert.getTopic());
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        Change change = db.changes().get(changeId);
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.addParentId(commit);
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setAuthor(authorIdent);
        commitBuilder.setCommitter(myIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        change.nextPatchSetId();
        final PatchSet originalPS = db.patchSets().get(patchSetId);
        final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
        newPatchSet.setCreatedOn(change.getCreatedOn());
        newPatchSet.setUploader(change.getOwner());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
        final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            Change updatedChange;
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
            }
            ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
            db.patchSets().insert(Collections.singleton(newPatchSet));
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(patchSetId)) {
                        return null;
                    }
                    if (change.getStatus() != Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            cmsg.setMessage(msg);
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.addParentId(commit);
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setAuthor(authorIdent);
            commitBuilder.setCommitter(myIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(change.getCreatedOn());
            newPatchSet.setUploader(change.getOwner());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus() == Change.Status.NEW && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    detail.setCanEditCommitMessage(change.getStatus().isOpen() && control.canAddPatchSet());
    detail.setCanEditTopicName(control.canEditTopicName());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AbandonChangeHandler.Factory.class);
            factory(EditCommitMessageHandler.Factory.class);
            factory(AlterTopicHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EditCommitMessageHandler.Factory.class);
            factory(RestoreChangeHandler.Factory.class);
            factory(RevertChange.Factory.class);
            factory(RebaseChangeHandler.Factory.class);
            factory(ChangeDetailFactory.Factory.class);
            factory(IncludedInDetailFactory.Factory.class);
            factory(PatchSetDetailFactory.Factory.class);
            factory(PatchSetPublishDetailFactory.Factory.class);
            factory(SubmitAction.Factory.class);
            factory(PublishAction.Factory.class);
            factory(DeleteDraftChange.Factory.class);
        }
    });
    rpc(ChangeDetailServiceImpl.class);
    rpc(ChangeManageServiceImpl.class);
}
#end_block

#method_before
public void display(final String commitMessage) {
    display(null, null, null, commitMessage);
}
#method_after
public void display(final String commitMessage) {
    display(null, null, false, commitMessage);
}
#end_block

#method_before
public void display(Change.Id changeId, final PatchSet.Id patchSetId, Boolean starred, final String commitMessage) {
    starPanel.clear();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null && patchSetId != null) {
        ChangeDetailCache detailCache = ChangeCache.get(patchSetId.getParentKey()).getChangeDetailCache();
        ChangeDetail changeDetail = detailCache.get();
        if (changeDetail.canEditCommitMessage()) {
            permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
            permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new EditCommitMessageActionDialog() {

                        {
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.editCommitMessage(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            edit.addStyleName(Gerrit.RESOURCES.css().changeInfoBlockEdit());
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#method_after
public void display(final PatchSet.Id patchSetId, Boolean starred, Boolean canEditCommitMessage, final String commitMessage) {
    starPanel.clear();
    Change.Id changeId = patchSetId.getParentKey();
    if (changeId != null && starred != null && Gerrit.isSignedIn()) {
        StarredChanges.Icon star = StarredChanges.createIcon(changeId, starred);
        star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon());
        starPanel.add(star);
        if (keysAction != null) {
            keysAction.add(StarredChanges.newKeyCommand(star));
        }
    }
    permalinkPanel.clear();
    if (changeId != null) {
        permalinkPanel.add(new ChangeLink(Util.C.changePermalink(), changeId));
        permalinkPanel.add(new CopyableLabel(ChangeLink.permalink(changeId), false));
        if (canEditCommitMessage) {
            final Image edit = new Image(Gerrit.RESOURCES.edit());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    new CommentedActionDialog<ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new ChangeDetailCache.IgnoreErrorCallback() {
                    }) {

                        {
                            message.setCharacterWidth(80);
                            message.setVisibleLines(20);
                            message.setText(commitMessage);
                        }

                        @Override
                        public void onSend() {
                            Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), createCallback());
                        }
                    }.center();
                }
            });
            permalinkPanel.add(edit);
        }
    }
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    String commitSummary = splitCommitMessage[0];
    String commitBody = "";
    if (splitCommitMessage.length > 1) {
        commitBody = splitCommitMessage[1];
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.getStyle().setDisplay(Display.NONE);
    } else {
        // Linkify commit body
        SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
        commitBodyLinkified = commitBodyLinkified.linkify();
        commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n\n", "<p></p>");
        commitBodyLinkified = commitBodyLinkified.replaceAll("\n", "<br />");
        commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new InvalidChangeOperationException("Not allowed to add new Patch Sets to: " + changeId.toString());
    }
    ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
public void display(Change chg, Boolean starred, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.getId(), chg.currentPatchSetId(), starred, info.getMessage());
}
#method_after
public void display(Change chg, Boolean starred, Boolean canEditCommitMessage, PatchSetInfo info, final AccountInfoCache acc, SubmitTypeRecord submitTypeRecord) {
    infoBlock.display(chg, acc, submitTypeRecord);
    messageBlock.display(chg.currentPatchSetId(), starred, canEditCommitMessage, info.getMessage());
}
#end_block

#method_before
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#method_after
@Override
protected void onCellDoubleClick(final int row, final int column) {
    if (column > C_ARROW && getRowItem(row) instanceof PatchLine) {
        final PatchLine pl = (PatchLine) getRowItem(row);
        switch(pl.getType()) {
            case DELETE:
            case CONTEXT:
                createCommentEditor(row + 1, PC, pl.getLineA(), (short) 0);
                break;
            case INSERT:
                createCommentEditor(row + 1, PC, pl.getLineB(), (short) 1);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final SparseHtmlFile a = getSparseHtmlFileA(script);
    final SparseHtmlFile b = getSparseHtmlFileB(script);
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(nc);
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            } else {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final boolean syntaxHighlighting = script.getDiffPrefs().isSyntaxHighlighting();
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final EditList.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.next()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, false, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumberForSideA(nc, hunk.getCurA());
                padLineNumberForSideB(nc);
                appendLineText(nc, syntaxHighlighting, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                if (a.size() == hunk.getCurA() && script.getA().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumberForSideA(nc);
                appendLineNumberForSideB(nc, hunk.getCurB());
                appendLineText(nc, syntaxHighlighting, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && script.getB().isMissingNewlineAtEnd()) {
                    appendNoLF(nc);
                }
            }
        }
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n;
        switch(l.getType()) {
            case CONTEXT:
                n = Gerrit.RESOURCES.css().diffTextCONTEXT();
                break;
            case DELETE:
                n = Gerrit.RESOURCES.css().diffTextDELETE();
                break;
            case INSERT:
                n = Gerrit.RESOURCES.css().diffTextINSERT();
                break;
            default:
                continue;
        }
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == 0) {
            fora = cd.getForA(0);
            forb = cd.getForB(0);
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
        } else {
            row++;
            continue;
        }
        row++;
        if (!fora.isEmpty() && !forb.isEmpty()) {
            all.clear();
            all.addAll(fora);
            all.addAll(forb);
            Collections.sort(all, BY_DATE);
            row = insert(all, row, expandComments);
        } else if (!fora.isEmpty()) {
            row = insert(fora, row, expandComments);
        } else if (!forb.isEmpty()) {
            row = insert(forb, row, expandComments);
        }
    }
}
#method_after
@Override
public void display(final CommentDetail cd, boolean expandComments) {
    if (cd.isEmpty()) {
        return;
    }
    setAccountInfoCache(cd.getAccounts());
    final ArrayList<PatchLineComment> all = new ArrayList<PatchLineComment>();
    for (int row = 0; row < table.getRowCount(); ) {
        final List<PatchLineComment> fora;
        final List<PatchLineComment> forb;
        if (row == R_HEAD) {
            fora = cd.getForA(R_HEAD);
            forb = cd.getForB(R_HEAD);
            row++;
            if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            }
            rowOfTableHeaderB = row;
            borderRowOfFileComment = row + 1;
            if (!forb.isEmpty()) {
                // Skip the Header of sideB.
                row++;
                row = insert(forb, row, expandComments);
                borderRowOfFileComment = row;
                createFileCommentBorderRow();
            }
        } else if (getRowItem(row) instanceof PatchLine) {
            final PatchLine pLine = (PatchLine) getRowItem(row);
            fora = cd.getForA(pLine.getLineA());
            forb = cd.getForB(pLine.getLineB());
            row++;
            if (!fora.isEmpty() && !forb.isEmpty()) {
                all.clear();
                all.addAll(fora);
                all.addAll(forb);
                Collections.sort(all, BY_DATE);
                row = insert(all, row, expandComments);
            } else if (!fora.isEmpty()) {
                row = insert(fora, row, expandComments);
            } else if (!forb.isEmpty()) {
                row = insert(forb, row, expandComments);
            }
        } else {
            row++;
            continue;
        }
    }
}
#end_block

#method_before
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, PC - 2, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC - 1, Gerrit.RESOURCES.css().lineNumber());
    fmt.addStyleName(row, PC, Gerrit.RESOURCES.css().diffText());
}
#method_after
@Override
protected void insertRow(final int row) {
    super.insertRow(row);
    final CellFormatter fmt = table.getCellFormatter();
    defaultStyle(row, fmt);
}
#end_block

#method_before
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        insertRow(row);
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#method_after
private int insert(final List<PatchLineComment> in, int row, boolean expandComment) {
    for (Iterator<PatchLineComment> ci = in.iterator(); ci.hasNext(); ) {
        final PatchLineComment c = ci.next();
        if (c.getLine() == R_HEAD) {
            insertFileCommentRow(row);
        } else {
            insertRow(row);
        }
        bindComment(row, PC, c, !ci.hasNext(), expandComment);
        row++;
    }
    return row;
}
#end_block

#method_before
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendFileHeader(final SafeHtmlBuilder m, final String line) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextFileHeader());
    m.append(line);
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendHunkHeader(final SafeHtmlBuilder m, final Hunk hunk) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextHunkHeader());
    m.append("@@ -");
    appendRange(m, hunk.getCurA() + 1, hunk.getEndA() - hunk.getCurA());
    m.append(" +");
    appendRange(m, hunk.getCurB() + 1, hunk.getEndB() - hunk.getCurB());
    m.append(" @@");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, boolean syntaxHighlighting, final PatchLine.Type type, final SparseHtmlFile src, final int i) {
    final SafeHtml text = src.getSafeHtmlLine(i);
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().fileLine());
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT());
            m.nbsp();
            m.append(text);
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            }
            m.append("-");
            m.append(text);
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT());
            if (syntaxHighlighting) {
                m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            }
            m.append("+");
            m.append(text);
            break;
    }
    m.closeTd();
}
#end_block

#method_before
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumber(m);
    padLineNumber(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#method_after
private void appendNoLF(final SafeHtmlBuilder m) {
    openLine(m);
    padLineNumberForSideA(m);
    padLineNumberForSideB(m);
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().diffText());
    m.addStyleName(Gerrit.RESOURCES.css().diffTextNoLF());
    m.append("\\ No newline at end of file");
    m.closeTd();
    closeLine(m);
}
#end_block

#method_before
public static String toProjectDashboard(Project.NameKey projectName, String dashboardId) {
    return PROJECTS + URL.encodePathSegment(projectName.get()) + DASHBOARDS + PageLinks.encodeDashboardId(dashboardId);
}
#method_after
public static String toProjectDashboard(Project.NameKey projectName, String dashboardId) {
    return PROJECTS + projectName.get() + DASHBOARDS + dashboardId;
}
#end_block

#method_before
public static String defaultOf(Project proj) {
    return Objects.firstNonNull(proj.getLocalDefaultDashboard(), Strings.nullToEmpty(proj.getDefaultDashboard()));
}
#method_after
public static String defaultOf(Project proj) {
    final String defaultId = Objects.firstNonNull(proj.getLocalDefaultDashboard(), Strings.nullToEmpty(proj.getDefaultDashboard()));
    if (defaultId.startsWith(REFS_DASHBOARDS)) {
        return defaultId.substring(REFS_DASHBOARDS.length());
    } else {
        return defaultId;
    }
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 4) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, A, psListOfHeaderA);
    table.setWidget(R_HEAD, B, psListOfHeaderB);
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    isFile = isFile();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    Label patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (!isFile) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    if (!isFile()) {
        return null;
    }
    Patch.Key key = (idSideA == null) ? patchKey : (new Patch.Key(idSideA, patchKey.get()));
    String sideURL = (side == Side.A) ? "1" : "0";
    final String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    final Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(key.toString()) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#end_block

#method_before
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    super.onCellSingleClick(row, column);
    if (column == 1 || column == 2) {
        if (!"".equals(table.getText(row, column))) {
            onCellDoubleClick(row, column);
        }
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    prepareHeaderWidgets(script, detail);
    table.setWidget(R_HEAD, PC, psListOfHeaderA);
    table.setWidget(rowOfTableHeaderB, PC, psListOfHeaderB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), CommitValidatorListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    newProgress.end();
    doReplaces();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                commandProgress.update(1);
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        if (cmd.getResult().equals(ReceiveCommand.Result.NOT_ATTEMPTED)) {
            cmd.execute(rp);
        }
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidatorListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.validate(cmd, project, ctl.getRefName(), c, currentUser);
        if (!validationResult.validated) {
            reject(cmd, validationResult.why);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (projectControl.getProjectState().isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader in commit message footer");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (projectControl.getProjectState().isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message footer");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message footer";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    for (CommitValidationListener validator : commitValidators) {
        CommitValidationResult validationResult = validator.onCommitReceived(new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser));
        String pluginName = pluginLoader.getPluginName(validator);
        if (!validationResult.validated) {
            reject(cmd, String.format("%s (rejected by plugin %s)", validationResult.message, pluginName));
            return false;
        } else if (!Strings.isNullOrEmpty(validationResult.message)) {
            addMessage(String.format("%s (from plugin %s)", pluginName));
        }
    }
    return true;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
public static CommitValidationResult newFailure(String why) {
    return new CommitValidationResult(false, why);
}
#method_after
public static CommitValidationResult newFailure(String message) {
    return new CommitValidationResult(false, message);
}
#end_block

#method_before
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    String browserCssName;
    String prettifyCssName;
    String prettifyJsName;
    serveRegex(ROOT_REGEX).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#method_after
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    serveRegex(ROOT_REGEX).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#end_block

#method_before
private void setDefaultFields(FilterConfig config) throws ServletException {
    if (renderer != null && urls != null && accessFactory != null && resolver != null && visibilityCache != null) {
        return;
    }
    String configPath = config.getInitParameter(CONFIG_PATH_PARAM);
    if (configPath == null) {
        throw new ServletException("Missing required parameter " + configPath);
    }
    FileBasedConfig jgitConfig = new FileBasedConfig(new File(configPath), FS.DETECTED);
    try {
        jgitConfig.load();
    } catch (IOException e) {
        throw new ServletException(e);
    } catch (ConfigInvalidException e) {
        throw new ServletException(e);
    }
    if (renderer == null) {
        String staticPrefix = config.getServletContext().getContextPath() + STATIC_PREFIX;
        String customTemplates = jgitConfig.getString("gitiles", null, "customTemplates");
        String siteTitle = jgitConfig.getString("gitiles", null, "siteTitle");
        // TODO(dborowitz): Automatically set to true when run with mvn jetty:run.
        if (jgitConfig.getBoolean("gitiles", null, "reloadTemplates", false)) {
            renderer = new DebugRenderer(staticPrefix, customTemplates, Joiner.on(File.separatorChar).join(System.getProperty("user.dir"), "gitiles-servlet", "src", "main", "resources", "com", "google", "gitiles", "templates"), siteTitle);
        } else {
            renderer = new DefaultRenderer(staticPrefix, Renderer.toFileURL(customTemplates), siteTitle);
        }
    }
    if (urls == null) {
        try {
            urls = new DefaultUrls(jgitConfig.getString("gitiles", null, "canonicalHostName"), getBaseGitUrl(jgitConfig), getGerritUrl(jgitConfig));
        } catch (UnknownHostException e) {
            throw new ServletException(e);
        }
    }
    linkifier = new Linkifier(urls);
    if (accessFactory == null || resolver == null) {
        String basePath = jgitConfig.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = jgitConfig.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(jgitConfig), fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
    if (visibilityCache == null) {
        if (jgitConfig.getSubsections("cache").contains("visibility")) {
            visibilityCache = new VisibilityCache(false, ConfigUtil.getCacheBuilder(jgitConfig, "visibility"));
        } else {
            visibilityCache = new VisibilityCache(false);
        }
    }
}
#method_after
private void setDefaultFields(FilterConfig config) throws ServletException {
    if (renderer != null && urls != null && accessFactory != null && resolver != null && visibilityCache != null) {
        return;
    }
    String configPath = config.getInitParameter(CONFIG_PATH_PARAM);
    if (configPath == null) {
        throw new ServletException("Missing required parameter " + configPath);
    }
    FileBasedConfig jgitConfig = new FileBasedConfig(new File(configPath), FS.DETECTED);
    try {
        jgitConfig.load();
    } catch (IOException e) {
        throw new ServletException(e);
    } catch (ConfigInvalidException e) {
        throw new ServletException(e);
    }
    if (renderer == null) {
        String staticPrefix = config.getServletContext().getContextPath() + STATIC_PREFIX;
        String customTemplates = jgitConfig.getString("gitiles", null, "customTemplates");
        String siteTitle = Objects.firstNonNull(jgitConfig.getString("gitiles", null, "siteTitle"), "Gitiles");
        // TODO(dborowitz): Automatically set to true when run with mvn jetty:run.
        if (jgitConfig.getBoolean("gitiles", null, "reloadTemplates", false)) {
            renderer = new DebugRenderer(staticPrefix, customTemplates, Joiner.on(File.separatorChar).join(System.getProperty("user.dir"), "gitiles-servlet", "src", "main", "resources", "com", "google", "gitiles", "templates"), siteTitle);
        } else {
            renderer = new DefaultRenderer(staticPrefix, Renderer.toFileURL(customTemplates), siteTitle);
        }
    }
    if (urls == null) {
        try {
            urls = new DefaultUrls(jgitConfig.getString("gitiles", null, "canonicalHostName"), getBaseGitUrl(jgitConfig), getGerritUrl(jgitConfig));
        } catch (UnknownHostException e) {
            throw new ServletException(e);
        }
    }
    linkifier = new Linkifier(urls);
    if (accessFactory == null || resolver == null) {
        String basePath = jgitConfig.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = jgitConfig.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(jgitConfig), fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
    if (visibilityCache == null) {
        if (jgitConfig.getSubsections("cache").contains("visibility")) {
            visibilityCache = new VisibilityCache(false, ConfigUtil.getCacheBuilder(jgitConfig, "visibility"));
        } else {
            visibilityCache = new VisibilityCache(false);
        }
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && ChangeUtil.canDoRebase(db, change, repoManager));
    detail.setCanEdit(control.getRefControl().canWrite());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    List<SubmitRecord> submitRecords = control.getSubmitRecords(db, patch);
    for (SubmitRecord rec : submitRecords) {
        if (rec.labels != null) {
            for (SubmitRecord.Label lbl : rec.labels) {
                aic.want(lbl.appliedBy);
            }
        }
        if (detail.getChange().getStatus().isOpen() && rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit() && ProjectUtil.branchExists(repoManager, change.getDest())) {
            detail.setCanSubmit(true);
        }
    }
    detail.setSubmitRecords(submitRecords);
    detail.setSubmitTypeRecord(control.getSubmitTypeRecord(db, patch));
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase() && RebaseChange.canDoRebase(db, change, repoManager, currentPatchSetAncestors, currentDepPatchSets, currentDepChanges));
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<PatchSet.Id> descendants = new HashSet<PatchSet.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                if (descendants.add(a.getPatchSet())) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null && ac.getProject().equals(detail.getChange().getProject())) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final PatchSet.Id a : descendants) {
        final Change ac = m.get(a.getParentKey());
        if (ac != null && ac.currentPatchSetId().equals(a)) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#method_after
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    currentDepPatchSets = new ArrayList<PatchSet>();
    currentDepChanges = new ArrayList<Change>();
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    currentPatchSetAncestors = db.patchSetAncestors().ancestorsOf(psId).toList();
    for (PatchSetAncestor a : currentPatchSetAncestors) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            currentDepPatchSets.add(p);
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<PatchSet.Id> descendants = new HashSet<PatchSet.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                if (descendants.add(a.getPatchSet())) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final CurrentUser currentUser = control.getCurrentUser();
    Account.Id currentUserId = null;
    if (currentUser instanceof IdentifiedUser) {
        currentUserId = ((IdentifiedUser) currentUser).getAccountId();
    }
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null && ac.getProject().equals(detail.getChange().getProject())) {
            currentDepChanges.add(ac);
            if (ac.getStatus().getCode() != Change.STATUS_DRAFT || ac.getOwner().equals(currentUserId) || isReviewer(ac)) {
                dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
            }
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final PatchSet.Id a : descendants) {
        final Change ac = m.get(a.getParentKey());
        if (ac != null && ac.currentPatchSetId().equals(a)) {
            if (ac.getStatus().getCode() != Change.STATUS_DRAFT || ac.getOwner().equals(currentUserId) || isReviewer(ac)) {
                neededBy.add(newChangeInfo(ac, null));
            }
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
protected void doLogout(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    webSession.get().logout();
    if (logoutUrl != null) {
        rsp.sendRedirect(logoutUrl);
    } else {
        String url = urlProvider.get();
        if (Strings.isNullOrEmpty(url)) {
            url = req.getContextPath();
        }
        if (Strings.isNullOrEmpty(url)) {
            url = "/";
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        rsp.sendRedirect(url);
    }
}
#method_after
private void doLogout(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    webSession.get().logout();
    if (logoutUrl != null) {
        rsp.sendRedirect(logoutUrl);
    } else {
        String url = urlProvider.get();
        if (Strings.isNullOrEmpty(url)) {
            url = req.getContextPath();
        }
        if (Strings.isNullOrEmpty(url)) {
            url = "/";
        }
        if (!url.endsWith("/")) {
            url += "/";
        }
        rsp.sendRedirect(url);
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final String sid = webSession.get().getToken();
    final String username = webSession.get().getCurrentUser().getUserName();
    final String what = "sign out";
    final AuditEvent record = new AuditEvent(sid, username, what, null);
    try {
        doLogout(req, rsp);
    } finally {
        record.setResult("{\"Success\":true}");
        audit.track(record);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final String sid = webSession.get().getToken();
    final CurrentUser currentUser = webSession.get().getCurrentUser();
    final String what = "sign out";
    final long when = System.currentTimeMillis();
    try {
        doLogout(req, rsp);
    } finally {
        audit.dispatch(new AuditEvent(sid, currentUser, what, when, null, null));
    }
}
#end_block

#method_before
public void setSession(final ServerSession session) {
    final SshSession s = session.getAttribute(SshSession.KEY);
    this.ctx = new Context(s, commandLine);
}
#method_after
public void setSession(final ServerSession session) {
    final SshSession s = session.getAttribute(SshSession.KEY);
    this.ctx = sshScope.newContext(s, commandLine);
}
#end_block

#method_before
private void onStart() throws IOException {
    synchronized (this) {
        final Context old = SshScope.set(ctx);
        try {
            cmd = dispatcher.get();
            cmd.setArguments(argv);
            cmd.setInputStream(in);
            cmd.setOutputStream(out);
            cmd.setErrorStream(err);
            cmd.setExitCallback(new ExitCallback() {

                @Override
                public void onExit(int rc, String exitMessage) {
                    exit.onExit(translateExit(rc), exitMessage);
                    log(rc);
                }

                @Override
                public void onExit(int rc) {
                    exit.onExit(translateExit(rc));
                    log(rc);
                }
            });
            cmd.start(env);
        } finally {
            SshScope.set(old);
        }
    }
}
#method_after
private void onStart() throws IOException {
    synchronized (this) {
        final Context old = sshScope.set(ctx);
        try {
            cmd = dispatcher.get();
            cmd.setArguments(argv);
            cmd.setInputStream(in);
            cmd.setOutputStream(out);
            cmd.setErrorStream(err);
            cmd.setExitCallback(new ExitCallback() {

                @Override
                public void onExit(int rc, String exitMessage) {
                    exit.onExit(translateExit(rc), exitMessage);
                    log(rc);
                }

                @Override
                public void onExit(int rc) {
                    exit.onExit(translateExit(rc));
                    log(rc);
                }
            });
            cmd.start(env);
        } finally {
            sshScope.set(old);
        }
    }
}
#end_block

#method_before
private void onDestroy() {
    synchronized (this) {
        if (cmd != null) {
            final Context old = SshScope.set(ctx);
            try {
                cmd.destroy();
                log(BaseCommand.STATUS_CANCEL);
            } finally {
                ctx = null;
                cmd = null;
                SshScope.set(old);
            }
        }
    }
}
#method_after
private void onDestroy() {
    synchronized (this) {
        if (cmd != null) {
            final Context old = sshScope.set(ctx);
            try {
                cmd.destroy();
                log(BaseCommand.STATUS_CANCEL);
            } finally {
                ctx = null;
                cmd = null;
                sshScope.set(old);
            }
        }
    }
}
#end_block

#method_before
static String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#method_after
static public String[] split(String commandLine) {
    final List<String> list = new ArrayList<String>();
    boolean inquote = false;
    boolean inDblQuote = false;
    StringBuilder r = new StringBuilder();
    for (int ip = 0; ip < commandLine.length(); ) {
        final char b = commandLine.charAt(ip++);
        switch(b) {
            case '\t':
            case ' ':
                if (inquote || inDblQuote)
                    r.append(b);
                else if (r.length() > 0) {
                    list.add(r.toString());
                    r = new StringBuilder();
                }
                continue;
            case '\"':
                if (inquote)
                    r.append(b);
                else
                    inDblQuote = !inDblQuote;
                continue;
            case '\'':
                if (inDblQuote)
                    r.append(b);
                else
                    inquote = !inquote;
                continue;
            case '\\':
                if (inquote || ip == commandLine.length())
                    // literal within a quote
                    r.append(b);
                else
                    r.append(commandLine.charAt(ip++));
                continue;
            default:
                r.append(b);
                continue;
        }
    }
    if (r.length() > 0) {
        list.add(r.toString());
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
void onLogin() {
    async.append(log("LOGIN FROM " + session.get().getRemoteAddressAsString()));
    audit("0", "LOGIN", Collections.emptyList());
}
#method_after
void onLogin() {
    async.append(log("LOGIN FROM " + session.get().getRemoteAddressAsString()));
    audit("0", "LOGIN", new String[] {});
}
#end_block

#method_before
void onAuthFail(final SshSession sd) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger (optional)
    null, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    "AUTH FAILURE FROM " + sd.getRemoteAddressAsString(), // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    event.setProperty(P_USER_NAME, sd.getUsername());
    final String error = sd.getAuthenticationError();
    if (error != null) {
        event.setProperty(P_STATUS, error);
    }
    async.append(event);
    audit("FAIL", "AUTH", Arrays.asList(sd.getRemoteAddressAsString()));
}
#method_after
void onAuthFail(final SshSession sd) {
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    "AUTH FAILURE FROM " + sd.getRemoteAddressAsString(), // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    event.setProperty(P_USER_NAME, sd.getUsername());
    final String error = sd.getAuthenticationError();
    if (error != null) {
        event.setProperty(P_STATUS, error);
    }
    async.append(event);
    audit("FAIL", "AUTH", new String[] { sd.getRemoteAddressAsString() });
}
#end_block

#method_before
void onExecute(int exitValue) {
    final Context ctx = context.get();
    ctx.finished = System.currentTimeMillis();
    final String commandLine = ctx.getCommandLine();
    String cmd = QuotedString.BOURNE.quote(commandLine);
    if (cmd == commandLine) {
        cmd = "'" + commandLine + "'";
    }
    final LoggingEvent event = log(cmd);
    event.setProperty(P_WAIT, (ctx.started - ctx.created) + "ms");
    event.setProperty(P_EXEC, (ctx.finished - ctx.started) + "ms");
    final String status;
    switch(exitValue) {
        case BaseCommand.STATUS_CANCEL:
            status = "killed";
            break;
        case BaseCommand.STATUS_NOT_FOUND:
            status = "not-found";
            break;
        case BaseCommand.STATUS_NOT_ADMIN:
            status = "not-admin";
            break;
        default:
            status = String.valueOf(exitValue);
            break;
    }
    event.setProperty(P_STATUS, status);
    async.append(event);
    audit(status, getCommand(commandLine), getCommandArgs(commandLine));
}
#method_after
void onExecute(int exitValue) {
    final Context ctx = context.get();
    ctx.finished = System.currentTimeMillis();
    final String commandLine = ctx.getCommandLine();
    String cmd = QuotedString.BOURNE.quote(commandLine);
    if (cmd == commandLine) {
        cmd = "'" + commandLine + "'";
    }
    final LoggingEvent event = log(cmd);
    event.setProperty(P_WAIT, (ctx.started - ctx.created) + "ms");
    event.setProperty(P_EXEC, (ctx.finished - ctx.started) + "ms");
    final String status;
    switch(exitValue) {
        case BaseCommand.STATUS_CANCEL:
            status = "killed";
            break;
        case BaseCommand.STATUS_NOT_FOUND:
            status = "not-found";
            break;
        case BaseCommand.STATUS_NOT_ADMIN:
            status = "not-admin";
            break;
        default:
            status = String.valueOf(exitValue);
            break;
    }
    event.setProperty(P_STATUS, status);
    async.append(event);
    audit(status, getCommand(commandLine), CommandFactoryProvider.split(commandLine));
}
#end_block

#method_before
void onLogout() {
    async.append(log("LOGOUT"));
    audit("0", "LOGOUT", Collections.emptyList());
}
#method_after
void onLogout() {
    async.append(log("LOGOUT"));
    audit("0", "LOGOUT", new String[] {});
}
#end_block

#method_before
private LoggingEvent log(final String msg) {
    final SshSession sd = session.get();
    final CurrentUser user = sd.getCurrentUser();
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger (optional)
    null, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    msg, // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    String userName = "-", accountId = "-";
    if (user instanceof IdentifiedUser) {
        IdentifiedUser u = (IdentifiedUser) user;
        userName = u.getAccount().getUserName();
        accountId = "a/" + u.getAccountId().toString();
    } else if (user instanceof PeerDaemonUser) {
        userName = PeerDaemonUser.USER_NAME;
    }
    event.setProperty(P_USER_NAME, userName);
    event.setProperty(P_ACCOUNT_ID, accountId);
    return event;
}
#method_after
private LoggingEvent log(final String msg) {
    final SshSession sd = session.get();
    final CurrentUser user = sd.getCurrentUser();
    final LoggingEvent event = new // 
    LoggingEvent(// fqnOfCategoryClass
    Logger.class.getName(), // logger
    log, // when
    System.currentTimeMillis(), // level
    Level.INFO, // message text
    msg, // thread name
    "SSHD", // exception information
    null, // current NDC string
    null, // caller location
    null, // MDC properties
    null);
    event.setProperty(P_SESSION, id(sd.getSessionId()));
    String userName = "-", accountId = "-";
    if (user instanceof IdentifiedUser) {
        IdentifiedUser u = (IdentifiedUser) user;
        userName = u.getAccount().getUserName();
        accountId = "a/" + u.getAccountId().toString();
    } else if (user instanceof PeerDaemonUser) {
        userName = PeerDaemonUser.USER_NAME;
    }
    event.setProperty(P_USER_NAME, userName);
    event.setProperty(P_ACCOUNT_ID, accountId);
    return event;
}
#end_block

#method_before
void audit(Object result, String commandName, List<?> args) {
    final Context ctx = context.get();
    final String sid = extractSessionId(ctx);
    final String username = extractUsername(ctx);
    final long elapsed = extractElapsed(ctx);
    final long created = extractCreated(ctx);
    final String what = extractWhat(commandName, args);
    auditService.track(new AuditEvent(sid, username, "ssh:" + what, created, args, result, elapsed));
}
#method_after
void audit(Object result, String commandName, String[] args) {
    final Context ctx = context.get();
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    final String what = extractWhat(commandName, args);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + what, created, Arrays.asList(args), result));
}
#end_block

#method_before
private String extractWhat(String commandName, List<?> args) {
    String result = commandName;
    if ("gerrit".equals(commandName)) {
        if (args.size() > 1)
            result = "gerrit" + "." + args.get(1);
    }
    return result;
}
#method_after
private String extractWhat(String commandName, String[] args) {
    String result = commandName;
    if ("gerrit".equals(commandName)) {
        if (args.length > 1)
            result = "gerrit" + "." + args[1];
    }
    return result;
}
#end_block

#method_before
@Override
protected GsonBuilder createGsonBuilder() {
    final GsonBuilder g = super.createGsonBuilder();
    g.registerTypeAdapter(org.eclipse.jgit.diff.Edit.class, new org.eclipse.jgit.diff.EditDeserializer());
    return g;
}
#method_after
@Override
protected GsonBuilder createGsonBuilder() {
    return gerritDefaultGsonBuilder();
}
#end_block

#method_before
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws IOException {
    try {
        super.service(req, resp);
    } finally {
        try {
            audit();
        } catch (Throwable ignoreExceptionWhileLogging) {
        } finally {
            currentCall.set(null);
        }
    }
}
#method_after
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws IOException {
    try {
        super.service(req, resp);
    } finally {
        audit();
        currentCall.set(null);
    }
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        Audit note = (Audit) call.getMethod().getAnnotation(Audit.class);
        if (note != null) {
            final Gson gson = createGsonBuilder().setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).setVersion(1.0).create();
            final String sid = call.getWebSession().getToken();
            final String username = extractUsername(call);
            final List<Object> args = extractParams(note, call, gson);
            final String what = extractWhat(note, call.getMethod().getName());
            final Object result = call.getResult();
            audit.track(new AuditEvent(sid, username, what, call.getWhen(), args, result, call.getElapsed()));
        }
    } catch (Throwable all) {
        LOG.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        Audit note = (Audit) call.getMethod().getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getToken();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final List<Object> args = extractParams(note, call);
            final String what = extractWhat(note, call.getMethod().getName());
            final Object result = call.getResult();
            audit.dispatch(new AuditEvent(sid, username, what, call.getWhen(), args, result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private List<Object> extractParams(final Audit note, final GerritCall call, Gson gson) {
    final List<Object> args = new ArrayList<Object>();
    final Object[] params = call.getParams();
    final int[] obfuscate = note.obfuscate();
    for (int i = 0; i < params.length; i++) {
        Object param = params[i];
        if (obfuscate.length > 0) {
            for (int id : obfuscate) {
                if (id == i) {
                    param = "*****";
                    break;
                }
            }
        }
        args.add(param);
    }
    return args;
}
#method_after
private List<Object> extractParams(final Audit note, final GerritCall call) {
    List<Object> args = Lists.newArrayList(Arrays.asList(call.getParams()));
    for (int idx : note.obfuscate()) {
        args.set(idx, "*****");
    }
    return args;
}
#end_block

#method_before
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (Character.isLowerCase(c) != ccase) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#method_after
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (ccase && !Character.isLowerCase(c)) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#end_block

#method_before
public Object getResult() {
    try {
        return resultField.get(this);
    } catch (IllegalArgumentException e) {
        LOG.error("Cannot access result field");
    } catch (IllegalAccessException e) {
        LOG.error("No permissions to access result field");
    }
    return null;
}
#method_after
public Object getResult() {
    if (resultField == null) {
        return null;
    }
    try {
        return resultField.get(this);
    } catch (IllegalArgumentException e) {
        log.error("Cannot access result field");
    } catch (IllegalAccessException e) {
        log.error("No permissions to access result field");
    }
    return null;
}
#end_block

#method_before
@Override
public MethodHandle getMethod() {
    if (currentMethod.get() == null)
        return super.getMethod();
    else
        return currentMethod.get();
}
#method_after
@Override
public MethodHandle getMethod() {
    if (currentMethod.get() == null) {
        return super.getMethod();
    } else {
        return currentMethod.get();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return asString().hashCode();
}
#method_after
@Override
public int hashCode() {
    return uuid.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AuditEvent other = (AuditEvent) obj;
    return this.asString().equals(other.asString());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AuditEvent other = (AuditEvent) obj;
    return this.uuid.equals(other.uuid);
}
#end_block

#method_before
@Override
public String toString() {
    return asString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(uuid.toString());
    sb.append("|");
    sb.append(sessionId);
    sb.append('|');
    sb.append(who);
    sb.append('|');
    sb.append(when);
    sb.append('|');
    sb.append(what);
    sb.append('|');
    sb.append(elapsed);
    sb.append('|');
    if (params != null) {
        sb.append('[');
        for (int i = 0; i < params.size(); i++) {
            if (i > 0)
                sb.append(',');
            Object param = params.get(i);
            if (param == null) {
                sb.append("null");
            } else {
                sb.append(param);
            }
        }
        sb.append(']');
    }
    sb.append('|');
    if (result != null) {
        sb.append(result);
    }
    return sb.toString();
}
#end_block

#method_before
private void recursivelyExpandGroups(final Set<String> groupDNs, final LdapSchema schema, final DirContext ctx, final String groupDN) {
    if (groupDNs.add(groupDN) && schema.accountMemberField != null) {
        Set<String> cachedGroupDNs = groupsByInclude.getIfPresent(groupDN);
        if (cachedGroupDNs != null) {
            for (String cachedGroupDN : cachedGroupDNs) {
                recursivelyExpandGroups(groupDNs, schema, ctx, cachedGroupDN);
            }
        } else {
            // 
            try {
                final Name compositeGroupName = new CompositeName().add(groupDN);
                final Attribute in = ctx.getAttributes(compositeGroupName).get(schema.accountMemberField);
                cachedGroupDNs = new HashSet<String>();
                if (in != null) {
                    final NamingEnumeration<?> groups = in.getAll();
                    try {
                        while (groups.hasMore()) {
                            final String nextDN = (String) groups.next();
                            cachedGroupDNs.add(nextDN);
                            recursivelyExpandGroups(groupDNs, schema, ctx, nextDN);
                        }
                    } catch (PartialResultException e) {
                    }
                }
                groupsByInclude.put(groupDN, cachedGroupDNs);
            } catch (NamingException e) {
                LdapRealm.log.warn("Could not find group " + groupDN, e);
            }
        }
    }
}
#method_after
private void recursivelyExpandGroups(final Set<String> groupDNs, final LdapSchema schema, final DirContext ctx, final String groupDN) {
    if (groupDNs.add(groupDN) && schema.accountMemberField != null) {
        ImmutableSet<String> cachedGroupDNs = groupsByInclude.getIfPresent(groupDN);
        if (cachedGroupDNs == null) {
            // Recursively identify the groups it is a member of.
            ImmutableSet.Builder<String> dns = ImmutableSet.builder();
            try {
                final Name compositeGroupName = new CompositeName().add(groupDN);
                final Attribute in = ctx.getAttributes(compositeGroupName).get(schema.accountMemberField);
                if (in != null) {
                    final NamingEnumeration<?> groups = in.getAll();
                    try {
                        while (groups.hasMore()) {
                            dns.add((String) groups.next());
                        }
                    } catch (PartialResultException e) {
                    }
                }
            } catch (NamingException e) {
                LdapRealm.log.warn("Could not find group " + groupDN, e);
            }
            cachedGroupDNs = dns.build();
            groupsByInclude.put(groupDN, cachedGroupDNs);
        }
        for (String dn : cachedGroupDNs) {
            recursivelyExpandGroups(groupDNs, schema, ctx, dn);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    cache(GROUP_EXIST_CACHE, String.class, new TypeLiteral<Boolean>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.ExistenceLoader.class);
    cache(GROUPS_BY_INCLUDED, String.class, new TypeLiteral<Set<String>>() {
    }).expireAfterWrite(1, HOURS);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    cache(GROUP_EXIST_CACHE, String.class, new TypeLiteral<Boolean>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.ExistenceLoader.class);
    cache(GROUPS_BYINCLUDE_CACHE, String.class, new TypeLiteral<ImmutableSet<String>>() {
    }).expireAfterWrite(1, HOURS);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
            loadPlugins(result.plugnis);
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
}
#end_block

#method_before
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    loadPlugins(hpd, token);
}
#end_block

#method_before
private void loadPlugins(String[] pluginsUrls) {
    for (final String url : pluginsUrls) {
        ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

            @Override
            public void onSuccess(Void result) {
            // does nothing
            }

            @Override
            public void onFailure(Exception reason) {
                Window.alert("Failed load pluing: " + url);
            }
        }).inject();
    }
}
#method_after
private void loadPlugins(HostPageData hpd, final String token) {
    if (hpd.plugins != null) {
        for (final String url : hpd.plugins) {
            ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

                @Override
                public void onSuccess(Void result) {
                }

                @Override
                public void onFailure(Exception reason) {
                    ErrorDialog d = new ErrorDialog(reason);
                    d.setTitle(M.pluginFailed(url));
                    d.center();
                }
            }).inject();
        }
    }
    CallbackHandle<Void> cb = new CallbackHandle<Void>(new ResultDeserializer<Void>() {

        @Override
        public Void fromResult(JavaScriptObject responseObject) {
            return null;
        }
    }, new AsyncCallback<Void>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(Void result) {
            display(token);
        }
    });
    cb.install();
    ScriptInjector.fromString(cb.getFunctionName() + "();").setWindow(ScriptInjector.TOP_WINDOW).inject();
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar menuBar = new LinkMenuBar();
        addLink(menuBar, C.menuGroups(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(menuBar, C.menuPlugins(), PageLinks.ADMIN_PLUGINS);
                }
            }
        }, ADMINISTRATE_SERVER);
        menuLeft.add(menuBar, C.menuAdmin());
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    if (signedIn) {
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
            }
        }, CREATE_PROJECT);
    }
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar groupsBar = new LinkMenuBar();
        addLink(groupsBar, C.menuGroupsList(), PageLinks.ADMIN_GROUPS);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_GROUP)) {
                    addLink(groupsBar, C.menuGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP);
                }
            }
        }, CREATE_GROUP);
        menuLeft.add(groupsBar, C.menuGroups());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(groupsBar) + 1);
                }
            }
        }, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI();
        addLink(menuRight, C.menuSettings(), PageLinks.SETTINGS);
        if (cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP) {
            menuRight.add(anchor(C.menuSignOut(), selfRedirect("/logout")));
        }
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        final String to = History.getToken();
                        new OpenIdSignInDialog(SignInMode.REGISTER, to, null).center();
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    menuRight.add(anchor(C.menuRegister(), cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", selfRedirect("/become")));
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = get().get(select(req));
    final byte[] raw;
    final CurrentUser user = currentUser.get();
    if (user instanceof IdentifiedUser) {
        final StringWriter w = new StringWriter();
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xsrfToken=");
        json(session.get().getToken(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
        final byte[] userData = w.toString().getBytes("UTF-8");
        raw = concat(page.part1, userData, page.part2);
    } else {
        raw = page.full;
    }
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = raw == page.full ? page.full_gz : HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = get().get(select(req));
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user instanceof IdentifiedUser) {
        w.write(HPD_ID + ".account=");
        json(((IdentifiedUser) user).getAccount(), w);
        w.write(";");
        w.write(HPD_ID + ".xsrfToken=");
        json(session.get().getToken(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(((IdentifiedUser) user).getAccountDiffPreference(), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC);
    rsp.setContentLength(tosend.length);
    final OutputStream out = rsp.getOutputStream();
    try {
        out.write(tosend);
    } finally {
        out.close();
    }
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.removeAttribute("id");
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(getProjectKey(), branchName, rev, new GerritCallback<ListBranchesResult>() {

        public void onSuccess(final ListBranchesResult result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            display(result.getBranches());
        }

        @Override
        public void onFailure(final Throwable caught) {
            addBranch.setEnabled(true);
            if (caught instanceof RemoteJsonException) {
                final String msg = caught.getMessage();
                String userMsg = null;
                if (InvalidNameException.MESSAGE.equals(msg)) {
                    selectAllAndFocus(nameTxtBox);
                    userMsg = Gerrit.M.invalidBranchName(branchName);
                } else if (InvalidRevisionException.MESSAGE.equals(msg)) {
                    selectAllAndFocus(irevTxtBox);
                    userMsg = Gerrit.M.invalidRevision(rev);
                } else if (msg.startsWith(BranchCreationNotAllowedUnderRefnamePrefixException.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String refnamePrefix = caught.getMessage().substring(BranchCreationNotAllowedUnderRefnamePrefixException.MESSAGE.length());
                    userMsg = Gerrit.M.branchCreationNotAllowedUnderRefnamePrefix(refnamePrefix);
                } else if (msg.startsWith(BranchAlreadyExistsException.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String existingBranchName = caught.getMessage().substring(BranchAlreadyExistsException.MESSAGE.length());
                    userMsg = Gerrit.M.branchAlreadyExists(existingBranchName);
                } else if (msg.startsWith(BranchCreationNotAllowedUnderExistingBranch.MESSAGE)) {
                    selectAllAndFocus(nameTxtBox);
                    final String existingBranchName = caught.getMessage().substring(BranchCreationNotAllowedUnderExistingBranch.MESSAGE.length());
                    userMsg = Gerrit.M.branchCreationNotAllowedUnderExistingBranch(branchName, existingBranchName);
                }
                if (userMsg != null) {
                    new ErrorDialog(userMsg).center();
                    return;
                }
            }
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    Util.PROJECT_SVC.addBranch(getProjectKey(), branchName, rev, new GerritCallback<AddBranchResult>() {

        public void onSuccess(final AddBranchResult result) {
            addBranch.setEnabled(true);
            if (!result.hasError()) {
                nameTxtBox.setText("");
                irevTxtBox.setText("");
                display(result.getListBranchesResult().getBranches());
            } else {
                final AddBranchResult.Error error = result.getError();
                final String msg;
                switch(error.getType()) {
                    case INVALID_NAME:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.invalidBranchName(branchName);
                        break;
                    case INVALID_REVISION:
                        selectAllAndFocus(irevTxtBox);
                        msg = Gerrit.M.invalidRevision(rev);
                        break;
                    case BRANCH_CREATION_NOT_ALLOWED_UNDER_REFNAME_PREFIX:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchCreationNotAllowedUnderRefnamePrefix(error.getRefname());
                        break;
                    case BRANCH_ALREADY_EXISTS:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchAlreadyExists(error.getRefname());
                        break;
                    case BRANCH_CREATION_CONFLICT:
                        selectAllAndFocus(nameTxtBox);
                        msg = Gerrit.M.branchCreationConflict(branchName, error.getRefname());
                        break;
                    default:
                        msg = Gerrit.M.branchCreationFailed(branchName, error.toString());
                }
                new ErrorDialog(msg).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addBranch.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void deleteChecked() {
    final StringBuilder message = new StringBuilder();
    message.append("<b>").append(Gerrit.C.branchDeletionConfirmationMessage()).append("</b>");
    message.append("<p>");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                message.append(", <br>");
            }
            message.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    message.append("</p>");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

        @Override
        public void onOk() {
            Util.PROJECT_SVC.deleteBranch(getProjectKey(), ids, new GerritCallback<Set<Branch.NameKey>>() {

                public void onSuccess(final Set<Branch.NameKey> deleted) {
                    for (int row = 1; row < table.getRowCount(); ) {
                        final Branch k = getRowItem(row);
                        if (k != null && deleted.contains(k.getNameKey())) {
                            table.removeRow(row);
                        } else {
                            row++;
                        }
                    }
                }
            });
        }
    });
    confirmationDialog.center();
}
#method_after
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchDeletionConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids);
        }
    });
    confirmationDialog.center();
}
#end_block

#method_before
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor(c.getLinkName(), false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor(c.getLinkName(), false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, InvalidNameException, InvalidRevisionException, IOException, BranchCreationNotAllowedUnderRefnamePrefixException, BranchAlreadyExistsException, BranchCreationNotAllowedUnderExistingBranch {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        throw new InvalidNameException();
    }
    if (MagicBranch.isMagicBranch(refname)) {
        throw new BranchCreationNotAllowedUnderRefnamePrefixException(MagicBranch.getMagicRefNamePrefix(refname));
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName);
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    replication.scheduleUpdate(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(refname) != null) {
                        throw new BranchAlreadyExistsException(refname);
                    }
                    String refPrefix = getRefPrefix(refname);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new BranchCreationNotAllowedUnderExistingBranch(refPrefix);
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } finally {
        repo.close();
    }
    return listBranchesFactory.create(projectName).call();
}
#method_after
@Override
public AddBranchResult call() throws NoSuchProjectException, IOException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    String refname = branchName;
    while (refname.startsWith("/")) {
        refname = refname.substring(1);
    }
    if (!refname.startsWith(Constants.R_REFS)) {
        refname = Constants.R_HEADS + refname;
    }
    if (!Repository.isValidRefName(refname)) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.INVALID_NAME, refname));
    }
    if (MagicBranch.isMagicBranch(refname)) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_CREATION_NOT_ALLOWED_UNDER_REFNAME_PREFIX, MagicBranch.getMagicRefNamePrefix(refname)));
    }
    final Branch.NameKey name = new Branch.NameKey(projectName, refname);
    final RefControl refControl = projectControl.controlForRef(name);
    final Repository repo = repoManager.openRepository(projectName);
    try {
        final ObjectId revid = parseStartingRevision(repo);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (refname.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new IllegalStateException(startingRevision + " not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create " + refname);
        }
        try {
            final RefUpdate u = repo.updateRef(refname);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via web from " + startingRevision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), refname);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(refname) != null) {
                        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_ALREADY_EXISTS, refname));
                    }
                    String refPrefix = getRefPrefix(refname);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.BRANCH_CREATION_CONFLICT, refPrefix));
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
        } catch (IOException err) {
            log.error("Cannot create branch " + name, err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        return new AddBranchResult(new AddBranchResult.Error(AddBranchResult.Error.Type.INVALID_REVISION));
    } finally {
        repo.close();
    }
    return new AddBranchResult(listBranchesFactory.create(projectName).call());
}
#end_block

#method_before
private String getRefPrefix(final String refName) {
    int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#method_after
private static String getRefPrefix(final String refName) {
    final int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#end_block

#method_before
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append("      $ scp -p -P 29418 review.example.com:hooks/commit-msg .git/hooks/");
    return sb.toString();
}
#method_after
private String getFixedCommitMsgWithChangeId(String errMsg, RevCommit c) {
    // We handle 3 cases:
    // 1. No change id in the commit message at all.
    // 2. change id last in the commit message but missing empty line to create the footer.
    // 3. there is a change-id somewhere in the commit message, but we ignore it.
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    sb.append("\n");
    sb.append("Suggestion for commit message:\n");
    if (c.getFullMessage().indexOf(changeId) == -1) {
        sb.append(c.getFullMessage());
        sb.append("\n");
        sb.append(changeId).append(" I").append(c.name());
    } else {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == 0) {
            for (int i = 0; i < lines.length - 1; i++) {
                sb.append(lines[i]);
                sb.append("\n");
            }
            sb.append("\n");
            sb.append(lastLine);
        } else {
            sb.append(c.getFullMessage());
            sb.append("\n");
            sb.append(changeId).append(" I").append(c.name());
            sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message.");
        }
    }
    sb.append("\n");
    sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    return sb.toString();
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            String msgbuf = msg;
            if (msgbuf == null) {
                // Initialize the message buffer
                msgbuf = "";
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.statusCode == CommitMergeStatus.CLEAN_MERGE || c.statusCode == CommitMergeStatus.CLEAN_PICK || c.statusCode == CommitMergeStatus.CLEAN_REBASE)) {
                        msgbuf += "\n";
                        msgbuf += c.getFullMessage();
                    }
                }
            }
            // update subscribers of this module
            for (final SubmoduleSubscription s : subscribers) {
                if (!updatedSubscribers.add(s.getSuperProject())) {
                    log.error("Possible circular subscription involving " + s.toString());
                } else {
                    Map<Branch.NameKey, ObjectId> modules = new HashMap<Branch.NameKey, ObjectId>(1);
                    modules.put(updatedBranch, mergedCommit);
                    Map<Branch.NameKey, String> paths = new HashMap<Branch.NameKey, String>(1);
                    paths.put(updatedBranch, s.getPath());
                    try {
                        updateGitlinks(s.getSuperProject(), modules, paths, msgbuf);
                    } catch (SubmoduleException e) {
                        throw e;
                    }
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            String msgbuf = msg;
            if (msgbuf == null) {
                // Initialize the message buffer
                msgbuf = "";
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.statusCode == CommitMergeStatus.CLEAN_MERGE || c.statusCode == CommitMergeStatus.CLEAN_PICK || c.statusCode == CommitMergeStatus.CLEAN_REBASE)) {
                        msgbuf += "\n";
                        msgbuf += c.getFullMessage();
                    }
                }
            }
            // update subscribers of this module
            for (final SubmoduleSubscription s : subscribers) {
                if (!updatedSubscribers.add(s.getSuperProject())) {
                    log.error("Possible circular subscription involving " + s.toString());
                } else {
                    Map<Branch.NameKey, ObjectId> modules = new HashMap<Branch.NameKey, ObjectId>(1);
                    modules.put(updatedBranch, mergedCommit);
                    Map<Branch.NameKey, String> paths = new HashMap<Branch.NameKey, String>(1);
                    paths.put(updatedBranch, s.getPath());
                    try {
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, msgbuf);
                    } catch (SubmoduleException e) {
                        throw e;
                    }
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = rw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  " + me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1 && msg != null) {
                msgbuf.append(msg);
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                replication.fire(subscriber.getParentKey(), rfu.getName());
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        logAndThrowSubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#method_after
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    try {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    } finally {
        rw.release();
    }
}
#end_block

#method_before
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            final boolean isMergeable = !toMerge.isEmpty() ? createStrategy().dryRun(branchTip, toMerge.remove(0)) : false;
            // update sha1 tested merge.
            if (destBranchRef != null) {
                change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
            } else {
                change.setLastSha1MergeTested(new RevId(""));
            }
            change.setMergeable(isMergeable);
            db.changes().update(Collections.singleton(change));
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void verifyMergeability(Change change) {
    try {
        setDestProject();
        openRepository();
        final Ref destBranchRef = repo.getRef(destBranch.get());
        // the change was tested against.
        if ((destBranchRef == null && change.getLastSha1MergeTested() == null) || change.getLastSha1MergeTested() == null || (destBranchRef != null && !destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))) {
            openSchema();
            openBranch();
            validateChangeList(Collections.singletonList(change));
            if (!toMerge.isEmpty()) {
                final Entry<SubmitType, CodeReviewCommit> e = toMerge.entries().iterator().next();
                final boolean isMergeable = createStrategy(e.getKey()).dryRun(branchTip, e.getValue());
                // update sha1 tested merge.
                if (destBranchRef != null) {
                    change.setLastSha1MergeTested(new RevId(destBranchRef.getObjectId().getName()));
                } else {
                    change.setLastSha1MergeTested(new RevId(""));
                }
                change.setMergeable(isMergeable);
                db.changes().update(Collections.singleton(change));
            } else {
                log.error("Test merge attempt for change: " + change.getId() + " failed");
            }
        }
    } catch (MergeException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } catch (OrmException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed: Not able to query the database", e);
    } catch (IOException e) {
        log.error("Test merge attempt for change: " + change.getId() + " failed", e);
    } finally {
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        final List<Change> submitted = db.changes().submitted(destBranch).toList();
        final RefUpdate branchUpdate = openBranch();
        validateChangeList(submitted);
        preMerge();
        updateBranch(branchUpdate);
        updateChangeStatus(submitted);
        updateSubscriptions(submitted);
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        openBranch();
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<Project.SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                final RefUpdate branchUpdate = openBranch();
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.change, message(commit.change, capable.getMessage()), false);
            }
        }
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void preMerge() throws MergeException {
    final SubmitStrategy strategy = createStrategy();
    mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    commits.putAll(strategy.getNewCommits());
}
#method_after
private void preMerge(final SubmitStrategy strategy, final List<CodeReviewCommit> toMerge) throws MergeException {
    mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    commits.putAll(strategy.getNewCommits());
}
#end_block

#method_before
private SubmitStrategy createStrategy() throws MergeException {
    return submitStrategyFactory.create(destProject.getSubmitType(), db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, destProject.isUseContentMerge());
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, destProject.isUseContentMerge());
}
#end_block

#method_before
private void validateChangeList(final List<Change> submitted) throws MergeException {
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        commit.add(canMergeFlag);
        toMerge.add(commit);
    }
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateBranch(final RefUpdate branchUpdate) throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_REBASE:
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db, repo);
    try {
        codeReviewNotes.create(merged, computeMergeCommitAuthor(db, identifiedUserFactory, myIdent, rw, merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.fire(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_REBASE:
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    potentiallyStillSubmittable.add(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db, repo);
    try {
        codeReviewNotes.create(merged, computeMergeCommitAuthor(db, identifiedUserFactory, myIdent, rw, merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.fire(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        capable = new Capable(txt);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#method_after
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change;
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        capable = new Capable(txt);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        db.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            db.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final MergedSender cm = mergedSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            PatchSetApproval submitter;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                    submitter = getSubmitter(reviewDb, c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (submitter != null) {
                    cm.setFrom(submitter.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m = newThreeWayMerger(args.repo, args.inserter, args.useContentMerge);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(newMergeTip, n)) {
                    newMergeTip = writeCherryPickCommit(m, newMergeTip, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m = newThreeWayMerger(args.repo, args.inserter, args.useContentMerge);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(newMergeTip, n)) {
                    newMergeTip = writeCherryPickCommit(m, newMergeTip, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final Merger m, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = args.db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = args.identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(args.inserter, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.rw.parseCommit(id);
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final Merger m, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = args.db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = args.identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(args.inserter, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.rw.parseCommit(id);
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            return createRandomObjectId();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#method_after
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        private final MutableObjectId buf = new MutableObjectId();

        private final static int LAST_BYTE = Constants.OBJECT_ID_LENGTH - 1;

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            // create non-existing dummy ID
            buf.setByte(LAST_BYTE, buf.getByte(LAST_BYTE) + 1);
            return buf.copy();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#end_block

#method_before
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#method_after
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#end_block

#method_before
private static CodeReviewCommit failed(final RevWalk rw, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#method_after
private static CodeReviewCommit failed(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final CodeReviewCommit n, final CommitMergeStatus failure) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit failed;
    while ((failed = (CodeReviewCommit) rw.next()) != null) {
        failed.statusCode = failure;
    }
    return failed;
}
#end_block

#method_before
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#method_after
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#end_block

#method_before
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer();
}
#method_after
public boolean canAbandon() {
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getCurrentUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon();
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#method_after
public boolean canRestore() {
    return // Anyone who can abandon the change can restore it back
    canAbandon() && // as long as you can upload too
    getRefControl().canUpload();
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    return evaluatePrologRules(db, patchSet, cd, fastEvalLabels, "submit_rule", "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, change, cd, fastEvalLabels, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#end_block

#method_before
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#method_after
public static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
private void reduceToMinimalMerge() throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = new MergeSorter(rw, alreadyAccepted, CAN_MERGE).sort(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toMerge.clear();
    toMerge.addAll(heads);
    Collections.sort(toMerge, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    final Change oldChange = n.change;
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    db.patchSets().insert(Collections.singleton(ps));
    n.change = db.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    this.submitted.remove(oldChange);
    this.submitted.add(n.change);
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case FAST_FORWARD_ONLY:
                            break;
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                        default:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.fire(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(db, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    switch(destProject.getSubmitType()) {
                        case CHERRY_PICK:
                        case MERGE_ALWAYS:
                        case MERGE_IF_NECESSARY:
                            mergeQueue.recheckAfter(destBranch, random.nextInt(1000), MILLISECONDS);
                            break;
                        case FAST_FORWARD_ONLY:
                            // Not mergeable, no need to recheck.
                            break;
                        default:
                            log.warn("Lock failure in project with unknown merge type " + destProject.getSubmitType());
                            break;
                    }
                    break;
            }
            throw new IOException(branchUpdate.getResult().name());
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeSubmitRecords) {
                    try {
                        PatchSet.Id psId = d.getChange().currentPatchSetId();
                        Change.Id changeId = psId.getParentKey();
                        ChangeControl control = changeControlFactory.validateFor(changeId);
                        List<SubmitRecord> submitResult = control.canSubmit(db.get(), psId);
                        eventFactory.addSubmitRecords(c, submitResult);
                    } catch (OrmException e) {
                    // Squash DB exceptions and leave submit records partially filled
                    } catch (NoSuchChangeException e) {
                    // Squash DB exceptions and leave submit records partially filled
                    }
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    Change.Id changeId = psId.getParentKey();
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.currentApprovals(db));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
public void addSubmitRecords(ChangeAttribute ca, List<SubmitRecord> submitRecords) {
    ca.submitRecords = new ArrayList<SubmitRecordAttribute>();
    for (SubmitRecord submitRecord : submitRecords) {
        SubmitRecordAttribute sa = new SubmitRecordAttribute();
        switch(submitRecord.status) {
            case OK:
                sa.status = "OK";
                break;
            case NOT_READY:
                sa.status = "NOT_READY";
                if (!submitRecord.labels.isEmpty()) {
                    sa.labels = new ArrayList<SubmitLabelAttribute>();
                    for (SubmitRecord.Label lbl : submitRecord.labels) {
                        SubmitLabelAttribute la = new SubmitLabelAttribute();
                        la.label = lbl.label;
                        switch(lbl.status) {
                            case OK:
                                la.status = "OK";
                                break;
                            case REJECT:
                                la.status = "REJECT";
                                break;
                            case NEED:
                                la.status = "NEED";
                                break;
                            case IMPOSSIBLE:
                                la.status = "IMPOSSIBLE";
                                break;
                            default:
                                throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                        }
                        sa.labels.add(la);
                    }
                }
                break;
            case CLOSED:
                sa.status = "CLOSED";
                break;
            case RULE_ERROR:
                sa.status = "RULE_ERROR";
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
        ca.submitRecords.add(sa);
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.submitRecords.isEmpty()) {
        ca.submitRecords = null;
    }
}
#method_after
public void addSubmitRecords(ChangeAttribute ca, List<SubmitRecord> submitRecords) {
    ca.submitRecords = new ArrayList<SubmitRecordAttribute>();
    for (SubmitRecord submitRecord : submitRecords) {
        SubmitRecordAttribute sa = new SubmitRecordAttribute();
        sa.status = submitRecord.status.name();
        if (submitRecord.status != SubmitRecord.Status.RULE_ERROR) {
            addSubmitRecordLabels(submitRecord, sa);
        }
        ca.submitRecords.add(sa);
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.submitRecords.isEmpty()) {
        ca.submitRecords = null;
    }
}
#end_block

#method_before
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    // reviewer see a draft.
                    if (control.forUser(user).isRefVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        // reviewer see a draft.
        if (!control.forUser(user).isRefVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final Change change = control.getChange();
    final PatchSet.Id psid = change.currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Execute hook for added reviewers
    // 
    final PatchSet patchSet = db.patchSets().get(psid);
    for (final Account.Id reviewer : added) {
        final Account account = db.accounts().get(reviewer);
        hooks.doReviewerAddedHook(change, account, patchSet, db);
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#method_after
@Override
public ReviewerResult call() throws Exception {
    final Set<Account.Id> reviewerIds = new HashSet<Account.Id>();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final ReviewerResult result = new ReviewerResult();
    for (final String reviewer : reviewers) {
        final Account account = accountResolver.find(reviewer);
        if (account == null) {
            AccountGroup group = groupCache.get(new AccountGroup.NameKey(reviewer));
            if (group == null) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, reviewer));
                continue;
            }
            if (!isLegalReviewerGroup(group.getGroupUUID())) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, reviewer));
                continue;
            }
            final Set<Account> members = groupMembersFactory.create().listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
            if (members == null || members.size() == 0) {
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_EMPTY, reviewer));
                continue;
            }
            // if maxAllowed is set to 0, it is allowed to add any number of
            // reviewers
            final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
            if (maxAllowed > 0 && members.size() > maxAllowed) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(false);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            // if maxWithoutCheck is set to 0, we never ask for confirmation
            final int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
            if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
                result.setMemberCount(members.size());
                result.setAskForConfirmation(true);
                result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.GROUP_HAS_TOO_MANY_MEMBERS, reviewer));
                continue;
            }
            for (final Account member : members) {
                if (member.isActive()) {
                    final IdentifiedUser user = identifiedUserFactory.create(member.getId());
                    // reviewer see a draft.
                    if (control.forUser(user).isRefVisible()) {
                        reviewerIds.add(member.getId());
                    }
                }
            }
            continue;
        }
        if (!account.isActive()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.ACCOUNT_INACTIVE, formatUser(account, reviewer)));
            continue;
        }
        final IdentifiedUser user = identifiedUserFactory.create(account.getId());
        // reviewer see a draft.
        if (!control.forUser(user).isRefVisible()) {
            result.addError(new ReviewerResult.Error(ReviewerResult.Error.Type.CHANGE_NOT_VISIBLE, formatUser(account, reviewer)));
            continue;
        }
        reviewerIds.add(account.getId());
    }
    if (reviewerIds.isEmpty()) {
        return result;
    }
    // Add the reviewers to the database
    // 
    final Set<Account.Id> added = new HashSet<Account.Id>();
    final List<PatchSetApproval> toInsert = new ArrayList<PatchSetApproval>();
    final Change change = control.getChange();
    final PatchSet.Id psid = change.currentPatchSetId();
    for (final Account.Id reviewer : reviewerIds) {
        if (!exists(psid, reviewer)) {
            // This reviewer has not entered an approval for this change yet.
            // 
            final PatchSetApproval myca = dummyApproval(control.getChange(), psid, reviewer);
            toInsert.add(myca);
            added.add(reviewer);
        }
    }
    db.patchSetApprovals().insert(toInsert);
    // Execute hook for added reviewers
    // 
    final PatchSet patchSet = db.patchSets().get(psid);
    for (final Account.Id id : added) {
        final Account account = accountCache.get(id).getAccount();
        hooks.doReviewerAddedHook(change, account, patchSet, db);
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    added.remove(currentUser.getAccountId());
    if (!added.isEmpty()) {
        final AddReviewerSender cm;
        cm = addReviewerSenderFactory.create(control.getChange());
        cm.setFrom(currentUser.getAccountId());
        cm.addReviewers(added);
        cm.send();
    }
    return result;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd);
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd);
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            final Image readOnlyIcon = new Image(Gerrit.RESOURCES.readonly());
            readOnlyIcon.setTitle(Gerrit.C.userCannotVoteToolTip());
            table.setWidget(row, col, readOnlyIcon);
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        } else if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    final Change.Status status = detail.getChange().getStatus();
    if ((status.equals(Change.Status.NEW) || status.equals(Change.Status.DRAFT)) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            d.votable(pr.getLabel());
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void loadApprovals(final PatchSetPublishDetail detail, final ChangeControl control) throws OrmException, NoSuchChangeException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final Change.Id changeId = patchSetId.getParentKey();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
        final ChangeControl chgCtrl = changeControlGenericFactory.controlFor(detail.getChange(), identifiedUserFactory.create(ca.getAccountId()));
        for (PermissionRange pr : chgCtrl.getLabelRanges()) {
            if (pr.getMin() != 0 || pr.getMax() != 0) {
                d.votable(pr.getLabel());
            }
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String token = "token=" + verifier.encode(currentUser.get().getUserName(), getReqUrl(req));
    sendText(req, res, token);
}
#method_after
@Override
protected final void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    CurrentUser user = userProvider.get();
    if (!(user instanceof IdentifiedUser)) {
        sendError(res, SC_UNAUTHORIZED, "API requires authentication");
        return;
    }
    TokenInfo info = new TokenInfo();
    info._authkey = verifier.sign(((IdentifiedUser) user).getAccountId(), computeUrl(req));
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    String type;
    buf.write(JSON_MAGIC);
    if (acceptsJson(req)) {
        type = JSON_TYPE;
        buf.write(gson.toJson(info).getBytes(UTF_8));
    } else {
        type = FORM_ENCODED;
        buf.write(String.format("%s=%s", AUTHKEY_NAME, URLEncoder.encode(info._authkey, UTF_8)).getBytes(UTF_8));
    }
    res.setContentType(type);
    res.setCharacterEncoding(UTF_8);
    res.setHeader("Content-Disposition", "attachment");
    send(req, res, buf.toByteArray());
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    noCache(res);
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        noCache(res);
        sendText(req, res, err.getMessage());
    } catch (Error err) {
        handleError(err, req, res);
    } catch (RuntimeException err) {
        handleError(err, req, res);
    }
}
#method_after
@Override
protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkRequiresCapability();
        super.service(req, res);
    } catch (RequireCapabilityException err) {
        sendError(res, SC_FORBIDDEN, err.getMessage());
    } catch (Error err) {
        handleException(err, req, res);
    } catch (RuntimeException err) {
        handleException(err, req, res);
    }
}
#end_block

#method_before
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), ((IdentifiedUser) user).getNameEmail()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#method_after
private void checkRequiresCapability() throws RequireCapabilityException {
    RequiresCapability rc = getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", Objects.firstNonNull(user.getUserName(), user instanceof IdentifiedUser ? ((IdentifiedUser) user).getNameEmail() : user.toString()), rc.value());
            throw new RequireCapabilityException(msg);
        }
    }
}
#end_block

#method_before
protected static void sendText(HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#method_after
protected static void sendText(@Nullable HttpServletRequest req, HttpServletResponse res, String data) throws IOException {
    res.setContentType("text/plain");
    res.setCharacterEncoding("UTF-8");
    send(req, res, data.getBytes("UTF-8"));
}
#end_block

#method_before
protected static void send(HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#method_after
protected static void send(@Nullable HttpServletRequest req, HttpServletResponse res, byte[] data) throws IOException {
    if (data.length > 256 && req != null && RPCServletUtils.acceptsGzipEncoding(req)) {
        res.setHeader("Content-Encoding", "gzip");
        data = HtmlDomUtil.compress(data);
    }
    res.setContentLength(data.length);
    OutputStream out = res.getOutputStream();
    try {
        out.write(data);
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, Response res) {
    String text = res.getText();
    if (text.startsWith("token=")) {
        RestApi.this.sendPost(cb, text);
        return;
    }
    RpcStatus.INSTANCE.onRpcComplete();
    int status = res.getStatusCode();
    if (status != 200) {
        if ((400 <= status && status < 500) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json.substring(JSON_MAGIC.length()));
    } catch (RuntimeException e) {
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
}
#method_after
@Override
public void onResponseReceived(Request req, Response res) {
    int status = res.getStatusCode();
    if (status != 200) {
        RpcStatus.INSTANCE.onRpcComplete();
        if ((400 <= status && status < 600) && isTextBody(res)) {
            cb.onFailure(new RemoteJsonException(res.getText(), status, null));
        } else {
            cb.onFailure(new StatusCodeException(status, res.getStatusText()));
        }
        return;
    }
    if (!isJsonBody(res)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    String json = res.getText();
    if (!json.startsWith(JSON_MAGIC)) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    json = json.substring(JSON_MAGIC.length());
    if (wasGet && json.startsWith("{\"_authkey\":")) {
        RestApi.this.resendPost(cb, json);
        return;
    }
    T data;
    try {
        // javac generics bug
        data = Natives.<T>parseJSON(json);
    } catch (RuntimeException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new RemoteJsonException("Invalid JSON"));
        return;
    }
    cb.onSuccess(data);
    RpcStatus.INSTANCE.onRpcComplete();
}
#end_block

#method_before
public RestApi addParameter(String name, int value) {
    return addParameterRaw(name, String.valueOf(value));
}
#method_after
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#end_block

#method_before
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#method_after
public <T extends JavaScriptObject> void send(final AsyncCallback<T> cb) {
    RequestBuilder req = new RequestBuilder(RequestBuilder.GET, url.toString());
    req.setHeader("Accept", JsonConstants.JSON_TYPE);
    req.setCallback(new MyRequestCallback<T>(true, cb));
    try {
        RpcStatus.INSTANCE.onRpcStart();
        req.send();
    } catch (RequestException e) {
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(e);
    }
}
#end_block

#method_before
@Deprecated
public Change.Id getId() {
    return changeId;
}
#method_after
public Change.Id getId() {
    return changeId;
}
#end_block

#method_before
@Deprecated
public int getChangeId() {
    return changeId.get();
}
#method_after
public int getChangeId() {
    return changeId.get();
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    this.testMergeabilityOfChangesbyBranch();
                    break;
                }
            case ALREADY_MERGED:
                {
                    setMerged(c, null);
                    break;
                }
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    String str = dependencyError(commit);
                    if (submitStillPossible) {
                        if (str != null) {
                            sendMergeFail(c, message(c, str), false, false);
                        }
                    } else {
                        setNew(c, message(c, str));
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).runTestMerge(change);
}
#method_after
public static void testMerge(MergeOp.Factory opFactory, Change change) {
    opFactory.create(change.getDest()).verifyMergeability(change);
}
#end_block

#method_before
public static void submit(MergeOp.Factory opFactory, PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db, MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (change.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, change.getDest());
    }
}
#method_after
public static void submit(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db, final MergeOp.Factory opFactory, final MergeQueue merger) throws OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSetApproval approval = createSubmitApproval(patchSetId, user, db);
    db.patchSetApprovals().upsert(Collections.singleton(approval));
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.NEW) {
                change.setStatus(Change.Status.SUBMITTED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
        merger.merge(opFactory, updatedChange.getDest());
    }
}
#end_block

#method_before
public static PatchSetApproval createSubmitApproval(PatchSet.Id patchSetId, IdentifiedUser user, ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#method_after
public static PatchSetApproval createSubmitApproval(final PatchSet.Id patchSetId, final IdentifiedUser user, final ReviewDb db) throws OrmException {
    final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
    final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT);
    for (final PatchSetApproval approval : allApprovals) {
        if (akey.equals(approval.getKey())) {
            approval.setValue((short) 1);
            approval.setGranted();
            return approval;
        }
    }
    return new PatchSetApproval(akey, (short) 1);
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canPushToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a refs/for/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    Map<String, Ref> blockingFors;
    try {
        blockingFors = repo.getRefDatabase().getRefs("refs/for/");
    } catch (IOException err) {
        String projName = project.getName();
        log.warn("Cannot scan refs in '" + projName + "'", err);
        return new Capable("Server process cannot read '" + projName + "'");
    }
    if (!blockingFors.isEmpty()) {
        String projName = project.getName();
        log.error("Repository '" + projName + "' needs the following refs removed to receive changes: " + blockingFors.keySet());
        return new Capable("One or more refs/for/ names blocks change upload");
    }
    return Capable.OK;
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
    ChangeUtil.testMerge(opFactory, change);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    ChangeUtil.testMerge(opFactory, change);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                change.setLastSha1MergeTested(null);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        ChangeUtil.mergeTestChangesByBranch(opFactory, destBranch);
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayDownload();
    patchTable = new PatchTable();
    patchTable.setSavePointerId("PatchTable " + patchSet.getId());
    patchTable.display(detail);
    body.add(infoTable);
    actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(actionsPanel);
    if (Gerrit.isSignedIn()) {
        populateReviewAction();
        if (changeDetail.isCurrentPatchSet(detail)) {
            populateActions(detail);
        }
    }
    populateDiffAllActions(detail);
    body.add(patchTable);
    if (!isMergeable) {
        final Label lbl = new Label();
        lbl.setText(Util.C.messageMergeFail());
        actionsPanel.add(lbl);
    }
    for (ClickHandler clickHandler : registeredClickHandler) {
        patchTable.addClickHandler(clickHandler);
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            populateReviewAction();
            if (changeDetail.isCurrentPatchSet(detail)) {
                populateActions(detail);
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && allowedSchemes.contains(DownloadScheme.ANON_GIT)) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    Set<ApprovalCategory.Id> allowed = changeDetail.getCurrentActions();
    if (allowed == null) {
        allowed = Collections.emptySet();
    }
    if (isOpen && allowed.contains(ApprovalCategory.SUBMIT)) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.setEnabled(isMergeable);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                new RestoreChangeDialog(patchSet.getId(), new AsyncCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        changeScreen.update(result);
                    }

                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                    }
                }).center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display("change,publish," + patchSet.getId().toString(), new PublishCommentScreen(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateReviewAction() {
    final Button b = new Button(Util.C.buttonReview());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            Gerrit.display(Dispatcher.toPublish(patchSet.getId()));
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        Util.DETAIL_SVC.patchSetDetail(patchSet.getId(), new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                ensureLoaded(result);
                patchTable.setRegisterKeys(true);
            }
        });
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
    errorlabel.setText(Util.C.messageMergeFail());
    body.add(errorlabel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen());
    approvalButtons = new ArrayList<ValueRadioButton>();
    descBlock = new ChangeDescriptionBlock();
    add(descBlock);
    final FormPanel form = new FormPanel();
    final FlowPanel body = new FlowPanel();
    form.setWidget(body);
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
        }
    });
    add(form);
    approvalPanel = new FlowPanel();
    body.add(approvalPanel);
    initMessage(body);
    draftsPanel = new FlowPanel();
    body.add(draftsPanel);
    final FlowPanel buttonRow = new FlowPanel();
    buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    body.add(buttonRow);
    send = new Button(Util.C.buttonPublishCommentsSend());
    send.addClickHandler(this);
    buttonRow.add(send);
    submit = new Button(Util.C.buttonPublishSubmitSend());
    submit.addClickHandler(this);
    buttonRow.add(submit);
    cancel = new Button(Util.C.buttonPublishCommentsCancel());
    cancel.addClickHandler(this);
    buttonRow.add(cancel);
}
#end_block

#method_before
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    for (final ApprovalType ct : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        if (r.isAllowed(ct.getCategory().getId())) {
            initApprovalType(r, body, ct);
        }
    }
}
#method_after
private void initApprovals(final PatchSetPublishDetail r, final Panel body) {
    ApprovalTypes types = Gerrit.getConfig().getApprovalTypes();
    for (PermissionRange range : r.getLabels()) {
        ApprovalType type = types.byLabel(range.getLabel());
        if (type != null) {
            // Legacy type, use radio buttons.
            initApprovalType(r, body, type, range);
        } else {
        // TODO Newer style label.
        }
    }
}
#end_block

#method_before
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final Set<ApprovalCategoryValue.Id> allowed = r.getAllowed(catId);
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!allowed.contains(buttonValue.getId())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initApprovalType(final PatchSetPublishDetail r, final Panel body, final ApprovalType ct, final PermissionRange range) {
    body.add(new SmallHeading(ct.getCategory().getName() + ":"));
    final VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    final List<ApprovalCategoryValue> lst = new ArrayList<ApprovalCategoryValue>(ct.getValues());
    Collections.reverse(lst);
    final ApprovalCategory.Id catId = ct.getCategory().getId();
    final PatchSetApproval prior = r.getChangeApproval(catId);
    for (final ApprovalCategoryValue buttonValue : lst) {
        if (!range.contains(buttonValue.getValue())) {
            continue;
        }
        final ValueRadioButton b = new ValueRadioButton(buttonValue, ct.getCategory().getName());
        b.setText(buttonValue.format());
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(buttonValue.getCategoryId())) {
            b.setValue(lastState.approvals.get(buttonValue.getCategoryId()).equals(buttonValue));
        } else {
            b.setValue(prior != null ? buttonValue.getValue() == prior.getValue() : buttonValue.getValue() == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.isSubmitAllowed());
    submit.setEnabled(r.getChange().isMergeable());
    errorlabel.setVisible(!r.getChange().isMergeable());
}
#method_after
private void display(final PatchSetPublishDetail r) {
    setPageTitle(Util.M.publishComments(r.getChange().getKey().abbreviate(), patchSetId.get()));
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    commentEditors = new ArrayList<CommentEditorPanel>();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName(Gerrit.RESOURCES.css().patchComments());
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any
                // next/previous links
                panel.add(new PatchLink.SideBySide(PatchTable.getDisplayFileName(patchKey), patchKey, 0, null, null));
                priorFile = fn;
            }
            final CommentEditorPanel editor = new CommentEditorPanel(c);
            editor.setAuthorNameText(Util.M.lineHeader(c.getLine()));
            editor.setOpen(true);
            commentEditors.add(editor);
            panel.add(editor);
        }
    }
    submit.setVisible(r.canSubmit());
    if (Gerrit.getConfig().testChangeMerge()) {
        submit.setEnabled(r.getChange().isMergeable());
    }
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> values = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            values.put(b.value.getCategoryId(), b.value.getId());
        }
    }
    enableForm(false);
    PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new HashSet<ApprovalCategoryValue.Id>(values.values()), new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }
    });
}
#method_after
private void submit() {
    Util.MANAGE_SVC.submit(patchSetId, new GerritCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            saveStateOnUnload = false;
            goChange();
        }

        @Override
        public void onFailure(Throwable caught) {
            goChange();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private String toHTML(SparseFileContent src) {
    SafeHtml html;
    if (diffPrefs.isIntralineDifference()) {
        html = colorLineEdits(src);
    } else {
        SafeHtmlBuilder b = new SafeHtmlBuilder();
        for (int index = src.first(); index < src.size(); index = src.next(index)) {
            b.append(src.get(index));
            b.append('\n');
        }
        html = b;
        final String r = // 
        "<span class=\"wse\"" + " title=\"" + PrettifyConstants.C.wseBareCR() + // 
        "\"" + ">&nbsp;</span>$1";
        html = html.replaceAll("\r([^\n])", r);
    }
    if (diffPrefs.isShowWhitespaceErrors()) {
        // We need to do whitespace errors before showing tabs, because
        // these patterns rely on \t as a literal, before it expands.
        // 
        html = showTabAfterSpace(html);
        html = showTrailingWhitespace(html);
    }
    if (diffPrefs.isShowCrLf()) {
        html = showCrLf(html);
    }
    if (diffPrefs.isShowTabs()) {
        String t = 1 < diffPrefs.getTabSize() ? "\t" : "";
        html = html.replaceAll("\t", "<span class=\"vt\">\u00BB</span>" + t);
    }
    return html.asString();
}
#method_after
private String toHTML(SparseFileContent src) {
    SafeHtml html;
    if (diffPrefs.isIntralineDifference()) {
        html = colorLineEdits(src);
    } else {
        SafeHtmlBuilder b = new SafeHtmlBuilder();
        for (int index = src.first(); index < src.size(); index = src.next(index)) {
            b.append(src.get(index));
            b.append('\n');
        }
        html = b;
        final String r = // 
        "<span class=\"wse\"" + " title=\"" + PrettifyConstants.C.wseBareCR() + // 
        "\"" + ">&nbsp;</span>$1";
        html = html.replaceAll("\r([^\n])", r);
    }
    if (diffPrefs.isShowWhitespaceErrors()) {
        // We need to do whitespace errors before showing tabs, because
        // these patterns rely on \t as a literal, before it expands.
        // 
        html = showTabAfterSpace(html);
        html = showTrailingWhitespace(html);
    }
    if (diffPrefs.isShowLineEndings()) {
        html = showLineEndings(html);
    }
    if (diffPrefs.isShowTabs()) {
        String t = 1 < diffPrefs.getTabSize() ? "\t" : "";
        html = html.replaceAll("\t", "<span class=\"vt\">\u00BB</span>" + t);
    }
    return html.asString();
}
#end_block

#method_before
private void appendShowBareCR(SafeHtmlBuilder buf, String src, boolean end) {
    while (!src.isEmpty()) {
        int cr = src.indexOf('\r');
        if (cr < 0) {
            buf.append(src);
            return;
        } else if (end) {
            if (cr == src.length() - 1) {
                buf.append(src.substring(0, cr + 1));
                return;
            }
        } else if (cr == src.length() - 2 && src.charAt(cr + 1) == '\n') {
            buf.append(src.substring(0, cr + 1));
            buf.append('\n');
            return;
        }
        buf.append(src.substring(0, cr));
        buf.openSpan();
        buf.setStyleName("wse");
        buf.setAttribute("title", PrettifyConstants.C.wseBareCR());
        buf.nbsp();
        buf.closeSpan();
        src = src.substring(cr + 1);
    }
}
#method_after
private void appendShowBareCR(SafeHtmlBuilder buf, String src, boolean end) {
    while (!src.isEmpty()) {
        int cr = src.indexOf('\r');
        if (cr < 0) {
            buf.append(src);
            return;
        } else if (end) {
            if (cr == src.length() - 1) {
                buf.append(src.substring(0, cr + 1));
                return;
            }
        } else if (cr == src.length() - 2 && src.charAt(cr + 1) == '\n') {
            buf.append(src);
            return;
        }
        buf.append(src.substring(0, cr));
        buf.openSpan();
        buf.setStyleName("wse");
        buf.setAttribute("title", PrettifyConstants.C.wseBareCR());
        buf.nbsp();
        buf.closeSpan();
        src = src.substring(cr + 1);
    }
}
#end_block

#method_before
protected void display() {
    final AccountDiffPreference dp = getValue();
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    crlfErrors.setValue(dp.isShowCrLf());
    showTabs.setValue(dp.isShowTabs());
    skipDeleted.setValue(dp.isSkipDeleted());
    skipUncommented.setValue(dp.isSkipUncommented());
    expandAllComments.setValue(dp.isExpandAllComments());
    retainHeader.setValue(dp.isRetainHeader());
    manualReview.setValue(dp.isManualReview());
}
#method_after
protected void display() {
    final AccountDiffPreference dp = getValue();
    setIgnoreWhitespace(dp.getIgnoreWhitespace());
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(dp.isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    setContext(dp.getContext());
    tabWidth.setIntValue(dp.getTabSize());
    colWidth.setIntValue(dp.getLineLength());
    intralineDifference.setValue(dp.isIntralineDifference());
    whitespaceErrors.setValue(dp.isShowWhitespaceErrors());
    showLineEndings.setValue(dp.isShowLineEndings());
    showTabs.setValue(dp.isShowTabs());
    skipDeleted.setValue(dp.isSkipDeleted());
    skipUncommented.setValue(dp.isSkipUncommented());
    expandAllComments.setValue(dp.isExpandAllComments());
    retainHeader.setValue(dp.isRetainHeader());
    manualReview.setValue(dp.isManualReview());
}
#end_block

#method_before
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowCrLf(crlfErrors.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    dp.setExpandAllComments(expandAllComments.getValue());
    dp.setRetainHeader(retainHeader.getValue());
    dp.setManualReview(manualReview.getValue());
    listenablePrefs.set(dp);
}
#method_after
private void update() {
    if (colWidth.getIntValue() <= 0) {
        new ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center();
        return;
    }
    AccountDiffPreference dp = new AccountDiffPreference(getValue());
    dp.setIgnoreWhitespace(getIgnoreWhitespace());
    dp.setContext(getContext());
    dp.setTabSize(tabWidth.getIntValue());
    dp.setLineLength(colWidth.getIntValue());
    dp.setSyntaxHighlighting(syntaxHighlighting.getValue());
    dp.setIntralineDifference(intralineDifference.getValue());
    dp.setShowWhitespaceErrors(whitespaceErrors.getValue());
    dp.setShowLineEndings(showLineEndings.getValue());
    dp.setShowTabs(showTabs.getValue());
    dp.setSkipDeleted(skipDeleted.getValue());
    dp.setSkipUncommented(skipUncommented.getValue());
    dp.setExpandAllComments(expandAllComments.getValue());
    dp.setRetainHeader(retainHeader.getValue());
    dp.setManualReview(manualReview.getValue());
    listenablePrefs.set(dp);
}
#end_block

#method_before
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowCrLf(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    return p;
}
#method_after
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowLineEndings(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    return p;
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    if (query.length() == 0) {
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#method_after
@Override
protected void onRequestSuggestions(Request request, Callback done) {
    final String query = request.getQuery();
    int lastSpace = query.lastIndexOf(' ');
    final String lastWord;
    // NOTE: this method is not called if the query is empty.
    if (lastSpace == query.length() - 1) {
        // Starting a new word - don't show suggestions yet.
        done.onSuggestionsReady(request, null);
        return;
    } else if (lastSpace == -1) {
        lastWord = query;
    } else {
        lastWord = query.substring(lastSpace + 1);
    }
    final ArrayList<SearchSuggestion> r = new ArrayList<SearchSuggestOracle.SearchSuggestion>();
    for (String suggestion : suggestions.tailSet(lastWord)) {
        if ((lastWord.length() < suggestion.length()) && suggestion.startsWith(lastWord)) {
            if (suggestion.contains("self") && !Gerrit.isSignedIn()) {
                continue;
            }
            r.add(new SearchSuggestion(suggestion, query + suggestion.substring(lastWord.length())));
        }
    }
    done.onSuggestionsReady(request, new Response(r));
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (names != null && !names.isEmpty()) {
        try {
            loader.enablePlugins(Sets.newHashSet(names));
        } catch (PluginInstallException e) {
            e.printStackTrace(stderr);
            throw die("plugin failed to install");
        }
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (names != null && !names.isEmpty()) {
        try {
            loader.enablePlugins(Sets.newHashSet(names));
        } catch (PluginInstallException e) {
            e.printStackTrace(stderr);
            throw die("plugin failed to enable");
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        String name = nameOf(jar);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        String name = nameOf(jar);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            oldPlugin.stop();
            running.remove(name);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            oldPlugin.stop();
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        unload.remove(nameOf(jar));
    }
    for (String name : unload) {
        log.info(String.format("Unloading plugin %s", name));
        running.remove(name).stop();
    }
}
#method_after
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        log.info(String.format("Unloading plugin %s", name));
        running.remove(name).stop();
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        unload.remove(nameOf(jar));
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    for (index--; index > -1; index--) {
        InlineHyperlink link = createLink(index, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getPreviousPatchLink(int index, PatchScreen.Type patchType) {
    int previousPatchIndex = getPreviousPatch(index, PREFERENCE_VALIDATOR);
    if (previousPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(previousPatchIndex, patchType, SafeHtml.asis(Util.C.prevPatchLinkIcon()), null);
    return link;
}
#end_block

#method_before
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    for (index++; index < patchList.size(); index++) {
        InlineHyperlink link = createLink(index, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
        if (link != null) {
            return link;
        }
    }
    return null;
}
#method_after
public InlineHyperlink getNextPatchLink(int index, PatchScreen.Type patchType) {
    int nextPatchIndex = getNextPatch(index, false, PREFERENCE_VALIDATOR);
    if (nextPatchIndex < 0) {
        return null;
    }
    InlineHyperlink link = createLink(nextPatchIndex, patchType, null, SafeHtml.asis(Util.C.nextPatchLinkIcon()));
    return link;
}
#end_block

#method_before
private PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    if ((listenablePrefs.get().isSkipDeleted() && patch.getChangeType().equals(ChangeType.DELETED)) || (listenablePrefs.get().isSkipUncommented() && patch.getCommentCount() == 0)) {
        return null;
    }
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
public PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    loadedInfoTable(detail);
    loadedActionPanel(detail);
    loadedPatchTable(detail);
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    loadInfoTable(detail);
    loadActionPanel(detail);
    loadPatchTable(detail);
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(parent.shortMessage));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(Util.cropSubject(parent.shortMessage)));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
public void refresh() {
    if (patchSet.getId().equals(diffBaseId)) {
        if (patchTable != null) {
            patchTable.setVisible(false);
        }
        if (actionsPanel != null) {
            actionsPanel.setVisible(false);
        }
    } else {
        if (patchTable != null) {
            if (patchTable.getBase() == null && diffBaseId == null || patchTable.getBase() != null && patchTable.getBase().equals(diffBaseId)) {
                actionsPanel.setVisible(true);
                patchTable.setVisible(true);
                return;
            }
        }
        AccountDiffPreference diffPrefs;
        if (patchTable == null) {
            diffPrefs = new ListenableAccountDiffPreference().get();
        } else {
            diffPrefs = patchTable.getPreferences().get();
            patchTable.setVisible(false);
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                if (actionsPanel != null) {
                    actionsPanel.setVisible(true);
                } else {
                    loadedActionPanel(result);
                }
                loadedPatchTable(result);
            }
        });
    }
}
#method_after
public void refresh() {
    if (patchSet.getId().equals(diffBaseId)) {
        if (patchTable != null) {
            patchTable.setVisible(false);
        }
        if (actionsPanel != null) {
            actionsPanel.setVisible(false);
        }
    } else {
        if (patchTable != null) {
            if (patchTable.getBase() == null && diffBaseId == null || patchTable.getBase() != null && patchTable.getBase().equals(diffBaseId)) {
                actionsPanel.setVisible(true);
                patchTable.setVisible(true);
                return;
            }
        }
        AccountDiffPreference diffPrefs;
        if (patchTable == null) {
            diffPrefs = new ListenableAccountDiffPreference().get();
        } else {
            diffPrefs = patchTable.getPreferences().get();
            patchTable.setVisible(false);
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                if (actionsPanel != null) {
                    actionsPanel.setVisible(true);
                } else {
                    loadActionPanel(result);
                }
                loadPatchTable(result);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                loadedInfoTable(result);
                loadedActionPanel(result);
            }
        });
    }
}
#method_after
@Override
public void onOpen(final OpenEvent<DisclosurePanel> event) {
    if (infoTable == null) {
        AccountDiffPreference diffPrefs;
        if (diffBaseId == null) {
            diffPrefs = null;
        } else {
            diffPrefs = new ListenableAccountDiffPreference().get();
        }
        Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                loadInfoTable(result);
                loadActionPanel(result);
            }
        });
    }
}
#end_block

#method_before
public static void doSignIn(String token) {
    switch(myConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
            Location.assign(loginRedirect(token));
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            Location.assign(selfRedirect("/become"));
            break;
        case OPENID_SSO:
            singleSignOnPanel.authenticate(SignInMode.SIGN_IN, token);
            break;
        case OPENID:
            new OpenIdSignInDialog(SignInMode.SIGN_IN, token, null).center();
            break;
        case LDAP:
        case LDAP_BIND:
            new UserPassSignInDialog(token, null).center();
            break;
    }
}
#method_after
public static void doSignIn(String token) {
    switch(myConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
            Location.assign(loginRedirect(token));
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            Location.assign(selfRedirect("/become"));
            break;
        case OPENID_SSO:
            final RootPanel gBody = RootPanel.get("gerrit_body");
            OpenIdSsoPanel singleSignOnPanel = new OpenIdSsoPanel();
            gBody.add(singleSignOnPanel);
            singleSignOnPanel.authenticate(SignInMode.SIGN_IN, token);
            break;
        case OPENID:
            new OpenIdSignInDialog(SignInMode.SIGN_IN, token, null).center();
            break;
        case LDAP:
        case LDAP_BIND:
            new UserPassSignInDialog(token, null).center();
            break;
    }
}
#end_block

#method_before
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    singleSignOnPanel = new OpenIdSsoPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(singleSignOnPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#method_after
private void onModuleLoad2() {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(menuRight);
    menuRightPanel.add(searchPanel);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xsrfToken;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    display(token);
}
#end_block

#method_before
public void authenticate(SignInMode requestedMode, final String token) {
    OpenIdUtil.SVC.discover(ssoUrl, requestedMode, /* remember */
    false, token, new GerritCallback<DiscoveryResult>() {

        public void onSuccess(final DiscoveryResult result) {
            onDiscovery(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            super.onFailure(caught);
        }
    });
}
#method_after
public void authenticate(SignInMode requestedMode, final String token) {
    OpenIdUtil.SVC.discover(ssoUrl, requestedMode, /* remember */
    false, token, new GerritCallback<DiscoveryResult>() {

        public void onSuccess(final DiscoveryResult result) {
            onDiscovery(result);
        }
    });
}
#end_block

#method_before
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    reloadButton = new Button(Util.C.buttonReloadPlugins());
    reloadButton.setTitle(Util.C.buttonReloadPluginsToolTip());
    reloadButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doReloadPlugins();
        }
    });
    HorizontalPanel buttonPanel = new HorizontalPanel();
    buttonPanel.add(reloadButton);
    buttonPanel.addStyleName(Gerrit.RESOURCES.css().pluginsTableButtonPanel());
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    pluginPanel.add(buttonPanel);
    add(pluginPanel);
}
#method_after
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    add(pluginPanel);
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    table.setWidget(row, 2, new Anchor(plugin.name(), Gerrit.selfRedirect("/plugins/" + plugin.name() + "/")));
    table.setText(row, 3, plugin.version());
    if (plugin.isDisabled()) {
        table.setText(row, 4, Util.C.pluginDisabled());
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    if (plugin.isDisabled()) {
        table.setText(row, 1, plugin.name());
    } else {
        table.setWidget(row, 1, new Anchor(plugin.name(), Gerrit.selfRedirect("/plugins/" + plugin.name() + "/")));
    }
    table.setText(row, 2, plugin.version());
    if (plugin.isDisabled()) {
        table.setText(row, 3, Util.C.pluginDisabled());
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
private void createReviewedPanel() {
    reviewedPanel = new FlowPanel();
    reviewedCheckBox = new CheckBox();
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    Anchor reviewedAnchor = new Anchor(PatchUtil.C.reviewed());
    reviewedAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setReviewedByCurrentUser(true);
        }
    });
    final PatchValidator unreviewedValidator = new PatchValidator() {

        public boolean isValid(Patch patch) {
            return !patch.isReviewedByCurrentUser();
        }
    };
    int nextUnreviewedPatchIndex = patchSetDetail.getNextPatch(patchIndex, true, unreviewedValidator, fileList.PREFERENCE_VALIDATOR);
    if (nextUnreviewedPatchIndex > -1) {
        // Create invisible patch link to change page
        final PatchLink reviewedLink = fileList.createLink(nextUnreviewedPatchIndex, getPatchScreenType(), null, null);
        reviewedLink.setText("");
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                reviewedLink.go();
            }
        });
    } else {
        final ChangeLink upLink = new ChangeLink("", patchKey.getParentKey());
        reviewedAnchor.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                upLink.go();
            }
        });
    }
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(reviewedAnchor);
}
#method_after
private void createReviewedPanel() {
    reviewedPanel = new FlowPanel();
    reviewedCheckBox = new CheckBox(PatchUtil.C.reviewedAnd() + " ");
    reviewedCheckBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            setReviewedByCurrentUser(event.getValue());
        }
    });
    reviewedPanel.add(reviewedCheckBox);
    reviewedPanel.add(getReviewedAnchor());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SingleUserGroup.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(SingleUserGroup.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), GroupBackend.class).to(SingleUserGroup.class);
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(final IdentifiedUser user) {
    return new GroupMembership() {

        @Override
        public boolean contains(AccountGroup.UUID uuid) {
            return username(uuid).equals(user.getUserName());
        }

        @Override
        public boolean containsAnyOf(Iterable<AccountGroup.UUID> groups) {
            for (AccountGroup.UUID uuid : groups) {
                if (contains(uuid)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public Set<AccountGroup.UUID> getKnownGroups() {
            return Collections.emptySet();
        }
    };
}
#method_after
@Override
public GroupMembership membershipsOf(final IdentifiedUser user) {
    ImmutableList.Builder<AccountGroup.UUID> groups = ImmutableList.builder();
    groups.add(uuid(user.getAccountId()));
    if (user.getUserName() != null) {
        groups.add(uuid(user.getUserName()));
    }
    return new ListGroupMembership(groups.build());
}
#end_block

#method_before
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    AccountState state = accountCache.getByUsername(username(uuid));
    if (state != null) {
        final String name = nameOf(state);
        return new GroupDescription.Basic() {

            @Override
            public AccountGroup.UUID getGroupUUID() {
                return uuid;
            }

            @Override
            public String getName() {
                return name;
            }

            @Override
            public boolean isVisibleToAll() {
                return false;
            }
        };
    }
    return null;
}
#method_after
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    String ident = username(uuid);
    AccountState state;
    if (ident.matches(ACCOUNT_ID_PATTERN)) {
        state = accountCache.get(new Account.Id(Integer.parseInt(ident)));
    } else if (ident.matches(Account.USER_NAME_PATTERN)) {
        state = accountCache.getByUsername(ident);
    } else {
        return null;
    }
    if (state != null) {
        final String name = nameOf(uuid, state);
        return new GroupDescription.Basic() {

            @Override
            public AccountGroup.UUID getGroupUUID() {
                return uuid;
            }

            @Override
            public String getName() {
                return name;
            }

            @Override
            public boolean isVisibleToAll() {
                return false;
            }
        };
    }
    return null;
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(String name) {
    if (name.startsWith(NAME_PREFIX)) {
        name = name.substring(NAME_PREFIX.length());
    }
    if (name.length() < 3) {
        return Collections.emptyList();
    }
    try {
        AccountControl ctl = accountControlFactory.get();
        Set<Account.Id> ids = Sets.newHashSet();
        List<GroupReference> matches = Lists.newArrayListWithCapacity(MAX);
        String a = name;
        String b = end(a);
        ReviewDb db = schemaFactory.open();
        try {
            if (name.matches("[1-9][0-9]*")) {
                Account.Id id = new Account.Id(Integer.parseInt(name));
                if (db.accounts().get(id) != null && ctl.canSee(id)) {
                    add(matches, id);
                    if (!matches.isEmpty()) {
                        return matches;
                    }
                }
            }
            if (name.matches(Account.USER_NAME_PATTERN)) {
                for (AccountExternalId e : db.accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + b), MAX)) {
                    if (!e.getSchemeRest().startsWith(a)) {
                        break;
                    } else if (ids.add(e.getAccountId()) && ctl.canSee(e.getAccountId())) {
                        add(matches, e.getAccountId());
                    }
                    if (matches.size() == MAX) {
                        return matches;
                    }
                }
            }
            for (Account p : db.accounts().suggestByFullName(a, b, MAX)) {
                if (!p.getFullName().startsWith(a)) {
                    break;
                } else if (ids.add(p.getId()) && ctl.canSee(p.getId())) {
                    add(matches, p.getId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            for (Account p : db.accounts().suggestByPreferredEmail(a, b, MAX)) {
                if (!p.getPreferredEmail().startsWith(a)) {
                    break;
                } else if (ids.add(p.getId()) && ctl.canSee(p.getId())) {
                    add(matches, p.getId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            for (AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, MAX)) {
                if (!e.getEmailAddress().startsWith(a)) {
                    break;
                } else if (ids.add(e.getAccountId()) && ctl.canSee(e.getAccountId())) {
                    add(matches, e.getAccountId());
                }
                if (matches.size() == MAX) {
                    return matches;
                }
            }
            return matches;
        } finally {
            db.close();
        }
    } catch (OrmException err) {
        log.warn("Cannot suggest users", err);
        return Collections.emptyList();
    }
}
#method_after
@Override
public Collection<GroupReference> suggest(String name) {
    if (name.startsWith(NAME_PREFIX)) {
        name = name.substring(NAME_PREFIX.length());
    } else if (name.startsWith(ACCOUNT_PREFIX)) {
        name = name.substring(ACCOUNT_PREFIX.length());
    }
    if (name.isEmpty()) {
        return Collections.emptyList();
    }
    try {
        AccountControl ctl = accountControlFactory.get();
        Set<Account.Id> ids = Sets.newHashSet();
        List<GroupReference> matches = Lists.newArrayListWithCapacity(MAX);
        String a = name;
        String b = end(a);
        ReviewDb db = schemaFactory.open();
        try {
            if (name.matches(ACCOUNT_ID_PATTERN)) {
                Account.Id id = new Account.Id(Integer.parseInt(name));
                if (db.accounts().get(id) != null) {
                    add(matches, ids, ctl, id);
                    return matches;
                }
            }
            if (name.matches(Account.USER_NAME_PATTERN)) {
                for (AccountExternalId e : db.accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME + b), MAX)) {
                    if (!e.getSchemeRest().startsWith(a)) {
                        break;
                    }
                    add(matches, ids, ctl, e.getAccountId());
                }
            }
            for (Account p : db.accounts().suggestByFullName(a, b, MAX)) {
                if (!p.getFullName().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, p.getId());
            }
            for (Account p : db.accounts().suggestByPreferredEmail(a, b, MAX)) {
                if (!p.getPreferredEmail().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, p.getId());
            }
            for (AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, MAX)) {
                if (!e.getEmailAddress().startsWith(a)) {
                    break;
                }
                add(matches, ids, ctl, e.getAccountId());
            }
            return matches;
        } finally {
            db.close();
        }
    } catch (OrmException err) {
        log.warn("Cannot suggest users", err);
        return Collections.emptyList();
    }
}
#end_block

#method_before
private void add(List<GroupReference> matches, Account.Id id) {
    AccountState state = accountCache.get(id);
    if (state != null && state.getUserName() != null) {
        matches.add(new GroupReference(uuid(state.getUserName()), nameOf(state)));
    }
}
#method_after
private void add(List<GroupReference> matches, Set<Account.Id> ids, AccountControl ctl, Account.Id id) {
    if (!ids.add(id) || !ctl.canSee(id)) {
        return;
    }
    AccountState state = accountCache.get(id);
    if (state == null) {
        return;
    }
    AccountGroup.UUID uuid;
    if (state.getUserName() != null) {
        uuid = uuid(state.getUserName());
    } else {
        uuid = uuid(id);
    }
    matches.add(new GroupReference(uuid, nameOf(uuid, state)));
}
#end_block

#method_before
private static AccountGroup.UUID uuid(String username) {
    return new AccountGroup.UUID(UUID_PREFIX + username);
}
#method_after
private static AccountGroup.UUID uuid(Account.Id ident) {
    return uuid(Integer.toString(ident.get()));
}
#end_block

#method_before
private static String nameOf(AccountState account) {
    if (account.getAccount().getFullName() != null) {
        return account.getAccount().getFullName();
    } else if (account.getUserName() != null) {
        return NAME_PREFIX + account.getUserName();
    } else {
        return NAME_PREFIX + account.getAccount().getId().get();
    }
}
#method_after
private static String nameOf(AccountGroup.UUID uuid, AccountState account) {
    StringBuilder buf = new StringBuilder();
    if (account.getAccount().getFullName() != null) {
        buf.append(account.getAccount().getFullName());
    }
    if (account.getUserName() != null) {
        if (buf.length() > 0) {
            buf.append(" (").append(account.getUserName()).append(")");
        } else {
            buf.append(account.getUserName());
        }
    } else if (buf.length() > 0) {
        buf.append(" (").append(account.getAccount().getId().get()).append(")");
    } else {
        buf.append(account.getAccount().getId().get());
    }
    String ident = username(uuid);
    if (ident.matches(ACCOUNT_ID_PATTERN)) {
        buf.insert(0, ACCOUNT_PREFIX);
    } else {
        buf.insert(0, NAME_PREFIX);
    }
    return buf.toString();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS, sugestParent);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectListPopup.setCoordinates(top, left);
            projectListPopup.display();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.suggestParentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.parentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                continue;
            }
            if (!isVisible && !(showTree && pctl.isOwner())) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && format.isJson() || (type == FilterType.SUGGEST_PARENT_CANDIDATES)) {
                ProjectState parent = e.getParentState();
                if (parent != null) {
                    ProjectControl parentCtrl = parent.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                            info.name = parent.getProject().getName();
                            info.description = parent.getProject().getDescription();
                            if (format.isJson()) {
                                output.put(info.name, info);
                            }
                            continue;
                        }
                        info.parent = parent.getProject().getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getProject().getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getProject().getName(), info.parent);
                        }
                    }
                } else {
                    if (type == FilterType.SUGGEST_PARENT_CANDIDATES) {
                        continue;
                    }
                }
            }
            info.name = projectName.get();
            if (showDescription && !e.getProject().getDescription().isEmpty()) {
                info.description = e.getProject().getDescription();
            }
            try {
                if (showBranch != null) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = Maps.newLinkedHashMap();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    } finally {
                        git.close();
                    }
                } else if (!showTree && type != FilterType.ALL) {
                    Repository git = repoManager.openRepository(projectName);
                    try {
                        if (!type.matches(git)) {
                            continue;
                        }
                    } finally {
                        git.close();
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + info.description.replace("\n", "\\n"));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#method_after
public void display(OutputStream out) {
    final PrintWriter stdout;
    try {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, "UTF-8")));
    } catch (UnsupportedEncodingException e) {
        // Our encoding is required by the specifications for the runtime.
        throw new RuntimeException("JVM lacks UTF-8 encoding", e);
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = e.getParentState();
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = parentState.getProject().getDescription();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final ProjectControl pctl = e.controlFor(currentUser);
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = e.getParentState();
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription && !e.getProject().getDescription().isEmpty()) {
                    info.description = e.getProject().getDescription();
                }
                try {
                    if (showBranch != null) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (showBranch != null) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
    } finally {
        stdout.flush();
    }
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
    resetHandlerRegistration();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    vp = new VerticalPanel();
    addCreateProjectPanel();
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
    projectListPopup.addProjectListPopupHandler(new ProjectListPopupHandler() {

        @Override
        public void onClose(ProjectListPopupOnCloseEvent projectListPopupEvent) {
            resetHandlerRegistration();
        }

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            sugestParent.setText(projectListPopupEvent.getProjectName());
        }

        @Override
        public void onMovePointer(ProjectListPopupOnMovePointerEvent projectListPopupEvent) {
            // prevent user input from being overwritten by simply poping up
            if (!projectListPopupEvent.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectListPopupEvent.getProjectName());
            }
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    final HorizontalPanel bp = new HorizontalPanel();
    bp.add(create);
    fp.add(bp);
    vp.add(fp);
    initSuggestedParents();
    add(vp);
}
#method_after
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    fp.add(create);
    VerticalPanel vp = new VerticalPanel();
    vp.add(fp);
    initSuggestedParents();
    vp.add(suggestedParentsTab);
    add(vp);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), suggestedParentsTab.getAbsoluteLeft() + suggestedParentsTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    vp.add(suggestedParentsTab);
    Util.PROJECT_SVC.suggestParentCandidates(new AsyncCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.permissions(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS, nameTxt, this);
    projectListPopup.addProjectListPopupOnOpenRowHandler(new ProjectListPopup.ProjectListPopupOnOpenRowHandler() {

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            doAddNew();
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPopingUp() || "".equals(nameBox.getText())) {
                nameBox.setText(projectName);
            }
        }

        @Override
        protected void openRow(String projectName) {
            nameBox.setText(projectName);
            doAddNew();
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.SETTINGS_PROJECTS);
}
#end_block

#method_before
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            calculatePopupCoordinates();
            projectListPopup.display();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#method_after
protected void createWidgets() {
    nameBox = new HintTextBox();
    nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
    nameBox.setVisibleLength(50);
    nameBox.setHintText(Util.C.defaultProjectName());
    nameBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            submitOnSelection = false;
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                if (((DefaultSuggestionDisplay) nameTxt.getSuggestionDisplay()).isSuggestionListShowing()) {
                    submitOnSelection = true;
                } else {
                    doAddNew();
                }
            }
        }
    });
    nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

        @Override
        public void onSelection(SelectionEvent<Suggestion> event) {
            if (submitOnSelection) {
                submitOnSelection = false;
                doAddNew();
            }
        }
    });
    filterTxt = new HintTextBox();
    filterTxt.setVisibleLength(50);
    filterTxt.setHintText(Util.C.defaultFilter());
    filterTxt.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNew();
            }
        }
    });
    addNew = new Button(Util.C.buttonWatchProject());
    addNew.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            projectsPopup.setPreferredCoordinates(top, left);
            projectsPopup.displayPopup();
        }
    });
    watchesTab = new MyWatchesTable();
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watchesTab.deleteChecked();
        }
    });
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    projectListPopup.closePopup();
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    projectsPopup.closePopup();
}
#end_block

#method_before
protected void initPopup() {
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            if (top + offsetHeight > Window.getClientWidth()) {
                top = Window.getClientWidth() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#method_after
public void initPopup(final String popupText, final String currentPageLink) {
    createWidgets(popupText, currentPageLink);
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    sp.setSize("100%", "100%");
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popup.setHeight("100%");
    popupPosition = getPositionCallback();
}
#end_block

#method_before
protected void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            handlerManager.fireEvent(new ProjectListPopupOnMovePointerEvent(popingUp, getRowItem(row).getName()));
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            handlerManager.fireEvent(new ProjectListPopupOnOpenRowEvent(getRowItem(row).getName()));
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
            handlerManager.fireEvent(new ProjectListPopupOnCloseEvent());
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#method_after
private void createWidgets(final String popupText, final String currentPageLink) {
    projectsTab = new ProjectsTable() {

        @Override
        protected void movePointerTo(final int row, final boolean scroll) {
            super.movePointerTo(row, scroll);
            onMovePointerTo(getRowItem(row).name());
        }

        @Override
        protected void onOpenRow(final int row) {
            super.onOpenRow(row);
            openRow(getRowItem(row).name());
        }
    };
    projectsTab.setSavePointerId(currentPageLink);
    close = new Button(Util.C.projectsClose());
    close.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            closePopup();
        }
    });
    popup = new PluginSafeDialogBox();
    popup.setModal(false);
    popup.setText(popupText);
}
#end_block

#method_before
public void closePopup() {
    popup.hide();
    resetHandlerRegistration();
}
#method_after
public void closePopup() {
    popup.hide();
}
#end_block

#method_before
protected void populateProjects() {
    Util.PROJECT_SVC.visibleProjects(new GerritCallback<ProjectList>() {

        @Override
        public void onSuccess(final ProjectList result) {
            projectsTab.display(result.getProjects());
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                display();
            }
        }
    });
}
#method_after
protected void populateProjects() {
    ProjectMap.all(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(final ProjectMap result) {
            projectsTab.display(result);
            if (firstPopupLoad) {
                // Display was delayed until table was loaded
                firstPopupLoad = false;
                displayPopup();
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    if (Gerrit.isSignedIn()) {
        setTitleFarEast(reviewed);
    }
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(patchKey.getParentKey(), 0, 'u'));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    historyTable = new HistoryTable(this);
    commitMessageBlock = new CommitMessageBlock();
    topPanel = new FlowPanel();
    add(topPanel);
    header = new PatchTableHeader(getPatchScreenType());
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference());
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    topNav = new NavLinks(keysNavigation, patchKey.getParentKey());
    bottomNav = new NavLinks(null, patchKey.getParentKey());
    add(topNav);
    contentPanel = new FlowPanel();
    contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable());
    contentPanel.add(header);
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(bottomNav);
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(script, patchKey, idSideA, idSideB, getPatchScreenType());
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    header.display(patchSetDetail, script, patchKey, idSideA, idSideB);
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
public void display(final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB, final PatchScreen.Type type) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.screenType = type;
    this.links = new LinkedList<Anchor>();
    linkPanel.add(new Label(PatchUtil.C.patchSet() + " "));
    if (side == Side.A) {
        addLink("Base", null);
    } else {
        links.add(null);
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    downloadLink();
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new LinkedList<Anchor>();
    if (screenType == PatchScreen.Type.UNIFIED) {
        sideMarker.setInnerText((side == Side.A) ? "(-)" : "(+)");
    }
    if (detail.getInfo().getParents().size() > 1) {
        addLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        addLink(PatchUtil.C.patchBase(), null);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        addLink(Integer.toString(psId.get()), psId);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = getDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(new Label(" - "));
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key k = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, k));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, k));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#method_after
private void addLink(String label, final PatchSet.Id id) {
    final Anchor anchor = new Anchor(label);
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (side == Side.A) {
                idSideA = id;
            } else {
                idSideB = id;
            }
            Patch.Key keySideB = new Patch.Key(idSideB, patchKey.get());
            switch(screenType) {
                case SIDE_BY_SIDE:
                    Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, keySideB));
                    break;
                case UNIFIED:
                    Gerrit.display(Dispatcher.toPatchUnified(idSideA, keySideB));
                    break;
            }
        }
    });
    links.add(anchor);
    linkPanel.add(anchor);
}
#end_block

#method_before
public void display(PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB, PatchScreen.Type type) {
    listA.display(script, patchKey, idSideA, idSideB, type);
    listB.display(script, patchKey, idSideA, idSideB, type);
    if (type == PatchScreen.Type.UNIFIED) {
        aligner.getStyle().setDisplay(Display.NONE);
    }
}
#method_after
public void display(final PatchSetDetail detail, PatchScript script, final Patch.Key patchKey, final PatchSet.Id idSideA, final PatchSet.Id idSideB) {
    listA.display(detail, script, patchKey, idSideA, idSideB);
    listB.display(detail, script, patchKey, idSideA, idSideB);
}
#end_block

#method_before
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        String parentMsg = parent.shortMessage;
        if (parentMsg.length() > 80) {
            parentMsg = parentMsg.substring(0, 80) + "...";
        }
        parentsTable.setWidget(row, 1, new InlineLabel(parentMsg));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#method_after
private void displayParents(final List<PatchSetInfo.ParentInfo> parents) {
    if (parents.size() == 0) {
        infoTable.setWidget(R_PARENTS, 1, new InlineLabel(Util.C.initialCommit()));
        return;
    }
    final Grid parentsTable = new Grid(parents.size(), 2);
    parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable());
    parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder());
    final CellFormatter ptfmt = parentsTable.getCellFormatter();
    int row = 0;
    for (PatchSetInfo.ParentInfo parent : parents) {
        parentsTable.setWidget(row, 0, new InlineLabel(parent.id.get()));
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder());
        ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace());
        parentsTable.setWidget(row, 1, new InlineLabel(Util.cropSubject(parent.shortMessage)));
        ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder());
        row++;
    }
    infoTable.setWidget(R_PARENTS, 1, parentsTable);
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or change/patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSetIds.addAll(parsePatchSetId(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSetIds.addAll(parsePatchSetId(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent event) {
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent event) {
    resetEditors();
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final Set<String> diffs = new HashSet<String>();
            final Map<String, AccessSection> wantedSections = new HashMap<String, AccessSection>();
            for (final AccessSection section : wantedAccess.getLocal()) {
                wantedSections.put(section.getName(), section);
            }
            for (final AccessSection newSection : newAccess.getLocal()) {
                final AccessSection wantedSection = wantedSections.remove(newSection.getName());
                if (wantedSection == null) {
                    diffs.add(newSection.getName());
                    continue;
                }
                if (wantedSection.compareTo(newSection) != 0) {
                    diffs.add(wantedSection.getName());
                    continue;
                }
            }
            for (final AccessSection wantedSection : wantedSections.values()) {
                diffs.add(wantedSection.getName());
            }
            return diffs;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            super.onFailure(caught);
        }
    });
}
#method_after
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final HashSet<AccessSection> same = new HashSet<AccessSection>(wantedAccess.getLocal());
            final HashSet<AccessSection> different = new HashSet<AccessSection>(wantedAccess.getLocal().size() + newAccess.getLocal().size());
            different.addAll(wantedAccess.getLocal());
            different.addAll(newAccess.getLocal());
            same.retainAll(newAccess.getLocal());
            different.removeAll(same);
            final Set<String> differentNames = new HashSet<String>();
            for (final AccessSection s : different) {
                differentNames.add(s.getName());
            }
            return differentNames;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    table.setWidget(row, 1, new Anchor(plugin.name(), "/plugins/" + plugin.name() + "/"));
    table.setText(row, 2, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    table.setWidget(row, 1, new Anchor(plugin.name(), Gerrit.selfRedirect("/plugins/" + plugin.name() + "/")));
    table.setText(row, 2, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.initHighlightUnreviewed(true, ownerId);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable2();
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable2.Section();
    incoming = new ChangeTable2.Section();
    closed = new ChangeTable2.Section();
    outgoing.setTitleText(Util.C.outgoingReviews());
    incoming.setTitleText(Util.C.incomingReviews());
    incoming.setHighlightUnreviewed(true);
    closed.setTitleText(Util.C.recentlyClosed());
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#end_block

#method_before
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), compare());
    Collections.sort(in.asList(), compare());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#method_after
private void display(NativeList<ChangeList> result) {
    if (!mine && !hasChanges(result)) {
        // When no results are returned and the data is not for the
        // current user, the target user is presumed to not exist.
        Gerrit.display(getToken(), new NotFoundScreen());
        return;
    }
    ChangeList out = result.get(0);
    ChangeList in = result.get(1);
    ChangeList done = result.get(2);
    if (mine) {
        setWindowTitle(Util.C.myDashboardTitle());
        setPageTitle(Util.C.myDashboardTitle());
    } else {
        // The server doesn't tell us who the dashboard is for. Try to guess
        // by looking at a change started by the owner and extract the name.
        String name = guessName(out);
        if (name == null) {
            name = guessName(done);
        }
        if (name != null) {
            setWindowTitle(name);
            setPageTitle(Util.M.accountDashboardTitle(name));
        } else {
            setWindowTitle(Util.C.unknownDashboardTitle());
            setWindowTitle(Util.C.unknownDashboardTitle());
        }
    }
    Collections.sort(out.asList(), outComparator());
    table.updateColumnsForLabels(out, in, done);
    outgoing.display(out);
    incoming.display(in);
    closed.display(done);
    table.finishDisplay();
}
#end_block

#method_before
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#method_after
public final SubmitRecord.Label.Status status() {
    if (approved() != null) {
        return SubmitRecord.Label.Status.OK;
    } else if (rejected() != null) {
        return SubmitRecord.Label.Status.REJECT;
    } else if (optional()) {
        return SubmitRecord.Label.Status.MAY;
    } else {
        return SubmitRecord.Label.Status.NEED;
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed, Account.Id accountId) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    boolean reviewScored = false;
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
        reviewScored = true;
    }
    boolean needHighlight = false;
    // patch set, we also don't highlight it.
    if (highlightUnreviewed && !reviewScored && accountId != null) {
        needHighlight = true;
        for (int i = 0; i < c.messageAuthorIds().length(); i++) {
            if (accountId.get() == c.messageAuthorIds().get(i)) {
                needHighlight = false;
                break;
            }
        }
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(c.id_abbreviated(), c));
    String subject = c.subject();
    if (subject.length() > 80) {
        subject = subject.substring(0, 80);
    }
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        subject += " (" + Util.toLongString(status) + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    String owner = "";
    if (c.owner() != null && c.owner().name() != null) {
        owner = c.owner().name();
    }
    table.setWidget(row, C_OWNER, new InlineHyperlink(owner, PageLinks.toAccountQuery(owner)));
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            table.clearCell(row, col);
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed, ownerId);
    }
}
#method_after
public void display(ChangeList changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    } else {
        parent.removeRow(dataBegin);
    }
    if (sz == 0) {
        parent.insertNoneRow(dataBegin);
        return;
    }
    while (rows < sz) {
        parent.insertChangeRow(dataBegin + rows);
        rows++;
    }
    for (int i = 0; i < sz; i++) {
        parent.populateChangeRow(dataBegin + i, changeList.get(i), highlightUnreviewed);
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.labels = labelsFor(cd);
    out.messageauthors = recentMessageAuthorIds(cd);
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.id = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd);
    return out;
}
#end_block

#method_before
private AccountAttribute asAccountAttribute(Account.Id user) {
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#method_after
private AccountAttribute asAccountAttribute(Account.Id user) {
    if (user == null) {
        return null;
    }
    AccountAttribute a = accounts.get(user);
    if (a == null) {
        a = new AccountAttribute();
        accounts.put(user, a);
    }
    return a;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    Change in = cd.change(db);
    ChangeControl ctl = cd.changeControl();
    if (ctl == null || ctl.getCurrentUser() != user) {
        try {
            ctl = changeControlFactory.controlFor(in);
        } catch (NoSuchChangeException e) {
            return null;
        }
    }
    PatchSet ps = cd.currentPatchSet(db);
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail);
    if (detail.getCurrentPatchSetDetail().getInfo().getParents().size() > 1) {
        patchesList.addItem(Util.C.autoMerge());
    } else {
        patchesList.addItem(Util.C.baseDiffItem());
    }
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    addComments(detail);
    // If any dependency change is still open, or is outdated,
    // show our dependency list.
    // 
    boolean depsOpen = false;
    int outdated = 0;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (!ci.isLatest()) {
                depsOpen = true;
                outdated++;
            } else if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
            }
        }
        if (detail.getNeededBy() != null) {
            depsOpen = true;
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    dependenciesPanel.getHeader().clear();
    if (outdated > 0) {
        dependenciesPanel.getHeader().add(new InlineLabel(Util.M.outdatedHeader(outdated)));
    }
    if (!isCurrentView()) {
        display();
    }
    patchSetsBlock.setRegisterKeys(true);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getKey(), detail.getChange().getSubject());
    if (Status.MERGED == detail.getChange().getStatus()) {
        includedInPanel.setVisible(true);
        includedInPanel.addOpenHandler(includedInTable);
    } else {
        includedInPanel.setVisible(false);
    }
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail);
    if (detail.getCurrentPatchSetDetail().getInfo().getParents().size() > 1) {
        patchesList.addItem(Util.C.autoMerge());
    } else {
        patchesList.addItem(Util.C.baseDiffItem());
    }
    for (PatchSet pId : detail.getPatchSets()) {
        if (patchesList != null) {
            patchesList.addItem(Util.M.patchSetHeader(pId.getPatchSetId()), pId.getId().toString());
        }
    }
    if (diffBaseId != null && patchesList != null) {
        patchesList.setSelectedIndex(diffBaseId.get());
    }
    patchSetsBlock.display(detail, diffBaseId);
    addComments(detail);
    // If any dependency change is still open, or is outdated,
    // or the change is needed by a change that is new or submitted,
    // show our dependency list.
    // 
    boolean depsOpen = false;
    int outdated = 0;
    if (!detail.getChange().getStatus().isClosed()) {
        if (detail.getDependsOn() != null) {
            for (final ChangeInfo ci : detail.getDependsOn()) {
                if (!ci.isLatest()) {
                    depsOpen = true;
                    outdated++;
                } else if (ci.getStatus() != Change.Status.MERGED) {
                    depsOpen = true;
                }
            }
        }
        if (detail.getNeededBy() != null) {
            for (final ChangeInfo ci : detail.getNeededBy()) {
                if ((ci.getStatus() == Change.Status.NEW) || (ci.getStatus() == Change.Status.SUBMITTED)) {
                    depsOpen = true;
                }
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    dependenciesPanel.getHeader().clear();
    if (outdated > 0) {
        dependenciesPanel.getHeader().add(new InlineLabel(Util.M.outdatedHeader(outdated)));
    }
    if (!isCurrentView()) {
        display();
    }
    patchSetsBlock.setRegisterKeys(true);
}
#end_block

#method_before
public void display(final String commitMessage) {
    String commitSummary = "";
    String commitBody = "";
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    commitSummary = splitCommitMessage[0];
    commitBody = SafeHtmlUtils.htmlEscape(splitCommitMessage[1]);
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.setAttribute("style", "display: none;");
    }
    commitSummaryPre.setInnerText(commitSummary);
    // Linkify commit body for Change-Id etc.
    SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
    commitBodyLinkified = commitBodyLinkified.linkify();
    commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
    commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
}
#method_after
public void display(final String commitMessage) {
    String commitSummary = "";
    String commitBody = "";
    String[] splitCommitMessage = commitMessage.split("\n", 2);
    commitSummary = splitCommitMessage[0];
    commitBody = splitCommitMessage[1];
    // Hide commit body if there is no body
    if (commitBody.trim().isEmpty()) {
        commitBodyPre.setAttribute("style", "display: none;");
    }
    // Linkify commit summary
    SafeHtml commitSummaryLinkified = new SafeHtmlBuilder().append(commitSummary);
    commitSummaryLinkified = commitSummaryLinkified.linkify();
    commitSummaryLinkified = CommentLinkProcessor.apply(commitSummaryLinkified);
    // Linkify commit body
    SafeHtml commitBodyLinkified = new SafeHtmlBuilder().append(commitBody);
    commitBodyLinkified = commitBodyLinkified.linkify();
    commitBodyLinkified = CommentLinkProcessor.apply(commitBodyLinkified);
    commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString());
    commitBodyPre.setInnerHTML(commitBodyLinkified.asString());
}
#end_block

#method_before
public static String toAccountQuery(final String fullname) {
    return "/q/owner:\"" + KeyUtil.encode(fullname) + "\"," + TOP;
}
#method_after
public static String toAccountQuery(final String fullname) {
    String query = op("owner", fullname) + " status:open";
    return toChangeQuery(query, TOP);
}
#end_block

#method_before
public static String toChangeQuery(String query, String page) {
    query = KeyUtil.encode(query).replaceAll("%3[Aa]", ":");
    return "/q/" + query + "," + page;
}
#method_after
public static String toChangeQuery(String query, String page) {
    return "/q/" + KeyUtil.encode(query) + "," + page;
}
#end_block

#method_before
public static String op(String name, String value) {
    if (value.indexOf(' ') >= 0) {
        return name + ":\"" + value + "\"";
    }
    return name + ":" + value;
}
#method_after
public static String op(String op, String value) {
    if (isSingleWord(value)) {
        return op + ":" + value;
    }
    return op + ":\"" + value + "\"";
}
#end_block

#method_before
private static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("/login/" + token);
}
#method_after
public static String loginRedirect(String token) {
    if (token == null) {
        token = "";
    } else if (token.startsWith("/")) {
        token = token.substring(1);
    }
    return selfRedirect("/login/" + token);
}
#end_block

#method_before
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        public void onSuccess(final HostPageData result) {
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xsrfToken = result.xsrfToken;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2();
        }
    });
}
#end_block

#method_before
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    // TODO: create buttons and handlers here.
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    add(pluginPanel);
}
#method_after
private void initPluginList() {
    pluginTable = new PluginTable();
    pluginTable.addStyleName(Gerrit.RESOURCES.css().pluginsTable());
    pluginPanel = new FlowPanel();
    pluginPanel.setWidth("500px");
    pluginPanel.add(pluginTable);
    add(pluginPanel);
}
#end_block

#method_before
void display(final PluginMap plugins) {
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    List<PluginInfo> list = plugins.values().asList();
    for (final PluginInfo p : list) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, p);
    }
}
#method_after
void display(final PluginMap plugins) {
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    for (final PluginInfo p : plugins.values().asList()) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, p);
    }
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    table.setText(row, 2, plugin.name());
    table.setText(row, 3, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    table.setText(row, 1, plugin.name());
    table.setText(row, 2, plugin.version());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
public String getUnifiedDiff() {
    StringBuilder detail = new StringBuilder();
    if (patchSet != null) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        DiffFormatter df = new DiffFormatter(out);
        db = openRepository();
        reader = db.newObjectReader();
        PatchList patchList = getPatchList();
        for (PatchListEntry p : patchList.getPatches()) {
            if (Patch.COMMIT_MSG.equals(p.getNewName())) {
                continue;
            }
            detail.append("\n");
            List<String> headers = p.getHeaderLines();
            for (String hdr : headers) {
                detail.append(hdr);
            }
            try {
                String filename = p.getNewName();
                RawText aText = resolve(patchList.getOldId(), filename);
                RawText bText = resolve(patchList.getNewId(), filename);
                df.format(toEditList(p.getEdits()), aText, bText);
                detail.append(out.toString());
            } catch (IOException err) {
            }
        }
        detail.append("\n");
    }
    return detail.toString();
}
#method_after
public String getUnifiedDiff() {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    Repository repo = getRepository();
    if (repo != null) {
        DiffFormatter df = new DiffFormatter(out);
        try {
            PatchList patchList = getPatchList();
            if (patchList.getOldId() != null) {
                df.setRepository(repo);
                df.setDetectRenames(true);
                df.format(patchList.getOldId(), patchList.getNewId());
            }
        } catch (PatchListNotAvailableException e) {
            log.error("Cannot format patch", e);
        } catch (IOException e) {
            log.error("Cannot format patch", e);
        } finally {
            df.release();
            repo.close();
        }
    }
    return RawParseUtils.decode(out.toByteArray());
}
#end_block

#method_before
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            for (int line = lineNbr - lines + 1; line <= lineNbr; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append(c.getMessage().trim());
            cmts.append("\n");
            for (int line = lineNbr + 1; line < lineNbr + lines; ++line) {
                appendFileLine(cmts, currentFileData, side, line);
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#method_after
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        final PatchList patchList = repo != null ? getPatchList() : null;
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            final int lineNbr = c.getLine();
            final short side = c.getSide();
            if (!pk.equals(currentFileKey)) {
                cmts.append("....................................................\n");
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append("File ");
                    cmts.append(pk.get());
                    cmts.append("\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.getFileName());
                    } catch (IOException e) {
                    // Don't quote the line if we can't load it.
                    }
                } else {
                    currentFileData = null;
                }
            }
            if (currentFileData != null) {
                int maxLines;
                try {
                    maxLines = currentFileData.getLineCount(side);
                } catch (Throwable e) {
                    maxLines = lineNbr;
                }
                final int startLine = Math.max(1, lineNbr - lines + 1);
                final int stopLine = Math.min(maxLines, lineNbr + lines);
                for (int line = startLine; line <= lineNbr; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
                cmts.append(c.getMessage().trim());
                cmts.append("\n");
                for (int line = lineNbr + 1; line < stopLine; ++line) {
                    appendFileLine(cmts, currentFileData, side, line);
                }
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    if (fileData != null) {
        try {
            final String lineStr = fileData.getLine(side, line);
            cmts.append(": ");
            cmts.append(lineStr);
        } catch (Throwable cce) {
        // Don't quote the line if we can't safely convert it.
        }
    }
    cmts.append("\n");
}
#method_after
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    cmts.append("Line " + line);
    try {
        final String lineStr = fileData.getLine(side, line);
        cmts.append(": ");
        cmts.append(lineStr);
    } catch (Throwable e) {
    // Don't quote the line if we can't safely convert it.
    }
    cmts.append("\n");
}
#end_block

#method_before
private List<GroupReference> suggestAccountGroup(@Nullable final ProjectControl projectControl, final String query, final int limit) {
    final int n = limit <= 0 ? 10 : Math.min(limit, 10);
    List<GroupReference> out = Lists.newArrayListWithCapacity(n);
    for (GroupReference g : groupBackend.suggest(query)) {
        try {
            if (groupControlFactory.controlFor(g.getUUID()).isVisible() || (GroupBackends.isExactSuggestion(g, query) && (projectControl != null) && projectControl.isOwnerAnyRef())) {
                out.add(g);
                if (out.size() == n) {
                    break;
                }
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return out;
}
#method_after
private List<GroupReference> suggestAccountGroup(@Nullable final ProjectControl projectControl, final String query, final int limit) {
    final int n = limit <= 0 ? 10 : Math.min(limit, 10);
    List<GroupReference> out = Lists.newArrayListWithCapacity(n);
    for (GroupReference g : groupBackend.suggest(query)) {
        try {
            if (groupControlFactory.controlFor(g.getUUID()).isVisible() || (GroupBackends.isExactSuggestion(g, query) && projectControl != null && projectControl.isOwnerAnyRef())) {
                out.add(g);
                if (out.size() == n) {
                    break;
                }
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return out;
}
#end_block

#method_before
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                final Change.Id ck = a.getPatchSet().getParentKey();
                if (descendants.add(ck)) {
                    changesToGet.add(a.getPatchSet().getParentKey());
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#method_after
private void loadCurrentPatchSet() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final PatchSet currentPatch = findCurrentOrLatestPatchSet();
    final PatchSet.Id psId = currentPatch.getId();
    final PatchSetDetailFactory loader = patchSetDetail.create(null, psId, null);
    loader.patchSet = currentPatch;
    loader.control = control;
    detail.setCurrentPatchSetDetail(loader.call());
    detail.setCurrentPatchSetId(psId);
    final HashSet<Change.Id> changesToGet = new HashSet<Change.Id>();
    final HashMap<Change.Id, PatchSet.Id> ancestorPatchIds = new HashMap<Change.Id, PatchSet.Id>();
    final List<Change.Id> ancestorOrder = new ArrayList<Change.Id>();
    for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
        for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
            final Change.Id ck = p.getId().getParentKey();
            if (changesToGet.add(ck)) {
                ancestorPatchIds.put(ck, p.getId());
                ancestorOrder.add(ck);
            }
        }
    }
    final Set<Change.Id> descendants = new HashSet<Change.Id>();
    RevId cprev;
    for (PatchSet p : detail.getPatchSets()) {
        cprev = p.getRevision();
        if (cprev != null) {
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(cprev)) {
                final Change.Id ck = a.getPatchSet().getParentKey();
                if (descendants.add(ck)) {
                    changesToGet.add(ck);
                }
            }
        }
    }
    final Map<Change.Id, Change> m = db.changes().toMap(db.changes().get(changesToGet));
    final ArrayList<ChangeInfo> dependsOn = new ArrayList<ChangeInfo>();
    for (final Change.Id a : ancestorOrder) {
        final Change ac = m.get(a);
        if (ac != null) {
            dependsOn.add(newChangeInfo(ac, ancestorPatchIds));
        }
    }
    final ArrayList<ChangeInfo> neededBy = new ArrayList<ChangeInfo>();
    for (final Change.Id a : descendants) {
        final Change ac = m.get(a);
        if (ac != null) {
            neededBy.add(newChangeInfo(ac, null));
        }
    }
    Collections.sort(neededBy, new Comparator<ChangeInfo>() {

        public int compare(final ChangeInfo o1, final ChangeInfo o2) {
            return o1.getId().get() - o2.getId().get();
        }
    });
    detail.setDependsOn(dependsOn);
    detail.setNeededBy(neededBy);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore(repoManager));
    detail.setCanDeleteDraft(change.getStatus() == Change.Status.DRAFT && control.isOwner());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, repoManager, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException, RepositoryNotFoundException, IOException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible(db));
    detail.setCanAbandon(change.getStatus() != Change.Status.DRAFT && change.getStatus().isOpen() && control.canAbandon());
    detail.setCanPublish(control.canPublish(db));
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore() && ProjectUtil.branchExists(repoManager, change.getDest()));
    detail.setCanDeleteDraft(control.canDeleteDraft(db));
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanRebase(detail.getChange().getStatus().isOpen() && control.canRebase());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch);
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    patchsetsById = new HashMap<PatchSet.Id, PatchSet>();
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    CurrentUser user = control.getCurrentUser();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    for (PatchSet ps : source) {
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
        }
        patchsetsById.put(ps.getId(), ps);
    }
    detail.setPatchSets(patches);
}
#end_block

#method_before
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (!control.canRestore(repoManager)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
    } else if (patch == null) {
        throw new NoSuchChangeException(changeId);
    } else {
        // Create a message to accompany the restored change
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
        if (changeComment != null && changeComment.length() > 0) {
            msgBuf.append("\n\n");
            msgBuf.append(changeComment);
        }
        cmsg.setMessage(msgBuf.toString());
        // Restore the change
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                    change.setStatus(Change.Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
        hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException, RepositoryNotFoundException, IOException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canRestore()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RESTORE_NOT_PERMITTED));
        return result;
    }
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Branch.NameKey destBranch = control.getChange().getDest();
    if (!ProjectUtil.branchExists(repoManager, destBranch)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.DEST_BRANCH_NOT_FOUND, destBranch.get()));
        return result;
    }
    // Create a message to accompany the restored change
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), patchSetId);
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Restored");
    if (changeComment != null && changeComment.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(changeComment);
    }
    cmsg.setMessage(msgBuf.toString());
    // Restore the change
    final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.ABANDONED && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    ChangeUtil.updatedChange(db, currentUser, updatedChange, cmsg, restoredSenderFactory, "Change is not abandoned or patchset is not latest");
    hooks.doChangeRestoreHook(updatedChange, currentUser.getAccount(), changeComment, db);
    return result;
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            rp.sendMessage("You are not allowed to perform this operation.\n" + "Configuration changes can only be pushed by project owners\n" + "who also have 'Push' rights");
        } else {
            rp.sendMessage("You are not allowed to perform this operation.\n" + "To push into this reference you need 'Push' rights." + MESSAGE_FOOTER);
        }
        reject(cmd, "Current user '" + ctl.getCurrentUser().getUserName() + "' can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "Deleting the project configuration is not allowed");
        } else {
            rp.sendMessage("You need 'Push' rights with the 'Force Push' flag set to delete references." + MESSAGE_FOOTER);
            reject(cmd, "Current user '" + ctl.getCurrentUser().getUserName() + "' can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        rp.sendMessage("You need 'Push' rights to upload code review requests.\n" + "Verify that you are pushing to the right branch." + MESSAGE_FOOTER);
        reject(cmd, "Current user '" + destBranchCtl.getCurrentUser().getUserName() + "' can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
        newProgress.update(1);
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(change, ps, info, reviewers);
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private void doReplaces() {
    for (final ReplaceRequest request : replaceByChange.values()) {
        try {
            doReplace(request);
        } catch (IOException err) {
            log.error("Error computing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "diff error");
        } catch (OrmException err) {
            log.error("Error storing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "database error");
        }
        if (request.cmd.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            log.error("Replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name() + " wasn't attempted." + "  This is a bug in the receive process implementation.");
            reject(request.cmd, "internal error");
        }
    }
}
#method_after
private void doReplaces() {
    for (final ReplaceRequest request : replaceByChange.values()) {
        try {
            doReplace(request, false);
            replaceProgress.update(1);
        } catch (IOException err) {
            log.error("Error computing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "diff error");
        } catch (OrmException err) {
            log.error("Error storing replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name(), err);
            reject(request.cmd, "database error");
        }
        if (request.cmd.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            log.error("Replacement patch for change " + request.ontoChange + ", commit " + request.newCommit.name() + " wasn't attempted." + "  This is a bug in the receive process implementation.");
            reject(request.cmd, "internal error");
        }
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request, boolean ignoreNoChanges) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq && !ignoreNoChanges) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet)) {
                    if (type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                        // If there was a negative vote on the prior patch set, carry it
                        // into this patch set.
                        // 
                        db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                    }
                }
            }
        }
        approvalsUtil.addReviewers(change, ps, info, reviewers, haveApprovals);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    addMessage(sb.toString());
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        addMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    ApprovalsUtil.syncChangeStatus(db, change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
@Override
public DeleteBranchesResult call() throws NoSuchProjectException, RepositoryNotFoundException, EmailException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final DeleteBranchesResult result = new DeleteBranchesResult();
    final Iterator<Branch.NameKey> branchIt = toRemove.iterator();
    while (branchIt.hasNext()) {
        final Branch.NameKey k = branchIt.next();
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
        final List<Change> openChanges = db.changes().byBranchOpenAll(k).toList();
        if (!openChanges.isEmpty()) {
            if (!abandonOpenChanges) {
                result.addError(new DeleteBranchesResult.Error(DeleteBranchesResult.Error.Type.OPEN_CHANGES, k));
                branchIt.remove();
            } else {
                final boolean allAbandoned = abandon(openChanges, "Branch " + k.get() + " gets deleted.");
                if (!allAbandoned) {
                    result.addError(new DeleteBranchesResult.Error(DeleteBranchesResult.Error.Type.ABANDON_FAILED, k));
                    branchIt.remove();
                }
            }
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName);
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result refUpdateResult;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                refUpdateResult = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(refUpdateResult) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + refUpdateResult.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + refUpdateResult.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    result.setDeletedBranches(deleted);
    return result;
}
#method_after
@Override
public Set<Branch.NameKey> call() throws NoSuchProjectException, RepositoryNotFoundException, OrmException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final Iterator<Branch.NameKey> branchIt = toRemove.iterator();
    while (branchIt.hasNext()) {
        final Branch.NameKey k = branchIt.next();
        if (!projectName.equals(k.getParentKey())) {
            throw new IllegalArgumentException("All keys must be from same project");
        }
        if (!projectControl.controlForRef(k).canDelete()) {
            throw new IllegalStateException("Cannot delete " + k.getShortName());
        }
        if (db.changes().byBranchOpenAll(k).iterator().hasNext()) {
            branchIt.remove();
        }
    }
    final Set<Branch.NameKey> deleted = new HashSet<Branch.NameKey>();
    final Repository r = repoManager.openRepository(projectName);
    try {
        for (final Branch.NameKey branchKey : toRemove) {
            final String refname = branchKey.get();
            final RefUpdate.Result result;
            final RefUpdate u;
            try {
                u = r.updateRef(refname);
                u.setForceUpdate(true);
                result = u.delete();
            } catch (IOException e) {
                log.error("Cannot delete " + branchKey, e);
                continue;
            }
            switch(result) {
                case NEW:
                case NO_CHANGE:
                case FAST_FORWARD:
                case FORCED:
                    deleted.add(branchKey);
                    replication.scheduleUpdate(projectName, refname);
                    hooks.doRefUpdatedHook(branchKey, u, identifiedUser.getAccount());
                    break;
                case REJECTED_CURRENT_BRANCH:
                    log.warn("Cannot delete " + branchKey + ": " + result.name());
                    break;
                default:
                    log.error("Cannot delete " + branchKey + ": " + result.name());
                    break;
            }
        }
    } finally {
        r.close();
    }
    return deleted;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.listBranches(getProjectKey(), new ScreenLoadCallback<ListBranchesResult>(this) {

        @Override
        public void preDisplay(final ListBranchesResult result) {
            if (result.getNoRepository()) {
                branches.setVisible(false);
                addPanel.setVisible(false);
                abandonOpenChanges.setVisible(false);
                delBranch.setVisible(false);
                Label no = new Label(Util.C.errorNoGitRepository());
                no.setStyleName(Gerrit.RESOURCES.css().smallHeading());
                add(no);
            } else {
                enableForm(true);
                display(result.getBranches());
                addPanel.setVisible(result.getCanAdd());
            }
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.listBranches(getProjectKey(), new ScreenLoadCallback<ListBranchesResult>(this) {

        @Override
        public void preDisplay(final ListBranchesResult result) {
            if (result.getNoRepository()) {
                branches.setVisible(false);
                addPanel.setVisible(false);
                delBranch.setVisible(false);
                Label no = new Label(Util.C.errorNoGitRepository());
                no.setStyleName(Gerrit.RESOURCES.css().smallHeading());
                add(no);
            } else {
                enableForm(true);
                display(result.getBranches());
                addPanel.setVisible(result.getCanAdd());
            }
        }
    });
}
#end_block

#method_before
private void display(final List<Branch> listBranches) {
    branches.display(listBranches);
    abandonOpenChanges.setVisible(branches.hasBranchCanDelete());
    delBranch.setVisible(branches.hasBranchCanDelete());
}
#method_after
private void display(final List<Branch> listBranches) {
    branches.display(listBranches);
    delBranch.setVisible(branches.hasBranchCanDelete());
}
#end_block

#method_before
private void enableForm(final boolean on) {
    abandonOpenChanges.setEnabled(on);
    delBranch.setEnabled(on);
    addBranch.setEnabled(on);
    nameTxtBox.setEnabled(on);
    irevTxtBox.setEnabled(on);
}
#method_after
private void enableForm(final boolean on) {
    delBranch.setEnabled(on);
    addBranch.setEnabled(on);
    nameTxtBox.setEnabled(on);
    irevTxtBox.setEnabled(on);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(2, 2);
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(50);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    abandonOpenChanges = new CheckBox(Util.C.checkboxAbandonOpenChanges());
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    final VerticalPanel v = new VerticalPanel();
    v.add(abandonOpenChanges);
    v.add(delBranch);
    add(v);
    add(addPanel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel());
    final Grid addGrid = new Grid(2, 2);
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(50);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(50);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    add(delBranch);
    add(addPanel);
}
#end_block

#method_before
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    if (abandonOpenChanges.getValue()) {
        b.append(Gerrit.C.branchDeletionAndAbandonOpenChangesConfirmationMessage());
    } else {
        b.append(Gerrit.C.branchDeletionConfirmationMessage());
    }
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids, abandonOpenChanges.getValue());
        }
    });
    confirmationDialog.center();
}
#method_after
void deleteChecked() {
    final SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchDeletionConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    final HashSet<Branch.NameKey> ids = new HashSet<Branch.NameKey>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final Branch k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            if (!ids.isEmpty()) {
                b.append(",").br();
            }
            b.append(k.getName());
            ids.add(k.getNameKey());
        }
    }
    b.closeElement("p");
    if (ids.isEmpty()) {
        return;
    }
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchDeletionDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
            deleteBranches(ids);
        }
    });
    confirmationDialog.center();
}
#end_block

#method_before
private void deleteBranches(final Set<Branch.NameKey> branchIds, final boolean abandonOpenChanges) {
    Util.PROJECT_SVC.deleteBranch(getProjectKey(), branchIds, abandonOpenChanges, new GerritCallback<DeleteBranchesResult>() {

        public void onSuccess(final DeleteBranchesResult result) {
            final Set<NameKey> deletedBranches = result.getDeletedBranches();
            if (!deletedBranches.isEmpty()) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final Branch k = getRowItem(row);
                    if (k != null && deletedBranches.contains(k.getNameKey())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
            }
            if (result.hasErrors()) {
                final SafeHtmlBuilder b = new SafeHtmlBuilder();
                final Set<Branch.NameKey> branchesWithOpenChanges = new HashSet<Branch.NameKey>();
                final Set<Branch.NameKey> branchesWithOpenChangesThatCannotBeAbandoned = new HashSet<Branch.NameKey>();
                for (final DeleteBranchesResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case OPEN_CHANGES:
                            branchesWithOpenChanges.add(e.getBranchKey());
                            break;
                        case ABANDON_FAILED:
                            branchesWithOpenChangesThatCannotBeAbandoned.add(e.getBranchKey());
                            break;
                        default:
                            b.append(Gerrit.M.branchDeletionFailed(e.getBranchKey().get(), e.toString()));
                            b.br();
                    }
                }
                if (!branchesWithOpenChanges.isEmpty()) {
                    b.append(Util.C.branchDeletionOpenChanges());
                    b.br();
                    appendBranchOpenChangesLinks(b, branchesWithOpenChanges);
                }
                if (!branchesWithOpenChangesThatCannotBeAbandoned.isEmpty()) {
                    b.append(Util.C.branchDeletionAbandonFailed());
                    b.br();
                    appendBranchOpenChangesLinks(b, branchesWithOpenChangesThatCannotBeAbandoned);
                }
                new ErrorDialog(b.toSafeHtml()).center();
            }
        }

        private void appendBranchOpenChangesLinks(final SafeHtmlBuilder b, final Set<Branch.NameKey> branches) {
            b.openElement("p");
            for (final Branch.NameKey branch : branches) {
                b.openAnchor();
                final BranchLink link = new BranchLink(branch.getParentKey(), Change.Status.NEW, branch.get(), null);
                b.setAttribute("href", "/#" + link.getTargetHistoryToken());
                b.setAttribute("target", "_blank");
                b.append(branch.get());
                b.closeAnchor();
                b.br();
            }
            b.closeElement("p");
        }
    });
}
#method_after
private void deleteBranches(final Set<Branch.NameKey> branchIds) {
    Util.PROJECT_SVC.deleteBranch(getProjectKey(), branchIds, new GerritCallback<Set<Branch.NameKey>>() {

        public void onSuccess(final Set<Branch.NameKey> deleted) {
            if (!deleted.isEmpty()) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final Branch k = getRowItem(row);
                    if (k != null && deleted.contains(k.getNameKey())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
            }
            branchIds.removeAll(deleted);
            if (!branchIds.isEmpty()) {
                final VerticalPanel p = new VerticalPanel();
                final ErrorDialog errorDialog = new ErrorDialog(p);
                final Label l = new Label(Util.C.branchDeletionOpenChanges());
                l.setStyleName(Gerrit.RESOURCES.css().errorDialogText());
                p.add(l);
                for (final Branch.NameKey branch : branchIds) {
                    final BranchLink link = new BranchLink(branch.getParentKey(), Change.Status.NEW, branch.get(), null) {

                        @Override
                        public void go() {
                            errorDialog.hide();
                            super.go();
                        }
                    };
                    p.add(link);
                }
                errorDialog.center();
            }
        }
    });
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (ProjectConfigSection.isValidReferenceSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmConcurrencyException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!projectControl.isOwner()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValidReferenceSection(name)) {
                if (!projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefControl.validateRefPattern(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (projectControl.isOwner()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        if (config.commit(md)) {
            projectCache.evict(config.getProject());
            return projectAccessFactory.create(projectName).call();
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } finally {
        md.close();
    }
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmConcurrencyException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!projectControl.isOwner()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (!projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefControl.validateRefPattern(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (projectControl.isOwner()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        if (config.commit(md)) {
            projectCache.evict(config.getProject());
            return projectAccessFactory.create(projectName).call();
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } finally {
        md.close();
    }
}
#end_block

#method_before
public boolean isVisible() {
    return projectControl.visibleForReplication() || canPerform(Permission.READ);
}
#method_after
public boolean isVisible() {
    return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && canRead();
}
#end_block

#method_before
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH);
}
#method_after
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE);
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT);
}
#method_after
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && canWrite();
}
#end_block

#method_before
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH);
}
#method_after
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canForceUpdate() {
    return canPushWithForce() || canDelete();
}
#method_after
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#end_block

#method_before
private boolean canPushWithForce() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#method_after
private boolean canPushWithForce() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public static void validateRefPattern(String refPattern) throws InvalidNameException {
    if (refPattern.startsWith(ProjectConfigSection.REGEX_PREFIX)) {
        if (!Repository.isValidRefName(RefControl.shortestExample(refPattern))) {
            throw new InvalidNameException();
        }
    } else if (refPattern.equals(ProjectConfigSection.ALL)) {
    // This is a special case we have to allow, it fails below.
    } else if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!Repository.isValidRefName(prefix)) {
            throw new InvalidNameException(refPattern);
        }
    } else if (!Repository.isValidRefName(refPattern)) {
        throw new InvalidNameException(refPattern);
    }
}
#method_after
public static void validateRefPattern(String refPattern) throws InvalidNameException {
    if (refPattern.startsWith(RefConfigSection.REGEX_PREFIX)) {
        if (!Repository.isValidRefName(RefControl.shortestExample(refPattern))) {
            throw new InvalidNameException(refPattern);
        }
    } else if (refPattern.equals(RefConfigSection.ALL)) {
    // This is a special case we have to allow, it fails below.
    } else if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!Repository.isValidRefName(prefix)) {
            throw new InvalidNameException(refPattern);
        }
    } else if (!Repository.isValidRefName(refPattern)) {
        throw new InvalidNameException(refPattern);
    }
}
#end_block

#method_before
static SectionMatcher wrap(AccessSection section) {
    String ref = section.getName();
    if (AccessSection.isValidReferenceSection(ref)) {
        return wrap(ref, section);
    } else {
        return null;
    }
}
#method_after
static SectionMatcher wrap(AccessSection section) {
    String ref = section.getName();
    if (AccessSection.isValid(ref)) {
        return wrap(ref, section);
    } else {
        return null;
    }
}
#end_block

#method_before
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && ProjectConfigSection.isValidReferenceSection(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#method_after
@UiHandler("deleteSection")
void onDeleteSection(ClickEvent event) {
    isDeleted = true;
    if (name.isVisible() && RefConfigSection.isValid(name.getValue())) {
        deletedName.setInnerText(Util.M.deletedReference(name.getValue()));
    } else {
        String name = Util.C.sectionNames().get(value.getName());
        if (name == null) {
            name = value.getName();
        }
        deletedName.setInnerText(Util.M.deletedSection(name));
    }
    normal.getStyle().setDisplay(Display.NONE);
    deleted.getStyle().setDisplay(Display.BLOCK);
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (ProjectConfigSection.isValidReferenceSection(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    Collections.sort(value.getPermissions());
    this.value = value;
    this.readOnly = !editing || !projectAccess.isOwnerOf(value);
    name.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (RefConfigSection.isValid(value.getName())) {
        name.setVisible(true);
        name.setIgnoreEditorValue(false);
        sectionType.setInnerText(Util.C.sectionTypeReference());
    } else {
        name.setVisible(false);
        name.setIgnoreEditorValue(true);
        String name = Util.C.sectionNames().get(value.getName());
        if (name != null) {
            sectionType.setInnerText(name);
            sectionName.getStyle().setDisplay(Display.NONE);
        } else {
            sectionType.setInnerText(Util.C.sectionTypeSection());
            sectionName.setInnerText(value.getName());
            sectionName.getStyle().clearDisplay();
        }
    }
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    } else if (ProjectConfigSection.isValidReferenceSection(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : Util.C.capabilityNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
            String varName = Permission.LABEL + t.getCategory().getLabelName();
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            if (value.getPermission(varName) == null) {
                perms.add(varName);
            }
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isValidReferenceSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isValidReferenceSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public int compare(final String pattern1, final String pattern2) {
    int cmp = distance(pattern1) - distance(pattern2);
    if (cmp == 0) {
        boolean p1_finite = finite(pattern1);
        boolean p2_finite = finite(pattern2);
        if (p1_finite && !p2_finite) {
            cmp = -1;
        } else if (!p1_finite && p2_finite) {
            cmp = 1;
        } else /* if (f1 == f2) */
        {
            cmp = 0;
        }
    }
    if (cmp == 0) {
        cmp = transitions(pattern1) - transitions(pattern2);
    }
    if (cmp == 0) {
        cmp = pattern2.length() - pattern1.length();
    }
    return cmp;
}
#method_after
@Override
public int compare(RefConfigSection a, RefConfigSection b) {
    return compare(a.getName(), b.getName());
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.display(diffBaseId, detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchSideBySide(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                Window.open(Window.Location.getPath() + "#" + Dispatcher.toPatchUnified(p.getKey()), "_blank", null);
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchSideBySide(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchUnified(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.display(diffBaseId, result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    if (c.currPatchSetId().equals(ps.getId())) {
        d.isCurrentPatchSet = "true";
    } else {
        d.isCurrentPatchSet = "false";
    }
    return d;
}
#method_after
private DependencyAttribute newDependsOn(Change c, PatchSet ps) {
    DependencyAttribute d = newDependencyAttribute(c, ps);
    d.isCurrentPatchSet = c.currPatchSetId().equals(ps.getId());
    return d;
}
#end_block

#method_before
public Task beginSubTask(final String subTask, final int subTaskWork) {
    Task task = new Task(subTaskWork);
    tasks.put(subTask, task);
    return task;
}
#method_after
public Task beginSubTask(final String subTask, final int subTaskWork) {
    Task task = new Task(subTask, subTaskWork);
    tasks.add(task);
    return task;
}
#end_block

#method_before
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Map.Entry<String, Task> e : tasks.entrySet()) {
            Task t = e.getValue();
            if (t.count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ').append(e.getKey()).append(": ");
            if (t.total == UNKNOWN) {
                s.append(t.count);
            } else {
                s.append(t.count * 100 / t.total).append("% (").append(t.count).append('/').append(t.total).append(')');
            }
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#method_after
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Task t : tasks) {
            int count = t.count;
            if (count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ').append(t.name).append(": ");
            if (t.total == UNKNOWN) {
                s.append(count);
            } else {
                s.append(String.format("%d%% (%d/%d)", count * 100 / t.total, count, t.total));
            }
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#end_block

#method_before
private void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        messageSender.sendMessage("");
        messageSender.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                messageSender.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                messageSender.sendMessage("  " + url + c.getChangeId());
            }
        }
        messageSender.sendMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        messageSender.sendMessage("");
        messageSender.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                messageSender.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                messageSender.sendMessage("  " + url + c.getChangeId());
            }
        }
        messageSender.sendMessage("");
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    messageSender.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    messageSender.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#end_block

#method_before
private void processCommands(final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
    sendMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands) {
    try {
        parseCommands(commands);
        if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
            createNewChanges();
        }
        doReplaces();
        for (final ReceiveCommand c : commands) {
            if (c.getResult() == Result.OK) {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only schedule direct refs updates for replication.
                    // Change refs are scheduled when they are created.
                    // 
                    replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                    hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            }
        }
        if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
            final String url = canonicalWebUrl;
            addMessage("");
            addMessage("New Changes:");
            for (final Change c : allNewChanges) {
                if (c.getStatus() == Change.Status.DRAFT) {
                    addMessage("  " + url + c.getChangeId() + " [DRAFT]");
                } else {
                    addMessage("  " + url + c.getChangeId());
                }
            }
            addMessage("");
        }
    } finally {
        sendMessages();
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final CreateChangeSender cm;
                cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final ReplacePatchSetSender cm;
                cm = replacePatchSetFactory.create(result.change);
                cm.setFrom(me);
                cm.setPatchSet(ps, result.info);
                cm.setChangeMessage(result.msg);
                cm.addReviewers(reviewers);
                cm.addExtraCC(cc);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (EmailException e) {
                log.error("Cannot send email for new patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (EmailException e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
private static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#method_after
static void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
}
#end_block

#method_before
@Override
public void advertiseRefs(ReceiveSession rs) throws ServiceMayNotContinueException {
    base.advertiseRefs(rs);
    HashMap<String, Ref> r = new HashMap<String, Ref>();
    for (Map.Entry<String, Ref> e : rs.getAdvertisedRefs().entrySet()) {
        if (!e.getKey().startsWith("refs/changes/")) {
            r.put(e.getKey(), e.getValue());
        }
    }
    rs.setAdvertisedRefs(r, rs.getAdvertisedObjects());
}
#method_after
@Override
public void advertiseRefs(UploadPack us) {
    throw new UnsupportedOperationException("ReceiveCommitsAdvertiseRefsHook cannot be used for UploadPack");
}
#end_block

#method_before
@Override
public void onPreReceive(final ReceiveSession rs, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceiveSession rs, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceiveSession().sendMessage(sb.toString());
}
#method_after
private void sendInvalidEmailError(RevCommit c, String type, PersonIdent who) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n");
    sb.append("ERROR:  In commit " + c.name() + "\n");
    sb.append("ERROR:  " + type + " email address " + who.getEmailAddress() + "\n");
    sb.append("ERROR:  does not match your user account.\n");
    sb.append("ERROR:\n");
    if (currentUser.getEmailAddresses().isEmpty()) {
        sb.append("ERROR:  You have not registered any email addresses.\n");
    } else {
        sb.append("ERROR:  The following addresses are currently registered:\n");
        for (String address : currentUser.getEmailAddresses()) {
            sb.append("ERROR:    " + address + "\n");
        }
    }
    sb.append("ERROR:\n");
    if (canonicalWebUrl != null) {
        sb.append("ERROR:  To register an email address, please visit:\n");
        sb.append("ERROR:  " + canonicalWebUrl + "#" + PageLinks.SETTINGS_CONTACT + "\n");
    }
    sb.append("\n");
    getReceivePack().sendMessage(sb.toString());
}
#end_block

#method_before
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db);
    final ReceivePack rp = (ReceivePack) rc.getReceiveSession();
    rp.setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rp;
}
#method_after
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db);
    rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rc.getReceivePack();
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = (ReceivePack) rc.getReceiveSession();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    Capable r = receive.canUpload();
    if (r != Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = (ReceivePack) receive.getReceiveSession();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    try {
        receive.advertiseHistory();
        rp.receive(in, out, err);
    } catch (UnpackException badStream) {
        // This may have been triggered by branch level access controls.
        // Log what the heck is going on, as detailed as we can.
        // 
        StringBuilder msg = new StringBuilder();
        msg.append("Unpack error on project \"" + projectControl.getProject().getName() + "\":\n");
        msg.append("  AdvertiseRefsHook: " + rp.getAdvertiseRefsHook());
        if (rp.getAdvertiseRefsHook() == AdvertiseRefsHook.DEFAULT) {
            msg.append("DEFAULT");
        } else if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            msg.append("VisibleRefFilter");
        } else {
            msg.append(rp.getAdvertiseRefsHook().getClass());
        }
        msg.append("\n");
        if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            Map<String, Ref> adv = rp.getAdvertisedRefs();
            msg.append("  Visible references (" + adv.size() + "):\n");
            for (Ref ref : adv.values()) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
            List<Ref> hidden = new ArrayList<Ref>();
            for (Ref ref : rp.getRepository().getAllRefs().values()) {
                if (!adv.containsKey(ref.getName())) {
                    hidden.add(ref);
                }
            }
            msg.append("  Hidden references (" + hidden.size() + "):\n");
            for (Ref ref : hidden) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
        }
        IOException detail = new IOException(msg.toString(), badStream);
        throw new Failure(128, "fatal: Unpack error, check server log", detail);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    Capable r = receive.canUpload();
    if (r != Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    try {
        receive.advertiseHistory();
        rp.receive(in, out, err);
    } catch (UnpackException badStream) {
        // This may have been triggered by branch level access controls.
        // Log what the heck is going on, as detailed as we can.
        // 
        StringBuilder msg = new StringBuilder();
        msg.append("Unpack error on project \"" + projectControl.getProject().getName() + "\":\n");
        msg.append("  AdvertiseRefsHook: " + rp.getAdvertiseRefsHook());
        if (rp.getAdvertiseRefsHook() == AdvertiseRefsHook.DEFAULT) {
            msg.append("DEFAULT");
        } else if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            msg.append("VisibleRefFilter");
        } else {
            msg.append(rp.getAdvertiseRefsHook().getClass());
        }
        msg.append("\n");
        if (rp.getAdvertiseRefsHook() instanceof VisibleRefFilter) {
            Map<String, Ref> adv = rp.getAdvertisedRefs();
            msg.append("  Visible references (" + adv.size() + "):\n");
            for (Ref ref : adv.values()) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
            List<Ref> hidden = new ArrayList<Ref>();
            for (Ref ref : rp.getRepository().getAllRefs().values()) {
                if (!adv.containsKey(ref.getName())) {
                    hidden.add(ref);
                }
            }
            msg.append("  Hidden references (" + hidden.size() + "):\n");
            for (Ref ref : hidden) {
                msg.append("  - " + ref.getObjectId().abbreviate(8).name() + " " + ref.getName() + "\n");
            }
        }
        IOException detail = new IOException(msg.toString(), badStream);
        throw new Failure(128, "fatal: Unpack error, check server log", detail);
    }
}
#end_block

#method_before
private JdbcAccess<Data, Data.DataKey> createClassUnderTest() {
    final SqlDialect dialect = mock(SqlDialect.class, CALLS_REAL_METHODS);
    JdbcSchema schema = setupSchema(dialect);
    JdbcAccess<Data, Data.DataKey> classUnderTest = new DataJdbcAccess(schema);
    return classUnderTest;
}
#method_after
private JdbcAccess<Data, Data.DataKey> createClassUnderTest() {
    return createJdbcAccess(DIALECT);
}
#end_block

#method_before
private JdbcSchema setupSchema(final SqlDialect dialect) {
    @SuppressWarnings("rawtypes")
    Database db = mock(Database.class);
    try {
        stub(db.getDialect()).toReturn(dialect);
        JdbcSchema schema = new Schema(db, conn);
        return schema;
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private JdbcSchema setupSchema(final SqlDialect dialect) {
    @SuppressWarnings("rawtypes")
    Database db = mock(Database.class);
    try {
        when(db.getDialect()).thenReturn(dialect);
        when(db.newConnection()).thenReturn(conn);
        JdbcSchema schema = new Schema(db);
        return schema;
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Test
public void testInsertNothing() throws OrmException, SQLException {
    setup();
    createClassUnderTest().insert(NO_DATA);
}
#method_after
@Test
public void testInsertNothing() throws OrmException {
    setup();
    createClassUnderTest().insert(NO_DATA);
}
#end_block

#method_before
@Test
public void testInsertOne() throws OrmException, SQLException {
    stubExecuteBatchOK(INSERT, 1);
    createClassUnderTest().insert(ONE_ROW);
}
#method_after
@Test
public void testInsertOne() throws OrmException, SQLException {
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT, 1);
    createClassUnderTest().insert(ONE_ROW);
    assertUsedBatchingOnly(insert);
}
#end_block

#method_before
@Test
public void testUpdateNothing() throws OrmException, SQLException {
    createClassUnderTest().update(NO_DATA);
}
#method_after
@Test
public void testUpdateNothing() throws OrmException {
    createClassUnderTest().update(NO_DATA);
}
#end_block

#method_before
@Test
public void testUpdateOne() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE, 1);
    createClassUnderTest().update(ONE_ROW);
}
#method_after
@Test
public void testUpdateOne() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE, 1);
    createClassUnderTest().update(ONE_ROW);
    assertUsedBatchingOnly(update);
}
#end_block

#method_before
@Test
public void testUpsertOneExisting() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE, 1);
    createClassUnderTest().upsert(ONE_ROW);
}
#method_after
@Test
public void testUpsertOneExisting() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE, 1);
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT);
    createClassUnderTest().upsert(ONE_ROW);
    assertUsedBatchingOnly(update);
    assertNotUsed(insert);
}
#end_block

#method_before
@Test
public void testUpsertOneException() throws OrmException, SQLException {
    stubExecuteBatchException(UPDATE, new BatchUpdateException());
    try {
        createClassUnderTest().upsert(ONE_ROW);
        fail("missingException");
    } catch (OrmException e) {
    // expected
    }
}
#method_after
@Test
public void testUpsertOneException() throws OrmException, SQLException {
    SQLException exception = new BatchUpdateException();
    PreparedStatement update = stubStatementThrowExceptionOnExecute(UPDATE, exception);
    JdbcAccess<Data, Data.DataKey> classUnderTest = createClassUnderTest();
    try {
        classUnderTest.upsert(ONE_ROW);
        fail("missingException");
    } catch (OrmException e) {
        // expected
        assertSame(e.getCause(), exception);
    }
    assertUsedBatchingOnly(update);
}
#end_block

#method_before
@Test
public void testUpsertOneNotExisting() throws OrmException, SQLException {
    stubExecuteBatchOK(UPDATE);
    PreparedStatement insert = stubExecuteBatchOK(INSERT, 1);
    createClassUnderTest().upsert(ONE_ROW);
    verifyIds(insert, 1);
}
#method_after
@Test
public void testUpsertOneNotExisting() throws OrmException, SQLException {
    PreparedStatement update = stubStatementWithUpdateCounts(UPDATE);
    PreparedStatement insert = stubStatementWithUpdateCounts(INSERT, 1);
    createClassUnderTest().upsert(ONE_ROW);
    assertUsedBatchingOnly(update);
    assertUsedBatchingOnly(insert);
    assertExpectedIdsUsed(insert, 1);
}
#end_block

#method_before
@Test
public void testDeleteOneExisting() throws SQLException, OrmException {
    stubExecuteBatchOK(DELETE, 1);
    createClassUnderTest().delete(ONE_ROW);
}
#method_after
@Test
public void testDeleteOneExisting() throws SQLException, OrmException {
    PreparedStatement delete = stubStatementWithUpdateCounts(DELETE, 1);
    createClassUnderTest().delete(ONE_ROW);
    assertUsedBatchingOnly(delete);
}
#end_block

#method_before
@Test
public void testDeleteOneNotExisting() throws SQLException, OrmException {
    stubExecuteBatchOK(DELETE, 0);
    try {
        createClassUnderTest().delete(ONE_ROW);
        fail("missing OrmConcurrencyException");
    } catch (OrmConcurrencyException e) {
    // expected
    }
}
#method_after
@Test
public void testDeleteOneNotExisting() throws SQLException, OrmException {
    PreparedStatement delete = stubStatementWithUpdateCounts(DELETE, 0);
    JdbcAccess<Data, Data.DataKey> classUnderTest = createClassUnderTest();
    try {
        classUnderTest.delete(ONE_ROW);
        fail("missing OrmConcurrencyException");
    } catch (OrmConcurrencyException e) {
    // expected
    }
    assertUsedBatchingOnly(delete);
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", null, id);
}
#end_block

#method_before
public static String toPatchSideBySide(final Patch.Key id) {
    return toPatch("", id);
}
#method_after
public static String toPatchSideBySide(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("", diffBase, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", null, id);
}
#end_block

#method_before
public static String toPatchUnified(final Patch.Key id) {
    return toPatch("unified", id);
}
#method_after
public static String toPatchUnified(PatchSet.Id diffBase, Patch.Key id) {
    return toPatch("unified", diffBase, id);
}
#end_block

#method_before
public static String toPatch(final PatchScreen.Type type, final Patch.Key id) {
    if (type == PatchScreen.Type.SIDE_BY_SIDE) {
        return toPatchSideBySide(id);
    } else {
        return toPatchUnified(id);
    }
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    PatchSet.Id ps = id.getParentKey();
    Change.Id c = ps.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(ps.get()).append("/").append(KeyUtil.encode(id.get()));
    if (type != null && !type.isEmpty()) {
        p.append(",").append(type);
    }
    return p.toString();
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, // 
        panel == null ? // 
        new ChangeScreen(id) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, rest);
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(ps));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static void patch(String token, final Patch.Key id, final int patchIndex, final PatchSetDetail patchSetDetail, final PatchTable patchTable, final PatchScreen.TopView topView, final String panelType) {
    final String parametersUrl;
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        parametersUrl = token.substring(token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) + 1);
        token = token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START));
    } else {
        parametersUrl = null;
    }
    final PatchScreen.TopView top = topView == null ? Gerrit.getPatchScreenTopView() : topView;
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (id != null) {
                String panel = panelType;
                if (panel == null) {
                    int c = token.lastIndexOf(',');
                    panel = 0 <= c ? token.substring(c + 1) : "";
                }
                if ("".equals(panel)) {
                    return new // 
                    PatchScreen.SideBySide(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                } else if ("unified".equals(panel)) {
                    return new // 
                    PatchScreen.Unified(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    parametersUrl);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
public static void patch(String token, PatchSet.Id base, Patch.Key id, int patchIndex, PatchSetDetail patchSetDetail, PatchTable patchTable, PatchScreen.TopView topView) {
    patch(token, base, id, patchIndex, patchSetDetail, patchTable, topView, null);
}
#end_block

#method_before
private static String skip(String token) {
    if (token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START) != -1) {
        return token.substring(0, token.indexOf(DiffPatchScreen.URL_PARAMETER_MARK_START)).substring(prefixlen);
    } else {
        return token.substring(prefixlen);
    }
}
#method_after
private static String skip(String token) {
    return token.substring(prefixlen);
}
#end_block

#method_before
private void update(AccountDiffPreference dp) {
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#method_after
private void update(AccountDiffPreference dp) {
    // Did the user just turn on auto-review?
    if (!reviewed.getValue() && prefs.getOld().isManualReview() && !dp.isManualReview()) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    if (lastScript != null && canReuse(dp, lastScript)) {
        lastScript.setDiffPrefs(dp);
        RpcStatus.INSTANCE.onRpcStart(null);
        settingsPanel.setEnabled(false);
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    onResult(lastScript, false);
                } finally {
                    RpcStatus.INSTANCE.onRpcComplete(null);
                }
            }
        });
    } else {
        refresh(false);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    if (patchSetDetail == null) {
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                patchSetDetail = result;
                if (fileList == null) {
                    fileList = new PatchTable(prefs);
                    fileList.display(idSideA, result);
                    patchIndex = fileList.indexOf(patchKey);
                }
                refresh(true);
            }
        });
    } else {
        refresh(true);
    }
}
#end_block

#method_before
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        reviewed.setValue(true);
        setReviewedByCurrentUser(true);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#method_after
private void onResult(final PatchScript script, final boolean isFirst) {
    final String path = PatchTable.getDisplayFileName(patchKey);
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(fileName);
    setPageTitle(path);
    if (idSideB.equals(patchSetDetail.getPatchSet().getId())) {
        commitMessageBlock.setVisible(true);
        commitMessageBlock.display(patchSetDetail.getInfo().getMessage());
    } else {
        commitMessageBlock.setVisible(false);
        Util.DETAIL_SVC.patchSetDetail(idSideB, new GerritCallback<PatchSetDetail>() {

            @Override
            public void onSuccess(PatchSetDetail result) {
                commitMessageBlock.setVisible(true);
                commitMessageBlock.display(result.getInfo().getMessage());
            }
        });
    }
    historyTable.display(script.getHistory());
    // True if there are differences between the two patch sets
    boolean hasEdits = !script.getEdits().isEmpty();
    // True if this change is a mode change or a pure rename/copy
    boolean hasMeta = !script.getPatchHeader().isEmpty();
    boolean hasDifferences = hasEdits || hasMeta;
    boolean pureMetaChange = !hasEdits && hasMeta;
    if (contentTable instanceof SideBySideTable && pureMetaChange) {
        // User asked for SideBySide (or a link guessed, wrong) and we can't
        // show a binary or pure-rename change there accurately. Switch to
        // the unified view instead.
        // 
        contentTable.removeFromParent();
        contentTable = new UnifiedDiffTable();
        contentTable.fileList = fileList;
        contentPanel.add(contentTable);
        setToken(Dispatcher.toPatchUnified(idSideA, patchKey));
    }
    if (hasDifferences) {
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(script.getCommentDetail(), script.isExpandAllComments());
        contentTable.finishDisplay();
    }
    showPatch(hasDifferences);
    settingsPanel.setEnableSmallFileFeatures(!script.isHugeFile());
    settingsPanel.setEnableIntralineDifference(script.hasIntralineDifference());
    settingsPanel.setEnabled(true);
    lastScript = script;
    if (fileList != null) {
        topNav.display(patchIndex, getPatchScreenType(), fileList);
        bottomNav.display(patchIndex, getPatchScreenType(), fileList);
    }
    if (Gerrit.isSignedIn()) {
        boolean isReviewed = false;
        if (isFirst && !prefs.get().isManualReview()) {
            isReviewed = true;
            setReviewedByCurrentUser(isReviewed);
        } else {
            for (Patch p : patchSetDetail.getPatches()) {
                if (p.getKey().equals(patchKey)) {
                    isReviewed = p.isReviewedByCurrentUser();
                    break;
                }
            }
        }
        reviewed.setValue(isReviewed);
    }
    intralineFailure = isFirst && script.hasIntralineFailure();
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    if (fileList == null || fileList.isAttached()) {
        final PatchSet.Id psid = patchKey.getParentKey();
        fileList = new PatchTable(prefs);
        fileList.setSavePointerId("PatchTable " + psid);
        Util.DETAIL_SVC.patchSetDetail(psid, new GerritCallback<PatchSetDetail>() {

            public void onSuccess(final PatchSetDetail result) {
                fileList.display(idSideA, result);
            }
        });
    }
    final PatchBrowserPopup p = new PatchBrowserPopup(patchKey, fileList);
    p.open();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.display(diffBaseId, detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void populateDiffAllActions(final PatchSetDetail detail) {
    diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    addHandlerForDiffButton(detail);
    actionsPanel.add(diffAllSideBySide);
    actionsPanel.add(diffAllUnified);
}
#method_after
private void populateDiffAllActions(final PatchSetDetail detail) {
    final Button diffAllSideBySide = new Button(Util.C.buttonDiffAllSideBySide());
    diffAllSideBySide.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchSideBySide(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllSideBySide);
    final Button diffAllUnified = new Button(Util.C.buttonDiffAllUnified());
    diffAllUnified.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            for (Patch p : detail.getPatches()) {
                openWindow(Dispatcher.toPatchUnified(diffBaseId, p.getKey()));
            }
        }
    });
    actionsPanel.add(diffAllUnified);
}
#end_block

#method_before
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    Gerrit.display(PageLinks.MINE);
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateDeleteDraftPatchSetAction() {
    final Button b = new Button(Util.C.buttonDeleteDraftPatchSet());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            b.setEnabled(false);
            PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                public void onSuccess(final ChangeDetail result) {
                    if (result != null) {
                        changeScreen.update(result);
                    } else {
                        Gerrit.display(PageLinks.MINE);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.setPatchSetIdToCompareWith(diffBaseId);
                patchTable.display(result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
            hOfdiffAllSideBySide.removeHandler();
            hOfdiffAllUnified.removeHandler();
            addHandlerForDiffButton(result);
        }
    });
}
#method_after
public void refresh() {
    AccountDiffPreference diffPrefs;
    if (patchTable == null) {
        diffPrefs = new ListenableAccountDiffPreference().get();
    } else {
        diffPrefs = patchTable.getPreferences().get();
    }
    Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new GerritCallback<PatchSetDetail>() {

        @Override
        public void onSuccess(PatchSetDetail result) {
            if (patchSet.getId().equals(diffBaseId)) {
                patchTable.setVisible(false);
                actionsPanel.setVisible(false);
            } else {
                if (patchTable != null) {
                    patchTable.removeFromParent();
                }
                patchTable = new PatchTable();
                patchTable.display(diffBaseId, result);
                body.add(patchTable);
                for (ClickHandler clickHandler : registeredClickHandler) {
                    patchTable.addClickHandler(clickHandler);
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#method_after
@Override
public void go() {
    // 
    Dispatcher.patch(// 
    getTargetHistoryToken(), // 
    base, // 
    patchKey, // 
    patchIndex, // 
    patchSetDetail, parentPatchTable, // 
    topView);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(RetrieveParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#method_after
@Override
protected void configureServlets() {
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AddBranch.Factory.class);
            factory(ChangeProjectAccess.Factory.class);
            factory(CreateProjectHandler.Factory.class);
            factory(ChangeProjectSettings.Factory.class);
            factory(DeleteBranches.Factory.class);
            factory(ListBranches.Factory.class);
            factory(VisibleProjects.Factory.class);
            factory(VisibleProjectDetails.Factory.class);
            factory(ProjectAccessFactory.Factory.class);
            factory(ProjectDetailFactory.Factory.class);
            factory(SuggestParentCandidatesHandler.Factory.class);
        }
    });
    rpc(ProjectAdminServiceImpl.class);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    vp = new VerticalPanel();
    addCreateProjectPanel();
    /* popup */
    projectListPopup = new ProjectListPopup(Util.C.projects());
    projectListPopup.addProjectListPopupHandler(new ProjectListPopupHandler() {

        @Override
        public void onClose(ProjectListPopupOnCloseEvent projectListPopupEvent) {
            resetHandlerRegistration();
        }

        @Override
        public void onOpenProjectRow(ProjectListPopupOnOpenRowEvent projectListPopupEvent) {
            sugestParent.setText(projectListPopupEvent.getProjectName());
        }

        @Override
        public void onMovePointer(ProjectListPopupOnMovePointerEvent projectListPopupEvent) {
            // prevent user input from being overwritten by simply poping up
            if (!projectListPopupEvent.isPopingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectListPopupEvent.getProjectName());
            }
        }
    });
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
}
#end_block

#method_before
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    final HorizontalPanel bp = new HorizontalPanel();
    bp.add(create);
    bp.add(browse);
    fp.add(bp);
    vp.add(fp);
    initSuggestedParents();
    add(vp);
}
#method_after
private void addCreateProjectPanel() {
    final VerticalPanel fp = new VerticalPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel());
    initCreateTxt();
    initCreateButton();
    initParentBox();
    addGrid(fp);
    emptyCommit = new CheckBox(Util.C.checkBoxEmptyCommit());
    permissionsOnly = new CheckBox(Util.C.checkBoxPermissionsOnly());
    fp.add(emptyCommit);
    fp.add(permissionsOnly);
    fp.add(create);
    VerticalPanel vp = new VerticalPanel();
    vp.add(fp);
    initSuggestedParents();
    vp.add(suggestedParentsTab);
    add(vp);
}
#end_block

#method_before
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
    browse = new Button(Util.C.buttonBrowseProjects());
    browse.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            displayPopup();
        }
    });
}
#method_after
private void initCreateButton() {
    create = new Button(Util.C.buttonCreateProject());
    create.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doCreateProject();
        }
    });
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    vp.add(suggestedParentsTab);
    Util.PROJECT_SVC.suggestParentCandidates(new AsyncCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final Project k) {
            final Anchor projectLink = new Anchor(k.getName());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).getName());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.getDescription());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    Util.PROJECT_SVC.suggestParentCandidates(new GerritCallback<List<Project>>() {

        @Override
        public void onSuccess(List<Project> result) {
            if (result != null && !result.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(result);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void addGrid(final VerticalPanel fp) {
    grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#method_after
private void addGrid(final VerticalPanel fp) {
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    fp.add(grid);
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()) {

                @Override
                public void setText(final String t) {
                }
            }.center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    Util.PROJECT_SVC.createNewProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(projectName), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    RetrieveParentCandidatesHandlerFactory.create().to(callback);
}
#method_after
@Override
public void suggestParentCandidates(AsyncCallback<List<Project>> callback) {
    suggestParentCandidatesHandlerFactory.create().to(callback);
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, AsyncCallback<ProjectAccess> cb) {
    ObjectId base;
    if (baseRevision != null && !baseRevision.isEmpty()) {
        base = ObjectId.fromString(baseRevision);
    } else {
        base = null;
    }
    changeProjectAccessFactory.create(projectName, base, sections, msg).to(cb);
}
#end_block

#method_before
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            ReviewResult result = null;
            try {
                result = deleteDraftFactory.create(psid).call();
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(result.getChangeId()));
            }
            if (result.getErrors().size() > 0) {
                throw new Failure(new NoSuchEntityException());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteDraftPatchSet(final PatchSet.Id psid, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            ReviewResult result = null;
            try {
                result = deleteDraftPatchSetFactory.create(psid).call();
            } catch (NoSuchChangeException e) {
                throw new Failure(new NoSuchChangeException(result.getChangeId()));
            }
            if (result.getErrors().size() > 0) {
                throw new Failure(new NoSuchEntityException());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraft.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishComments.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
    factory(RetrieveParentCandidates.Factory.class);
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            final ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            final ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            final ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        final ReviewResult result = publishDraftFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    } else if (deleteDraftPatchSet) {
        final ReviewResult result = deleteDraftPatchSetFactory.create(patchSetId).call();
        handleReviewResultErrors(result);
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case DELETE_NOT_PERMITTED:
                errMsg += "not permitted to delete change/patch set";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            case NOT_A_DRAFT:
                errMsg += "change is not a draft";
                break;
            case GIT_ERROR:
                errMsg += "error writing change to git repository";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case CHANGE_NOT_VISIBLE:
                errMsg += "not permitted to review change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case PUBLISH_NOT_PERMITTED:
                errMsg += "not permitted to publish change";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.isVisible(db) && !control.isOwner()) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_NOT_VISIBLE));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final Change.Id changeId = patchSetId.getParentKey();
    result.setChangeId(changeId);
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null || !patch.isDraft()) {
        throw new NoSuchChangeException(changeId);
    }
    if (!control.canPublish(db)) {
        result.addError(new ReviewResult.Error(ReviewResult.Error.Type.PUBLISH_NOT_PERMITTED));
    } else {
        db.patchSets().atomicUpdate(patchSetId, new AtomicUpdate<PatchSet>() {

            @Override
            public PatchSet update(PatchSet patchset) {
                if (patchset.isDraft()) {
                    patchset.setDraft(false);
                }
                return null;
            }
        });
        final Change change = db.changes().get(changeId);
        if (change.getStatus() == Change.Status.DRAFT) {
            db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus() == Change.Status.DRAFT && change.currentPatchSetId().equals(patchSetId)) {
                        change.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
        }
    }
    return result;
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            ReviewResult result = abandonChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        } else if (restoreChange) {
            ReviewResult result = restoreChangeFactory.create(patchSetId, changeComment).call();
            handleReviewResultErrors(result);
        }
        if (submitChange) {
            ReviewResult result = submitFactory.create(patchSetId).call();
            handleReviewResultErrors(result);
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    }
    if (publishPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            ChangeUtil.publishDraftPatchSet(db, patchSetId);
        } else {
            throw error("Not permitted to publish draft patchset");
        }
    }
    if (deleteDraftPatchSet) {
        if (changeControl.isOwner() && changeControl.isVisible(db)) {
            try {
                ChangeUtil.deleteDraftPatchSet(patchSetId, gitManager, replication, patchSetInfoFactory, db);
            } catch (PatchSetInfoNotAvailableException e) {
                throw error("Error retrieving draft patchset: " + patchSetId);
            } catch (IOException e) {
                throw error("Error deleting draft patchset: " + patchSetId);
            }
        } else {
            throw error("Not permitted to delete draft patchset");
        }
    }
}
#end_block

#method_before
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#method_after
private void handleReviewResultErrors(final ReviewResult result) {
    for (ReviewResult.Error resultError : result.getErrors()) {
        String errMsg = "error: (change " + result.getChangeId() + ") ";
        switch(resultError.getType()) {
            case ABANDON_NOT_PERMITTED:
                errMsg += "not permitted to abandon change";
                break;
            case RESTORE_NOT_PERMITTED:
                errMsg += "not permitted to restore change";
                break;
            case SUBMIT_NOT_PERMITTED:
                errMsg += "not permitted to submit change";
                break;
            case SUBMIT_NOT_READY:
                errMsg += "approvals or dependencies lacking";
                break;
            case CHANGE_IS_CLOSED:
                errMsg += "change is closed";
                break;
            case RULE_ERROR:
                errMsg += "rule error";
                break;
            default:
                errMsg += "failure in review";
        }
        if (resultError.getMessage() != null) {
            errMsg += ": " + resultError.getMessage();
        }
        writeError(errMsg);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AbandonChange.Factory.class);
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoreChange.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
    factory(Submit.Factory.class);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, IllegalStateException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final ReviewResult result = submitFactory.create(patchSetId).call();
    if (result.getErrors().size() > 0) {
        throw new IllegalStateException("Cannot submit " + result.getErrors().get(0));
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, IllegalStateException, InvalidChangeOperationException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    final ReviewResult result = submitFactory.create(patchSetId).call();
    if (result.getErrors().size() > 0) {
        throw new IllegalStateException("Cannot submit " + result.getErrors().get(0).getMessageOrType());
    }
    return changeDetailFactory.create(result.getChangeId()).call();
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
// public ReviewResult call() throws EmailException,
@Override
public ReviewResult call() throws InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, patchSetId);
    if (submitResult.isEmpty()) {
        throw new InvalidChangeOperationException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new InvalidChangeOperationException("Unsupported SubmitRecord.Label.status");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
            default:
                throw new InvalidChangeOperationException("Unsupported SubmitRecord.status");
        }
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#method_after
@Override
public ReviewResult call() throws IllegalStateException, InvalidChangeOperationException, NoSuchChangeException, OrmException {
    final ReviewResult result = new ReviewResult();
    final PatchSet patch = db.patchSets().get(patchSetId);
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    result.setChangeId(changeId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    List<SubmitRecord> submitResult = control.canSubmit(db, patchSetId);
    if (submitResult.isEmpty()) {
        throw new IllegalStateException("ChangeControl.canSubmit returned empty list");
    }
    for (SubmitRecord submitRecord : submitResult) {
        switch(submitRecord.status) {
            case OK:
                if (!control.getRefControl().canSubmit()) {
                    result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_PERMITTED));
                }
                break;
            case NOT_READY:
                StringBuilder errMsg = new StringBuilder();
                for (SubmitRecord.Label lbl : submitRecord.labels) {
                    switch(lbl.status) {
                        case OK:
                            break;
                        case REJECT:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": blocked by " + lbl.label);
                            break;
                        case NEED:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label);
                            break;
                        case IMPOSSIBLE:
                            if (errMsg.length() > 0)
                                errMsg.append("; ");
                            errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                            break;
                        default:
                            throw new IllegalArgumentException("Unsupported SubmitRecord.Label.status (" + lbl.status + ")");
                    }
                }
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString()));
                break;
            case CLOSED:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.CHANGE_IS_CLOSED));
                break;
            case RULE_ERROR:
                result.addError(new ReviewResult.Error(ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage));
                break;
            default:
                throw new IllegalStateException("Unsupported SubmitRecord.status + (" + submitRecord.status + ")");
        }
    }
    // Submit the change if we can
    if (result.getErrors().isEmpty()) {
        final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList());
        final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT);
        PatchSetApproval approval = new PatchSetApproval(akey, (short) 1);
        for (final PatchSetApproval candidateApproval : allApprovals) {
            if (akey.equals(candidateApproval.getKey())) {
                candidateApproval.setValue((short) 1);
                candidateApproval.setGranted();
                approval = candidateApproval;
                break;
            }
        }
        db.patchSetApprovals().upsert(Collections.singleton(approval));
        final Change updatedChange = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Change.Status.NEW) {
                    change.setStatus(Change.Status.SUBMITTED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        if (updatedChange.getStatus() == Change.Status.SUBMITTED) {
            merger.merge(opFactory, updatedChange.getDest());
        }
    }
    return result;
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
        updateSubscriptions();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : rw.getRepository().getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#method_after
private void openBranch() throws MergeException {
    alreadyAccepted = new HashSet<RevCommit>();
    try {
        branchUpdate = db.updateRef(destBranch.get());
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = (CodeReviewCommit) rw.parseCommit(branchUpdate.getOldObjectId());
            alreadyAccepted.add(branchTip);
        } else {
            branchTip = null;
        }
        for (final Ref r : db.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Cannot open branch", e);
    }
}
#end_block

#method_before
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final Merger m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void mergeOneCommit(final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m;
    if (destProject.isUseContentMerge()) {
        // Settings for this project allow us to try and
        // automatically resolve conflicts within files if needed.
        // Use ResolveMerge and instruct to operate in core.
        m = MergeStrategy.RESOLVE.newMerger(db, true);
    } else {
        // No auto conflict resolving allowed. If any of the
        // affected files was modified, merge will fail.
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
    }
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            writeMergeCommit(m, n);
        } else {
            failed(n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : merged) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : merged) {
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(merged.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip, n });
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    mergeTip = (CodeReviewCommit) rw.parseCommit(id);
}
#method_after
private void writeMergeCommit(final Merger m, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeAuthor(merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    mergeTip = (CodeReviewCommit) rw.parseCommit(commit(m, mergeCommit));
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException, OrmException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.getApprovalType(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final Commit mergeCommit = new Commit(db);
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentIds(new ObjectId[] { mergeTip });
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = m.getObjectWriter().writeCommit(mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateBranch() throws MergeException {
    if (branchTip == null || branchTip != mergeTip) {
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private void updateBranch() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getNameKey());
                cfg.load(db, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getName(), e);
            }
        }
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (GitRepositoryManager.REF_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject);
                        ProjectState ps = projectCache.get(destProject.getNameKey());
                        // 
                        repoManager.setProjectDescription(// 
                        destProject.getNameKey(), ps.getProject().getDescription());
                    }
                    replication.scheduleUpdate(destBranch.getParentKey(), branchUpdate.getName());
                    Account account = null;
                    final PatchSetApproval submitter = getSubmitter(mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateChangeStatus() {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void updateSubscriptions() {
    // Note: The merge is already performed so we shall not throw an exception
    // on failure.
    Transaction txn = null;
    final String gitmodulesFile = ".gitmodules";
    File tmpGitmodulesFile = null;
    try {
        final TreeWalk tw = TreeWalk.forPath(db, gitmodulesFile, mergeTip.getTree());
        if ((tw != null) && (tw.getFileMode(0).getObjectType() == Constants.OBJ_BLOB)) {
            tmpGitmodulesFile = File.createTempFile(gitmodulesFile, ".tmp");
            final byte[] blobData = db.openBlob(tw.getObjectId(0)).getCachedBytes();
            FileOutputStream fos = new FileOutputStream(tmpGitmodulesFile.getCanonicalPath());
            fos.write(blobData);
            fos.close();
            final FileBasedConfig cfg = new FileBasedConfig(tmpGitmodulesFile);
            final String thisServer = getSrvName(urlProvider.get());
            if (thisServer == null) {
                throw new DataFormatException("At parse of " + gitmodulesFile + ": problem retrieving name of this server.");
            }
            txn = schema.beginTransaction();
            schema.subscriptions().delete(schema.subscriptions().getSubscription(destBranch), txn);
            cfg.load();
            for (String id : cfg.getSubsections("submodule")) {
                final String url = cfg.getString("submodule", id, "url");
                final String path = cfg.getString("submodule", id, "path");
                String revision = cfg.getString("submodule", id, "revision");
                if (url != null && url.length() > 0 && path != null && path.length() > 0 && revision != null && revision.length() > 0) {
                    boolean pathIsRelative = url.startsWith("/");
                    String server = null;
                    if (!pathIsRelative)
                        server = getSrvName(url);
                    if ((pathIsRelative) || (server != null && server.equalsIgnoreCase(thisServer))) {
                        if (revision.equals(".")) {
                            revision = destBranch.get();
                        }
                        schema.subscriptions().insert(Collections.singleton(new Subscription(new Subscription.Id(schema.nextSubscriptionId()), new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get()), new Branch.NameKey(new Project.NameKey(path), revision))), txn);
                    }
                }
            }
            txn.commit();
        }
    } catch (OrmException e) {
        log.error("Database problem at update of subscriptions table from " + gitmodulesFile + " file.", e);
    } catch (ConfigInvalidException e) {
        log.error("Problem at update of subscriptions table: " + gitmodulesFile + " config file is invalid.", e);
    } catch (IOException e) {
        log.error("Problem at update of subscriptions table from " + gitmodulesFile + ".", e);
    } catch (DataFormatException e) {
        log.error(e.getMessage(), e);
    } finally {
        if (txn != null) {
            try {
                txn.rollback();
            } catch (OrmException e) {
            }
        }
        if (tmpGitmodulesFile != null) {
            tmpGitmodulesFile.delete();
        }
    }
}
#method_after
private void updateSubscriptions() throws MergeException {
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        SubmoduleOp subOp = subOpFactory.create(destBranch, mergeTip, rw, db, destProject, submitted, commits);
        try {
            subOp.update();
        } catch (SubmoduleException e) {
            log.error("The gitLinks were not updated according to the subscriptions " + e.getMessage());
        }
    }
}
#end_block

#method_before
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, c.currentPatchSetId());
    m.setMessage(body);
    return m;
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(schema, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()), schema);
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public Capable canUpload() {
    if (!projectControl.canUploadToAtLeastOneRef()) {
        String reqName = project.getName();
        return new Capable("Upload denied for project '" + reqName + "'");
    }
    if (project.isUseContributorAgreements()) {
        try {
            return verifyActiveContributorAgreement();
        } catch (OrmException e) {
            log.error("Cannot query database for agreements", e);
            return new Capable("Cannot verify contribution agreement");
        }
    } else {
        return Capable.OK;
    }
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#method_after
@Override
public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    doReplaces();
}
#end_block

#method_before
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (isHead(c) || isTag(c)) {
                // We only schedule heads and tags for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                rp.sendMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                rp.sendMessage("  " + url + c.getChangeId());
            }
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.find(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#method_after
private Account.Id toAccountId(final String nameOrEmail) throws OrmException, NoSuchAccountException {
    final Account a = accountResolver.findByNameOrEmail(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (cmd.getRefName().startsWith(NEW_CHANGE)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                continue;
            case UPDATE:
                parseUpdate(cmd);
                continue;
            case DELETE:
                parseDelete(cmd);
                continue;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                continue;
        }
        // Everything else is bogus as far as we are concerned.
        // 
        reject(cmd);
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    final RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    final RevObject oldObject, newObject;
    try {
        oldObject = rp.getRevWalk().parseAny(cmd.getOldId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getOldId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    try {
        newObject = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (oldObject instanceof RevCommit && newObject instanceof RevCommit && ctl.canForceUpdate()) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    if (rp.getAdvertisedRefs().containsKey(destBranchName)) {
        // We advertised the branch to the client so we know
        // the branch exists. Target this branch for the upload.
        // 
        destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
    } else {
        // We didn't advertise the branch, because it doesn't exist yet.
        // Allow it anyway if HEAD is a symbolic reference to the name.
        // 
        final String head;
        try {
            head = repo.getFullBranch();
        } catch (IOException e) {
            log.error("Cannot read HEAD symref", e);
            reject(cmd, "internal error");
            return;
        }
        if (head.equals(destBranchName)) {
            destBranch = new Branch.NameKey(project.getNameKey(), destBranchName);
        }
    }
    if (destBranch == null) {
        String n = destBranchName;
        if (n.startsWith(Constants.R_HEADS))
            n = n.substring(Constants.R_HEADS.length());
        reject(cmd, "branch " + n + " not found");
        return;
    }
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        boolean haveHeads = false;
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            if (isHead(r) || isTag(r)) {
                try {
                    final RevCommit h = walk.parseCommit(r.getObjectId());
                    h.add(SIDE_HAVE);
                    walk.markStart(h);
                    haveHeads = true;
                } catch (IOException e) {
                    continue;
                }
            }
        }
        if (haveHeads) {
            boolean isConnected = false;
            RevCommit c;
            while ((c = walk.next()) != null) {
                if (c.hasAll(COMMON)) {
                    isConnected = true;
                    break;
                }
            }
            if (!isConnected) {
                reject(newChange, "no common ancestry");
                return;
            }
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    requestReplace(cmd, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void requestReplace(final ReceiveCommand cmd, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#end_block

#method_before
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                final Change.Key key = new Change.Key(idStr);
                final List<Change> changes = db.changes().byProjectKey(project.getNameKey(), key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // Schedule as a replacement to this one matching change.
                    // 
                    requestReplace(newChange, changes.get(0), c);
                    continue;
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#method_after
private void createNewChanges() {
    final List<RevCommit> toCreate = new ArrayList<RevCommit>();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                // 
                return;
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                if (idStr.matches("^I00*$")) {
                    // Reject this invalid line from EGit.
                    reject(newChange, "invalid Change-Id");
                    return;
                }
                final Change.Key key = new Change.Key(idStr);
                if (newChangeIds.contains(key)) {
                    reject(newChange, "squash commits first");
                    return;
                }
                final List<Change> changes = db.changes().byBranchKey(destBranch, key).toList();
                if (changes.size() > 1) {
                    // WTF, multiple changes in this project have the same key?
                    // Since the commit is new, the user should recreate it with
                    // a different Change-Id. In practice, we should never see
                    // this error message as Change-Id should be unique.
                    // 
                    reject(newChange, key.get() + " has duplicates");
                    return;
                }
                if (changes.size() == 1) {
                    // 
                    if (requestReplace(newChange, false, changes.get(0), c)) {
                        continue;
                    } else {
                        return;
                    }
                }
                if (changes.size() == 0) {
                    if (!isValidChangeId(idStr)) {
                        reject(newChange, "invalid Change-Id");
                        return;
                    }
                    newChangeIds.add(key);
                }
            }
            toCreate.add(c);
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return;
    }
    if (toCreate.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return;
    }
    for (final RevCommit c : toCreate) {
        try {
            createChange(walk, c);
        } catch (IOException e) {
            log.error("Error computing patch of commit " + c.name(), e);
            reject(newChange, "diff error");
            return;
        } catch (OrmException e) {
            log.error("Error creating change for commit " + c.name(), e);
            reject(newChange, "database error");
            return;
        }
    }
    newChange.setResult(ReceiveCommand.Result.OK);
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change);
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    rp.sendMessage(// 
                    "(W) " + c.abbreviate(repo, 6).name() + ":" + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : ""));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (final Ref r : rp.getAdvertisedRefs().values()) {
            try {
                walk.markUninteresting(walk.parseCommit(r.getObjectId()));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void warnMalformedMessage(RevCommit c) {
    if (65 < c.getShortMessage().length()) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        rp.sendMessage("(W) " + c.abbreviate(repo, 6).name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#method_after
private void warnMalformedMessage(RevCommit c) {
    ObjectReader reader = rp.getRevWalk().getObjectReader();
    if (65 < c.getShortMessage().length()) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit subject >65 characters; use shorter first paragraph");
    }
    int longLineCnt = 0, nonEmptyCnt = 0;
    for (String line : c.getFullMessage().split("\n")) {
        if (!line.trim().isEmpty()) {
            nonEmptyCnt++;
        }
        if (70 < line.length()) {
            longLineCnt++;
        }
    }
    if (0 < longLineCnt && 33 < longLineCnt * 100 / nonEmptyCnt) {
        AbbreviatedObjectId id;
        try {
            id = reader.abbreviate(c);
        } catch (IOException err) {
            id = c.abbreviate(6);
        }
        rp.sendMessage(// 
        "(W) " + id.name() + ": commit message lines >70 characters; manually wrap lines");
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey();
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            } else {
                log.warn("Replacement of Change-Id " + req.ontoChange + " with commit " + req.newCommit.name() + " did not import the new patch set.");
            }
        }
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                continue;
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (final Ref r : repo.getAllRefs().values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey() throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byProjectOpenAll(project.getNameKey())) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db);
    }
}
#method_after
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db, toTargetVersion);
    }
}
#end_block

#method_before
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        final List<String> pruneList = new ArrayList<String>();
        s.pruneSchema(new StatementExecutor() {

            public void execute(String sql) {
                pruneList.add(sql);
            }
        });
        if (!pruneList.isEmpty()) {
            ui.pruneSchema(e, pruneList);
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#method_after
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    prior.get().check(ui, curr, db, false);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        if (toTargetVersion) {
            final List<String> pruneList = new ArrayList<String>();
            s.pruneSchema(new StatementExecutor() {

                public void execute(String sql) {
                    pruneList.add(sql);
                }
            });
            if (!pruneList.isEmpty()) {
                ui.pruneSchema(e, pruneList);
            }
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#end_block

#method_before
@SuppressWarnings("unused")
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateProjectImpl.Factory.class);
    bind(RetrieveParentCandidates.class).to(RetrieveParentCandidatesImpl.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(AnonymousUser.class).in(RequestScoped.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(CreateProject.Factory.class);
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    if (approvalList != null) {
        for (PatchSetApproval a : approvalList) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
public static void revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps);
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHookRunner hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final ReplicationQueue replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    ;
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommit = new CommitBuilder();
        revertCommit.addParentId(commitToRevert);
        revertCommit.setTreeId(parentToCommitToRevert.getTree());
        revertCommit.setAuthor(authorIdent);
        revertCommit.setCommitter(myIdent);
        revertCommit.setMessage(message);
        final ObjectInserter oi = git.newObjectInserter();
        ;
        ObjectId id;
        try {
            id = oi.insert(revertCommit);
            oi.flush();
        } finally {
            oi.release();
        }
        Change.Key changeKey = new Change.Key("I" + id.name());
        final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), user.getAccountId(), db.changes().get(changeId).getDest());
        change.nextPatchSetId();
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(user.getAccountId());
        ps.setRevision(new RevId(id.getName()));
        db.patchSets().insert(Collections.singleton(ps));
        final PatchSetInfo info = patchSetInfoFactory.get(revWalk.parseCommit(id), ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setNewObjectId(id);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + git.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(db.changes().get(changeId).getProject(), ru.getName());
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + changeKey.get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
private static void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#method_after
private static <T extends ReplyToChangeSender> void updatedChange(final ReviewDb db, final IdentifiedUser user, final Change change, final ChangeMessage cmsg, ReplyToChangeSender.Factory<T> senderFactory, final String err) throws NoSuchChangeException, InvalidChangeOperationException, EmailException, OrmException {
    if (change == null) {
        throw new InvalidChangeOperationException(err);
    }
    db.changeMessages().insert(Collections.singleton(cmsg));
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    // Email the reviewers
    final ReplyToChangeSender cm = senderFactory.create(change);
    cm.setFrom(user.getAccountId());
    cm.setChangeMessage(cmsg);
    cm.send();
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    publishDrafts();
    final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
    if (isCurrent && change.getStatus().isOpen()) {
        publishApprovals(ctl);
    } else if (!approvals.isEmpty()) {
        throw new InvalidChangeOperationException("Change is closed");
    } else {
        publishMessageOnly();
    }
    touchChange();
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    db.changes().beginTransaction(changeId);
    try {
        publishDrafts();
        final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
        if (isCurrent && change.getStatus().isOpen()) {
            publishApprovals(ctl);
        } else if (approvals.isEmpty() || forceMessage) {
            publishMessageOnly();
        } else {
            throw new InvalidChangeOperationException("Change is closed");
        }
        touchChange();
        db.commit();
    } finally {
        db.rollback();
    }
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draft(patchSetId, user.getAccountId()).toList();
}
#method_after
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draftByPatchSetAuthor(patchSetId, user.getAccountId()).toList();
}
#end_block

#method_before
private void email() {
    try {
        final CommentSender cm = commentSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setPatchSet(patchSet, patchSetInfoFactory.get(patchSetId));
        cm.setChangeMessage(message);
        cm.setPatchLineComments(drafts);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#end_block

#method_before
public void merge() throws MergeException {
    final ProjectState pe = projectCache.get(destBranch.getParentKey());
    if (pe == null) {
        throw new MergeException("No such project: " + destBranch.getParentKey());
    }
    destProject = pe.getProject();
    try {
        schema = schemaFactory.open();
    } catch (OrmException e) {
        throw new MergeException("Cannot open database", e);
    }
    try {
        mergeImpl();
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        submitted = schema.changes().submitted(destBranch).toList();
        preMerge();
        updateBranch();
        updateChangeStatus();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (db != null) {
            db.close();
        }
        schema.close();
        schema = null;
    }
}
#end_block

#method_before
private void cherryPickChanges() throws MergeException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#method_after
private void cherryPickChanges() throws MergeException, OrmException {
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        final ThreeWayMerger m;
        if (destProject.isUseContentMerge()) {
            // Settings for this project allow us to try and
            // automatically resolve conflicts within files if needed.
            // Use ResolveMerge and instruct to operate in core.
            m = MergeStrategy.RESOLVE.newMerger(db, true);
        } else {
            // No auto conflict resolving allowed. If any of the
            // affected files was modified, merge will fail.
            m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(db);
        }
        try {
            if (mergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                mergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                m.setBase(n.getParent(0));
                if (m.merge(mergeTip, n)) {
                    writeCherryPickCommit(m, n);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (hasDependenciesMet(n)) {
                    if (rw.isMergedInto(mergeTip, n)) {
                        mergeTip = n;
                    } else {
                        mergeOneCommit(n);
                    }
                    markCleanMerges();
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
}
#end_block

#method_before
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#method_after
private void writeCherryPickCommit(final Merger m, final CodeReviewCommit n) throws IOException, OrmException {
    rw.parseBody(n);
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    try {
        final List<PatchSetApproval> approvalList = schema.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        for (final PatchSetApproval a : approvalList) {
            if (a.getValue() <= 0) {
                // Negative votes aren't counted.
                continue;
            }
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                // 
                if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                    submitAudit = a;
                }
                continue;
            }
            final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
            final StringBuilder identbuf = new StringBuilder();
            if (acc.getFullName() != null && acc.getFullName().length() > 0) {
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append(acc.getFullName());
            }
            if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
                if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                    continue;
                }
                if (identbuf.length() > 0) {
                    identbuf.append(' ');
                }
                identbuf.append('<');
                identbuf.append(acc.getPreferredEmail());
                identbuf.append('>');
            }
            if (identbuf.length() == 0) {
                // Nothing reasonable to describe them by? Ignore them.
                continue;
            }
            final String tag;
            if (CRVW.equals(a.getCategoryId())) {
                tag = "Reviewed-by";
            } else if (VRIF.equals(a.getCategoryId())) {
                tag = "Tested-by";
            } else {
                final ApprovalType at = approvalTypes.byId(a.getCategoryId());
                if (at == null) {
                    // A deprecated/deleted approval type, ignore it.
                    continue;
                }
                tag = at.getCategory().getName().replace(' ', '-');
            }
            if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
                msgbuf.append(tag);
                msgbuf.append(": ");
                msgbuf.append(identbuf);
                msgbuf.append('\n');
            }
        }
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(m.getResultTreeId());
    mergeCommit.setParentId(mergeTip);
    mergeCommit.setAuthor(n.getAuthorIdent());
    mergeCommit.setCommitter(toCommitterIdent(submitAudit));
    mergeCommit.setMessage(msgbuf.toString());
    final ObjectId id = commit(m, mergeCommit);
    final CodeReviewCommit newCommit = (CodeReviewCommit) rw.parseCommit(id);
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.nextPatchSetId();
            return change;
        }
    });
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(id.getName()));
    insertAncestors(ps.getId(), newCommit);
    schema.patchSets().insert(Collections.singleton(ps));
    n.change = schema.changes().atomicUpdate(n.change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
            return change;
        }
    });
    for (PatchSetApproval a : schema.patchSetApprovals().byChange(n.change.getId())) {
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            schema.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
    }
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    commits.put(newCommit.patchsetId.getParentKey(), newCommit);
    mergeTip = newCommit;
    setRefLogIdent(submitAudit);
}
#end_block

#method_before
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        switch(s) {
            case CLEAN_MERGE:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
            case CRISS_CROSS_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case NOT_FAST_FORWARD:
                {
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    final Capable capable = isSubmitStillPossible(commit);
                    if (capable != Capable.OK) {
                        sendMergeFail(c, message(c, capable.getMessage()), false);
                    }
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(schema, db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), GitRepositoryManager.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, null);
    m.setMessage(body);
    return m;
}
#method_after
private ChangeMessage message(final Change c, final String body) {
    final String uuid;
    try {
        uuid = ChangeUtil.messageUUID(schema);
    } catch (OrmException e) {
        return null;
    }
    final ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(c.getId(), uuid), null, c.currentPatchSetId());
    m.setMessage(body);
    return m;
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    // We must pull the patchset out of commits, because the patchset ID is
    // modified when using the cherry-pick merge strategy.
    final CodeReviewCommit commit = commits.get(c.getId());
    final PatchSet.Id merged = commit.change.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                // It could be possible that the change being merged
                // has never had its mergeability tested. So we insure
                // merged changes has mergeable field true.
                c.setMergeable(true);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(schema, merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())), merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (NoSuchChangeException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        // 
        hooks.doChangeMergedHook(// 
        c, // 
        accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        change.setStatus(Change.Status.NEW);
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((cmd.getRefName().startsWith(NEW_CHANGE) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    // Don't permit receive-pack to be executed if a (magic branch)/branch_name
    // reference exists in the destination repository. These block the
    // client from being able to even send us a pack file, as it is very
    // unlikely the user passed the --force flag and the new commit is
    // probably not going to fast-forward the branch.
    // 
    result = checkMagicBranchRef(NEW_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_PUBLISH_CHANGE);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    return MagicBranch.checkMagicBranchRefs(repo, project);
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!isMagicBranch(c)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (isMagicBranch(cmd)) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            rp.sendError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                rp.sendError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not create new references");
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd, "can not delete references");
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = getDestBranchName(cmd);
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd, "can not upload a change to this reference");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    if (isDraft(newChange)) {
        change.setStatus(Change.Status.DRAFT);
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    hooks.doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (isValidChangeId(v)) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change;
    final PatchSet ps;
    final PatchSetInfo info;
    change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.setTopic(destTopicName);
    change.nextPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(me);
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(newChange.getRefName())) {
            change.setStatus(Change.Status.DRAFT);
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        ChangeUtil.updated(change);
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        haveApprovals.add(me);
        if (allTypes.size() > 0) {
            final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
            final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(change, ps.getId(), authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(change, ps.getId(), committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(change, ps.getId(), reviewer, catId, db);
                }
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps, db);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    if (isDraft(request.cmd)) {
        ps.setDraft(true);
    }
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    if (request.checkMergedInto) {
        final Ref mergedInto = findMergedInto(change.getDest().get(), c);
        result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
        if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            final ApprovalType type = approvalTypes.byId(a.getCategoryId());
            if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                // If there was a negative vote on the prior patch set, carry it
                // into this patch set.
                // 
                db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
            }
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    msg.setPatchSetId(ps.getId());
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        change.setStatus(Change.Status.DRAFT);
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    final PatchSet ps;
    final ChangeMessage msg;
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.nextPatchSetId();
                    change.setLastSha1MergeTested(null);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            reject(request.cmd, "change is closed");
            return null;
        }
        ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
        ps.setUploader(currentUser.getAccountId());
        ps.setRevision(toRevId(c));
        if (MagicBranch.isDraft(request.cmd.getRefName())) {
            ps.setDraft(true);
        }
        insertAncestors(ps.getId(), c);
        db.patchSets().insert(Collections.singleton(ps));
        if (request.checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
        change.setCurrentPatchSet(info);
        result.change = change;
        result.patchSet = ps;
        result.info = info;
        final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
        final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
        boolean haveAuthor = false;
        boolean haveCommitter = false;
        final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
        oldReviewers.clear();
        oldCC.clear();
        for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
            haveApprovals.add(a.getAccountId());
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
            // ApprovalCategory.SUBMIT is still in db but not relevant in git-store
            if (!ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                final ApprovalType type = approvalTypes.byId(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
                }
            }
            if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                haveAuthor = true;
            }
            if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                haveCommitter = true;
            }
        }
        final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
        if (allTypes.size() > 0) {
            final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
            if (authorId != null && haveApprovals.add(authorId)) {
                insertDummyApproval(result, authorId, catId, db);
            }
            if (committerId != null && haveApprovals.add(committerId)) {
                insertDummyApproval(result, committerId, catId, db);
            }
            for (final Account.Id reviewer : reviewers) {
                if (haveApprovals.add(reviewer)) {
                    insertDummyApproval(result, reviewer, catId, db);
                }
            }
        }
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
        msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        result.msg = msg;
        if (result.mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isOpen()) {
                        if (destTopicName != null) {
                            change.setTopic(destTopicName);
                        }
                        if (change.getStatus() == Change.Status.DRAFT && ps.isDraft()) {
                        // Leave in draft status.
                        } else {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setCurrentPatchSet(result.info);
                        ChangeUtil.updated(change);
                        return change;
                    } else {
                        return null;
                    }
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(ps));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(request.cmd, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps, db);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID() && (isMagicBranch(cmd) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
            String errMsg = "missing Change-Id in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message";
            reject(cmd, errMsg);
            rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                rp.sendMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                rp.sendError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    rp.sendError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    msg.setPatchSetId(result.info.getKey());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setPatchSet(result.patchSet, result.info);
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#end_block

#method_before
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException {
    return validate(controlFor(id));
}
#method_after
public ChangeControl validateFor(final Change.Id id) throws NoSuchChangeException, OrmException {
    return validate(controlFor(id), db.get());
}
#end_block

#method_before
public ChangeControl validateFor(final Change change) throws NoSuchChangeException {
    return validate(controlFor(change));
}
#method_after
public ChangeControl validateFor(final Change change) throws NoSuchChangeException, OrmException {
    return validate(controlFor(change), db.get());
}
#end_block

#method_before
private static ChangeControl validate(final ChangeControl c) throws NoSuchChangeException {
    if (!c.isVisible()) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
private static ChangeControl validate(final ChangeControl c, final ReviewDb db) throws NoSuchChangeException, OrmException {
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isOwner() && !isReviewer(db)) {
        return false;
    }
    return isVisible();
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    if (change.getStatus() == Change.Status.DRAFT && !isDraftVisible(db)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    if (change.getStatus() == Change.Status.DRAFT) {
        return ruleError("Cannot submit draft changes");
    }
    try {
        if (isDraftPatchSet(patchSetId, db)) {
            return ruleError("Cannot submit draft patch sets");
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (isDraftPatchSet(patchSetId, db)) {
            if (!isVisible(db)) {
                return ruleError("Patch set " + patchSetId + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSetId, err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        return false;
    }
    return ps.isDraft();
}
#method_after
private boolean isDraftPatchSet(PatchSet.Id id, ReviewDb db) throws OrmException {
    PatchSet ps = db.patchSets().get(id);
    if (ps == null) {
        throw new OrmException("Patch set " + id + " not found");
    }
    return ps.isDraft();
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
        reject(cmd, "For non-fast forward updates, 'Force Push' privilege is needed");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, groupUUID, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            groupId = result.group.getId();
            groupUUID = result.group.getGroupUUID();
            display(result);
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            saveType.setVisible(result.canModify);
            delInclude.setVisible(result.canModify);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNew();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#method_after
private void initMemberList() {
    addMemberBox = new AddMemberBox();
    addMemberBox.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewMember();
        }
    });
    members = new MemberTable();
    delMember = new Button(Util.C.buttonDeleteGroupMembers());
    delMember.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            members.deleteChecked();
        }
    });
    memberPanel = new FlowPanel();
    memberPanel.add(new SmallHeading(Util.C.headingMembers()));
    memberPanel.add(addMemberBox);
    memberPanel.add(members);
    memberPanel.add(delMember);
    add(memberPanel);
}
#end_block

#method_before
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#method_after
private void initExternal() {
    externalName = new Label();
    externalNameFilter = new NpTextBox();
    externalNameFilter.setVisibleLength(30);
    externalNameFilter.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doExternalSearch();
            }
        }
    });
    externalNameSearch = new Button(Gerrit.C.searchButton());
    externalNameSearch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doExternalSearch();
        }
    });
    externalMatches = new Grid();
    externalMatches.setStyleName(Gerrit.RESOURCES.css().infoTable());
    externalMatches.setVisible(false);
    final FlowPanel searchLine = new FlowPanel();
    searchLine.add(externalNameFilter);
    searchLine.add(externalNameSearch);
    externalPanel = new VerticalPanel();
    externalPanel.add(new SmallHeading(Util.C.headingExternalGroup()));
    externalPanel.add(externalName);
    externalPanel.add(searchLine);
    externalPanel.add(externalMatches);
    add(externalPanel);
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (value.isLabel()) {
                newRule.setRange(0, 1);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#method_after
private void addGroup(GroupReference ref) {
    if (ref.getUUID() != null) {
        if (value.getRule(ref) == null) {
            PermissionRule newRule = value.getRule(ref, true);
            if (rangeType != null) {
                int min = rangeType.getMin().getValue();
                int max = rangeType.getMax().getValue();
                newRule.setRange(min, max);
            }
            rules.getList().add(newRule);
        }
        groupToAdd.setValue(null);
        groupToAdd.setFocus(true);
    } else {
        // If the oracle didn't get to complete a UUID, resolve it now.
        // 
        addRule.setEnabled(false);
        SuggestUtil.SVC.suggestAccountGroup(ref.getName(), 1, new GerritCallback<List<GroupReference>>() {

            @Override
            public void onSuccess(List<GroupReference> result) {
                addRule.setEnabled(true);
                if (result.size() == 1) {
                    addGroup(result.get(0));
                } else {
                    groupToAdd.setFocus(true);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                addRule.setEnabled(true);
                super.onFailure(caught);
            }
        });
    }
}
#end_block

#method_before
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value != null && Permission.OWNER.equals(value.getName())) {
        inherit.setEnabled(false);
    } else {
        inherit.setEnabled(!readOnly);
    }
}
#method_after
@Override
public void setValue(Permission value) {
    this.value = value;
    if (value.isLabel()) {
        rangeType = Gerrit.getConfig().getApprovalTypes().byLabel(value.getLabel());
    } else {
        rangeType = null;
    }
    if (value != null && Permission.OWNER.equals(value.getName())) {
        exclusiveGroup.setEnabled(false);
    } else {
        exclusiveGroup.setEnabled(!readOnly);
    }
}
#end_block

#method_before
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#method_after
@Override
public PermissionRuleEditor create(int index) {
    PermissionRuleEditor subEditor = new PermissionRuleEditor(readOnly, section, value, rangeType);
    ruleContainer.insert(subEditor, index);
    return subEditor;
}
#end_block

#method_before
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    local.getEditors().get(index).editRefPattern();
}
#method_after
@UiHandler("addSection")
void onAddSection(ClickEvent event) {
    int index = local.getList().size();
    local.getList().add(new AccessSection("refs/heads/*"));
    AccessSectionEditor editor = local.getEditors().get(index);
    editor.enableEditing();
    editor.editRefPattern();
}
#end_block

#method_before
@Override
public void render(Action object, Appendable appendable) throws IOException {
    appendable.append(render(object));
}
#method_after
@Override
public String render(PermissionRule.Action object) {
    return object != null ? object.toString() : "";
}
#end_block

#method_before
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#method_after
public void suggestAccount(final String query, final Boolean active, final int limit, final AsyncCallback<List<AccountInfo>> callback) {
    if (suggestAccounts == SuggestAccountsEnum.OFF) {
        callback.onSuccess(Collections.<AccountInfo>emptyList());
        return;
    }
    run(callback, new Action<List<AccountInfo>>() {

        public List<AccountInfo> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            final LinkedHashMap<Account.Id, AccountInfo> r = new LinkedHashMap<Account.Id, AccountInfo>();
            for (final Account p : db.accounts().suggestByFullName(a, b, n)) {
                addSuggestion(r, p, new AccountInfo(p), active);
            }
            if (r.size() < n) {
                for (final Account p : db.accounts().suggestByPreferredEmail(a, b, n - r.size())) {
                    addSuggestion(r, p, new AccountInfo(p), active);
                }
            }
            if (r.size() < n) {
                for (final AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, n - r.size())) {
                    if (!r.containsKey(e.getAccountId())) {
                        final Account p = accountCache.get(e.getAccountId()).getAccount();
                        final AccountInfo info = new AccountInfo(p);
                        info.setPreferredEmail(e.getEmailAddress());
                        addSuggestion(r, p, info, active);
                    }
                }
            }
            return new ArrayList<AccountInfo>(r.values());
        }
    });
}
#end_block

#method_before
private void addSuggestion(Map map, Account account, AccountInfo info, Boolean active) {
    if (active == null || active == account.isActive()) {
        map.put(account.getId(), info);
    }
}
#method_after
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account account, AccountInfo info, Boolean active) {
    if (map.containsKey(account.getId())) {
        return;
    }
    if (active != null && active != account.isActive()) {
        return;
    }
    switch(suggestAccounts) {
        case ALL:
            map.put(account.getId(), info);
            break;
        case SAME_GROUP:
            {
                Set<AccountGroup.UUID> usersGroups = groupsOf(account);
                usersGroups.remove(AccountGroup.ANONYMOUS_USERS);
                usersGroups.remove(AccountGroup.REGISTERED_USERS);
                usersGroups.remove(authConfig.getBatchUsersGroup());
                for (AccountGroup.UUID myGroup : currentUser.get().getEffectiveGroups()) {
                    if (usersGroups.contains(myGroup)) {
                        map.put(account.getId(), info);
                        break;
                    }
                }
                break;
            }
        case OFF:
            break;
        default:
            throw new IllegalStateException("Bad SuggestAccounts " + suggestAccounts);
    }
}
#end_block

#method_before
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName c : db.accountGroupNames().suggestByName(a, b, n)) {
                AccountGroup g = groupCache.get(c.getId());
                if (g != null && g.getGroupUUID() != null) {
                    r.add(GroupReference.forGroup(g));
                }
            }
            return r;
        }
    });
}
#method_after
public void suggestAccountGroup(final String query, final int limit, final AsyncCallback<List<GroupReference>> callback) {
    run(callback, new Action<List<GroupReference>>() {

        public List<GroupReference> run(final ReviewDb db) throws OrmException {
            final String a = query;
            final String b = a + MAX_SUFFIX;
            final int max = 10;
            final int n = limit <= 0 ? max : Math.min(limit, max);
            Set<AccountGroup.UUID> memberOf = currentUser.get().getEffectiveGroups();
            List<GroupReference> r = new ArrayList<GroupReference>(n);
            for (AccountGroupName group : db.accountGroupNames().suggestByName(a, b, n)) {
                try {
                    if (memberOf.contains(group.getId()) || groupControlFactory.controlFor(group.getId()).isVisible()) {
                        AccountGroup g = groupCache.get(group.getId());
                        if (g != null && g.getGroupUUID() != null) {
                            r.add(GroupReference.forGroup(g));
                        }
                    }
                } catch (NoSuchGroupException e) {
                    continue;
                }
            }
            return r;
        }
    });
}
#end_block

#method_before
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#method_after
private static Screen core(final String token) {
    String p;
    p = "change,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final String q = "patchset=";
        final String[] t = s.split(",", 2);
        if (t.length > 1 && t[1].startsWith(q)) {
            return new ChangeScreen(PatchSet.Id.parse(t[0] + "," + skip(q, t[1])));
        }
        return new ChangeScreen(Change.Id.parse(t[0]));
    }
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    p = "q,";
    if (token.startsWith(p)) {
        final String s = skip(p, token);
        final int c = s.indexOf(',');
        return new QueryScreen(s.substring(0, c), s.substring(c + 1));
    }
    return new NotFoundScreen();
}
#end_block

#method_before
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAdd(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#method_after
public void addGroupMember(final AccountGroup.Id groupId, final String nameOrEmail, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final Account a = findAccount(nameOrEmail);
            if (!a.isActive()) {
                throw new Failure(new InactiveAccountException(a.getFullName()));
            }
            if (!control.canAddMember(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), groupId);
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, getAccountId())));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#end_block

#method_before
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemove(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteGroupMembers(final AccountGroup.Id groupId, final Set<AccountGroupMember.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (control.getAccountGroup().getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupMember.Key k : keys) {
                if (!groupId.equals(k.getAccountGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            for (final AccountGroupMember.Key k : keys) {
                final AccountGroupMember m = db.accountGroupMembers().get(k);
                if (m != null) {
                    if (!control.canRemoveMember(m.getAccountId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupMemberAudit audit = null;
                    for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupMembersAudit().update(Collections.singleton(audit));
                    } else {
                        audit = new AccountGroupMemberAudit(m, me);
                        audit.removedLegacy();
                        db.accountGroupMembersAudit().insert(Collections.singleton(audit));
                    }
                    db.accountGroupMembers().delete(Collections.singleton(m));
                    accountCache.evict(m.getAccountId());
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public void setAction(Action action) {
    switch(action) {
        case ALLOW:
            setDeny(false);
            break;
        case DENY:
            setDeny(true);
            break;
        default:
            throw new IllegalArgumentException();
    }
}
#method_after
public void setAction(Action action) {
    if (action == null) {
        throw new NullPointerException("action");
    }
    setDeny(action == Action.DENY);
}
#end_block

#method_before
public int getMin() {
    return min;
}
#method_after
public Integer getMin() {
    return min;
}
#end_block

#method_before
public int getMax() {
    return max;
}
#method_after
public Integer getMax() {
    return max;
}
#end_block

#method_before
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#method_after
@Override
public int compareTo(PermissionRule o) {
    int cmp = deny(this) - deny(o);
    if (cmp == 0)
        cmp = range(o) - range(this);
    if (cmp == 0)
        cmp = group(this).compareTo(group(o));
    return cmp;
}
#end_block

#method_before
public String asString(boolean useRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (useRange) {
        if (getMin() == 0 && getMax() == 1) {
        } else if (getMin() == 1 && getMax() == 1) {
        } else if (getMin() < 0 && getMax() == 0) {
            r.append(getMin());
            r.append(' ');
        } else {
            if (getMin() != getMax()) {
                if (0 <= getMin())
                    r.append('+');
                r.append(getMin());
                r.append("..");
            }
            if (0 <= getMax())
                r.append('+');
            r.append(getMax());
            r.append(' ');
        }
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#method_after
public String asString(boolean canUseRange) {
    StringBuilder r = new StringBuilder();
    if (getDeny()) {
        r.append("deny ");
    }
    if (getForce()) {
        r.append("+force ");
    }
    if (canUseRange && (getMin() != 0 || getMax() != 0)) {
        if (0 <= getMin())
            r.append('+');
        r.append(getMin());
        r.append("..");
        if (0 <= getMax())
            r.append('+');
        r.append(getMax());
        r.append(' ');
    }
    r.append("group ");
    r.append(getGroup().getName());
    return r.toString();
}
#end_block

#method_before
public static PermissionRule fromString(String src, boolean useRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (useRange) {
        if (src.startsWith("group ")) {
            rule.setRange(0, 1);
        } else {
            int sp = src.indexOf(' ');
            String range = src.substring(0, sp);
            if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
                int dotdot = range.indexOf("..");
                int min = parseInt(range.substring(0, dotdot));
                int max = parseInt(range.substring(dotdot + 2));
                rule.setRange(min, max);
            } else if (range.matches("^([+-]\\d)$")) {
                int v = parseInt(range);
                rule.setRange(v, v);
            } else {
                throw new IllegalArgumentException("Invalid range in rule: " + orig);
            }
            src = src.substring(sp + 1).trim();
        }
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#method_after
public static PermissionRule fromString(String src, boolean mightUseRange) {
    final String orig = src;
    final PermissionRule rule = new PermissionRule();
    src = src.trim();
    if (src.startsWith("deny ")) {
        rule.setDeny(true);
        src = src.substring(5).trim();
    }
    if (src.startsWith("+force ")) {
        rule.setForce(true);
        src = src.substring("+force ".length()).trim();
    }
    if (mightUseRange && !src.startsWith("group ")) {
        int sp = src.indexOf(' ');
        String range = src.substring(0, sp);
        if (range.matches("^([+-]\\d+)\\.\\.([+-]\\d)$")) {
            int dotdot = range.indexOf("..");
            int min = parseInt(range.substring(0, dotdot));
            int max = parseInt(range.substring(dotdot + 2));
            rule.setRange(min, max);
        } else {
            throw new IllegalArgumentException("Invalid range in rule: " + orig);
        }
        src = src.substring(sp + 1).trim();
    }
    if (src.startsWith("group ")) {
        src = src.substring(6).trim();
        GroupReference group = new GroupReference();
        group.setName(src);
        rule.setGroup(group);
    } else {
        throw new IllegalArgumentException("Rule must include group: " + orig);
    }
    return rule;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_DO_NOT_INHERIT)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setInherit(false);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    boolean useRange = perm.isLabel();
                    for (String ruleString : rc.getStringList(ACCESS, refName, varName)) {
                        PermissionRule rule;
                        try {
                            rule = PermissionRule.fromString(ruleString, useRange);
                        } catch (IllegalArgumentException notRule) {
                            throw new ConfigInvalidException("Invalid rule in " + ACCESS + "." + refName + "." + varName + ": " + notRule.getMessage(), notRule);
                        }
                        GroupReference ref = groupsByName.get(rule.getGroup().getName());
                        if (ref == null) {
                            // The group wasn't mentioned in the groups table, so there is
                            // no valid UUID for it. Pool the reference anyway so at least
                            // all rules in the same file share the same GroupReference.
                            // 
                            ref = rule.getGroup();
                            groupsByName.put(ref.getName(), ref);
                        }
                        rule.setGroup(ref);
                        perm.add(rule);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (!perm.getInherit()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_DO_NOT_INHERIT, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_DO_NOT_INHERIT);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        rebuildPermissionSelector();
    }
}
#method_after
@Override
public void setValue(AccessSection value) {
    this.value = value;
    this.readOnly = !projectAccess.isOwnerOf(value);
    refPattern.setEnabled(!readOnly);
    deleteSection.setVisible(!readOnly);
    if (readOnly) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        enableEditing();
    }
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addDotDotDot());
        permissionSelector.setValue(Util.C.addDotDotDot());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    for (ApprovalType t : Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) {
        String varName = Permission.LABEL + t.getCategory().getLabelName();
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    for (String varName : Util.C.permissionNames().keySet()) {
        if (value.getPermission(varName) == null) {
            perms.add(varName);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    publishDrafts();
    final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
    if (isCurrent && change.getStatus().isOpen()) {
        publishApprovals(ctl);
    } else if (!approvals.isEmpty() && !alwaysPublishMessage) {
        throw new InvalidChangeOperationException("Change is closed");
    } else {
        publishMessageOnly();
    }
    touchChange();
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws NoSuchChangeException, InvalidChangeOperationException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl ctl = changeControlFactory.validateFor(changeId);
    change = ctl.getChange();
    patchSet = db.patchSets().get(patchSetId);
    if (patchSet == null) {
        throw new NoSuchChangeException(changeId);
    }
    drafts = drafts();
    db.changes().beginTransaction(changeId);
    try {
        publishDrafts();
        final boolean isCurrent = patchSetId.equals(change.currentPatchSetId());
        if (isCurrent && change.getStatus().isOpen()) {
            publishApprovals(ctl);
        } else if (approvals.isEmpty() || forceMessage) {
            publishMessageOnly();
        } else {
            throw new InvalidChangeOperationException("Change is closed");
        }
        touchChange();
        db.commit();
    } finally {
        db.rollback();
    }
    email();
    fireHook();
    return VoidResult.INSTANCE;
}
#end_block

#method_before
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draft(patchSetId, user.getAccountId()).toList();
}
#method_after
private List<PatchLineComment> drafts() throws OrmException {
    return db.patchComments().draftByPatchSetAuthor(patchSetId, user.getAccountId()).toList();
}
#end_block

#method_before
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#method_after
private void email() {
    try {
        if (message != null) {
            final CommentSender cm = commentSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId));
            cm.setChangeMessage(message);
            cm.setPatchLineComments(drafts);
            cm.send();
        }
    } catch (EmailException e) {
        log.error("Cannot send comments by email for patch set " + patchSetId, e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error("Failed to obtain PatchSetInfo for patch set " + patchSetId, e);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, alwaysPublishMsg).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, OrmException, EmailException, Failure {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    try {
        publishCommentsFactory.create(patchSetId, changeComment, aps, forceMessage).call();
        if (abandonChange) {
            if (changeControl.canAbandon()) {
                ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
            } else {
                throw error("Not permitted to abandon change");
            }
        }
        if (restoreChange) {
            if (changeControl.canRestore()) {
                ChangeUtil.restore(patchSetId, currentUser, changeComment, db, restoredSenderFactory, hooks);
            } else {
                throw error("Not permitted to restore change");
            }
            if (submitChange) {
                changeControl = changeControlFactory.validateFor(changeId);
            }
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    }
    if (submitChange) {
        List<SubmitRecord> result = changeControl.canSubmit(db, patchSetId);
        if (result.isEmpty()) {
            throw new Failure(1, "ChangeControl.canSubmit returned empty list");
        }
        switch(result.get(0).status) {
            case OK:
                if (changeControl.getRefControl().canSubmit()) {
                    toSubmit.add(patchSetId);
                } else {
                    throw error("change " + changeId + ": you do not have submit permission");
                }
                break;
            case NOT_READY:
                {
                    StringBuilder msg = new StringBuilder();
                    for (SubmitRecord.Label lbl : result.get(0).labels) {
                        switch(lbl.status) {
                            case OK:
                                break;
                            case REJECT:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": blocked by " + lbl.label);
                                break;
                            case NEED:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label);
                                break;
                            case IMPOSSIBLE:
                                if (msg.length() > 0)
                                    msg.append("\n");
                                msg.append("change " + changeId + ": needs " + lbl.label + " (check project access)");
                                break;
                            default:
                                throw new Failure(1, "Unsupported label status " + lbl.status);
                        }
                    }
                    throw error(msg.toString());
                }
            case CLOSED:
                throw error("change " + changeId + " is closed");
            case RULE_ERROR:
                if (result.get(0).errorMessage != null) {
                    throw error("change " + changeId + ": " + result.get(0).errorMessage);
                } else {
                    throw error("change " + changeId + ": internal rule error");
                }
            default:
                throw new Failure(1, "Unsupported status " + result.get(0).status);
        }
    }
}
#end_block

#method_before
public void deleteDraft(final PatchLineComment.Key commentKey, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            final PatchLineComment comment = db.patchComments().get(commentKey);
            if (comment == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (!getAccountId().equals(comment.getAuthor())) {
                throw new Failure(new NoSuchEntityException());
            }
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            db.patchComments().delete(Collections.singleton(comment));
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteDraft(final PatchLineComment.Key commentKey, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException, Failure {
            Change.Id id = commentKey.getParentKey().getParentKey().getParentKey();
            db.changes().beginTransaction(id);
            try {
                final PatchLineComment comment = db.patchComments().get(commentKey);
                if (comment == null) {
                    throw new Failure(new NoSuchEntityException());
                }
                if (!getAccountId().equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                    throw new Failure(new IllegalStateException("Comment published"));
                }
                db.patchComments().delete(Collections.singleton(comment));
                db.commit();
                return VoidResult.INSTANCE;
            } finally {
                db.rollback();
            }
        }
    });
}
#end_block

#method_before
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            AccountPatchReview apr = db.accountPatchReviews().get(key);
            if (apr == null && reviewed) {
                db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
            } else if (apr != null && !reviewed) {
                db.accountPatchReviews().delete(Collections.singleton(apr));
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void setReviewedByCurrentUser(final Key patchKey, final boolean reviewed, AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(ReviewDb db) throws OrmException {
            Account.Id account = getAccountId();
            AccountPatchReview.Key key = new AccountPatchReview.Key(patchKey, account);
            db.accounts().beginTransaction(account);
            try {
                AccountPatchReview apr = db.accountPatchReviews().get(key);
                if (apr == null && reviewed) {
                    db.accountPatchReviews().insert(Collections.singleton(new AccountPatchReview(patchKey, account)));
                } else if (apr != null && !reviewed) {
                    db.accountPatchReviews().delete(Collections.singleton(apr));
                }
                db.commit();
                return VoidResult.INSTANCE;
            } finally {
                db.rollback();
            }
        }
    });
}
#end_block

#method_before
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encode(project.get()));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toProject(final Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type.getProject());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", encode(project.get()));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", URL.encodeQueryString(branch.getParentKey().get()));
    p.put("branch", URL.encodeQueryString(branch.get()));
    p.put("file", URL.encodeQueryString(file));
    return baseUrl + pattern.replace(p);
}
#method_after
public String toFileHistory(final Branch.NameKey branch, final String file) {
    ParameterizedString pattern = new ParameterizedString(type.getFileHistory());
    final Map<String, String> p = new HashMap<String, String>();
    p.put("project", encode(branch.getParentKey().get()));
    p.put("branch", encode(branch.get()));
    p.put("file", encode(file));
    return baseUrl + pattern.replace(p);
}
#end_block

#method_before
String encode(String segment) {
    return URL.encodeQueryString(type.replacePathSeparator(segment));
}
#method_after
private String encode(String segment) {
    return URL.encodeQueryString(type.replacePathSeparator(segment));
}
#end_block

#method_before
public String replacePathSeparator(String newSeparator) {
    if ('/' != pathSeparator) {
        return newSeparator.replace('/', pathSeparator);
    }
    return newSeparator;
}
#method_after
public String replacePathSeparator(String urlSegment) {
    if ('/' != pathSeparator) {
        return urlSegment.replace('/', pathSeparator);
    }
    return urlSegment;
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (maxLimit <= 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null, includeFiles, d.change(db));
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) {
    if (commitMessage == null) {
        try {
            PatchSet.Id psId = change.currentPatchSetId();
            String sha1 = db.get().patchSets().get(psId).getRevision().get();
            Project.NameKey name = change.getProject();
            Repository repo = repoManager.openRepository(name);
            RevWalk walk = new RevWalk(repo);
            RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
            commitMessage = c.getFullMessage();
            walk.release();
        } catch (RepositoryNotFoundException e) {
        } catch (IOException e) {
        } catch (OrmException e) {
        }
    }
    return commitMessage;
}
#method_after
public String commitMessage(GitRepositoryManager repoManager, Provider<ReviewDb> db) throws IOException, OrmException {
    if (commitMessage == null) {
        PatchSet.Id psId = change(db).currentPatchSetId();
        String sha1 = db.get().patchSets().get(psId).getRevision().get();
        Project.NameKey name = change.getProject();
        Repository repo = repoManager.openRepository(name);
        try {
            RevWalk walk = new RevWalk(repo);
            try {
                RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
                commitMessage = c.getFullMessage();
            } finally {
                walk.release();
            }
        } finally {
            repo.close();
        }
    }
    return commitMessage;
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute a, Collection<PatchSet> ps) {
    addPatchSets(a, ps, null);
}
#method_after
public void addPatchSets(ChangeAttribute a, Collection<PatchSet> ps) {
    addPatchSets(a, ps, null, false, null);
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
        }
    }
}
#method_after
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    addPatchSets(ca, ps, approvals, false, null);
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
        }
    }
}
#method_after
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals, boolean includeFiles, Change change) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<PatchSetAttribute>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals);
            }
            ca.patchSets.add(psa);
            if (includeFiles && change != null) {
                addPatchSetFileNames(psa, change, p);
            }
        }
    }
}
#end_block

#method_before
public boolean isVisible() {
    if (isOwner()) {
        return true;
    } else {
        return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && !isHidden();
    }
}
#method_after
public boolean isVisible() {
    return (projectControl.visibleForReplication() || canPerform(Permission.READ)) && canRead();
}
#end_block

#method_before
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpload() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && isActive();
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && isActive();
}
#method_after
public boolean canSubmit() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName)) {
        // granting of powers beyond submitting to the configuration.
        return projectControl.isOwner();
    }
    return canPerform(Permission.SUBMIT) && canWrite();
}
#end_block

#method_before
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && isActive();
}
#method_after
public boolean canUpdate() {
    if (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner()) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    return canPerform(Permission.PUSH) && canWrite();
}
#end_block

#method_before
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && isActive();
}
#method_after
public boolean canForceUpdate() {
    return (canPushWithForce() || canDelete()) && canWrite();
}
#end_block

#method_before
private boolean canPushWithForce() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#method_after
private boolean canPushWithForce() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName) && !projectControl.isOwner())) {
        // granting of powers beyond pushing to the configuration.
        return false;
    }
    boolean result = false;
    for (PermissionRule rule : access(Permission.PUSH)) {
        if (rule.isBlock()) {
            return false;
        }
        if (rule.getForce()) {
            result = true;
        }
    }
    return result;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!isActive()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!isActive() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case WEB_UI:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().isOwner() || control.getRefControl().isActive());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#method_after
@Override
public ChangeDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    control = changeControlFactory.validateFor(changeId);
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
    if (patch == null) {
        throw new NoSuchEntityException();
    }
    aic.want(change.getOwner());
    detail = new ChangeDetail();
    detail.setChange(change);
    detail.setAllowsAnonymous(control.forUser(anonymousUser).isVisible());
    detail.setCanAbandon(change.getStatus().isOpen() && control.canAbandon());
    detail.setCanRestore(change.getStatus() == Change.Status.ABANDONED && control.canRestore());
    detail.setStarred(control.getCurrentUser().getStarredChanges().contains(changeId));
    detail.setCanRevert(change.getStatus() == Change.Status.MERGED && control.canAddPatchSet());
    detail.setCanEdit(control.getRefControl().canWrite());
    if (detail.getChange().getStatus().isOpen()) {
        List<SubmitRecord> submitRecords = control.canSubmit(db, patch.getId());
        for (SubmitRecord rec : submitRecords) {
            if (rec.labels != null) {
                for (SubmitRecord.Label lbl : rec.labels) {
                    aic.want(lbl.appliedBy);
                }
            }
            if (rec.status == SubmitRecord.Status.OK && control.getRefControl().canSubmit()) {
                detail.setCanSubmit(true);
            }
        }
        detail.setSubmitRecords(submitRecords);
    }
    loadPatchSets();
    loadMessages();
    if (change.currentPatchSetId() != null) {
        loadCurrentPatchSet();
    }
    load();
    detail.setAccounts(aic.create());
    return detail;
}
#end_block

#method_before
private void load() throws OrmException {
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#method_after
private void load() throws OrmException, NoSuchChangeException {
    if (detail.getChange().getStatus().equals(Change.Status.NEW) && testMerge) {
        ChangeUtil.testMerge(opFactory, detail.getChange());
    }
    final PatchSet.Id psId = detail.getChange().currentPatchSetId();
    final List<PatchSetApproval> allApprovals = db.patchSetApprovals().byChange(changeId).toList();
    if (detail.getChange().getStatus().isOpen()) {
        final FunctionState fs = functionState.create(control, psId, allApprovals);
        for (final ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
    }
    final boolean canRemoveReviewers = // 
    detail.getChange().getStatus().isOpen() && control.getCurrentUser() instanceof IdentifiedUser;
    final HashMap<Account.Id, ApprovalDetail> ad = new HashMap<Account.Id, ApprovalDetail>();
    for (PatchSetApproval ca : allApprovals) {
        ApprovalDetail d = ad.get(ca.getAccountId());
        if (d == null) {
            d = new ApprovalDetail(ca.getAccountId());
            d.setCanRemove(canRemoveReviewers);
            ad.put(d.getAccount(), d);
        }
        if (d.canRemove()) {
            d.setCanRemove(control.canRemoveReviewer(ca));
        }
        if (ca.getPatchSetId().equals(psId)) {
            d.add(ca);
        }
    }
    final Account.Id owner = detail.getChange().getOwner();
    if (ad.containsKey(owner)) {
        // Ensure the owner always sorts to the top of the table
        // 
        ad.get(owner).sortFirst();
    }
    aic.want(ad.keySet());
    detail.setApprovals(ad.values());
}
#end_block

#method_before
public boolean isVisible() {
    return visibleForReplication() || canPerformOnAnyRef(Permission.READ) && !isHidden();
}
#method_after
public boolean isVisible() {
    return (visibleForReplication() || canPerformOnAnyRef(Permission.READ)) && !isHidden();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, STATE, null, KEY_VALUE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, STATE, null, KEY_VALUE, p.getState(), defaultStateValue);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (isEditable()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#method_after
public void ensureLoaded(final PatchSetDetail detail) {
    infoTable = new Grid(R_CNT, 2);
    infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock());
    initRow(R_AUTHOR, Util.C.patchSetInfoAuthor());
    initRow(R_COMMITTER, Util.C.patchSetInfoCommitter());
    initRow(R_PARENTS, Util.C.patchSetInfoParents());
    initRow(R_DOWNLOAD, Util.C.patchSetInfoDownload());
    final CellFormatter itfmt = infoTable.getCellFormatter();
    itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    itfmt.addStyleName(R_CNT - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    itfmt.addStyleName(R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity());
    itfmt.addStyleName(R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell());
    final PatchSetInfo info = detail.getInfo();
    displayUserIdentity(R_AUTHOR, info.getAuthor());
    displayUserIdentity(R_COMMITTER, info.getCommitter());
    displayParents(info.getParents());
    displayDownload();
    body.add(infoTable);
    if (!patchSet.getId().equals(diffBaseId)) {
        patchTable = new PatchTable();
        patchTable.setSavePointerId("PatchTable " + patchSet.getId());
        patchTable.setPatchSetIdToCompareWith(diffBaseId);
        patchTable.display(detail);
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        body.add(actionsPanel);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
        }
        populateDiffAllActions(detail);
        body.add(patchTable);
        for (ClickHandler clickHandler : registeredClickHandler) {
            patchTable.addClickHandler(clickHandler);
        }
    }
}
#end_block

#method_before
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(GWT.getHostPageBaseURL());
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String base = GWT.getHostPageBaseURL();
        int p = base.indexOf("://");
        int s = base.indexOf('/', p + 3);
        if (s < 0) {
            s = base.length();
        }
        String host = base.substring(p + 3, s);
        if (host.contains("@")) {
            host = host.substring(host.indexOf('@') + 1);
        }
        final StringBuilder r = new StringBuilder();
        r.append(base.substring(0, p + 3));
        r.append(Gerrit.getUserAccount().getUserName());
        r.append('@');
        r.append(host);
        r.append(base.substring(s));
        r.append("p/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#method_after
private void displayDownload() {
    final Project.NameKey projectKey = changeDetail.getChange().getProject();
    final String projectName = projectKey.get();
    final CopyableLabel copyLabel = new CopyableLabel("");
    final DownloadCommandPanel commands = new DownloadCommandPanel();
    final DownloadUrlPanel urls = new DownloadUrlPanel(commands);
    final Set<DownloadScheme> allowedSchemes = Gerrit.getConfig().getDownloadSchemes();
    copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadLinkCopyLabel());
    if (changeDetail.isAllowsAnonymous() && Gerrit.getConfig().getGitDaemonUrl() != null && (allowedSchemes.contains(DownloadScheme.ANON_GIT) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        r.append(Gerrit.getConfig().getGitDaemonUrl());
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_GIT, Util.M.anonymousDownload("Git"), r.toString()));
    }
    if (changeDetail.isAllowsAnonymous() && (allowedSchemes.contains(DownloadScheme.ANON_HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            r.append(GWT.getHostPageBaseURL());
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.ANON_HTTP, Util.M.anonymousDownload("HTTP"), r.toString()));
    }
    if (Gerrit.getConfig().getSshdAddress() != null && Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.SSH) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        String sshAddr = Gerrit.getConfig().getSshdAddress();
        final StringBuilder r = new StringBuilder();
        r.append("ssh://");
        r.append(Gerrit.getUserAccount().getUserName());
        r.append("@");
        if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
            r.append(Window.Location.getHostName());
        }
        if (sshAddr.startsWith("*")) {
            sshAddr = sshAddr.substring(1);
        }
        r.append(sshAddr);
        r.append("/");
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.SSH, "SSH", r.toString()));
    }
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getUserName() != null && Gerrit.getUserAccount().getUserName().length() > 0 && (allowedSchemes.contains(DownloadScheme.HTTP) || allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS))) {
        final StringBuilder r = new StringBuilder();
        if (Gerrit.getConfig().getGitHttpUrl() != null && changeDetail.isAllowsAnonymous()) {
            r.append(Gerrit.getConfig().getGitHttpUrl());
        } else {
            String base = GWT.getHostPageBaseURL();
            int p = base.indexOf("://");
            int s = base.indexOf('/', p + 3);
            if (s < 0) {
                s = base.length();
            }
            String host = base.substring(p + 3, s);
            if (host.contains("@")) {
                host = host.substring(host.indexOf('@') + 1);
            }
            r.append(base.substring(0, p + 3));
            r.append(Gerrit.getUserAccount().getUserName());
            r.append('@');
            r.append(host);
            r.append(base.substring(s));
            r.append("p/");
        }
        r.append(projectName);
        r.append(" ");
        r.append(patchSet.getRefName());
        urls.add(new DownloadUrlLink(DownloadScheme.HTTP, "HTTP", r.toString()));
    }
    if (allowedSchemes.contains(DownloadScheme.REPO_DOWNLOAD)) {
        // This site prefers usage of the 'repo' tool, so suggest
        // that for easy fetch.
        // 
        final StringBuilder r = new StringBuilder();
        r.append("repo download ");
        r.append(projectName);
        r.append(" ");
        r.append(changeDetail.getChange().getChangeId());
        r.append("/");
        r.append(patchSet.getPatchSetId());
        final String cmd = r.toString();
        commands.add(new DownloadCommandLink(DownloadCommand.REPO_DOWNLOAD, "repo download") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(false);
                copyLabel.setText(cmd);
            }
        });
    }
    if (!urls.isEmpty()) {
        commands.add(new DownloadCommandLink(DownloadCommand.CHECKOUT, "checkout") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git checkout FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.PULL, "pull") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git pull " + link.urlData);
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.CHERRY_PICK, "cherry-pick") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git cherry-pick FETCH_HEAD");
            }
        });
        commands.add(new DownloadCommandLink(DownloadCommand.FORMAT_PATCH, "patch") {

            @Override
            void setCurrentUrl(DownloadUrlLink link) {
                urls.setVisible(true);
                copyLabel.setText("git fetch " + link.urlData + " && git format-patch -1 --stdout FETCH_HEAD");
            }
        });
    }
    final FlowPanel fp = new FlowPanel();
    if (!commands.isEmpty()) {
        final AccountGeneralPreferences pref;
        if (Gerrit.isSignedIn()) {
            pref = Gerrit.getUserAccount().getGeneralPreferences();
        } else {
            pref = new AccountGeneralPreferences();
            pref.resetToDefaults();
        }
        commands.select(pref.getDownloadCommand());
        urls.select(pref.getDownloadUrl());
        FlowPanel p = new FlowPanel();
        p.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeader());
        p.add(commands);
        final InlineLabel glue = new InlineLabel();
        glue.setStyleName(Gerrit.RESOURCES.css().downloadLinkHeaderGap());
        p.add(glue);
        p.add(urls);
        fp.add(p);
        fp.add(copyLabel);
    }
    infoTable.setWidget(R_DOWNLOAD, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.submit(patchSet.getId(), new GerritCallback<ChangeDetail>() {

                    public void onSuccess(ChangeDetail result) {
                        onSubmitResult(result);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) {

                    public void onSend() {
                        Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) {

                    public void onSend() {
                        Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback());
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            changeScreen.update(result);
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#method_after
private AsyncCallback<ChangeDetail> createCommentedCallback(final Button b, final boolean redirect) {
    return new AsyncCallback<ChangeDetail>() {

        public void onSuccess(ChangeDetail result) {
            if (redirect) {
                Gerrit.display(PageLinks.toChange(result.getChange().getId()));
            } else {
                changeScreen.update(result);
            }
        }

        public void onFailure(Throwable caught) {
            b.setEnabled(true);
        }
    };
}
#end_block

#method_before
public void setParentName(String n) {
    parent = n != null ? new NameKey(n) : null;
}
#method_after
public void setParentName(NameKey n) {
    parent = n;
}
#end_block

#method_before
private void setState(final Project.State newState) {
    int index = -1;
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                index = i;
                break;
            }
        }
        state.setSelectedIndex(index);
    }
}
#method_after
private void setState(final Project.State newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#end_block

#method_before
public void setCanModifyState(final boolean cmmt) {
    canModifyState = cmmt;
}
#method_after
public void setCanModifyState(final boolean cms) {
    canModifyState = cms;
}
#end_block

#method_before
private void onLogin() {
    hideError();
    final String user = username.getText();
    if (user == null || user.equals("")) {
        showError(Util.C.usernameRequired());
        username.setFocus(true);
        return;
    }
    final String pass = password.getText();
    if (pass == null || pass.equals("")) {
        showError(Util.C.passwordRequired());
        password.setFocus(true);
        return;
    }
    enable(false);
    Util.SVC.authenticate(user, pass, new GerritCallback<LoginResult>() {

        public void onSuccess(final LoginResult result) {
            if (result.success) {
                String to = token;
                if (!to.startsWith("/")) {
                    to = "/" + to;
                }
                if (result.isNew && !token.startsWith(PageLinks.REGISTER + "/")) {
                    to = PageLinks.REGISTER + to;
                }
                Location.replace(Location.getPath() + "login" + to);
            } else {
                final String message;
                switch(result.getError()) {
                    case LDAP_SERVER_UNAVAILABLE:
                        message = Util.C.ldapServerUnavailable();
                        break;
                    case INVALID_LOGIN:
                    default:
                        message = Util.C.invalidLogin();
                }
                showError(message);
                enable(true);
                password.selectAll();
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        password.setFocus(true);
                    }
                });
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            super.onFailure(caught);
            enable(true);
        }
    });
}
#method_after
private void onLogin() {
    hideError();
    final String user = username.getText();
    if (user == null || user.equals("")) {
        showError(Util.C.usernameRequired());
        username.setFocus(true);
        return;
    }
    final String pass = password.getText();
    if (pass == null || pass.equals("")) {
        showError(Util.C.passwordRequired());
        password.setFocus(true);
        return;
    }
    enable(false);
    Util.SVC.authenticate(user, pass, new GerritCallback<LoginResult>() {

        public void onSuccess(final LoginResult result) {
            if (result.success) {
                String to = token;
                if (!to.startsWith("/")) {
                    to = "/" + to;
                }
                if (result.isNew && !token.startsWith(PageLinks.REGISTER + "/")) {
                    to = PageLinks.REGISTER + to;
                }
                Location.replace(Location.getPath() + "login" + to);
            } else {
                final String message;
                switch(result.getError()) {
                    case AUTHENTICATION_UNAVAILABLE:
                        message = Util.M.authenticationUnavailable(result.getAuthType());
                        break;
                    case INVALID_LOGIN:
                    default:
                        message = Util.C.invalidLogin();
                }
                showError(message);
                enable(true);
                password.selectAll();
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        password.setFocus(true);
                    }
                });
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            super.onFailure(caught);
            enable(true);
        }
    });
}
#end_block

#method_before
@Override
public void authenticate(String username, final String password, final AsyncCallback<LoginResult> callback) {
    LoginResult result = new LoginResult();
    if (// 
    username == null || "".equals(username.trim()) || password == null || "".equals(password)) {
        result.setError(LoginResult.Error.INVALID_LOGIN);
        callback.onSuccess(result);
        return;
    }
    username = username.trim();
    final AuthRequest req = AuthRequest.forUser(username);
    req.setPassword(password);
    final AuthResult res;
    try {
        res = accountManager.authenticate(req);
    } catch (AccountUserNameException e) {
        // entered user name and password were correct, but user name could not be
        // set for the newly created account and this is why the login fails,
        // error screen with error message should be shown to the user
        callback.onFailure(e);
        return;
    } catch (LdapQueryException e) {
        result.setError(LoginResult.Error.LDAP_SERVER_UNAVAILABLE);
        callback.onSuccess(result);
        return;
    } catch (AccountException e) {
        result.setError(LoginResult.Error.INVALID_LOGIN);
        callback.onSuccess(result);
        return;
    }
    result.success = true;
    result.isNew = res.isNew();
    webSession.get().login(res, true);
    callback.onSuccess(result);
}
#method_after
@Override
public void authenticate(String username, final String password, final AsyncCallback<LoginResult> callback) {
    LoginResult result = new LoginResult(authType);
    if (// 
    username == null || "".equals(username.trim()) || password == null || "".equals(password)) {
        result.setError(LoginResult.Error.INVALID_LOGIN);
        callback.onSuccess(result);
        return;
    }
    username = username.trim();
    final AuthRequest req = AuthRequest.forUser(username);
    req.setPassword(password);
    final AuthResult res;
    try {
        res = accountManager.authenticate(req);
    } catch (AccountUserNameException e) {
        // entered user name and password were correct, but user name could not be
        // set for the newly created account and this is why the login fails,
        // error screen with error message should be shown to the user
        callback.onFailure(e);
        return;
    } catch (AuthenticationUnavailableException e) {
        result.setError(LoginResult.Error.AUTHENTICATION_UNAVAILABLE);
        callback.onSuccess(result);
        return;
    } catch (AccountException e) {
        result.setError(LoginResult.Error.INVALID_LOGIN);
        callback.onSuccess(result);
        return;
    }
    result.success = true;
    result.isNew = res.isNew();
    webSession.get().login(res, true);
    callback.onSuccess(result);
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, helper.queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new LdapQueryException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, helper.queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException {
    final Project.NameKey projectName = update.getNameKey();
    projectControlFactory.ownerFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        // TODO We really should take advantage of the Git commit DAG and
        // ensure the current version matches the old version the caller read.
        // 
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().copySettingsFrom(update);
        md.setMessage("Modified project settings\n");
        if (config.commit(md)) {
            mgr.setProjectDescription(projectName, update.getDescription());
            projectCache.evict(config.getProject());
            userCache.get().evict(projectName);
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } catch (ConfigInvalidException err) {
        throw new OrmException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new OrmException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException {
    final Project.NameKey projectName = update.getNameKey();
    projectControlFactory.ownerFor(projectName);
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
    try {
        // TODO We really should take advantage of the Git commit DAG and
        // ensure the current version matches the old version the caller read.
        // 
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().copySettingsFrom(update);
        md.setMessage("Modified project settings\n");
        if (config.commit(md)) {
            mgr.setProjectDescription(projectName, update.getDescription());
            userCache.get().evict(config.getProject());
        } else {
            throw new OrmConcurrencyException("Cannot update " + projectName);
        }
    } catch (ConfigInvalidException err) {
        throw new OrmException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new OrmException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public void evict(Project.NameKey nameKey) {
    controls.remove(nameKey);
}
#method_after
public void evict(Project project) {
    projectCache.evict(project);
    controls.remove(project.getNameKey());
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/query").with(ChangeQueryServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    filter("/p/*").through(ProjectAccessPathFilter.class);
    if (authConfig.isTrustContainerAuth())
        filter("/p/*").through(ContainerAuthFilter.class);
    else
        filter("/p/*").through(ProjectDigestFilter.class);
    serve("/p/*").with(ProjectServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/query").with(ChangeQueryServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    filter("/p/*").through(ProjectAccessPathFilter.class);
    if (authConfig.isTrustContainerAuth()) {
        filter("/p/*").through(ContainerAuthFilter.class);
    } else {
        filter("/p/*").through(ProjectDigestFilter.class);
    }
    serve("/p/*").with(ProjectServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, HttpServletResponseWrapper rsp) throws IOException {
    if (!authConfig.isTrustContainerAuth())
        return true;
    final String username = req.getRemoteUser();
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    session.get().setUserAccountId(who.getAccount().getId());
    return true;
}
#method_after
private boolean verify(HttpServletRequest req, HttpServletResponseWrapper rsp) throws IOException {
    final String username = req.getRemoteUser();
    final AccountState who = (username == null) ? null : accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    session.get().setUserAccountId(who.getAccount().getId());
    return true;
}
#end_block

#method_before
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groups = new ArrayList<GroupDetail>();
            try {
                for (AccountGroup group : myGroupsFactory.create().call()) {
                    groups.add(groupDetailFactory.create(group.getId()).call());
                }
            } catch (Exception e) {
                throw new Failure(e);
            }
            return groups;
        }
    });
}
#method_after
@Override
public void myGroups(final AsyncCallback<List<GroupDetail>> callback) {
    run(callback, new Action<List<GroupDetail>>() {

        public List<GroupDetail> run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            List<GroupDetail> groupDetails = new ArrayList<GroupDetail>();
            for (AccountGroup group : myGroupsFactory.create().call()) {
                groupDetails.add(groupDetailFactory.create(group.getId()).call());
            }
            return groupDetails;
        }
    });
}
#end_block

#method_before
private void postLoad() {
    if (haveAccount && haveEmails) {
        if (currentEmail != null) {
            boolean found = false;
            for (int i = 0; i < emailPick.getItemCount(); i++) {
                if (currentEmail.equals(emailPick.getValue(i))) {
                    emailPick.setSelectedIndex(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                emailPick.addItem(currentEmail);
                emailPick.setSelectedIndex(emailPick.getItemCount() - 1);
            }
        }
        if (emailPick.getItemCount() > 0) {
            emailPick.setVisible(true);
            emailPick.setEnabled(true);
            if (canRegisterNewEmail()) {
                final String t = Util.C.buttonOpenRegisterNewEmail();
                emailPick.addItem("... " + t + "  ", t);
            }
        } else {
            emailPick.setVisible(false);
        }
        registerNewEmail.setEnabled(true);
    }
    display();
}
#method_after
private void postLoad() {
    if (haveAccount && haveEmails) {
        updateEmailList();
        registerNewEmail.setEnabled(true);
    }
    display();
}
#end_block

#method_before
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<VoidResult>() {

                public void onSuccess(VoidResult result) {
                    box.hide();
                    switch(Gerrit.getConfig().getAuthType()) {
                        case HTTP:
                        case HTTP_LDAP:
                        case CLIENT_SSL_CERT_LDAP:
                        case OPENID:
                        case LDAP:
                        case LDAP_BIND:
                            break;
                        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                            Gerrit.upgradeUI(PageLinks.SETTINGS_CONTACT);
                            break;
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    body.add(new HTML(Util.C.descRegisterNewEmail()));
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#method_after
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                new ErrorDialog(Util.C.invalidUserEmail()).center();
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            Util.ACCOUNT_SEC.registerEmail(addr, new GerritCallback<Account>() {

                public void onSuccess(Account currentUser) {
                    box.hide();
                    if (Gerrit.getConfig().getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
                        currentEmail = addr;
                        if (emailPick.getItemCount() == 0) {
                            onSaveSuccess(currentUser);
                        } else {
                            save.setEnabled(true);
                        }
                        updateEmailList();
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    super.onFailure(caught);
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    if (Gerrit.getConfig().getAuthType() != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        body.add(new HTML(Util.C.descRegisterNewEmail()));
    }
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#end_block

#method_before
public void registerEmail(final String address, final AsyncCallback<VoidResult> cb) {
    try {
        switch(authConfig.getAuthType()) {
            case OPENID:
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
            case LDAP:
            case LDAP_BIND:
                final RegisterNewEmailSender sender;
                sender = registerNewEmailFactory.create(address);
                sender.send();
                cb.onSuccess(VoidResult.INSTANCE);
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                registerMail(address, cb);
                break;
            default:
                log.error("Unsupported loginType: " + authConfig.getAuthType(), new ProvisionException("Unsupported loginType: " + authConfig.getAuthType()));
                throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
        }
    } catch (EmailException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    } catch (RuntimeException e) {
        log.error("Cannot send email verification message to " + address, e);
        cb.onFailure(e);
    }
}
#method_after
public void registerEmail(final String address, final AsyncCallback<Account> cb) {
    if (authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(address));
            cb.onSuccess(user.get().getAccount());
        } catch (AccountException e) {
            cb.onFailure(e);
        }
    } else {
        try {
            final RegisterNewEmailSender sender;
            sender = registerNewEmailFactory.create(address);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + address, e);
            cb.onFailure(e);
        }
    }
}
#end_block

#method_before
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        registerMail(newEmail, callback);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    }
}
#method_after
public void validateEmail(final String token, final AsyncCallback<VoidResult> callback) {
    try {
        final ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null);
        if (t == null || t.getData() == null || "".equals(t.getData())) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        final String newEmail = new String(Base64.decode(t.getData()), "UTF-8");
        if (!newEmail.contains("@")) {
            callback.onFailure(new IllegalStateException("Invalid token"));
            return;
        }
        accountManager.link(user.get().getAccountId(), AuthRequest.forEmail(newEmail));
        callback.onSuccess(VoidResult.INSTANCE);
    } catch (XsrfException e) {
        callback.onFailure(e);
    } catch (UnsupportedEncodingException e) {
        callback.onFailure(e);
    } catch (AccountException e) {
        callback.onFailure(e);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    if (a2.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a2.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regexEdit = Pattern.compile(a2.name());
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchList pl = getPatchList(env, psInfo);
    Repository repo;
    try {
        repo = getRepository(env);
    } catch (RepositoryNotFoundException err) {
        throw new JavaException(this, 1, err);
    }
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            final RevCommit p = bCommit.getParent(0);
            rw.parseHeaders(p);
            aTree = p.getTree();
        }
        bTree = bCommit.getTree();
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    for (PatchListEntry entry : pl.getPatches()) {
        String newName = entry.getNewName();
        String oldName = entry.getOldName();
        if (regex.matcher(newName).find() || (oldName != null && regex.matcher(oldName).find())) {
            List<Edit> edits = entry.getEdits();
            if (edits.isEmpty()) {
                continue;
            }
            try {
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, repo);
                } else {
                    tA = load(aTree, newName, repo);
                }
                Text tB = load(bTree, newName, repo);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (regexEdit.matcher(aDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (regexEdit.matcher(bDiff).find()) {
                            engine.neckCut();
                            return cont;
                        }
                    }
                }
            } catch (IOException err) {
                throw new JavaException(this, 1, err);
            }
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo = StoredValues.PATCH_SET_INFO.get(engine);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    final ObjectReader reader = repo.newObjectReader();
    final RevTree aTree;
    final RevTree bTree;
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                List<Edit> edits = entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    } finally {
        reader.release();
    }
    return engine.fail();
}
#end_block

#method_before
private Text load(final ObjectId tree, final String path, final Repository repo) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(repo, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(repo.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#method_after
private Text load(final ObjectId tree, final String path, final ObjectReader reader) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException {
    if (path == null) {
        return Text.EMPTY;
    }
    final TreeWalk tw = TreeWalk.forPath(reader, path, tree);
    if (tw == null) {
        return Text.EMPTY;
    }
    if (tw.getFileMode(0).getObjectType() != Constants.OBJ_BLOB) {
        return Text.EMPTY;
    }
    return new Text(reader.open(tw.getObjectId(0), Constants.OBJ_BLOB));
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        try {
            while (parentState != null) {
                if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                    // parent has been seen before, stop walk up inheritance tree
                    break;
                }
                PrologEnvironment parentEnv;
                try {
                    parentEnv = parentState.newPrologEnvironment();
                } catch (CompileException err) {
                    return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
                }
                try {
                    parentEnv.copyStoredValues(childEnv);
                    Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
                    if (filterRule != null) {
                        try {
                            Term resultsTerm = toListTerm(results);
                            results.clear();
                            Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                            results.addAll(((ListTerm) template[2]).toJava());
                        } catch (PrologException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        } catch (RuntimeException err) {
                            return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                        }
                    }
                    parentState = parentState.getParentState();
                    childEnv = parentEnv;
                } finally {
                    // childEnv.close() below will handle it.
                    if (childEnv != parentEnv) {
                        parentEnv.close();
                    }
                }
            }
        } finally {
            childEnv.close();
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    if (change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSetId.equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSetId + " is not current");
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.PATCH_SET_ID, patchSetId);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    results.addAll(((ListTerm) template[2]).toJava());
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    child.delegateCleanup(cleanup);
}
#method_after
public void copyStoredValues(PrologEnvironment child) {
    storedValues.putAll(child.storedValues);
    setCleanup(child.cleanup);
}
#end_block

#method_before
public void close() {
    for (Runnable task : cleanup) {
        task.run();
    }
    // ensure cleanup tasks run only once, even if close() is called again
    cleanup.clear();
}
#method_after
public void close() {
    for (final Iterator<Runnable> i = cleanup.iterator(); i.hasNext(); ) {
        try {
            i.next().run();
        } catch (Throwable err) {
            log.error("Failed to execute cleanup for PrologEnvironment", err);
        }
        i.remove();
    }
}
#end_block

#method_before
public T get(Prolog engine) {
    T obj = getOrNull(engine);
    if (obj == null) {
        // unless createValue() is overridden, will throw an exception
        obj = createValue(engine);
        set(engine, obj);
    }
    return obj;
}
#method_after
public T get(Prolog engine) {
    T obj = getOrNull(engine);
    if (obj == null) {
        // unless createValue() is overridden, will return null
        obj = createValue(engine);
        if (obj == null) {
            throw new SystemException("No " + key + " available");
        }
        set(engine, obj);
    }
    return obj;
}
#end_block

#method_before
protected T createValue(Prolog engine) {
    throw new SystemException("No " + key + " available");
}
#method_after
protected T createValue(Prolog engine) {
    return null;
}
#end_block

#method_before
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    if ("refs/meta/config".equals(k.getShortName()) || Constants.HEAD.equals(k.getShortName())) {
        fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().italic());
    }
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    if (c != null) {
        fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    }
    setRowItem(row, k);
}
#method_after
void populate(final int row, final Branch k) {
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (k.getCanDelete()) {
        table.setWidget(row, 1, new CheckBox());
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.getRevision() != null) {
        table.setText(row, 3, k.getRevision().get());
    } else {
        table.setText(row, 3, "");
    }
    if (c != null) {
        table.setWidget(row, 4, new Anchor("(gitweb)", false, c.toBranch(k.getNameKey())));
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if ("refs/meta/config".equals(k.getShortName()) || Constants.HEAD.equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    if (c != null) {
        fmt.addStyleName(row, 4, dataCellStyle);
    }
    setRowItem(row, k);
}
#end_block

#method_before
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, "Base");
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, Util.M.patchSetHeader(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#method_after
void display(final List<Patch> result) {
    all.clear();
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    table.setText(0, 0, PatchUtil.C.patchHeaderPatchSet());
    fmt.setStyleName(0, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(1, 0, PatchUtil.C.patchHeaderOld());
    fmt.setStyleName(1, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(2, 0, PatchUtil.C.patchHeaderNew());
    fmt.setStyleName(2, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(3, 0, Util.C.patchTableColumnComments());
    fmt.setStyleName(3, 0, Gerrit.RESOURCES.css().dataHeader());
    table.setText(0, 1, PatchUtil.C.patchBase());
    fmt.setStyleName(0, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topMostCell());
    fmt.setStyleName(1, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(2, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.setStyleName(3, 1, Gerrit.RESOURCES.css().dataCell());
    installRadio(1, 1, null, screen.idSideA, 0);
    int col = 2;
    for (final Patch k : result) {
        final PatchSet.Id psId = k.getKey().getParentKey();
        table.setText(0, col, String.valueOf(psId.get()));
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().patchHistoryTablePatchSetHeader());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().dataCell());
        fmt.addStyleName(0, col, Gerrit.RESOURCES.css().topMostCell());
        installRadio(1, col, psId, screen.idSideA, 0);
        installRadio(2, col, psId, screen.idSideB, 1);
        fmt.setStyleName(3, col, Gerrit.RESOURCES.css().dataCell());
        if (k.getCommentCount() > 0) {
            table.setText(3, col, Util.M.patchTableComments(k.getCommentCount()));
        }
        col++;
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    doPost(req, rsp);
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#end_block

#method_before
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(rsp, req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(rsp, req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(rsp, req.getParameter("account_id"));
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        rsp.setContentLength(raw.length);
        final OutputStream out = rsp.getOutputStream();
        try {
            out.write(raw);
        } finally {
            out.close();
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(urlProvider.get());
        if (IS_DEV && req.getParameter("gwt.codesvr") != null) {
            if (rdr.indexOf("?") < 0) {
                rdr.append("?");
            } else {
                rdr.append("&");
            }
            rdr.append("gwt.codesvr=").append(req.getParameter("gwt.codesvr"));
        }
        rdr.append('#');
        if (res.isNew()) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(PageLinks.MINE);
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#method_after
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    rsp.setHeader("Pragma", "no-cache");
    rsp.setHeader("Cache-Control", "no-cache, must-revalidate");
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(rsp, req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(rsp, req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(rsp, req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        rsp.setContentLength(raw.length);
        final OutputStream out = rsp.getOutputStream();
        try {
            out.write(raw);
        } finally {
            out.close();
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(urlProvider.get());
        if (IS_DEV && req.getParameter("gwt.codesvr") != null) {
            if (rdr.indexOf("?") < 0) {
                rdr.append("?");
            } else {
                rdr.append("&");
            }
            rdr.append("gwt.codesvr=").append(req.getParameter("gwt.codesvr"));
        }
        rdr.append('#');
        if (res.isNew()) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(PageLinks.MINE);
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC);
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#end_block

#method_before
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerFactory.create(id, reviewers, confirmed).to(callback);
}
#method_after
public void addReviewers(final Change.Id id, final List<String> reviewers, final boolean confirmed, final AsyncCallback<ReviewerResult> callback) {
    addReviewerHandlerFactory.create(id, reviewers, confirmed).to(callback);
}
#end_block

#method_before
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerFactory.create(id, reviewerId).to(callback);
}
#method_after
public void removeReviewer(final Change.Id id, final Account.Id reviewerId, final AsyncCallback<ReviewerResult> callback) {
    removeReviewerHandlerFactory.create(id, reviewerId).to(callback);
}
#end_block

#method_before
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void userApprovals(final Set<Change.Id> cids, final Account.Id aid, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            aicFactory.want(aid);
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (final PatchSetApproval ca : db.patchSetApprovals().byPatchSetUser(ps_id, aid)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        psas.put(category, ca);
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(cc, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        final ApprovalCategory.Id category = ca.getCategoryId();
                        if (ApprovalCategory.SUBMIT.equals(category)) {
                            continue;
                        }
                        if (change.getStatus().isOpen()) {
                            fs.normalize(approvalTypes.byId(category), ca);
                        }
                        if (ca.getValue() == 0) {
                            continue;
                        }
                        boolean keep = true;
                        if (psas.containsKey(category)) {
                            final short oldValue = psas.get(category).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(category, ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /*
             * The user has no access to see this change, so we simply do not
             * provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
private void displayHeader() {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (final ApprovalType t : types) {
        table.setText(0, col, t.getCategory().getName());
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(0, col, Gerrit.RESOURCES.css().rightmost());
    col++;
}
#method_after
private void displayHeader(List<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (String name : labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), change);
        }
        table.setVisible(true);
    }
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Element li = DOM.createElement("li");
                li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                DOM.setInnerText(li, Util.M.needApproval(at.getCategory().getName(), at.getMax().formatValue(), at.getMax().getName()));
                DOM.appendChild(missingList, li);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.setVisible(Gerrit.isSignedIn() && change.getStatus().isOpen());
}
#method_after
void display(ChangeDetail detail) {
    reviewerSuggestOracle.setProject(detail.getChange().getProject());
    List<String> columns = new ArrayList<String>();
    List<ApprovalDetail> rows = detail.getApprovals();
    changeId = detail.getChange().getId();
    final Element missingList = missing.getElement();
    while (DOM.getChildCount(missingList) > 0) {
        DOM.removeChild(missingList, DOM.getChild(missingList, 0));
    }
    missing.setVisible(false);
    if (detail.getSubmitRecords() != null) {
        HashSet<String> reportedMissing = new HashSet<String>();
        HashMap<Account.Id, ApprovalDetail> byUser = new HashMap<Account.Id, ApprovalDetail>();
        for (ApprovalDetail ad : detail.getApprovals()) {
            byUser.put(ad.getAccount(), ad);
        }
        for (SubmitRecord rec : detail.getSubmitRecords()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label lbl : rec.labels) {
                if (!columns.contains(lbl.label)) {
                    columns.add(lbl.label);
                }
                switch(lbl.status) {
                    case OK:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.approved(lbl.label);
                            }
                            break;
                        }
                    case REJECT:
                        {
                            ApprovalDetail ad = byUser.get(lbl.appliedBy);
                            if (ad != null) {
                                ad.rejected(lbl.label);
                            }
                            break;
                        }
                    case NEED:
                    case IMPOSSIBLE:
                        if (reportedMissing.add(lbl.label)) {
                            Element li = DOM.createElement("li");
                            li.setClassName(Gerrit.RESOURCES.css().missingApproval());
                            DOM.setInnerText(li, Util.M.needApproval(lbl.label));
                            DOM.appendChild(missingList, li);
                        }
                        break;
                }
            }
        }
        missing.setVisible(!reportedMissing.isEmpty());
    } else {
        for (ApprovalDetail ad : rows) {
            for (PatchSetApproval psa : ad.getPatchSetApprovals()) {
                ApprovalType legacyType = types.byId(psa.getCategoryId());
                if (legacyType == null) {
                    continue;
                }
                String labelName = legacyType.getCategory().getLabelName();
                if (psa.getValue() == legacyType.getMax().getValue()) {
                    ad.approved(labelName);
                } else if (psa.getValue() == legacyType.getMin().getValue()) {
                    ad.rejected(labelName);
                }
                if (!columns.contains(labelName)) {
                    columns.add(labelName);
                }
            }
            Collections.sort(columns, new Comparator<String>() {

                @Override
                public int compare(String o1, String o2) {
                    ApprovalType a = types.byLabel(o1);
                    ApprovalType b = types.byLabel(o2);
                    int cmp = 0;
                    if (a != null && b != null) {
                        cmp = a.getCategory().getPosition() - b.getCategory().getPosition();
                    }
                    if (cmp == 0) {
                        cmp = o1.compareTo(o2);
                    }
                    return cmp;
                }
            });
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        displayHeader(columns);
        table.resizeRows(1 + rows.size());
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i), detail.getChange(), columns);
        }
        table.setVisible(true);
    }
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void doAddReviewer() {
    final String userNameOrEmailOrGroupName = addMemberBox.getText();
    if (userNameOrEmailOrGroupName.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(userNameOrEmailOrGroupName);
    addReviewers(reviewers, false);
}
#method_after
private void doAddReviewer() {
    final String reviewer = addMemberBox.getText();
    if (reviewer.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(reviewer);
    addReviewers(reviewers, false);
}
#end_block

#method_before
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail.getChange(), changeDetail.getMissingApprovals(), changeDetail.getApprovals());
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case ACCOUNT_OR_GROUP_NOT_FOUND:
                            r.append(Util.M.accountOrGroupNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                StringBuilder message = new StringBuilder();
                                message.append("<b>");
                                message.append(Util.M.groupManyMembersConfirmation(e.getName(), result.getMemberCount()));
                                message.append("</b>");
                                ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                                    @Override
                                    public void onOk() {
                                        addReviewers(reviewers, true);
                                    }
                                });
                                confirmationDialog.center();
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void addReviewers(final List<String> reviewers, final boolean confirmed) {
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, confirmed, new GerritCallback<ReviewerResult>() {

        public void onSuccess(final ReviewerResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
            final ChangeDetail changeDetail = result.getChange();
            if (changeDetail != null) {
                setAccountInfoCache(changeDetail.getAccounts());
                display(changeDetail);
            }
            if (!result.getErrors().isEmpty()) {
                final SafeHtmlBuilder r = new SafeHtmlBuilder();
                for (final ReviewerResult.Error e : result.getErrors()) {
                    switch(e.getType()) {
                        case REVIEWER_NOT_FOUND:
                            r.append(Util.M.reviewerNotFound(e.getName()));
                            break;
                        case ACCOUNT_INACTIVE:
                            r.append(Util.M.accountInactive(e.getName()));
                            break;
                        case CHANGE_NOT_VISIBLE:
                            r.append(Util.M.changeNotVisibleTo(e.getName()));
                            break;
                        case GROUP_EMPTY:
                            r.append(Util.M.groupIsEmpty(e.getName()));
                            break;
                        case GROUP_HAS_TOO_MANY_MEMBERS:
                            if (result.askForConfirmation() && !confirmed) {
                                askForConfirmation(e.getName(), result.getMemberCount());
                                return;
                            } else {
                                r.append(Util.M.groupHasTooManyMembers(e.getName()));
                            }
                            break;
                        case GROUP_NOT_ALLOWED:
                            r.append(Util.M.groupIsNotAllowed(e.getName()));
                            break;
                        default:
                            r.append(e.getName());
                            r.append(" - ");
                            r.append(e.getType());
                            r.br();
                            break;
                    }
                }
                new ErrorDialog(r).center();
            }
        }

        private void askForConfirmation(final String groupName, final int memberCount) {
            final StringBuilder message = new StringBuilder();
            message.append("<b>");
            message.append(Util.M.groupManyMembersConfirmation(groupName, memberCount));
            message.append("</b>");
            final ConfirmationDialog confirmationDialog = new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new HTML(message.toString()), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewers(reviewers, true);
                }
            });
            confirmationDialog.center();
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void displayRow(final int row, final ApprovalDetail ad, final Change change) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> am = ad.getApprovalMap();
    final StringBuilder hint = new StringBuilder();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (final ApprovalType type : types) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        final PatchSetApproval ca = am.get(type.getCategory().getId());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
            col++;
            continue;
        }
        final ApprovalCategoryValue acv = type.getValue(ca);
        if (acv != null) {
            if (hint.length() > 0) {
                hint.append("; ");
            }
            hint.append(acv.getName());
        }
        if (type.isMaxNegative(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (type.isMaxPositive(ca)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    table.setText(row, col, hint.toString());
    fmt.setStyleName(row, col, Gerrit.RESOURCES.css().rightmost());
    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().approvalhint());
    col++;
}
#method_after
private void displayRow(final int row, final ApprovalDetail ad, final Change change, List<String> columns) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, link(ad.getAccount()));
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(// 
        Util.M.removeReviewer(FormatUtil.name(accountCache.get(ad.getAccount()))));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : columns) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            ApprovalType legacyType = types.byLabel(labelName);
            if (legacyType == null) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            PatchSetApproval ca = ad.getPatchSetApproval(legacyType.getCategory().getId());
            if (ca == null || ca.getValue() == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ca.getValue());
            if (ca.getValue() > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r.getChange(), r.getMissingApprovals(), r.getApprovals());
            } else {
                new ErrorDialog(result.getErrors().get(0).toString()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doRemove(final ApprovalDetail ad, final PushButton remove) {
    remove.setEnabled(false);
    PatchUtil.DETAIL_SVC.removeReviewer(changeId, ad.getAccount(), new GerritCallback<ReviewerResult>() {

        @Override
        public void onSuccess(ReviewerResult result) {
            if (result.getErrors().isEmpty()) {
                final ChangeDetail r = result.getChange();
                display(r);
            } else {
                final ReviewerResult.Error resultError = result.getErrors().get(0);
                String message;
                switch(resultError.getType()) {
                    case REMOVE_NOT_PERMITTED:
                        message = Util.C.approvalTableRemoveNotPermitted();
                        break;
                    case COULD_NOT_REMOVE:
                    default:
                        message = Util.C.approvalTableCouldNotRemove();
                }
                new ErrorDialog(message + " " + resultError.getName()).center();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            remove.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.areg2 = arg2;
    engine.areg3 = arg3;
    engine.areg4 = arg4;
    engine.cont = cont;
    engine.setB0();
    Term a1 = arg1.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity author = psInfo.getAuthor();
    PatchListCache plCache = env.getInjector().getInstance(PatchListCache.class);
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey projectKey = change.getProject();
    ObjectId a = null;
    ObjectId b = ObjectId.fromString(psInfo.getRevId());
    Whitespace ws = Whitespace.IGNORE_NONE;
    PatchListKey plKey = new PatchListKey(projectKey, a, b, ws);
    // make a modifiable copy of the patches list
    List<PatchListEntry> patches = new ArrayList<PatchListEntry>();
    PatchList pl = plCache.get(plKey);
    for (PatchListEntry entry : pl.getPatches()) {
        patches.add(entry);
    }
    engine.areg1 = arg1;
    engine.areg5 = new JavaObjectTerm(patches);
    return commit_delta_4_top;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.cont = cont;
    engine.setB0();
    Term a1 = arg1.dereference();
    if (a1.isVariable()) {
        throw new PInstantiationException(this, 1);
    }
    if (!a1.isSymbol()) {
        throw new IllegalTypeException(this, 1, "symbol", a1);
    }
    Pattern regex = Pattern.compile(a1.name());
    engine.areg1 = new JavaObjectTerm(regex);
    engine.areg2 = arg2;
    engine.areg3 = arg3;
    engine.areg4 = arg4;
    PrologEnvironment env = (PrologEnvironment) engine.control;
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(env);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    PatchListCache plCache = env.getInjector().getInstance(PatchListCache.class);
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey projectKey = change.getProject();
    ObjectId a = null;
    ObjectId b = ObjectId.fromString(psInfo.getRevId());
    Whitespace ws = Whitespace.IGNORE_NONE;
    PatchListKey plKey = new PatchListKey(projectKey, a, b, ws);
    PatchList pl = plCache.get(plKey);
    Iterator<PatchListEntry> iter = pl.getPatches().iterator();
    engine.areg5 = new JavaObjectTerm(iter);
    return engine.jtry5(commit_delta_check, commit_delta_next);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    a1.dereference();
    a2.dereference();
    a3.dereference();
    a4.dereference();
    a5.dereference();
    String regex = a1.toString();
    List<PatchListEntry> patches = (List<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (!patches.isEmpty()) {
        PatchListEntry patch = patches.get(0);
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if ((oldName != null && oldName.matches(regex)) || newName.matches(regex)) {
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm changeSym = SymbolTerm.intern(changeType.toString());
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) {
    Term a1 = engine.areg1;
    Term a2 = engine.areg2;
    Term a3 = engine.areg3;
    Term a4 = engine.areg4;
    Term a5 = engine.areg5;
    Pattern regex = (Pattern) ((JavaObjectTerm) a1).object();
    Iterator<PatchListEntry> iter = (Iterator<PatchListEntry>) ((JavaObjectTerm) a5).object();
    if (iter.hasNext()) {
        PatchListEntry patch = iter.next();
        String newName = patch.getNewName();
        String oldName = patch.getOldName();
        Patch.ChangeType changeType = patch.getChangeType();
        if (regex.matcher(newName).matches() || (oldName != null && regex.matcher(oldName).matches())) {
            SymbolTerm changeSym = getTypeSymbol(changeType);
            SymbolTerm newSym = SymbolTerm.create(newName);
            SymbolTerm oldSym = Prolog.Nil;
            if (oldName != null) {
                oldSym = SymbolTerm.create(oldName);
            }
            if (!a2.unify(changeSym, engine.trail)) {
                return engine.fail();
            }
            if (!a3.unify(newSym, engine.trail)) {
                return engine.fail();
            }
            if (!a4.unify(oldSym, engine.trail)) {
                return engine.fail();
            }
            return engine.cont;
        }
    }
    return engine.fail();
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) {
    return engine.trust(commit_delta_modify);
}
#method_after
@Override
public Operation exec(Prolog engine) {
    return engine.trust(commit_delta_empty);
}
#end_block

#method_before
public PatchSet.Id getPatchSetId() {
    return psId;
}
#method_after
public PatchSet.Id getPatchSetId() {
    return patchSetId;
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(db, pc, meta, true, this.tagCache).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> generateUpdates(final Transport tn) throws IOException {
    final ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = db.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!mirror) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<String, Ref>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        final ReviewDb meta;
        try {
            meta = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, db, pc, meta, true).filter(local);
        } finally {
            meta.close();
        }
    }
    final List<RemoteRefUpdate> cmds = new ArrayList<RemoteRefUpdate>();
    if (mirror) {
        final Map<String, Ref> remote = listRemote(tn);
        for (final Ref src : local.values()) {
            final RefSpec spec = matchSrc(src.getName());
            if (spec != null) {
                final Ref dst = remote.get(spec.getDestination());
                if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                    // Doesn't exist yet, or isn't the same value, request to push.
                    // 
                    send(cmds, spec, src);
                }
            }
        }
        for (final Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                final RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    // 
                    delete(cmds, spec);
                }
            }
        }
    } else {
        for (final String src : delta) {
            final RefSpec spec = matchSrc(src);
            if (spec != null) {
                // If the ref still exists locally, send it, otherwise delete it.
                // 
                Ref srcRef = local.get(src);
                if (srcRef != null) {
                    send(cmds, spec, srcRef);
                } else {
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(GitTagCacheImpl.module());
    install(RegExpCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(TagCache.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            if (isHead(c)) {
                switch(c.getType()) {
                    case CREATE:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                }
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#method_after
@Override
public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (!c.getRefName().startsWith(NEW_CHANGE)) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        rp.sendMessage("");
        rp.sendMessage("New Changes:");
        for (final Change.Id c : allNewChanges) {
            rp.sendMessage("  " + url + c.get());
        }
        rp.sendMessage("");
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
    // Let the core receive process handle it
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        evictTagCache(cmd);
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
    // Let the core receive process handle it
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD);
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = cmd.getRefName().substring(NEW_CHANGE.length());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        reject(cmd);
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevFlag SIDE_NEW = walk.newFlag("NEW");
        final RevFlag SIDE_HAVE = walk.newFlag("HAVE");
        final RevFlagSet COMMON = new RevFlagSet();
        COMMON.add(SIDE_NEW);
        COMMON.add(SIDE_HAVE);
        walk.carry(COMMON);
        walk.reset();
        walk.sort(RevSort.TOPO);
        walk.sort(RevSort.REVERSE, true);
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        tip.add(SIDE_NEW);
        walk.markStart(tip);
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        h.add(SIDE_HAVE);
        walk.markStart(h);
        boolean isConnected = false;
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (c.hasAll(COMMON)) {
                isConnected = true;
                break;
            }
        }
        if (!isConnected) {
            reject(newChange, "no common ancestry");
            return;
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    warnMalformedMessage(c);
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    final List<FooterLine> footerLines = c.getFooterLines();
    for (final FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final ChangeControl changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(request.cmd, "cannot replace " + request.ontoChange);
        return null;
    }
    if (!validCommit(changeCtl.getRefControl(), request.cmd, c)) {
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(c.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                final boolean authorEq = authorEqual(c, prior);
                if (messageEq && parentsEq && authorEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(c).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    rp.sendMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(result.change, ps);
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            // 
            deferredTags.add(ref);
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        Map<Ref, List<Ref>> reachableTags = tagCache.get(db);
        for (Ref tag : reachableTags.keySet()) {
            for (Ref ref : reachableTags.get(tag)) {
                if (projectCtl.controlForRef(ref.getName()).isVisible()) {
                    result.put(tag.getName(), tag);
                    break;
                }
            }
        }
    }
    return result;
}
#method_after
@Override
public Map<String, Ref> filter(Map<String, Ref> refs) {
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // 
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && !result.isEmpty()) {
        TagMatcher tags = tagCache.get(projectName).matcher(db, result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get(), true, tagCache));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get(), true, tagCache));
    }
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(tagCache, repo, pc, db.get(), true));
    }
    return up;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey name = change.getProject();
    if (!a1.unify(SymbolTerm.intern(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Project.NameKey name = change.getProject();
    if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Term topicTerm = Prolog.Nil;
    Change change = StoredValues.CHANGE.get(engine);
    String topic = change.getTopic();
    if (topic != null) {
        topicTerm = SymbolTerm.intern(topic);
    }
    if (!a1.unify(topicTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Term topicTerm = Prolog.Nil;
    Change change = StoredValues.CHANGE.get(engine);
    String topic = change.getTopic();
    if (topic != null) {
        topicTerm = SymbolTerm.create(topic);
    }
    if (!a1.unify(topicTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Branch.NameKey name = change.getDest();
    if (!a1.unify(SymbolTerm.intern(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    Change change = StoredValues.CHANGE.get(engine);
    Branch.NameKey name = change.getDest();
    if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Term a3 = arg3.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    final PatchSet.Id id = StoredValues.PATCH_SET_ID.get(engine);
    PatchSetInfoFactory psiFactory = env.getInjector().getInstance(PatchSetInfoFactory.class);
    Term idTerm;
    Term nameTerm = Prolog.Nil;
    Term emailTerm = Prolog.Nil;
    try {
        UserIdentity author = psiFactory.get(id).getAuthor();
        Account.Id authorId = author.getAccount();
        if (authorId == null) {
            idTerm = SymbolTerm.intern("anonymous");
        } else {
            idTerm = new IntegerTerm(authorId.get());
        }
        String name = author.getName();
        if (name != null && !name.equals("")) {
            nameTerm = SymbolTerm.intern(name);
        }
        String email = author.getEmail();
        if (email != null && !email.equals("")) {
            emailTerm = SymbolTerm.intern(email);
        }
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    if (!a1.unify(new StructureTerm(user, idTerm), engine.trail)) {
        return engine.fail();
    }
    if (!a2.unify(nameTerm, engine.trail)) {
        return engine.fail();
    }
    if (!a3.unify(emailTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(engine);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity author = psInfo.getAuthor();
    return exec(engine, author);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Term a3 = arg3.dereference();
    PrologEnvironment env = (PrologEnvironment) engine.control;
    final PatchSet.Id id = StoredValues.PATCH_SET_ID.get(engine);
    PatchSetInfoFactory psiFactory = env.getInjector().getInstance(PatchSetInfoFactory.class);
    Term idTerm;
    Term nameTerm = Prolog.Nil;
    Term emailTerm = Prolog.Nil;
    try {
        UserIdentity committer = psiFactory.get(id).getCommitter();
        Account.Id committerId = committer.getAccount();
        if (committerId == null) {
            idTerm = SymbolTerm.intern("anonymous");
        } else {
            idTerm = new IntegerTerm(committerId.get());
        }
        String name = committer.getName();
        if (name != null && !name.equals("")) {
            nameTerm = SymbolTerm.intern(name);
        }
        String email = committer.getEmail();
        if (email != null && !email.equals("")) {
            emailTerm = SymbolTerm.intern(email);
        }
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    if (!a1.unify(new StructureTerm(user, idTerm), engine.trail)) {
        return engine.fail();
    }
    if (!a2.unify(nameTerm, engine.trail)) {
        return engine.fail();
    }
    if (!a3.unify(emailTerm, engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    PatchSetInfo psInfo;
    try {
        psInfo = getPatchSetInfo(engine);
    } catch (PatchSetInfoNotAvailableException err) {
        throw new JavaException(this, 1, err);
    }
    UserIdentity committer = psInfo.getCommitter();
    return exec(engine, committer);
}
#end_block

#method_before
private File local(final HttpServletRequest req) {
    final String name = req.getPathInfo();
    if (name.length() < 2 || !name.startsWith("/")) {
        // 
        return null;
    }
    final File p = new File(staticBase, name.substring(1));
    // Ensure that the requested file is *actually* within the static dir base.
    try {
        if (!p.getCanonicalFile().getPath().startsWith(staticBase.getPath() + File.separator))
            return null;
    } catch (IOException e) {
        return null;
    }
    return p.isFile() ? p : null;
}
#method_after
private File local(final HttpServletRequest req) {
    final String name = req.getPathInfo();
    if (name.length() < 2 || !name.startsWith("/") || isUnreasonableName(name)) {
        // 
        return null;
    }
    final File p = new File(staticBase, name.substring(1));
    // Ensure that the requested file is *actually* within the static dir base.
    try {
        if (!p.getCanonicalFile().getPath().startsWith(staticBasePath))
            return null;
    } catch (IOException e) {
        return null;
    }
    return p.isFile() ? p : null;
}
#end_block

#method_before
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            parseCommandLine();
            boolean ok = true;
            for (final Change.Id changeId : changeIds) {
                try {
                    ok = ok && modifyOne(changeId);
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while modifying reviewers in " + changeId + "\n");
                    log.error("internal error while modifying reviewers in " + changeId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more modifications of reviewers failed; review output above");
            }
        }
    });
}
#method_after
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            parseCommandLine();
            boolean ok = true;
            for (Change.Id changeId : changes) {
                try {
                    ok &= modifyOne(changeId);
                } catch (Exception err) {
                    ok = false;
                    log.error("Error updating reviewers on change " + changeId, err);
                    writeError("fatal", "internal error while updating " + changeId);
                }
            }
            if (!ok) {
                throw error("fatal: one or more updates failed; review output above");
            }
        }
    });
}
#end_block

#method_before
private boolean modifyOne(final Change.Id changeId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException, Exception {
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    boolean ok = true;
    for (final Account.Id accountId : reviewersToRemove) {
        final ReviewerResult result = removeReviewerFactory.create(changeId, accountId).call();
        for (ReviewerResult.Error resultError : result.getErrors()) {
            // sensitive information that we do not want to reveal to the user.
            if (resultError.getType() == ReviewerResult.Error.Type.COULD_NOT_REMOVE) {
                // For COULD_NOT_REMOVE, getName() contains the specific error
                // message with an id at the end
                final String message = resultError.getName();
                String regex = accountId + "$";
                if (message.matches("^.* " + regex)) {
                    writeError("error: " + message.replaceAll(regex, "\"" + allReviewers.get(accountId)) + "\"\n");
                } else {
                    writeError("error: " + "\"" + allReviewers.get(accountId) + "\" could not be removed\n");
                }
                ok = false;
            }
        }
    }
    final ReviewerResult result = addReviewerFactory.create(changeId, reviewersToAdd).call();
    // user and we have checked for this when we parsed the arguments.
    for (ReviewerResult.Error resultError : result.getErrors()) {
        ok = false;
        writeError("\"" + resultError.getName() + "\" could not be added\n");
    }
    return ok;
}
#method_after
private boolean modifyOne(Change.Id changeId) throws Exception {
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    ReviewerResult result;
    boolean ok = true;
    // Remove reviewers
    // 
    result = removeReviewerFactory.create(changeId, toRemove).call();
    ok &= result.getErrors().isEmpty();
    for (ReviewerResult.Error resultError : result.getErrors()) {
        String message;
        switch(resultError.getType()) {
            case REMOVE_NOT_PERMITTED:
                message = "not permitted to remove {0} from {1}";
                break;
            case COULD_NOT_REMOVE:
                message = "could not remove {0} from {1}";
                break;
            default:
                message = "could not remove {0}: {2}";
        }
        writeError("error", MessageFormat.format(message, resultError.getName(), changeId, resultError.getType()));
    }
    // Add reviewers
    // 
    result = addReviewerFactory.create(changeId, stringSet(toAdd)).call();
    ok &= result.getErrors().isEmpty();
    for (ReviewerResult.Error resultError : result.getErrors()) {
        String message;
        switch(resultError.getType()) {
            case ACCOUNT_NOT_FOUND:
                message = "account {0} not found";
                break;
            case ACCOUNT_INACTIVE:
                message = "account {0} inactive";
                break;
            case CHANGE_NOT_VISIBLE:
                message = "change {1} not visible to {0}";
                break;
            default:
                message = "could not add {0}: {2}";
        }
        writeError("error", MessageFormat.format(message, resultError.getName(), changeId, resultError.getType()));
    }
    return ok;
}
#end_block

#method_before
private Set<Change.Id> parseChangeId(final String changeIdentity) throws UnloggedFailure, OrmException {
    final Set<Change.Id> matches = new HashSet<Change.Id>();
    boolean foundInOtherProject = false;
    boolean matchesChangeKey = changeIdentity.matches("^I[0-9a-fA-F]*$");
    boolean matchesChangeId = changeIdentity.matches("^[1-9][0-9]*$");
    // By newer style changeKey?
    // 
    boolean changeKeyParses = matchesChangeKey;
    if (matchesChangeKey) {
        Change.Key changeKey = null;
        try {
            changeKey = Change.Key.parse(changeIdentity);
        } catch (IllegalArgumentException e) {
            changeKeyParses = false;
        }
        if (changeKeyParses) {
            final ResultSet<Change> changes = db.changes().byKeyRange(changeKey, changeKey.max());
            for (final Change change : changes) {
                if (inProject(change)) {
                    matches.add(change.getId());
                } else {
                    foundInOtherProject = true;
                }
            }
        }
    }
    // By older style changeId?
    // 
    boolean changeIdParses = matchesChangeId;
    if (matchesChangeId) {
        Change.Id changeId = null;
        try {
            changeId = Change.Id.parse(changeIdentity);
        } catch (IllegalArgumentException e) {
            changeIdParses = false;
        }
        if (changeIdParses) {
            final Change change = db.changes().get(changeId);
            if (change != null) {
                if (inProject(change)) {
                    matches.add(change.getId());
                } else {
                    foundInOtherProject = true;
                }
            }
        }
    }
    if (!changeKeyParses && !changeIdParses) {
        throw error("\"" + changeIdentity + "\" is not a valid change");
    }
    switch(matches.size()) {
        case 1:
            return matches;
        case 0:
            if (foundInOtherProject) {
                throw error("change " + changeIdentity + " not in project " + projectControl.getProject().getName());
            }
            throw error("\"" + changeIdentity + "\" no such change");
        default:
    }
    throw error("\"" + changeIdentity + "\" matches multiple changes");
}
#method_after
private Set<Change.Id> parseChangeId(String idstr) throws UnloggedFailure, OrmException {
    Set<Change.Id> matched = new HashSet<Change.Id>(4);
    boolean isCommit = idstr.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$");
    // By newer style changeKey?
    // 
    boolean changeKeyParses = false;
    if (idstr.matches("^I[0-9a-fA-F]*$")) {
        Change.Key key;
        try {
            key = Change.Key.parse(idstr);
            changeKeyParses = true;
        } catch (IllegalArgumentException e) {
            key = null;
            changeKeyParses = false;
        }
        if (changeKeyParses) {
            for (Change change : db.changes().byKeyRange(key, key.max())) {
                matchChange(matched, change);
            }
        }
    }
    // 
    if (isCommit) {
        RevId id = new RevId(idstr);
        ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet ps : patches) {
            matchChange(matched, ps.getId().getParentKey());
        }
    }
    // By older style changeId?
    // 
    boolean changeIdParses = false;
    if (idstr.matches("^[1-9][0-9]*$")) {
        Change.Id id;
        try {
            id = Change.Id.parse(idstr);
            changeIdParses = true;
        } catch (IllegalArgumentException e) {
            id = null;
            changeIdParses = false;
        }
        if (changeIdParses) {
            matchChange(matched, id);
        }
    }
    if (!changeKeyParses && !isCommit && !changeIdParses) {
        throw error("\"" + idstr + "\" is not a valid change");
    }
    switch(matched.size()) {
        case 0:
            throw error("\"" + idstr + "\" no such change");
        case 1:
            return matched;
        default:
            throw error("\"" + idstr + "\" matches multiple changes");
    }
}
#end_block

#method_before
private boolean inProject(final Change change) {
    if (projectControl == null) {
        // No --project option, so they want every project.
        return true;
    }
    return projectControl.getProject().getNameKey().equals(change.getProject());
}
#method_after
private boolean inProject(Change change) {
    if (projectControl != null) {
        return projectControl.getProject().getNameKey().equals(change.getProject());
    } else {
        // No --project option, so they want every project.
        return true;
    }
}
#end_block

#method_before
private void writeError(final String msg) {
    try {
        err.write(msg.getBytes(ENC));
    } catch (IOException e) {
    }
}
#method_after
private void writeError(String type, String msg) {
    try {
        err.write((type + ": " + msg + "\n").getBytes(ENC));
    } catch (IOException e) {
    }
}
#end_block

#method_before
private static UnloggedFailure error(final String msg) {
    return new UnloggedFailure(1, msg);
}
#method_after
private static UnloggedFailure error(String msg) {
    return new UnloggedFailure(1, msg);
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, final int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 2) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(idx + 1);
    m.closeAnchor();
    m.closeTd();
}
#method_after
private void appendLineNumber(final SafeHtmlBuilder m, final int idx) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(idx + 1);
    m.closeTd();
}
#end_block

#method_before
@Override
protected void onCellSingleClick(final int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#method_after
@Override
protected void onCellSingleClick(int row, int column) {
    if (column == 1 || column == 3) {
        onCellDoubleClick(row, column);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.openAnchor();
    m.append(lineNumberMinusOne + 1);
    m.closeAnchor();
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final int lineNumberMinusOne, final PatchLine.Type type, final SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) {
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().lineNumber());
    m.append(lineNumberMinusOne + 1);
    m.closeTd();
    m.openTd();
    m.addStyleName(Gerrit.RESOURCES.css().fileLine());
    switch(type) {
        case CONTEXT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT());
            break;
        case DELETE:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdd");
            }
            break;
        case INSERT:
            m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT());
            if (trailingEdit || fullBlock) {
                m.addStyleName("wdi");
            }
            break;
    }
    m.append(lineHtml);
    m.closeTd();
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    return envFactory.create(getClass().getClassLoader());
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    // TODO Replace this with a per-project ClassLoader to isolate rules.
    PrologEnvironment env = envFactory.create(getClass().getClassLoader());
    // consult rules.pl at refs/meta/config branch for custom submit rules
    String rules = getConfig().getPrologRules();
    if (rules != null) {
        PushbackReader in = new PushbackReader(new StringReader(rules), Prolog.PUSHBACK_SIZE);
        JavaObjectTerm streamObject = new JavaObjectTerm(in);
        if (!env.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.makeSymbol("rules.pl"), streamObject)) {
            throw new CompileException("Cannot consult rules.pl " + getProject().getName() + " " + getConfig().getRevision());
        }
    }
    return env;
}
#end_block

#method_before
public boolean canRestore() {
    // Anyone who can abandon the change can restore it
    return canAbandon();
// back
}
#method_after
public boolean canRestore() {
    // Anyone who can abandon the change can restore it back
    return canAbandon();
}
#end_block

#method_before
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env = getProjectControl().getProjectState().newPrologEnvironment();
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    StructureTerm submitRule = SymbolTerm.makeSymbol("com.google.gerrit.rules.common", "default_submit", 1);
    ObjectStream ruleStream = getProjectControl().getProjectState().getPrologRules();
    if (ruleStream != null) {
        try {
            PushbackReader in = new PushbackReader(new InputStreamReader(ruleStream, Charset.forName("UTF-8")), Prolog.PUSHBACK_SIZE);
            JavaObjectTerm streamObject = new JavaObjectTerm(in);
            if (!env.execute(Prolog.BUILTIN, "consultStream", SymbolTerm.makeSymbol("submitrules"), streamObject)) {
                throw new CompileException("Cannot consult" + streamObject.toString());
            }
            // Replaces default_submit predicate with the submit_rule predicate in
            // the refs/meta/config:submit_rules.pl (if it exists)
            submitRule = SymbolTerm.makeSymbol("user", "submit_rule", 1);
        } catch (CompileException err) {
            log.error("Cannot consult provided submit_rules.pl", err);
        } finally {
            try {
                ruleStream.close();
            } catch (IOException err) {
                log.error("Close of ruleStream failed", err);
            }
        }
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#method_after
public CanSubmitResult canSubmit(ReviewDb db, PatchSet.Id patchSetId) {
    CanSubmitResult result = canSubmit(patchSetId);
    if (result != CanSubmitResult.OK) {
        return result;
    }
    PrologEnvironment env;
    try {
        env = getProjectControl().getProjectState().newPrologEnvironment();
    } catch (CompileException err) {
        log.error("cannot consult rules.pl", err);
        return new CanSubmitResult("Error reading submit rule");
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE, change);
    env.set(StoredValues.PATCH_SET_ID, patchSetId);
    env.set(StoredValues.CHANGE_CONTROL, this);
    Term submitRule = env.once("com.google.gerrit.rules.common", "locate_submit_rule", new VariableTerm());
    if (submitRule == null) {
        log.error("Error in locate_submit_rule: no submit_rule found");
        return new CanSubmitResult("Error in finding submit rule");
    }
    List<Term> results = new ArrayList<Term>();
    try {
        for (Term[] template : env.all("com.google.gerrit.rules.common", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
    } catch (PrologException err) {
        log.error("PrologException calling " + submitRule, err);
        return new CanSubmitResult("Error in submit rule");
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule has no solution: " + submitRule);
        return new CanSubmitResult("Error in submit rule (no solution possible)");
    }
    // The last result produced will be an "ok(P)" format if submit is possible.
    // This is always true because can_submit (called above) will cut away all
    // choice points once a solution is found.
    Term last = results.get(results.size() - 1);
    if (last.isStructure() && 1 == last.arity() && "ok".equals(last.name())) {
        Term solution = last.arg(0);
        return CanSubmitResult.OK;
    }
    // For now only process the first result. Later we can examine all of the
    // results and proposes different alternative paths to a submit solution.
    Term first = results.get(0);
    if (!first.isStructure() || 1 != first.arity() || !"not_ready".equals(first.name())) {
        log.error("Unexpected result from can_submit: " + first);
        return new CanSubmitResult("Error in submit rule");
    }
    Term submitRecord = first.arg(0);
    if (!submitRecord.isStructure()) {
        log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
        return new CanSubmitResult("Error in submit rule");
    }
    for (Term state : ((StructureTerm) submitRecord).args()) {
        if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
            log.error("Invalid result from submit rule " + submitRule + ": " + submitRecord);
            return new CanSubmitResult("Invalid submit rule result");
        }
        String label = state.arg(0).name();
        Term status = state.arg(1);
        if ("ok".equals(status.name())) {
            continue;
        } else if ("reject".equals(status.name())) {
            return new CanSubmitResult("Submit blocked by " + label);
        } else if ("need".equals(status.name())) {
            if (status.isStructure() && status.arg(0).isInteger()) {
                IntegerTerm val = (IntegerTerm) status.arg(0);
                if (1 < val.intValue()) {
                    label += "+" + val.intValue();
                }
            }
            return new CanSubmitResult("Requires " + label);
        } else if ("impossble".equals(status.name())) {
            return new CanSubmitResult("Requires " + label + " (check permissions)");
        } else {
            return new CanSubmitResult("Invalid submit rule result");
        }
    }
    return CanSubmitResult.OK;
}
#end_block

#method_before
void create(List<CodeReviewCommit> commits, PersonIdent author) throws MergeException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new MergeException("Couldn't create code review notes. Failed to lock the ref: " + REFS_NOTES_SUBMITTED);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                // TODO: NoteMapMerger.merge(base, ours,
                NoteMap merged = null;
                // theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new MergeException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new MergeException("Couldn't create code review notes", e);
    } catch (InterruptedException e) {
        throw new MergeException("Couldn't create code review notes", e);
    }
}
#method_after
public void create(List<CodeReviewCommit> commits, PersonIdent author) throws CodeReviewNoteCreationException {
    try {
        this.commits = commits;
        this.author = author;
        setBase();
        setOurs();
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        RefUpdate refUpdate = createRefUpdate(oursCommit, baseCommit);
        for (; ; ) {
            Result result = refUpdate.update();
            if (result == Result.LOCK_FAILURE) {
                if (--remainingLockFailureCalls > 0) {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } else {
                    throw new CodeReviewNoteCreationException("Failed to lock the ref: " + REFS_NOTES_REVIEW);
                }
            } else if (result == Result.REJECTED) {
                RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
                NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
                NoteMapMerger merger = new NoteMapMerger(db);
                NoteMap merged = merger.merge(base, ours, theirs);
                RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
                refUpdate = createRefUpdate(mergeCommit, theirsCommit);
                remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
            } else if (result == Result.IO_FAILURE) {
                throw new CodeReviewNoteCreationException("Couldn't create code review notes because of IO_FAILURE");
            } else {
                break;
            }
        }
    } catch (IOException e) {
        throw new CodeReviewNoteCreationException(e);
    } catch (InterruptedException e) {
        throw new CodeReviewNoteCreationException(e);
    } finally {
        reader.release();
        inserter.release();
        revWalk.release();
    }
}
#end_block

#method_before
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_SUBMITTED);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#method_after
private void setBase() throws IOException {
    Ref notesBranch = db.getRef(REFS_NOTES_REVIEW);
    if (notesBranch != null) {
        baseCommit = revWalk.parseCommit(notesBranch.getObjectId());
        base = NoteMap.read(revWalk.getObjectReader(), baseCommit);
    }
}
#end_block

#method_before
private void setOurs() throws IOException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Submitted the following changes:");
    for (CodeReviewCommit c : commits) {
        if (ours.contains(c)) {
            throw new IllegalStateException("Review summary note already exists for commit: " + c + ". Merging of notes not yet supported");
        }
        ObjectId id = inserter.insert(Constants.OBJ_BLOB, createNoteContent(c));
        inserter.flush();
        RevBlob blob = revWalk.lookupBlob(id);
        ours.set(c, blob);
        message.append(" ");
        message.append(c.change.getId());
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#method_after
private void setOurs() throws IOException, CodeReviewNoteCreationException {
    if (baseCommit != null) {
        ours = NoteMap.read(db.newObjectReader(), baseCommit);
    } else {
        ours = NoteMap.newEmptyMap();
    }
    StringBuilder message = new StringBuilder("Update notes for submitted changes\n\n");
    for (CodeReviewCommit c : commits) {
        ObjectId noteContent = createNoteContent(c);
        if (ours.contains(c)) {
            // merge the existing and the new note as if they are both new
            // means: base == null
            // there is not really a common ancestry for these two note revisions
            // use the same NoteMerger that is used from the NoteMapMerger
            DefaultNoteMerger noteMerger = new DefaultNoteMerger();
            Note newNote = new Note(c, noteContent);
            noteContent = noteMerger.merge(null, newNote, base.getNote(c), reader, inserter).getData();
        }
        ours.set(c, noteContent);
        message.append("* ").append(c.getShortMessage()).append("\n");
    }
    if (baseCommit != null) {
        oursCommit = createCommit(ours, author, message.toString(), baseCommit);
    } else {
        oursCommit = createCommit(ours, author, message.toString());
    }
}
#end_block

#method_before
private byte[] createNoteContent(CodeReviewCommit commit) throws UnsupportedEncodingException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter();
        formatter.appendChangeId(commit.change.getId());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(schema.approvalCategories().get(a.getCategoryId()), a.getValue(), schema.accounts().get(a.getAccountId()));
            }
        }
        formatter.appendBranch(schema.projects().get(commit.change.getProject()), commit.change.getDest());
        formatter.appendSubmittedBy(schema.accounts().get(submit.getAccountId()));
        formatter.appendSubmittedOn(submit.getGranted());
        return formatter.toString().getBytes("UTF-8");
    } catch (OrmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
private ObjectId createNoteContent(CodeReviewCommit commit) throws CodeReviewNoteCreationException, IOException {
    try {
        ReviewNoteHeaderFormatter formatter = new ReviewNoteHeaderFormatter(author.getTimeZone());
        final List<String> idList = commit.getFooterLines(CHANGE_ID);
        if (idList.isEmpty())
            formatter.appendChangeId(commit.change.getKey());
        ResultSet<PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId);
        PatchSetApproval submit = null;
        for (PatchSetApproval a : approvals) {
            if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                submit = a;
            } else {
                formatter.appendApproval(approvalTypes.getApprovalType(a.getCategoryId()).getCategory(), a.getValue(), accountCache.get(a.getAccountId()).getAccount());
            }
        }
        formatter.appendSubmittedBy(accountCache.get(submit.getAccountId()).getAccount());
        formatter.appendSubmittedAt(submit.getGranted());
        formatter.appendReviewedOn(canonicalWebUrl, commit.change.getId());
        formatter.appendProject(commit.change.getProject().get());
        formatter.appendBranch(commit.change.getDest());
        return inserter.insert(Constants.OBJ_BLOB, formatter.toString().getBytes("UTF-8"));
    } catch (OrmException e) {
        throw new CodeReviewNoteCreationException(commit, e);
    }
}
#end_block

#method_before
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    ObjectInserter inserter = db.newObjectInserter();
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    return revWalk.parseCommit(inserter.insert(b));
}
#method_after
private RevCommit createCommit(NoteMap map, PersonIdent author, String message, RevCommit... parents) throws IOException {
    CommitBuilder b = new CommitBuilder();
    b.setTreeId(map.writeTree(inserter));
    b.setAuthor(author);
    b.setCommitter(gerritIdent);
    if (parents.length > 0) {
        b.setParentIds(parents);
    }
    b.setMessage(message);
    ObjectId commitId = inserter.insert(b);
    inserter.flush();
    return revWalk.parseCommit(commitId);
}
#end_block

#method_before
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_SUBMITTED);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#method_after
private RefUpdate createRefUpdate(ObjectId newObjectId, ObjectId expectedOldObjectId) throws IOException {
    RefUpdate refUpdate = db.updateRef(REFS_NOTES_REVIEW);
    refUpdate.setNewObjectId(newObjectId);
    if (expectedOldObjectId == null) {
        refUpdate.setExpectedOldObjectId(ObjectId.zeroId());
    } else {
        refUpdate.setExpectedOldObjectId(expectedOldObjectId);
    }
    return refUpdate;
}
#end_block

#method_before
private void openRepository() throws MergeException {
    final String name = destBranch.getParentKey().get();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#method_after
private void openRepository() throws MergeException {
    final Project.NameKey name = destBranch.getParentKey();
    try {
        db = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notGit) {
        final String m = "Repository \"" + name.get() + "\" unknown.";
        throw new MergeException(m, notGit);
    }
    rw = new RevWalk(db) {

        @Override
        protected RevCommit createCommit(final AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    CAN_MERGE = rw.newFlag("CAN_MERGE");
}
#end_block

#method_before
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = new CreateCodeReviewNotes(schema, db, myIdent);
    codeReviewNotes.create(merged, computeAuthor(merged));
}
#method_after
private void updateChangeStatus() throws MergeException {
    List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
                {
                    final String txt = "Change has been successfully merged into the git repository.";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case CLEAN_PICK:
                {
                    final String txt = "Change has been successfully cherry-picked as " + commit.name() + ".";
                    setMerged(c, message(c, txt));
                    merged.add(commit);
                    break;
                }
            case ALREADY_MERGED:
                setMerged(c, null);
                merged.add(commit);
                break;
            case PATH_CONFLICT:
                {
                    final String txt = "Your change could not be merged due to a path conflict.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CRISS_CROSS_MERGE:
                {
                    final String txt = "Your change requires a recursive merge to resolve.\n" + "\n" + "Please merge (or rebase) the change locally and upload the resolution for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case CANNOT_CHERRY_PICK_ROOT:
                {
                    final String txt = "Cannot cherry-pick an initial commit onto an existing branch.\n" + "\n" + "Please merge the change locally and upload the merge commit for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case NOT_FAST_FORWARD:
                {
                    final String txt = "Project policy requires all submissions to be a fast-forward.\n" + "\n" + "Please rebase the change locally and upload again for review.";
                    setNew(c, message(c, txt));
                    break;
                }
            case MISSING_DEPENDENCY:
                {
                    dependencyError(commit);
                    break;
                }
            default:
                setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                break;
        }
    }
    CreateCodeReviewNotes codeReviewNotes = codeReviewNotesFactory.create(db);
    try {
        codeReviewNotes.create(merged, computeAuthor(merged));
    } catch (CodeReviewNoteCreationException e) {
        log.error(e.getMessage());
    }
    replication.scheduleUpdate(destBranch.getParentKey(), CreateCodeReviewNotes.REFS_NOTES_REVIEW);
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
public void appendChangeId(Change.Id changeId) {
    sb.append("Change-Id: ").append(changeId).append("\n");
}
#method_after
void appendChangeId(Change.Key changeKey) {
    sb.append("Change-Id: ").append(changeKey.get()).append("\n");
}
#end_block

#method_before
public void appendApproval(ApprovalCategory category, short value, Account user) {
    sb.append(category.getName());
    sb.append(value < 0 ? "-" : "+").append(value).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendApproval(ApprovalCategory category, short value, Account user) {
    // TODO: use category.getLabel() when available
    sb.append(category.getName().replace(' ', '-'));
    sb.append(value < 0 ? "-" : "+").append(Math.abs(value)).append(": ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
private void appendUserData(Account user) {
    sb.append(user.getFullName()).append(" <").append(user.getPreferredEmail()).append(">");
}
#method_after
private void appendUserData(Account user) {
    boolean needSpace = false;
    boolean wroteData = false;
    if (user.getFullName() != null && !user.getFullName().isEmpty()) {
        sb.append(user.getFullName());
        needSpace = true;
        wroteData = true;
    }
    if (user.getPreferredEmail() != null && !user.getPreferredEmail().isEmpty()) {
        if (needSpace) {
            sb.append(" ");
        }
        sb.append("<").append(user.getPreferredEmail()).append(">");
        wroteData = true;
    }
    if (!wroteData) {
        sb.append("Anonymous Coward #").append(user.getId());
    }
}
#end_block

#method_before
public void appendBranch(Project project, Branch.NameKey branch) {
    sb.append("Branch: ").append(project.getName()).append(" ").append(branch.get()).append("\n");
}
#method_after
void appendBranch(Branch.NameKey branch) {
    sb.append("Branch: ").append(branch.get()).append("\n");
}
#end_block

#method_before
public void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#method_after
void appendSubmittedBy(Account user) {
    sb.append("Submitted-by: ");
    appendUserData(user);
    sb.append("\n");
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you [" + currentUser.getName() + " <" + currentUser.getEmailAddress() + ">]" + " are not author [" + author.getName() + " <" + author.getEmailAddress() + ">]");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you [" + currentUser.getName() + " <" + currentUser.getEmailAddress() + ">]" + " are not committer [" + committer.getName() + " <" + committer.getEmailAddress() + ">]");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        if (project.isRequireChangeID()) {
            reject(cmd, "missing Change-Id in commit message");
            return false;
        }
    } else if (idList.size() > 1) {
        reject(cmd, "multiple Change-Id lines in commit message");
        return false;
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initGroupNotifications();
    Label spacer = new Label("");
    spacer.setHeight("15px");
    add(spacer);
    initMemberList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initExternal();
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    onlyAuthors.setValue(group.isEmailOnlyAuthors());
    onlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
    visibleToAllCheckBox.setEnabled(true);
    emailOnlyAuthors.setValue(group.isEmailOnlyAuthors());
    emailOnlyAuthors.setEnabled(true);
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            members.display(result.members);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            display(result);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Util.GROUP_SVC.groupDetail(groupId, new ScreenLoadCallback<GroupDetail>(this) {

        @Override
        protected void preDisplay(final GroupDetail result) {
            enableForm(result.canModify);
            saveName.setVisible(result.canModify);
            saveOwner.setVisible(result.canModify);
            saveDesc.setVisible(result.canModify);
            saveGroupOptions.setVisible(result.canModify);
            delMember.setVisible(result.canModify);
            members.setEnabled(result.canModify);
            saveType.setVisible(result.canModify);
            display(result);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupType();
    initMemberList();
    initIncludedGroupList();
    initExternal();
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    initName();
    initOwner();
    initDescription();
    initGroupOptions();
    initGroupType();
    initMemberList();
    initIncludeList();
    initExternal();
}
#end_block

#method_before
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includedGroupPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#method_after
private void setType(final AccountGroup.Type newType) {
    final boolean system = newType == AccountGroup.Type.SYSTEM;
    typeSystem.setVisible(system);
    typeSelect.setVisible(!system);
    saveType.setVisible(!system);
    memberPanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    includePanel.setVisible(newType == AccountGroup.Type.INTERNAL);
    externalPanel.setVisible(newType == AccountGroup.Type.LDAP);
    externalNameFilter.setText(groupNameTxt.getText());
    if (!system) {
        for (int i = 0; i < typeSelect.getItemCount(); i++) {
            if (newType.name().equals(typeSelect.getValue(i))) {
                typeSelect.setSelectedIndex(i);
                break;
            }
        }
    }
    saveType.setEnabled(false);
}
#end_block

#method_before
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includedGroups.display(result.includedGroups);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
}
#method_after
private void display(final GroupDetail result) {
    final AccountGroup group = result.group;
    setPageTitle(Util.M.group(group.getName()));
    groupNameTxt.setText(group.getName());
    if (result.ownerGroup != null) {
        ownerTxt.setText(result.ownerGroup.getName());
    } else {
        ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get()));
    }
    descTxt.setText(group.getDescription());
    switch(group.getType()) {
        case INTERNAL:
            accounts = result.accounts;
            groups = result.groups;
            members.display(result.members);
            includes.display(result.includes);
            break;
        case LDAP:
            externalName.setText(group.getExternalNameKey() != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected());
            break;
    }
    setType(group.getType());
    visibleToAllCheckBox.setValue(group.isVisibleToAll());
}
#end_block

#method_before
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    table.setWidget(row, 1, new CheckBox());
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void populate(final int row, final AccountGroupMember k) {
    final Account.Id accountId = k.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountDashboardLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
public IdentifiedUser create(Provider<ReviewDb> db, Account.Id id) {
    return new IdentifiedUser(AccessPath.UNKNOWN, authConfig, canonicalUrl, realm, accountCache, null, db, id);
}
#method_after
public IdentifiedUser create(Provider<ReviewDb> db, Account.Id id) {
    return new IdentifiedUser(AccessPath.UNKNOWN, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, null, db, id);
}
#end_block

#method_before
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, null, id);
}
#method_after
public IdentifiedUser create(AccessPath accessPath, Provider<SocketAddress> remotePeerProvider, Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, remotePeerProvider, null, id);
}
#end_block

#method_before
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, dbProvider, id);
}
#method_after
public IdentifiedUser create(final AccessPath accessPath, final Account.Id id) {
    return new IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, groupIncludeCache, remotePeerProvider, dbProvider, id);
}
#end_block

#method_before
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        Set<AccountGroup.Id> seedGroups = new HashSet<AccountGroup.Id>();
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            seedGroups = realm.groups(state());
        } else {
            seedGroups = authConfig.getRegisteredGroups();
        }
        effectiveGroups = getIncludedGroups(seedGroups);
    }
    return effectiveGroups;
}
#method_after
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        Set<AccountGroup.Id> seedGroups;
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            seedGroups = realm.groups(state());
        } else {
            seedGroups = authConfig.getRegisteredGroups();
        }
        effectiveGroups = getIncludedGroups(seedGroups);
    }
    return effectiveGroups;
}
#end_block

#method_before
private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) {
    Set<AccountGroup.Id> includedGroups = new HashSet<AccountGroup.Id>(seedGroups);
    Queue<AccountGroup.Id> groupQueue = new LinkedList<AccountGroup.Id>(seedGroups);
    while (groupQueue.size() > 0) {
        AccountGroup.Id id = groupQueue.remove();
        try {
            for (final AccountGroupIncludedGroup i : dbProvider.get().accountGroupIncludedGroups().byIncludedGroup(id)) {
                AccountGroup.Id groupId = i.getGroupId();
                if (!includedGroups.contains(groupId)) {
                    includedGroups.add(groupId);
                    groupQueue.add(groupId);
                }
            }
        } catch (OrmException e) {
            log.warn("Cannot query included groups", e);
        }
    }
    return includedGroups;
}
#method_after
private Set<AccountGroup.Id> getIncludedGroups(Set<AccountGroup.Id> seedGroups) {
    Set<AccountGroup.Id> includes = new HashSet<AccountGroup.Id>(seedGroups);
    Queue<AccountGroup.Id> groupQueue = new LinkedList<AccountGroup.Id>(seedGroups);
    while (groupQueue.size() > 0) {
        AccountGroup.Id id = groupQueue.remove();
        for (final AccountGroup.Id groupId : groupIncludeCache.getByInclude(id)) {
            if (includes.add(groupId)) {
                groupQueue.add(groupId);
            }
        }
    }
    return Collections.unmodifiableSet(includes);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public boolean isVisible() {
    return isOwner();
}
#method_after
public boolean isVisible() {
    return group.isVisibleToAll() || isOwner();
}
#end_block

#method_before
public boolean canSeeMember(Account.Id id) {
    return isOwner();
}
#method_after
public boolean canSeeMember(Account.Id id) {
    return isVisible();
}
#end_block

#method_before
private void createGroup() throws OrmException, UnloggedFailure {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    try {
        performCreateGroup.createGroup(groupName, groupDescription, ownerGroupId, initialMembers.toArray(new Account.Id[initialMembers.size()]), initialIncludedGroups.toArray(new AccountGroup.Id[initialIncludedGroups.size()]));
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#method_after
private void createGroup() throws OrmException, UnloggedFailure {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    try {
        performCreateGroup.createGroup(groupName, groupDescription, visibleToAll, ownerGroupId, initialMembers, initialGroups);
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
public AccountGroup.Id call() throws OrmException, NameAlreadyUsedException {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    final Account.Id me = user.getAccountId();
    return performCreateGroup.createGroup(groupName, null, null, new Account.Id[] { me }, null);
}
#method_after
@Override
public AccountGroup.Id call() throws OrmException, NameAlreadyUsedException {
    final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create();
    final Account.Id me = user.getAccountId();
    return performCreateGroup.createGroup(groupName, null, false, null, Collections.singleton(me), null);
}
#end_block

#method_before
private AccountGroup findGroup(final String name) throws OrmException, Failure {
    final AccountGroup g = groupCache.get(new AccountGroup.NameKey(name));
    if (g == null) {
        throw new Failure(new NoSuchEntityException());
    }
    return g;
}
#method_after
private AccountGroup findGroup(final String name) throws OrmException, Failure {
    final AccountGroup g = groupCache.get(new AccountGroup.NameKey(name));
    if (g == null) {
        throw new Failure(new NoSuchGroupException(name));
    }
    return g;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RefControl.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = control.getAccountGroup();
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludedGroups(loadIncludedGroups());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setGroups(gic.create());
    return detail;
}
#method_after
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = control.getAccountGroup();
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#end_block

#method_before
public AccountGroup.Id createGroup(final String groupName, final String groupDescription, final AccountGroup.Id ownerGroupId, final Account.Id[] initialMembers, final AccountGroup.Id[] initialIncludedGroups) throws OrmException, NameAlreadyUsedException {
    final AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    final AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    final AccountGroup group = new AccountGroup(nameKey, groupId);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    final AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new NameAlreadyUsedException();
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers(groupId, initialMembers);
    if (initialIncludedGroups != null) {
        addIncludedGroups(groupId, initialIncludedGroups);
    }
    return groupId;
}
#method_after
public AccountGroup.Id createGroup(final String groupName, final String groupDescription, final boolean visibleToAll, final AccountGroup.Id ownerGroupId, final Collection<? extends Account.Id> initialMembers, final Collection<? extends AccountGroup.Id> initialGroups) throws OrmException, NameAlreadyUsedException {
    final AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    final AccountGroup.NameKey nameKey = new AccountGroup.NameKey(groupName);
    final AccountGroup group = new AccountGroup(nameKey, groupId);
    group.setVisibleToAll(visibleToAll);
    if (ownerGroupId != null) {
        group.setOwnerGroupId(ownerGroupId);
    }
    if (groupDescription != null) {
        group.setDescription(groupDescription);
    }
    final AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new NameAlreadyUsedException();
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers(groupId, initialMembers);
    if (initialGroups != null) {
        addGroups(groupId, initialGroups);
    }
    return groupId;
}
#end_block

#method_before
private void addMembers(final AccountGroup.Id groupId, final Account.Id[] members) throws OrmException {
    final List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    final List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        final AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#method_after
private void addMembers(final AccountGroup.Id groupId, final Collection<? extends Account.Id> members) throws OrmException {
    final List<AccountGroupMember> memberships = new ArrayList<AccountGroupMember>();
    final List<AccountGroupMemberAudit> membershipsAudit = new ArrayList<AccountGroupMemberAudit>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
        final AccountGroupMemberAudit audit = new AccountGroupMemberAudit(membership, currentUser.getAccountId());
        membershipsAudit.add(audit);
    }
    db.accountGroupMembers().insert(memberships);
    db.accountGroupMembersAudit().insert(membershipsAudit);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#end_block

#method_before
private void displayApprovals(final int row, final ApprovalSummary summary, final AccountInfoCache aic, final boolean highlightUnreviewed) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> approvals = summary.getApprovalMap();
    int col = BASE_COLUMNS;
    boolean haveReview = false;
    for (final ApprovalType type : approvalTypes) {
        final PatchSetApproval ca = approvals.get(type.getCategory().getId());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
        } else {
            haveReview = true;
            final ApprovalCategoryValue acv = type.getValue(ca);
            final AccountInfo ai = aic.get(ca.getAccountId());
            if (type.isMaxNegative(ca)) {
                table.setHTML(row, col, new Image(Gerrit.RESOURCES.redNot()).getElement().getString() + FormatUtil.name(ai));
            } else if (type.isMaxPositive(ca)) {
                table.setHTML(row, col, new Image(Gerrit.RESOURCES.greenCheck()).getElement().getString() + FormatUtil.name(ai));
            } else {
                String vstr = String.valueOf(ca.getValue()) + " " + FormatUtil.name(ai);
                if (ca.getValue() > 0) {
                    vstr = "+" + vstr;
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
                } else {
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                }
                table.setText(row, col, vstr);
            }
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            // 
            fmt.getElement(row, col).setTitle(acv.getName() + " \nby " + FormatUtil.nameEmail(ai));
        }
        col++;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed);
}
#method_after
private void displayApprovals(final int row, final ApprovalSummary summary, final AccountInfoCache aic, final boolean highlightUnreviewed) {
    final CellFormatter fmt = table.getCellFormatter();
    final Map<ApprovalCategory.Id, PatchSetApproval> approvals = summary.getApprovalMap();
    int col = BASE_COLUMNS;
    boolean haveReview = false;
    boolean displayPersonNameInReviewCategory = false;
    if (Gerrit.isSignedIn()) {
        AccountGeneralPreferences prefs = Gerrit.getUserAccount().getGeneralPreferences();
        if (prefs.isDisplayPersonNameInReviewCategory()) {
            displayPersonNameInReviewCategory = true;
        }
    }
    for (final ApprovalType type : approvalTypes) {
        final PatchSetApproval ca = approvals.get(type.getCategory().getId());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().negscore());
        fmt.removeStyleName(row, col, Gerrit.RESOURCES.css().posscore());
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (ca == null || ca.getValue() == 0) {
            table.clearCell(row, col);
        } else {
            haveReview = true;
            final ApprovalCategoryValue acv = type.getValue(ca);
            final AccountInfo ai = aic.get(ca.getAccountId());
            if (type.isMaxNegative(ca)) {
                if (displayPersonNameInReviewCategory) {
                    FlowPanel fp = new FlowPanel();
                    fp.add(new Image(Gerrit.RESOURCES.redNot()));
                    fp.add(new InlineLabel(FormatUtil.name(ai)));
                    table.setWidget(row, col, fp);
                } else {
                    table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
                }
            } else if (type.isMaxPositive(ca)) {
                if (displayPersonNameInReviewCategory) {
                    FlowPanel fp = new FlowPanel();
                    fp.add(new Image(Gerrit.RESOURCES.greenCheck()));
                    fp.add(new InlineLabel(FormatUtil.name(ai)));
                    table.setWidget(row, col, fp);
                } else {
                    table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
                }
            } else {
                String vstr = String.valueOf(ca.getValue());
                if (displayPersonNameInReviewCategory) {
                    vstr = vstr + " " + FormatUtil.name(ai);
                }
                if (ca.getValue() > 0) {
                    vstr = "+" + vstr;
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
                } else {
                    fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
                }
                table.setText(row, col, vstr);
            }
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            // 
            fmt.getElement(row, col).setTitle(acv.getName() + " \nby " + FormatUtil.nameEmail(ai));
        }
        col++;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), !haveReview && highlightUnreviewed);
}
#end_block

#method_before
public void visibleGroups(final AsyncCallback<List<AccountGroup>> callback) {
    run(callback, new Action<List<AccountGroup>>() {

        public List<AccountGroup> run(ReviewDb db) throws OrmException {
            final IdentifiedUser user = identifiedUser.get();
            final List<AccountGroup> result;
            if (user.isAdministrator()) {
                result = db.accountGroups().all().toList();
            } else {
                final HashSet<AccountGroup.Id> seen = new HashSet<AccountGroup.Id>();
                result = new ArrayList<AccountGroup>();
                for (final AccountGroup.Id myGroup : user.getEffectiveGroups()) {
                    for (AccountGroup group : db.accountGroups().ownedByGroup(myGroup)) {
                        final AccountGroup.Id id = group.getId();
                        if (!seen.add(id)) {
                            continue;
                        }
                        try {
                            GroupControl c = groupControlFactory.controlFor(id);
                            if (c.isOwner()) {
                                result.add(c.getAccountGroup());
                            }
                        } catch (NoSuchGroupException e) {
                            continue;
                        }
                    }
                }
            }
            for (final AccountGroup group : db.accountGroups().all().toList()) {
                if (group.isVisibleToAll() && !result.contains(group)) {
                    result.add(group);
                }
            }
            Collections.sort(result, new Comparator<AccountGroup>() {

                public int compare(final AccountGroup a, final AccountGroup b) {
                    return a.getName().compareTo(b.getName());
                }
            });
            return result;
        }
    });
}
#method_after
public void visibleGroups(final AsyncCallback<List<AccountGroup>> callback) {
    run(callback, new Action<List<AccountGroup>>() {

        public List<AccountGroup> run(ReviewDb db) throws OrmException {
            final IdentifiedUser user = identifiedUser.get();
            final List<AccountGroup> result;
            if (user.isAdministrator()) {
                result = db.accountGroups().all().toList();
            } else {
                result = new ArrayList<AccountGroup>();
                for (final AccountGroup group : db.accountGroups().all().toList()) {
                    final GroupControl c = groupControlFactory.controlFor(group);
                    if (c.isVisible()) {
                        result.add(c.getAccountGroup());
                    }
                }
            }
            Collections.sort(result, new Comparator<AccountGroup>() {

                public int compare(final AccountGroup a, final AccountGroup b) {
                    return a.getName().compareTo(b.getName());
                }
            });
            return result;
        }
    });
}
#end_block

#method_before
public void changeGroupOptions(final AccountGroup.Id groupId, final boolean visibleToAll, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            group.setVisibleToAll(visibleToAll);
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void changeGroupOptions(final AccountGroup.Id groupId, final GroupOptions groupOptions, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            group.setVisibleToAll(groupOptions.isVisibleToAll());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
private void initGroupOptions() {
    groupOptionsPanel = new VerticalPanel();
    groupOptionsPanel.add(new SmallHeading(Util.C.headingGroupOptions()));
    visibleToAllCheckBox = new CheckBox(Util.C.isVisibleToAll());
    groupOptionsPanel.add(visibleToAllCheckBox);
    saveGroupOptions = new Button(Util.C.buttonSaveGroupOptions());
    saveGroupOptions.setEnabled(false);
    saveGroupOptions.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final boolean visibleToAll = visibleToAllCheckBox.getValue();
            Util.GROUP_SVC.changeGroupOptions(groupId, visibleToAll, new GerritCallback<VoidResult>() {

                public void onSuccess(final VoidResult result) {
                    saveGroupOptions.setEnabled(false);
                }
            });
        }
    });
    groupOptionsPanel.add(saveGroupOptions);
    add(groupOptionsPanel);
    new OnEditEnabler(saveGroupOptions, visibleToAllCheckBox);
}
#method_after
private void initGroupOptions() {
    groupOptionsPanel = new VerticalPanel();
    groupOptionsPanel.add(new SmallHeading(Util.C.headingGroupOptions()));
    visibleToAllCheckBox = new CheckBox(Util.C.isVisibleToAll());
    groupOptionsPanel.add(visibleToAllCheckBox);
    saveGroupOptions = new Button(Util.C.buttonSaveGroupOptions());
    saveGroupOptions.setEnabled(false);
    saveGroupOptions.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            final GroupOptions groupOptions = new GroupOptions(visibleToAllCheckBox.getValue());
            Util.GROUP_SVC.changeGroupOptions(groupId, groupOptions, new GerritCallback<VoidResult>() {

                public void onSuccess(final VoidResult result) {
                    saveGroupOptions.setEnabled(false);
                }
            });
        }
    });
    groupOptionsPanel.add(saveGroupOptions);
    add(groupOptionsPanel);
    new OnEditEnabler(saveGroupOptions, visibleToAllCheckBox);
}
#end_block

#method_before
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            initOptionList();
            parseCommandLine();
            boolean ok = true;
            for (final PatchSet.Id patchSetId : patchSetIds) {
                try {
                    approveOne(patchSetId);
                } catch (UnloggedFailure e) {
                    ok = false;
                    writeError("error: " + e.getMessage() + "\n");
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while approving " + patchSetId + "\n");
                    log.error("internal error while approving " + patchSetId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
            }
        }
    });
}
#method_after
@Override
public final void start(final Environment env) {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Failure {
            initOptionList();
            parseCommandLine();
            if (abandonChange) {
                if (restoreChange) {
                    throw error("abandon and restore actions are mutually exclusive");
                }
                if (submitChange) {
                    throw error("abandon and submit actions are mutually exclusive");
                }
            }
            boolean ok = true;
            for (final PatchSet.Id patchSetId : patchSetIds) {
                try {
                    approveOne(patchSetId);
                } catch (UnloggedFailure e) {
                    ok = false;
                    writeError("error: " + e.getMessage() + "\n");
                } catch (Exception e) {
                    ok = false;
                    writeError("fatal: internal server error while approving " + patchSetId + "\n");
                    log.error("internal error while approving " + patchSetId, e);
                }
            }
            if (!ok) {
                throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
            }
            if (!toSubmit.isEmpty()) {
                final Set<Branch.NameKey> toMerge = new HashSet<Branch.NameKey>();
                try {
                    for (PatchSet.Id patchSetId : toSubmit) {
                        ChangeUtil.submit(opFactory, patchSetId, currentUser, db, new MergeQueue() {

                            @Override
                            public void merge(MergeOp.Factory mof, Branch.NameKey branch) {
                                toMerge.add(branch);
                            }

                            @Override
                            public void schedule(Branch.NameKey branch) {
                                toMerge.add(branch);
                            }

                            @Override
                            public void recheckAfter(Branch.NameKey branch, long delay, TimeUnit delayUnit) {
                                toMerge.add(branch);
                            }
                        });
                    }
                    for (Branch.NameKey branch : toMerge) {
                        merger.merge(opFactory, branch);
                    }
                } catch (OrmException updateError) {
                    throw new Failure(1, "one or more submits failed", updateError);
                }
            }
        }
    });
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            ChangeUtil.submit(opFactory, patchSetId, currentUser, db, merger);
        } else {
            throw error(result.getMessage());
        }
    }
    if (abandonChange) {
        if (changeControl.canAbandon()) {
            ChangeUtil.abandon(patchSetId, changeId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("User does not have the privileges to abandon this change");
        }
    }
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (changeComment == null) {
        changeComment = "";
    }
    Set<ApprovalCategoryValue.Id> aps = new HashSet<ApprovalCategoryValue.Id>();
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            assertScoreIsAllowed(patchSetId, changeControl, ao, v);
            aps.add(new ApprovalCategoryValue.Id(ao.getCategoryId(), v));
        }
    }
    publishCommentsFactory.create(patchSetId, changeComment, aps).call();
    if (abandonChange) {
        if (changeControl.canAbandon()) {
            ChangeUtil.abandon(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("Not permitted to abandon change");
        }
    }
    if (restoreChange) {
        if (changeControl.canRestore()) {
            ChangeUtil.restore(patchSetId, currentUser, changeComment, db, abandonedSenderFactory, hooks);
        } else {
            throw error("Not permitted to restore change");
        }
        if (submitChange) {
            changeControl = changeControlFactory.validateFor(changeId);
        }
    }
    if (submitChange) {
        CanSubmitResult result = changeControl.canSubmit(patchSetId, db, approvalTypes, functionStateFactory);
        if (result == CanSubmitResult.OK) {
            toSubmit.add(patchSetId);
        } else {
            throw error(result.getMessage());
        }
    }
}
#end_block

#method_before
public static void abandon(final PatchSet.Id patchSetId, final Change.Id changeId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, EmailException, OrmException {
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, user.getAccount(), message);
}
#method_after
public static void abandon(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final AbandonedSender.Factory abandonedSenderFactory, final ChangeHookRunner hooks) throws NoSuchChangeException, EmailException, OrmException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    final Change change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, user.getAccount(), message);
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.abandon(patchSetId, changeId, currentUser, message, db, abandonedSenderFactory, hooks);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    ChangeUtil.abandon(patchSetId, currentUser, message, db, abandonedSenderFactory, hooks);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroupImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
}
#end_block

#method_before
private NoteMap loadRejectCommitsMap(final String refName) {
    try {
        final ObjectId rejectCommitsId = repo.resolve(refName);
        if (rejectCommitsId == null) {
            return null;
        }
        final ObjectReader reader = repo.newObjectReader();
        final RevWalk rw = new RevWalk(reader);
        final RevCommit c;
        if (rejectCommitsId instanceof RevCommit) {
            c = (RevCommit) rejectCommitsId;
        } else {
            c = rw.parseCommit(rejectCommitsId);
        }
        return NoteMap.load(reader, c);
    } catch (AmbiguousObjectException e) {
        log.error("Ambiguous reference for reject commits map: " + refName, e);
        return null;
    } catch (IOException e) {
        log.error("Error loading reject commits map", e);
        return null;
    }
}
#method_after
private NoteMap loadRejectCommitsMap() throws IOException {
    String rejectNotes = "refs/meta/reject-commits";
    try {
        Ref ref = repo.getRef(rejectNotes);
        if (ref == null) {
            return null;
        }
        RevWalk rw = rp.getRevWalk();
        RevCommit map = rw.parseCommit(ref.getObjectId());
        return NoteMap.read(rw.getObjectReader(), map);
    } catch (IOException badMap) {
        throw new IOException("Cannot load " + rejectNotes, badMap);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits != null && rejectCommits.contains(c.getId())) {
        reject(newChange, "contains bad commit " + c.getId().getName());
        return false;
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits != null && rejectCommits.contains(c)) {
        reject(newChange, "contains banned commit " + c.getName());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    {
        nameBox = new NpTextBox();
        nameTxt = new SuggestBox(new ProjectNameSuggestOracle(), nameBox);
        nameBox.setVisibleLength(50);
        nameBox.setText(Util.C.defaultProjectName());
        nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        nameBox.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultProjectName().equals(nameBox.getText())) {
                    nameBox.setText("");
                    nameBox.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(nameBox.getText())) {
                    nameBox.setText(Util.C.defaultProjectName());
                    nameBox.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        nameBox.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                submitOnSelection = false;
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    if (nameTxt.isSuggestionListShowing()) {
                        submitOnSelection = true;
                    } else {
                        doAddNew();
                    }
                }
            }
        });
        nameTxt.addSelectionHandler(new SelectionHandler<Suggestion>() {

            @Override
            public void onSelection(SelectionEvent<Suggestion> event) {
                if (submitOnSelection) {
                    submitOnSelection = false;
                    doAddNew();
                }
            }
        });
        filterTxt = new NpTextBox();
        filterTxt.setVisibleLength(50);
        filterTxt.setText(Util.C.defaultFilter());
        filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
        filterTxt.addFocusHandler(new FocusHandler() {

            @Override
            public void onFocus(FocusEvent event) {
                if (Util.C.defaultFilter().equals(filterTxt.getText())) {
                    filterTxt.setText("");
                    filterTxt.removeStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(BlurEvent event) {
                if ("".equals(filterTxt.getText())) {
                    filterTxt.setText(Util.C.defaultFilter());
                    filterTxt.addStyleName(Gerrit.RESOURCES.css().inputFieldTypeHint());
                }
            }
        });
        filterTxt.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                    doAddNew();
                }
            }
        });
        projects = new ProjectTable();
        addNew = new Button(Util.C.buttonWatchProject());
        addNew.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                doAddNew();
            }
        });
        final Grid grid = new Grid(2, 2);
        grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
        grid.setText(0, 0, Util.C.watchedProjectName());
        grid.setWidget(0, 1, nameTxt);
        grid.setText(1, 0, Util.C.watchedProjectFilter());
        grid.setWidget(1, 1, filterTxt);
        final CellFormatter fmt = grid.getCellFormatter();
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
        fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
        fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
        DisclosurePanel unwatched = new DisclosurePanel(Util.C.unwatchedProjects());
        unwatched.setContent(projects);
        final Grid grid2 = new Grid(1, 2);
        final FlowPanel fp2 = new FlowPanel();
        fp2.add(addNew);
        grid2.setWidget(0, 0, fp2);
        grid2.setWidget(0, 1, unwatched);
        final CellFormatter fmt2 = grid2.getCellFormatter();
        fmt2.setAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT, HasVerticalAlignment.ALIGN_TOP);
        final FlowPanel fp = new FlowPanel();
        fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
        fp.add(grid);
        fp.add(grid2);
        add(fp);
    }
    watches = new WatchTable();
    add(watches);
    delSel = new Button(Util.C.buttonDeleteSshKey());
    delSel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            watches.deleteChecked();
        }
    });
    add(delSel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    createWidgets();
    /* top table */
    final Grid grid = new Grid(2, 2);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.watchedProjectName());
    grid.setWidget(0, 1, nameTxt);
    grid.setText(1, 0, Util.C.watchedProjectFilter());
    grid.setWidget(1, 1, filterTxt);
    final CellFormatter fmt = grid.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel());
    fp.add(grid);
    fp.add(addNew);
    fp.add(browse);
    add(fp);
    /* bottom table */
    add(watchesTab);
    add(delSel);
    /* popup */
    final FlowPanel pfp = new FlowPanel();
    sp = new ScrollPanel(projectsTab);
    pfp.add(sp);
    pfp.add(close);
    popup.setWidget(pfp);
    popupPosition = new PopupPanel.PositionCallback() {

        public void setPosition(int offsetWidth, int offsetHeight) {
            if (preferredPopupWidth == -1) {
                preferredPopupWidth = offsetWidth;
            }
            // under page header
            int top = grid.getAbsoluteTop() - 50;
            // Try to place it to the right of everything else, but not
            // right justified
            int left = 5 + Math.max(grid.getAbsoluteLeft() + grid.getOffsetWidth(), watchesTab.getAbsoluteLeft() + watchesTab.getOffsetWidth());
            if (top + offsetHeight > Window.getClientHeight()) {
                top = Window.getClientHeight() - offsetHeight;
            }
            if (left + offsetWidth > Window.getClientWidth()) {
                left = Window.getClientWidth() - offsetWidth;
            }
            if (top < 0) {
                sp.setHeight((sp.getOffsetHeight() + top) + "px");
                top = 0;
            }
            if (left < 0) {
                sp.setWidth((sp.getOffsetWidth() + left) + "px");
                left = 0;
            }
            popup.setPopupPosition(left, top);
        }
    };
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.ACCOUNT_SVC.myProjectWatch(new ScreenLoadCallback<List<AccountProjectWatchInfo>>(this) {

        public void preDisplay(final List<AccountProjectWatchInfo> result) {
            watchedProjects = result;
            watches.display(result);
            displayUnwatchedProjects();
        }
    });
    Util.PROJECT_SVC.visibleProjects(new ScreenLoadCallback<List<Project>>(this) {

        @Override
        protected void preDisplay(final List<Project> result) {
            allProjects = new ArrayList(result);
            // unneeded fake "--all projects--" entry
            allProjects.remove(0);
            displayUnwatchedProjects();
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    populateWatches();
}
#end_block

#method_before
void doAddNew() {
    final String projectName = nameTxt.getText();
    if (projectName == null || projectName.length() == 0 || Util.C.defaultProjectName().equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watches.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
protected void doAddNew() {
    final String projectName = nameTxt.getText();
    if ("".equals(projectName)) {
        return;
    }
    String filter = filterTxt.getText();
    if (filter == null || filter.isEmpty() || filter.equals(Util.C.defaultFilter())) {
        filter = null;
    }
    addNew.setEnabled(false);
    nameBox.setEnabled(false);
    filterTxt.setEnabled(false);
    Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new GerritCallback<AccountProjectWatchInfo>() {

        public void onSuccess(final AccountProjectWatchInfo result) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            nameTxt.setText("");
            watchesTab.insertWatch(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            addNew.setEnabled(true);
            nameBox.setEnabled(true);
            filterTxt.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initSubmitType();
    initAgreements();
    add(saveProject);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    saveProject = new Button(Util.C.buttonSaveChanges());
    saveProject.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doSave();
        }
    });
    initDescription();
    initProjectOptions();
    initAgreements();
    add(saveProject);
}
#end_block

#method_before
private void initAgreements() {
    final ValueChangeHandler<Boolean> onChangeSave = new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            saveProject.setEnabled(true);
        }
    };
    agreementsPanel = new VerticalPanel();
    agreementsPanel.add(new SmallHeading(Util.C.headingAgreements()));
    useContributorAgreements = new CheckBox(Util.C.useContributorAgreements());
    useContributorAgreements.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useContributorAgreements);
    useSignedOffBy = new CheckBox(Util.C.useSignedOffBy(), true);
    useSignedOffBy.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useSignedOffBy);
    requireChangeID = new CheckBox(Util.C.requireChangeID(), true);
    requireChangeID.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(requireChangeID);
    add(agreementsPanel);
}
#method_after
private void initAgreements() {
    final ValueChangeHandler<Boolean> onChangeSave = new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            saveProject.setEnabled(true);
        }
    };
    agreementsPanel = new VerticalPanel();
    agreementsPanel.add(new SmallHeading(Util.C.headingAgreements()));
    useContributorAgreements = new CheckBox(Util.C.useContributorAgreements());
    useContributorAgreements.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useContributorAgreements);
    useSignedOffBy = new CheckBox(Util.C.useSignedOffBy(), true);
    useSignedOffBy.addValueChangeHandler(onChangeSave);
    agreementsPanel.add(useSignedOffBy);
    add(agreementsPanel);
}
#end_block

#method_before
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    submitTypePanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    requireChangeID.setValue(project.isRequireChangeID());
    setSubmitType(project.getSubmitType());
}
#method_after
void display(final ProjectDetail result) {
    project = result.project;
    final boolean isall = Gerrit.getConfig().getWildProject().equals(project.getNameKey());
    projectOptionsPanel.setVisible(!isall);
    agreementsPanel.setVisible(!isall);
    useContributorAgreements.setVisible(Gerrit.getConfig().isUseContributorAgreements());
    descTxt.setText(project.getDescription());
    useContributorAgreements.setValue(project.isUseContributorAgreements());
    useSignedOffBy.setValue(project.isUseSignedOffBy());
    requireChangeID.setValue(project.isRequireChangeID());
    setSubmitType(project.getSubmitType());
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        // If the project wants Change-ID line, verify we
        // have it and it's legal.
        // 
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        reject(cmd, "you are not author " + author.getEmailAddress());
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        reject(cmd, "you are not committer " + committer.getEmailAddress());
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    if (project.isRequireChangeID()) {
        final List<String> idList = c.getFooterLines(CHANGE_ID);
        if (idList.isEmpty()) {
            reject(cmd, "missing Change-Id in commit message ");
            return false;
        }
        if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message ");
            return false;
        }
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            reject(cmd, "invalid Change-Id line format in commit message ");
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    serveRegex("^/(.*?)/?$").with(new HttpServlet() {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            ProjectControl pc;
            try {
                pc = getProjectControl(req);
            } catch (ServiceNotEnabledException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            Project.NameKey dst = pc.getProject().getNameKey();
            StringBuilder r = new StringBuilder();
            r.append(urlProvider.get());
            r.append('#');
            r.append(PageLinks.toProject(dst, Change.Status.NEW));
            rsp.sendRedirect(r.toString());
        }
    });
}
#method_after
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    serveRegex("^/(.*?)/?$").with(new HttpServlet() {

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            ProjectControl pc;
            try {
                pc = getProjectControl(req);
            } catch (ServiceNotEnabledException e) {
                rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
                return;
            }
            Project.NameKey dst = pc.getProject().getNameKey();
            StringBuilder r = new StringBuilder();
            r.append(urlProvider.get());
            r.append('#');
            r.append(PageLinks.toChangeQuery(PageLinks.projectQuery(dst, Change.Status.NEW)));
            rsp.sendRedirect(r.toString());
        }
    });
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    final CurrentUser user = pc.getCurrentUser();
    final Set<AccountGroup.Id> uploadGroup = serverCommandConfig.getUploadGroup();
    if (uploadGroup != null && !uploadGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(user.getEffectiveGroups(), uploadGroup)) {
            throw new ServiceNotAuthorizedException();
        }
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get()));
    }
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    ProjectControl pc = getProjectControl(req);
    if (!pc.canRunUploadPack()) {
        throw new ServiceNotAuthorizedException();
    }
    // The Resolver above already checked READ access for us.
    // 
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    if (!pc.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, pc, db.get()));
    }
    return up;
}
#end_block

#method_before
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    if (pc.getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
        final Set<AccountGroup.Id> receiveGroup = serverCommandConfig.getReceiveGroup();
        if (receiveGroup != null && !receiveGroup.isEmpty()) {
            if (!CollectionsUtil.isAnyIncludedIn(user.getEffectiveGroups(), receiveGroup)) {
                throw new ServiceNotAuthorizedException();
            }
        }
        final ReceiveCommits rc = factory.create(pc, db);
        final ReceiveCommits.Capable s = rc.canUpload();
        if (s != ReceiveCommits.Capable.OK) {
            // TODO We should alert the user to this message on the HTTP
            // response channel, assuming Git will even report it to them.
            // 
            final String who = user.getUserName();
            final String why = s.getMessage();
            log.warn("Rejected push from " + who + ": " + why);
            throw new ServiceNotEnabledException();
        }
        rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
        return rc.getReceivePack();
    } else {
        throw new ServiceNotAuthorizedException();
    }
}
#method_after
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotEnabledException, ServiceNotAuthorizedException {
    final ProjectControl pc = getProjectControl(req);
    if (!pc.canRunReceivePack()) {
        throw new ServiceNotAuthorizedException();
    }
    if (pc.getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
        final ReceiveCommits rc = factory.create(pc, db);
        final ReceiveCommits.Capable s = rc.canUpload();
        if (s != ReceiveCommits.Capable.OK) {
            // TODO We should alert the user to this message on the HTTP
            // response channel, assuming Git will even report it to them.
            // 
            final String who = user.getUserName();
            final String why = s.getMessage();
            log.warn("Rejected push from " + who + ": " + why);
            throw new ServiceNotEnabledException();
        }
        rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
        return rc.getReceivePack();
    } else {
        throw new ServiceNotAuthorizedException();
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final Set<AccountGroup.Id> receiveGroup = getServerCommandConfig().getReceiveGroup();
    if (receiveGroup != null && !receiveGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(currentUser.getEffectiveGroups(), receiveGroup)) {
            throw new Failure(1, "User: " + currentUser.getUserName() + " not allowed to execute this command on this server");
        }
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    ReceiveCommits.Capable r = receive.canUpload();
    if (r != ReceiveCommits.Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    try {
        rp.receive(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunReceivePack()) {
        throw new Failure(1, "fatal: receive-pack not permitted on this server");
    }
    final ReceiveCommits receive = factory.create(projectControl, repo);
    ReceiveCommits.Capable r = receive.canUpload();
    if (r != ReceiveCommits.Capable.OK) {
        throw new UnloggedFailure(1, "\nfatal: " + r.getMessage());
    }
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    receive.addReviewers(reviewerId);
    receive.addExtraCC(ccId);
    final ReceivePack rp = receive.getReceivePack();
    rp.setRefLogIdent(currentUser.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    try {
        rp.receive(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final Set<AccountGroup.Id> uploadGroup = getServerCommandConfig().getUploadGroup();
    if (uploadGroup != null && !uploadGroup.isEmpty()) {
        if (!CollectionsUtil.isAnyIncludedIn(currentUser.getEffectiveGroups(), uploadGroup)) {
            throw new Failure(1, "User: " + currentUser.getUserName() + " not allowed to execute this command on this server");
        }
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get()));
    }
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setRefFilter(new VisibleRefFilter(repo, projectControl, db.get()));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    try {
        up.upload(in, out, err);
    } catch (InterruptedIOException err) {
        throw new Failure(128, "fatal: client IO read/write timeout", err);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.Id>>() {
    }).annotatedWith(ProjectCreatorGroups.class).toProvider(ProjectCreatorGroupsProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.Id>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(new TypeLiteral<ServerCommand>() {
    }).annotatedWith(ServerCommandConfig.class).toProvider(ServerCommandConfigProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(MergeOp.Factory.class);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    factory(FunctionState.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
            install(new LdapModule());
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(Project.NameKey.class).annotatedWith(WildProjectName.class).toProvider(WildProjectNameProvider.class).in(SINGLETON);
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(AnonymousUser.class);
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(IdGenerator.class);
    bind(CachePool.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(new AccessControlModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(ProjectState.Factory.class);
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(WorkQueue.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ReplicationQueue.class).to(PushReplication.class).in(SINGLETON);
    factory(PushAllProjectsOp.Factory.class);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(EmailSender.class).to(SmtpEmailSender.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(LocalDiskRepositoryManager.Lifecycle.class);
            listener().to(CachePool.Lifecycle.class);
            listener().to(WorkQueue.Lifecycle.class);
            listener().to(VelocityLifecycle.class);
        }
    });
}
#end_block

#method_before
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("MergeFail.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#method_after
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath())) {
            throw die("aborted by user");
        }
        if (!site.site_path.isDirectory() && !site.site_path.mkdirs()) {
            throw die("Cannot make directory " + site.site_path);
        }
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    for (InitStep step : steps) {
        step.run();
    }
    savePublic(flags.cfg);
    saveSecure(flags.sec);
    if (!site.replication_config.exists()) {
        site.replication_config.createNewFile();
    }
    extract(site.gerrit_sh, Init.class, "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    extractMailExample("Abandoned.vm");
    extractMailExample("ChangeFooter.vm");
    extractMailExample("ChangeSubject.vm");
    extractMailExample("Comment.vm");
    extractMailExample("Merged.vm");
    extractMailExample("MergeFail.vm");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#end_block

#method_before
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, "/" + orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#method_after
private void extractMailExample(String orig) throws Exception {
    File ex = new File(site.mail_dir, orig + ".example");
    extract(ex, OutgoingEmail.class, orig);
    chmod(0444, ex);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccExistingReviewers();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccExistingReviewers();
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("MergeFail.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("MergeFail.vm"));
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    bccWatchesNotifyAllComments();
}
#end_block

#method_before
@Override
protected void formatChange() {
    appendText(velocifyFile("Abandoned.vm"));
}
#method_after
@Override
protected void formatChange() throws EmailException {
    appendText(velocifyFile("Abandoned.vm"));
}
#end_block

#method_before
protected void format() {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#method_after
protected void format() throws EmailException {
    formatChange();
    if (getChangeUrl() != null) {
        openFooter();
        appendText("To view visit ");
        appendText(getChangeUrl());
        appendText("\n");
    }
    if (getSettingsUrl() != null) {
        openFooter();
        appendText("To unsubscribe, visit ");
        appendText(getSettingsUrl());
        appendText("\n");
    }
    if (inFooter) {
        appendText("\n");
    } else {
        openFooter();
    }
    appendText("Gerrit-MessageType: " + messageClass + "\n");
    appendText("Gerrit-Project: " + projectName + "\n");
    appendText("Gerrit-Branch: " + change.getDest().getShortName() + "\n");
    appendText("Gerrit-Owner: " + getNameEmailFor(change.getOwner()) + "\n");
    try {
        HashSet<Account.Id> reviewers = new HashSet<Account.Id>();
        for (PatchSetApproval p : args.db.get().patchSetApprovals().byChange(change.getId())) {
            reviewers.add(p.getAccountId());
        }
        TreeSet<String> names = new TreeSet<String>();
        for (Account.Id who : reviewers) {
            names.add(getNameEmailFor(who));
        }
        for (String name : names) {
            appendText("Gerrit-Reviewer: " + name + "\n");
        }
    } catch (OrmException e) {
    }
}
#end_block

#method_before
protected void init() {
    super.init();
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#method_after
protected void init() {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
        projectName = projectState != null ? projectState.getProject().getName() : null;
    } else {
        projectState = null;
        projectName = null;
    }
    if (patchSet == null) {
        try {
            patchSet = args.db.get().patchSets().get(change.currentPatchSetId());
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(patchSet.getId());
        } catch (PatchSetInfoNotAvailableException err) {
            patchSetInfo = null;
        }
    }
    super.init();
    if (changeMessage != null && changeMessage.getWrittenOn() != null) {
        setHeader("Date", new Date(changeMessage.getWrittenOn().getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setListIdHeader();
    setChangeUrlHeader();
    setCommitIdHeader();
    inFooter = false;
}
#end_block

#method_before
private String getSettingsUrl() {
    if (getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append("settings");
        return r.toString();
    }
    return null;
}
#method_after
public String getSettingsUrl() {
    if (getGerritUrl() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(getGerritUrl());
        r.append("settings");
        return r.toString();
    }
    return null;
}
#end_block

#method_before
protected void setVHeader(final String name, final String value) {
    setHeader(name, velocify(value));
}
#method_after
protected void setVHeader(final String name, final String value) throws EmailException {
    setHeader(name, velocify(value));
}
#end_block

#method_before
private void add(final RecipientType rt, final UserIdentity who) {
    if (who != null && who.getAccount() != null) {
        add(rt, who.getAccount());
    }
}
#method_after
protected void add(final RecipientType rt, final UserIdentity who) {
    if (who != null && who.getAccount() != null) {
        add(rt, who.getAccount());
    }
}
#end_block

#method_before
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#method_after
private Address toAddress(final Account.Id id) {
    final Account a = args.accountCache.get(id).getAccount();
    final String e = a.getPreferredEmail();
    if (!a.isActive() || e == null) {
        return null;
    }
    return new Address(a.getFullName(), e);
}
#end_block

#method_before
protected void setupVelocityContext() {
    String rl = "resource.loader";
    String pkg = "org.apache.velocity.runtime.resource.loader";
    Properties p = new Properties();
    p.setProperty(rl, "file, class");
    p.setProperty("file." + rl + ".class", pkg + ".FileResourceLoader");
    p.setProperty("file." + rl + ".path", args.site.mail_dir.getAbsolutePath());
    p.setProperty("class." + rl + ".class", pkg + ".ClasspathResourceLoader");
    p.setProperty(org.apache.velocity.runtime.RuntimeConstants.RUNTIME_LOG, args.site.logs_dir.getAbsolutePath() + java.io.File.separator + "velocity_log");
    try {
        Velocity.init(p);
    } catch (Exception e) {
    }
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#method_after
protected void setupVelocityContext() {
    velocityContext = new VelocityContext();
    velocityContext.put("email", this);
    velocityContext.put("messageClass", messageClass);
    velocityContext.put("StringUtils", StringUtils.class);
}
#end_block

#method_before
protected String velocify(String tpl) {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        return tpl.toString();
    }
}
#method_after
protected String velocify(String tpl) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.evaluate(velocityContext, w, "OutgoingEmail", tpl);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Velocity template " + tpl.toString(), e);
    }
}
#end_block

#method_before
protected String velocifyFile(String name) {
    Exception eo;
    StringWriter w = new StringWriter();
    try {
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            eo = e;
        }
    } catch (Exception e) {
        eo = e;
    }
    return "Velocity exception in template " + name + ".\n" + eo.toString();
}
#method_after
protected String velocifyFile(String name) throws EmailException {
    try {
        StringWriter w = new StringWriter();
        Velocity.mergeTemplate(name, velocityContext, w);
        return w.toString();
    } catch (ResourceNotFoundException e) {
        try {
            StringWriter w = new StringWriter();
            String pkg = "com/google/gerrit/server/mail/";
            Velocity.mergeTemplate(pkg + name, velocityContext, w);
            return w.toString();
        } catch (Exception e2) {
            throw new EmailException("Velocity WAR template" + name + ".\n", e2);
        }
    } catch (Exception e) {
        throw new EmailException("Velocity template " + name + ".\n", e);
    }
}
#end_block

#method_before
@Override
public Map<K, V> getAll(Iterable<? extends K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#method_after
@Override
public Map<K, V> getAll(Iterable<K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#end_block

#method_before
@Override
public Map<K, V> getAll(Iterable<? extends K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#method_after
@Override
public Map<K, V> getAll(Iterable<K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#end_block

#method_before
@Override
public Map<K, V> getAll(Iterable<? extends K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#method_after
@Override
public Map<K, V> getAll(Iterable<K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#end_block

#method_before
@Override
public Map<K, V> getAll(Iterable<? extends K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#method_after
@Override
public Map<K, V> getAll(Iterable<K> keys) {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keys) {
        if (!map.containsKey(k)) {
            V v = get(k);
            if (v != null) {
                map.put(k, v);
            }
        }
    }
    return map;
}
#end_block

#method_before
private void start() {
    synchronized (lock) {
        if (manager != null) {
            throw new IllegalStateException("Cache pool has already been started");
        }
        try {
            System.setProperty("net.sf.ehcache.skipUpdateCheck", "" + true);
        } catch (SecurityException e) {
        // Ignore it, the system is just going to ping some external page
        // using a background thread and there's not much we can do about
        // it now.
        }
        manager = new CacheManager(new Factory().toConfiguration());
        for (CacheProvider<?, ?> p : caches.values()) {
            Ehcache eh = manager.getEhcache(p.getName());
            EntryCreator<?, ?> c = p.getEntryCreator();
            if (c != null) {
                if (p.disk()) {
                    p.bind(new PopulatingProtobufCache(eh, c, p.getKeyClass(), p.getValueClass(), p.getValueProvider()));
                } else {
                    p.bind(new PopulatingCache(eh, c));
                }
            } else {
                if (p.disk()) {
                    p.bind(new SimpleProtobufCache(eh, p.getKeyClass(), p.getValueClass(), p.getValueProvider()));
                } else {
                    p.bind(new SimpleCache(eh));
                }
            }
        }
    }
}
#method_after
private void start() {
    synchronized (lock) {
        if (manager != null) {
            throw new IllegalStateException("Cache pool has already been started");
        }
        try {
            System.setProperty("net.sf.ehcache.skipUpdateCheck", "" + true);
        } catch (SecurityException e) {
        // Ignore it, the system is just going to ping some external page
        // using a background thread and there's not much we can do about
        // it now.
        }
        manager = new CacheManager(new Factory().toConfiguration());
        for (CacheProvider<?, ?> p : caches.values()) {
            Ehcache eh = manager.getEhcache(p.getName());
            EntryCreator<?, ?> c = p.getEntryCreator();
            if (c != null && p.disk()) {
                c = new ProtobufEntryCreator(c, p.getKeyClass(), p.getValueClass());
            }
            Cache m;
            if (c != null) {
                m = new PopulatingCache(eh, c);
            } else {
                m = new SimpleCache(eh);
            }
            if (p.disk()) {
                m = new ProtobufCache(m, p.getKeyClass(), p.getValueClass(), p.getValueProvider());
            }
            p.bind(m);
        }
    }
}
#end_block

#method_before
public T toObject(ProtobufCodec<T> codec, Provider<T> provider) {
    if (object == null) {
        this.codec = codec;
        if (provider == null) {
            object = codec.decode(buf);
        } else {
            object = provider.get();
            try {
                codec.mergeFrom(CodedInputStream.newInstance(buf), object);
            } catch (IOException e) {
                throw new RuntimeException("Cannot decode message", e);
            }
        }
        // Free the memory being taken up by the buffer.
        buf = null;
    }
    return object;
}
#method_after
T toObject(ProtobufCodec<T> codec, Provider<T> provider) {
    if (codec == null) {
        return null;
    }
    Object d = data;
    if (d instanceof byte[]) {
        this.codec = codec;
        if (provider == null) {
            d = codec.decode((byte[]) d);
        } else {
            T tmp = provider.get();
            codec.mergeFrom((byte[]) d, tmp);
            d = tmp;
        }
        data = d;
    }
    return (T) d;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SerializableProtobuf<?>)) {
        return false;
    }
    SerializableProtobuf<?> other = ((SerializableProtobuf<?>) obj);
    if (hash != other.hash) {
        return false;
    }
    if (object != null && other.object != null) {
        return object.equals(other.object);
    }
    return Arrays.equals(buf, other.buf);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SerializableProtobuf<?>)) {
        return false;
    }
    SerializableProtobuf<T> other = ((SerializableProtobuf<T>) obj);
    if (hash != other.hash) {
        return false;
    }
    // Make sure we either both have codecs, or we both do not
    if (this.codec == null && other.codec != null) {
        this.codec = other.codec;
    } else if (this.codec != null && other.codec == null) {
        other.codec = this.codec;
    }
    // Equals is only ever called on keys, which cannot have providers
    T thisObject = this.toObject(codec, null);
    T otherObject = other.toObject(other.codec, null);
    if (thisObject == null && otherObject == null) {
        // Neither of us had codecs, so we must compare byte arrays
        return Arrays.equals((byte[]) this.data, (byte[]) other.data);
    } else if (thisObject != null && otherObject != null) {
        return thisObject.equals(otherObject);
    } else {
        return false;
    }
}
#end_block

#method_before
private void writeObject(ObjectOutputStream oos) throws IOException {
    if (buf == null) {
        // If buffer is null, toObject must have been called, which means that we
        // have the object and the codec.
        buf = new byte[codec.sizeof(object)];
        codec.encode(object, buf);
    }
    oos.defaultWriteObject();
}
#method_after
private void writeObject(ObjectOutputStream oos) throws IOException {
    oos.writeInt(hash);
    Object d = data;
    if (d instanceof byte[]) {
        byte[] buf = (byte[]) d;
        oos.writeInt(buf.length);
        oos.write(buf);
    } else {
        // We assume that if we have an object, we must have a codec
        T obj = (T) d;
        oos.writeInt(codec.sizeof(obj));
        CodedOutputStream cos = CodedOutputStream.newInstance(oos);
        codec.encode(obj, cos);
        cos.flush();
    }
}
#end_block

#method_before
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (!refPattern.startsWith(Constants.R_REFS)) {
        refPattern = Constants.R_HEADS + refPattern;
    }
    if (refPattern.endsWith("/*")) {
        final String prefix = refPattern.substring(0, refPattern.length() - 2);
        if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
            throw new InvalidNameException();
        }
    } else if (!Pattern.compile("refs/.*").matcher(refPattern.replace("*", ".*")).matches()) {
        if (!Repository.isValidRefName(refPattern)) {
            throw new InvalidNameException();
        }
    }
    if (!controlForRef(projectControl, refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#method_after
@Override
public ProjectDetail call() throws NoSuchProjectException, OrmException, NoSuchGroupException, InvalidNameException, NoSuchRefException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    final ApprovalType at = approvalTypes.getApprovalType(categoryId);
    if (at == null || at.getValue(min) == null || at.getValue(max) == null) {
        throw new IllegalArgumentException("Invalid category " + categoryId + " or range " + min + ".." + max);
    }
    String refPattern = this.refPattern;
    if (refPattern == null || refPattern.isEmpty()) {
        if (categoryId.equals(ApprovalCategory.SUBMIT) || categoryId.equals(ApprovalCategory.PUSH_HEAD)) {
            // Explicitly related to a branch head.
            refPattern = Constants.R_HEADS + "*";
        } else if (!at.getCategory().isAction()) {
            // Non actions are approval votes on a change, assume these apply
            // to branch heads only.
            refPattern = Constants.R_HEADS + "*";
        } else if (categoryId.equals(ApprovalCategory.PUSH_TAG)) {
            // Explicitly related to the tag namespace.
            refPattern = Constants.R_TAGS + "*";
        } else if (categoryId.equals(ApprovalCategory.READ) || categoryId.equals(ApprovalCategory.OWN)) {
            // Currently these are project-wide rights, so apply that way.
            refPattern = RefRight.ALL;
        } else {
            // Assume project wide for the default.
            refPattern = RefRight.ALL;
        }
    }
    boolean exclusive = refPattern.startsWith("-");
    if (exclusive) {
        refPattern = refPattern.substring(1);
    }
    while (refPattern.startsWith("/")) {
        refPattern = refPattern.substring(1);
    }
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        String example = RefControl.shortestExample(refPattern);
        if (!example.startsWith(Constants.R_REFS)) {
            refPattern = RefRight.REGEX_PREFIX + Constants.R_HEADS + refPattern.substring(RefRight.REGEX_PREFIX.length());
            example = RefControl.shortestExample(refPattern);
        }
        if (!Repository.isValidRefName(example)) {
            throw new InvalidNameException();
        }
    } else {
        if (!refPattern.startsWith(Constants.R_REFS)) {
            refPattern = Constants.R_HEADS + refPattern;
        }
        if (refPattern.endsWith("/*")) {
            final String prefix = refPattern.substring(0, refPattern.length() - 2);
            if (!"refs".equals(prefix) && !Repository.isValidRefName(prefix)) {
                throw new InvalidNameException();
            }
        } else {
            if (!Repository.isValidRefName(refPattern)) {
                throw new InvalidNameException();
            }
        }
    }
    if (exclusive) {
        refPattern = "-" + refPattern;
    }
    if (!projectControl.controlForRef(refPattern).isOwner()) {
        throw new NoSuchRefException(refPattern);
    }
    final AccountGroup group = groupCache.get(groupName);
    if (group == null) {
        throw new NoSuchGroupException(groupName);
    }
    final RefRight.Key key = new RefRight.Key(projectName, new RefRight.RefPattern(refPattern), categoryId, group.getId());
    RefRight rr = db.refRights().get(key);
    if (rr == null) {
        rr = new RefRight(key);
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().insert(Collections.singleton(rr));
    } else {
        rr.setMinValue(min);
        rr.setMaxValue(max);
        db.refRights().update(Collections.singleton(rr));
    }
    projectCache.evictAll();
    return projectDetailFactory.create(projectName).call();
}
#end_block

#method_before
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (!RefRight.ALL.equals(getRefName()) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (canPerform(OWN, (short) 1)) {
        return true;
    }
    // 
    if (getRefName().equals(RefRight.ALL.substring(0, RefRight.ALL.length() - 1)) && getProjectControl().isOwner()) {
        return true;
    }
    return false;
}
#end_block

#method_before
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    for (RefRight right : filterMostSpecific(allRights)) {
        if (groups.contains(right.getAccountGroupId())) {
            val = Math.max(right.getMaxValue(), val);
        }
    }
    return val >= level;
}
#method_after
boolean canPerform(ApprovalCategory.Id actionId, short level) {
    final Set<AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups();
    int val = Integer.MIN_VALUE;
    List<RefRight> allRights = new ArrayList<RefRight>();
    allRights.addAll(getLocalRights(actionId));
    if (actionId.canInheritFromWildProject()) {
        allRights.addAll(getInheritedRights(actionId));
    }
    SortedMap<String, RefRightsForPattern> perPatternRights = sortedRightsByPattern(allRights);
    for (RefRightsForPattern right : perPatternRights.values()) {
        val = Math.max(val, right.allowedValueForRef(groups));
        if (val >= level || right.containsExclusive()) {
            return val >= level;
        }
    }
    return val >= level;
}
#end_block

#method_before
public static boolean matches(String refName, String refPattern) {
    return Pattern.matches(refPattern.replace("*", "(.*)"), refName);
}
#method_after
public static boolean matches(String refName, String refPattern) {
    if (refPattern.startsWith(RefRight.REGEX_PREFIX)) {
        return Pattern.matches(refPattern, refName);
    }
    if (refPattern.endsWith("/*")) {
        String prefix = refPattern.substring(0, refPattern.length() - 1);
        return refName.startsWith(prefix);
    } else {
        return refName.equals(refPattern);
    }
}
#end_block

