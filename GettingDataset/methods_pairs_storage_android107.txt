749
#method_before
private void handleRequests(String dataString, String iface) {
    String SSID = null;
    int networkId = -2;
    String requestName = dataString.substring(REQUEST_PREFIX_LEN_STR);
    if (TextUtils.isEmpty(requestName)) {
        return;
    }
    if (requestName.startsWith(IDENTITY_STR)) {
        Matcher match = mRequestIdentityPattern.matcher(requestName);
        if (match.find()) {
            SSID = match.group(2);
            try {
                networkId = Integer.parseInt(match.group(1));
            } catch (NumberFormatException e) {
                networkId = -1;
            }
        } else {
            Log.e(TAG, "didn't find SSID " + requestName);
        }
        broadcastNetworkIdentityRequestEvent(iface, networkId, SSID);
    } else if (requestName.startsWith(SIM_STR)) {
        Matcher matchGsm = mRequestGsmAuthPattern.matcher(requestName);
        Matcher matchUmts = mRequestUmtsAuthPattern.matcher(requestName);
        if (matchGsm.find()) {
            String[] data = matchGsm.group(2).split(":");
            broadcastNetworkGsmAuthRequestEvent(iface, Integer.parseInt(matchGsm.group(1)), matchGsm.group(4), data);
        } else if (matchUmts.find()) {
            String[] data = new String[2];
            data[0] = matchUmts.group(2);
            data[1] = matchUmts.group(3);
            broadcastNetworkUmtsAuthRequestEvent(iface, Integer.parseInt(matchUmts.group(1)), matchUmts.group(4), data);
        } else {
            Log.e(TAG, "couldn't parse SIM auth request - " + requestName);
        }
    } else {
        if (mVerboseLoggingEnabled) {
            Log.w(TAG, "couldn't identify request type - " + dataString);
        }
    }
}
#method_after
private void handleRequests(String dataString, String iface) {
    String SSID = null;
    int networkId = -2;
    String requestName = dataString.substring(REQUEST_PREFIX_LEN_STR);
    if (TextUtils.isEmpty(requestName)) {
        return;
    }
    if (requestName.startsWith(IDENTITY_STR)) {
        Matcher match = mRequestIdentityPattern.matcher(requestName);
        if (match.find()) {
            SSID = match.group(2);
            try {
                networkId = Integer.parseInt(match.group(1));
            } catch (NumberFormatException e) {
                networkId = -1;
            }
        } else {
            Log.e(TAG, "didn't find SSID " + requestName);
        }
        broadcastNetworkIdentityRequestEvent(iface, networkId, SSID);
    } else if (requestName.startsWith(SIM_STR)) {
        Matcher matchGsm = mRequestGsmAuthPattern.matcher(requestName);
        Matcher matchUmts = mRequestUmtsAuthPattern.matcher(requestName);
        if (matchGsm.find()) {
            String[] data = matchGsm.group(2).split(":");
            broadcastNetworkGsmAuthRequestEvent(iface, Integer.parseInt(matchGsm.group(1)), matchGsm.group(4), data);
        } else if (matchUmts.find()) {
            String[] data = { matchUmts.group(2), matchUmts.group(3) };
            broadcastNetworkUmtsAuthRequestEvent(iface, Integer.parseInt(matchUmts.group(1)), matchUmts.group(4), data);
        } else {
            Log.e(TAG, "couldn't parse SIM auth request - " + requestName);
        }
    } else {
        if (mVerboseLoggingEnabled) {
            Log.w(TAG, "couldn't identify request type - " + dataString);
        }
    }
}
#end_block

#method_before
public void broadcastNetworkGsmAuthRequestEvent(String iface, int networkId, String ssid, String[] data) {
    SimAuthRequestData authData = new SimAuthRequestData();
    authData.networkId = networkId;
    authData.protocol = WifiEnterpriseConfig.Eap.SIM;
    authData.ssid = ssid;
    authData.data = data;
    sendMessage(iface, SUP_REQUEST_SIM_AUTH, data);
}
#method_after
public void broadcastNetworkGsmAuthRequestEvent(String iface, int networkId, String ssid, String[] data) {
    sendMessage(iface, SUP_REQUEST_SIM_AUTH, new SimAuthRequestData(networkId, WifiEnterpriseConfig.Eap.SIM, ssid, data));
}
#end_block

#method_before
public void broadcastNetworkUmtsAuthRequestEvent(String iface, int networkId, String ssid, String[] data) {
    SimAuthRequestData authData = new SimAuthRequestData();
    authData.networkId = networkId;
    authData.protocol = WifiEnterpriseConfig.Eap.AKA;
    authData.ssid = ssid;
    authData.data = data;
    sendMessage(iface, SUP_REQUEST_SIM_AUTH, data);
}
#method_after
public void broadcastNetworkUmtsAuthRequestEvent(String iface, int networkId, String ssid, String[] data) {
    sendMessage(iface, SUP_REQUEST_SIM_AUTH, new SimAuthRequestData(networkId, WifiEnterpriseConfig.Eap.AKA, ssid, data));
}
#end_block

#method_before
@Test
public void testBroadcastNetworkGsmAuthRequestEvent() {
    mWifiMonitor.registerHandler(WLAN_IFACE_NAME, WifiMonitor.SUP_REQUEST_SIM_AUTH, mHandlerSpy);
    int networkId = 45;
    String ssid = "\"test124\"";
    String[] data = new String[] { "45adbc", "fead45" };
    mWifiMonitor.broadcastNetworkGsmAuthRequestEvent(WLAN_IFACE_NAME, networkId, ssid, data);
    mLooper.dispatchAll();
    ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
    verify(mHandlerSpy).handleMessage(messageCaptor.capture());
    assertEquals(WifiMonitor.SUP_REQUEST_SIM_AUTH, messageCaptor.getValue().what);
    assertEquals(networkId, ((TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj).networkId);
    assertEquals(ssid, ((TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj).ssid);
    assertEquals(WifiEnterpriseConfig.Eap.SIM, ((TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj).protocol);
    assertEquals(data, ((TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj).data);
}
#method_after
@Test
public void testBroadcastNetworkGsmAuthRequestEvent() {
    mWifiMonitor.registerHandler(WLAN_IFACE_NAME, WifiMonitor.SUP_REQUEST_SIM_AUTH, mHandlerSpy);
    int networkId = 45;
    String ssid = "\"test124\"";
    String[] data = new String[] { "45adbc", "fead45", "0x3452" };
    mWifiMonitor.broadcastNetworkGsmAuthRequestEvent(WLAN_IFACE_NAME, networkId, ssid, data);
    mLooper.dispatchAll();
    ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
    verify(mHandlerSpy).handleMessage(messageCaptor.capture());
    assertEquals(WifiMonitor.SUP_REQUEST_SIM_AUTH, messageCaptor.getValue().what);
    TelephonyUtil.SimAuthRequestData authData = (TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj;
    assertEquals(networkId, authData.networkId);
    assertEquals(ssid, authData.ssid);
    assertEquals(WifiEnterpriseConfig.Eap.SIM, authData.protocol);
    assertArrayEquals(data, authData.data);
}
#end_block

#method_before
@Test
public void testBroadcastNetworkUmtsAuthRequestEvent() {
    mWifiMonitor.registerHandler(WLAN_IFACE_NAME, WifiMonitor.SUP_REQUEST_SIM_AUTH, mHandlerSpy);
    int networkId = 45;
    String ssid = "\"test124\"";
    String[] data = new String[] { "45adbc", "fead45" };
    mWifiMonitor.broadcastNetworkUmtsAuthRequestEvent(WLAN_IFACE_NAME, networkId, ssid, data);
    mLooper.dispatchAll();
    ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
    verify(mHandlerSpy).handleMessage(messageCaptor.capture());
    assertEquals(WifiMonitor.SUP_REQUEST_SIM_AUTH, messageCaptor.getValue().what);
    assertEquals(networkId, ((TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj).networkId);
    assertEquals(ssid, ((TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj).ssid);
    assertEquals(WifiEnterpriseConfig.Eap.AKA, ((TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj).protocol);
    assertEquals(data, ((TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj).data);
}
#method_after
@Test
public void testBroadcastNetworkUmtsAuthRequestEvent() {
    mWifiMonitor.registerHandler(WLAN_IFACE_NAME, WifiMonitor.SUP_REQUEST_SIM_AUTH, mHandlerSpy);
    int networkId = 45;
    String ssid = "\"test124\"";
    String[] data = new String[] { "45adbc", "fead45" };
    mWifiMonitor.broadcastNetworkUmtsAuthRequestEvent(WLAN_IFACE_NAME, networkId, ssid, data);
    mLooper.dispatchAll();
    ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
    verify(mHandlerSpy).handleMessage(messageCaptor.capture());
    assertEquals(WifiMonitor.SUP_REQUEST_SIM_AUTH, messageCaptor.getValue().what);
    TelephonyUtil.SimAuthRequestData authData = (TelephonyUtil.SimAuthRequestData) messageCaptor.getValue().obj;
    assertEquals(networkId, authData.networkId);
    assertEquals(ssid, authData.ssid);
    assertEquals(WifiEnterpriseConfig.Eap.AKA, authData.protocol);
    assertArrayEquals(data, authData.data);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        case CMD_DIAGS_CONNECT_TIMEOUT:
            mWifiDiagnostics.reportConnectionEvent((Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_REMOVE_NETWORK:
            deleteNetworkConfigAndSendReply(message, false);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            deleteNetworkConfigAndSendReply(message, true);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        case CMD_DIAGS_CONNECT_TIMEOUT:
            mWifiDiagnostics.reportConnectionEvent((Long) message.obj, BaseWifiDiagnostics.CONNECTION_EVENT_FAILED);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone(message.arg1 != 0, (AnqpEvent) message.obj);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            IconEvent event = (IconEvent) message.obj;
            mPasspointManager.notifyIconDone(event.getBSSID(), event);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((AnqpEvent) message.obj);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            IconEvent event = (IconEvent) message.obj;
            mPasspointManager.notifyIconDone(event.getBSSID(), event);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, false)) {
                // failed to remove the config and caller was notified
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            // we successfully deleted the network config
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            if (!deleteNetworkConfigAndSendReply(message, true)) {
                // Caller was notified of failure, nothing else to do
                break;
            }
            // the network was deleted
            netId = message.arg1;
            if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Test
public void testBroadcastAnqpDoneEvent() {
    mWifiMonitor.registerHandler(WLAN_IFACE_NAME, WifiMonitor.ANQP_DONE_EVENT, mHandlerSpy);
    long bssid = 5;
    mWifiMonitor.broadcastAnqpDoneEvent(WLAN_IFACE_NAME, 1, new AnqpEvent(bssid, null));
    mLooper.dispatchAll();
    ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
    verify(mHandlerSpy).handleMessage(messageCaptor.capture());
    assertEquals(WifiMonitor.ANQP_DONE_EVENT, messageCaptor.getValue().what);
    assertEquals(1, messageCaptor.getValue().arg1);
    assertEquals(bssid, ((AnqpEvent) messageCaptor.getValue().obj).getBssid());
    assertNull(((AnqpEvent) messageCaptor.getValue().obj).getElements());
}
#method_after
@Test
public void testBroadcastAnqpDoneEvent() {
    mWifiMonitor.registerHandler(WLAN_IFACE_NAME, WifiMonitor.ANQP_DONE_EVENT, mHandlerSpy);
    long bssid = 5;
    mWifiMonitor.broadcastAnqpDoneEvent(WLAN_IFACE_NAME, new AnqpEvent(bssid, null));
    mLooper.dispatchAll();
    ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
    verify(mHandlerSpy).handleMessage(messageCaptor.capture());
    assertEquals(WifiMonitor.ANQP_DONE_EVENT, messageCaptor.getValue().what);
    assertEquals(bssid, ((AnqpEvent) messageCaptor.getValue().obj).getBssid());
    assertNull(((AnqpEvent) messageCaptor.getValue().obj).getElements());
}
#end_block

#method_before
@Test
public void anqpRequestCompletedWithError() {
    mHandler.notifyANQPDone(false, new AnqpEvent(BSSID, null));
    verify(mCallbacks).onANQPResponse(BSSID, null);
}
#method_after
@Test
public void anqpRequestCompletedWithError() {
    mHandler.notifyANQPDone(new AnqpEvent(BSSID, null));
    verify(mCallbacks).onANQPResponse(BSSID, null);
}
#end_block

#method_before
// ANQP-QUERY-DONE addr=18:cf:5e:26:a4:88 result=SUCCESS
private void handleAnqpResult(String eventStr, String iface) {
    int addrPos = eventStr.indexOf(ADDR_STRING);
    int resPos = eventStr.indexOf(RESULT_STRING);
    if (addrPos < 0 || resPos < 0) {
        throw new IllegalArgumentException("Unexpected ANQP result notification");
    }
    int eoaddr = eventStr.indexOf(' ', addrPos + ADDR_STRING.length());
    if (eoaddr < 0) {
        eoaddr = eventStr.length();
    }
    int eoresult = eventStr.indexOf(' ', resPos + RESULT_STRING.length());
    if (eoresult < 0) {
        eoresult = eventStr.length();
    }
    long bssid = 0;
    int result = 0;
    try {
        bssid = Utils.parseMac(eventStr.substring(addrPos + ADDR_STRING.length(), eoaddr));
        result = eventStr.substring(resPos + RESULT_STRING.length(), eoresult).equalsIgnoreCase("success") ? 1 : 0;
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, "Bad MAC address in ANQP response: " + iae.getMessage());
        return;
    }
    AnqpEvent anqpEvent = null;
    if (bssid != 0 && result != 0) {
        // Any errors in retrieving/parsing the ANQP results should mark the result as failed.
        String bssData = mWifiNative.scanResult(Utils.macToString(bssid));
        if (TextUtils.isEmpty(bssData)) {
            result = 0;
        } else {
            anqpEvent = AnqpEvent.buildAnqpEvent(bssid, bssData);
            if (anqpEvent == null) {
                result = 0;
            }
        }
    }
    broadcastAnqpDoneEvent(iface, result, anqpEvent);
}
#method_after
// ANQP-QUERY-DONE addr=18:cf:5e:26:a4:88 result=SUCCESS
private void handleAnqpResult(String eventStr, String iface) {
    int addrPos = eventStr.indexOf(ADDR_STRING);
    int resPos = eventStr.indexOf(RESULT_STRING);
    if (addrPos < 0 || resPos < 0) {
        throw new IllegalArgumentException("Unexpected ANQP result notification");
    }
    int eoaddr = eventStr.indexOf(' ', addrPos + ADDR_STRING.length());
    if (eoaddr < 0) {
        eoaddr = eventStr.length();
    }
    int eoresult = eventStr.indexOf(' ', resPos + RESULT_STRING.length());
    if (eoresult < 0) {
        eoresult = eventStr.length();
    }
    long bssid = 0;
    int result = 0;
    try {
        bssid = Utils.parseMac(eventStr.substring(addrPos + ADDR_STRING.length(), eoaddr));
        result = eventStr.substring(resPos + RESULT_STRING.length(), eoresult).equalsIgnoreCase("success") ? 1 : 0;
    } catch (IllegalArgumentException iae) {
        Log.e(TAG, "Bad MAC address in ANQP response: " + iae.getMessage());
        return;
    }
    AnqpEvent anqpEvent = null;
    // empty ANQP elements.
    if (bssid != 0 && result != 0) {
        String bssData = mWifiNative.scanResult(Utils.macToString(bssid));
        anqpEvent = AnqpEvent.buildAnqpEvent(bssid, bssData);
    } else {
        anqpEvent = AnqpEvent.buildAnqpEvent(bssid, null);
    }
    broadcastAnqpDoneEvent(iface, anqpEvent);
}
#end_block

#method_before
public void broadcastAnqpDoneEvent(String iface, int result, AnqpEvent anqpEvent) {
    sendMessage(iface, ANQP_DONE_EVENT, result, 0, anqpEvent);
}
#method_after
public void broadcastAnqpDoneEvent(String iface, AnqpEvent anqpEvent) {
    sendMessage(iface, ANQP_DONE_EVENT, anqpEvent);
}
#end_block

#method_before
public void notifyANQPDone(boolean success, AnqpEvent anqpEvent) {
    if (anqpEvent == null)
        return;
    mCallbacks.onANQPResponse(anqpEvent.getBssid(), anqpEvent.getElements());
}
#method_after
public void notifyANQPDone(AnqpEvent anqpEvent) {
    if (anqpEvent == null)
        return;
    mCallbacks.onANQPResponse(anqpEvent.getBssid(), anqpEvent.getElements());
}
#end_block

#method_before
public boolean addOrUpdateProvider(PasspointConfiguration config) {
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    // Verify IMSI against the IMSI of the installed SIM cards for SIM credential.
    if (config.getCredential().getSimCredential() != null) {
        if (mSimAccessor.getMatchingImsis(IMSIParameter.build(config.getCredential().getSimCredential().getImsi())) == null) {
            Log.e(TAG, "IMSI does not match any SIM card");
            return false;
        }
    }
    // Create a provider and install the necessary certificates and keys.
    PasspointProvider newProvider = mObjectFactory.makePasspointProvider(config, mKeyStore, mSimAccessor, mProviderID++);
    if (!newProvider.installCertsAndKeys()) {
        Log.e(TAG, "Failed to install certificates and keys to keystore");
        return false;
    }
    // Remove existing provider with the same FQDN.
    if (mProviders.containsKey(config.getHomeSp().getFqdn())) {
        Log.d(TAG, "Replacing configuration for " + config.getHomeSp().getFqdn());
        removeProvider(config.getHomeSp().getFqdn());
    }
    mProviders.put(config.getHomeSp().getFqdn(), newProvider);
    return true;
}
#method_after
public boolean addOrUpdateProvider(PasspointConfiguration config) {
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    // Verify IMSI against the IMSI of the installed SIM cards for SIM credential.
    if (config.getCredential().getSimCredential() != null) {
        if (mSimAccessor.getMatchingImsis(IMSIParameter.build(config.getCredential().getSimCredential().getImsi())) == null) {
            Log.e(TAG, "IMSI does not match any SIM card");
            return false;
        }
    }
    // Create a provider and install the necessary certificates and keys.
    PasspointProvider newProvider = mObjectFactory.makePasspointProvider(config, mKeyStore, mSimAccessor, mProviderIndex++);
    if (!newProvider.installCertsAndKeys()) {
        Log.e(TAG, "Failed to install certificates and keys to keystore");
        return false;
    }
    // Remove existing provider with the same FQDN.
    if (mProviders.containsKey(config.getHomeSp().getFqdn())) {
        Log.d(TAG, "Replacing configuration for " + config.getHomeSp().getFqdn());
        mProviders.get(config.getHomeSp().getFqdn()).uninstallCertsAndKeys();
        mProviders.remove(config.getHomeSp().getFqdn());
    }
    mProviders.put(config.getHomeSp().getFqdn(), newProvider);
    mWifiConfigManager.saveToStore(true);
    return true;
}
#end_block

#method_before
public boolean removeProvider(String fqdn) {
    if (!mProviders.containsKey(fqdn)) {
        Log.e(TAG, "Config doesn't exist");
        return false;
    }
    mProviders.get(fqdn).uninstallCertsAndKeys();
    mProviders.remove(fqdn);
    return true;
}
#method_after
public boolean removeProvider(String fqdn) {
    if (!mProviders.containsKey(fqdn)) {
        Log.e(TAG, "Config doesn't exist");
        return false;
    }
    mProviders.get(fqdn).uninstallCertsAndKeys();
    mProviders.remove(fqdn);
    mWifiConfigManager.saveToStore(true);
    return true;
}
#end_block

#method_before
public void notifyANQPDone(boolean success, AnqpEvent anqpEvent) {
    mHandler.notifyANQPDone(success, anqpEvent);
}
#method_after
public void notifyANQPDone(AnqpEvent anqpEvent) {
    mHandler.notifyANQPDone(anqpEvent);
}
#end_block

#method_before
public static PasspointConfiguration deserializePasspointConfiguration(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    PasspointConfiguration config = new PasspointConfiguration();
    config.setUpdateIdentifier((int) XmlUtil.readNextValueWithName(in, XML_TAG_UPDATE_IDENTIFIER));
    config.setCredentialPriority((int) XmlUtil.readNextValueWithName(in, XML_TAG_CREDENTIAL_PRIORITY));
    config.setTrustRootCertList((Map<String, byte[]>) XmlUtil.readNextValueWithName(in, XML_TAG_TRUST_ROOT_CERT_LIST));
    config.setSubscriptionCreationTimeInMs((long) XmlUtil.readNextValueWithName(in, XML_TAG_SUBSCRIPTION_CREATION_TIME));
    config.setSubscriptionExpirationTimeInMs((long) XmlUtil.readNextValueWithName(in, XML_TAG_SUBSCRIPTION_EXPIRATION_TIME));
    config.setSubscriptionType((String) XmlUtil.readNextValueWithName(in, XML_TAG_SUBSCRIPTION_TYPE));
    config.setUsageLimitUsageTimePeriodInMinutes((long) XmlUtil.readNextValueWithName(in, XML_TAG_USAGE_LIMIT_TIME_PERIOD));
    config.setUsageLimitStartTimeInMs((long) XmlUtil.readNextValueWithName(in, XML_TAG_USAGE_LIMIT_START_TIME));
    config.setUsageLimitDataLimit((long) XmlUtil.readNextValueWithName(in, XML_TAG_USAGE_LIMIT_DATA_LIMIT));
    config.setUsageLimitTimeLimitInMinutes((long) XmlUtil.readNextValueWithName(in, XML_TAG_USAGE_LIMIT_TIME_LIMIT));
    String[] headerName = new String[1];
    while (XmlUtil.gotoNextSectionOrEnd(in, headerName, outerTagDepth)) {
        switch(headerName[0]) {
            case XML_TAG_SECTION_HEADER_HOMESP:
                config.setHomeSp(deserializeHomeSP(in, outerTagDepth + 1));
                break;
            case XML_TAG_SECTION_HEADER_CREDENTIAL:
                config.setCredential(deserializeCredential(in, outerTagDepth + 1));
                break;
            case XML_TAG_SECTION_HEADER_POLICY:
                config.setPolicy(deserializePolicy(in, outerTagDepth + 1));
                break;
            case XML_TAG_SECTION_HEADER_SUBSCRIPTION_UPDATE:
                config.setSubscriptionUpdate(deserializeUpdateParameter(in, outerTagDepth + 1));
                break;
            default:
                throw new XmlPullParserException("Unknown data under provider: " + headerName[0]);
        }
    }
    return config;
}
#method_after
public static PasspointConfiguration deserializePasspointConfiguration(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    PasspointConfiguration config = new PasspointConfiguration();
    while (XmlUtils.nextElementWithin(in, outerTagDepth)) {
        if (isValueElement(in)) {
            // Value elements.
            String[] name = new String[1];
            Object value = XmlUtil.readCurrentValue(in, name);
            switch(name[0]) {
                case XML_TAG_UPDATE_IDENTIFIER:
                    config.setUpdateIdentifier((int) value);
                    break;
                case XML_TAG_CREDENTIAL_PRIORITY:
                    config.setCredentialPriority((int) value);
                    break;
                case XML_TAG_TRUST_ROOT_CERT_LIST:
                    config.setTrustRootCertList((Map<String, byte[]>) value);
                    break;
                case XML_TAG_SUBSCRIPTION_CREATION_TIME:
                    config.setSubscriptionCreationTimeInMs((long) value);
                    break;
                case XML_TAG_SUBSCRIPTION_EXPIRATION_TIME:
                    config.setSubscriptionExpirationTimeInMs((long) value);
                    break;
                case XML_TAG_SUBSCRIPTION_TYPE:
                    config.setSubscriptionType((String) value);
                    break;
                case XML_TAG_USAGE_LIMIT_TIME_PERIOD:
                    config.setUsageLimitUsageTimePeriodInMinutes((long) value);
                    break;
                case XML_TAG_USAGE_LIMIT_START_TIME:
                    config.setUsageLimitStartTimeInMs((long) value);
                    break;
                case XML_TAG_USAGE_LIMIT_DATA_LIMIT:
                    config.setUsageLimitDataLimit((long) value);
                    break;
                case XML_TAG_USAGE_LIMIT_TIME_LIMIT:
                    config.setUsageLimitTimeLimitInMinutes((long) value);
                    break;
                default:
                    throw new XmlPullParserException("Unknown value under " + "PasspointConfiguration: " + in.getName());
            }
        } else {
            // Section elements.
            switch(in.getName()) {
                case XML_TAG_SECTION_HEADER_HOMESP:
                    config.setHomeSp(deserializeHomeSP(in, outerTagDepth + 1));
                    break;
                case XML_TAG_SECTION_HEADER_CREDENTIAL:
                    config.setCredential(deserializeCredential(in, outerTagDepth + 1));
                    break;
                case XML_TAG_SECTION_HEADER_POLICY:
                    config.setPolicy(deserializePolicy(in, outerTagDepth + 1));
                    break;
                case XML_TAG_SECTION_HEADER_SUBSCRIPTION_UPDATE:
                    config.setSubscriptionUpdate(deserializeUpdateParameter(in, outerTagDepth + 1));
                    break;
                default:
                    throw new XmlPullParserException("Unknown section under " + "PasspointConfiguration: " + in.getName());
            }
        }
    }
    return config;
}
#end_block

#method_before
private static HomeSp deserializeHomeSP(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    HomeSp homeSp = new HomeSp();
    homeSp.setFqdn((String) XmlUtil.readNextValueWithName(in, XML_TAG_FQDN));
    homeSp.setFriendlyName((String) XmlUtil.readNextValueWithName(in, XML_TAG_FRIENDLY_NAME));
    homeSp.setIconUrl((String) XmlUtil.readNextValueWithName(in, XML_TAG_ICON_URL));
    homeSp.setHomeNetworkIds((Map<String, Long>) XmlUtil.readNextValueWithName(in, XML_TAG_HOME_NETWORK_IDS));
    homeSp.setMatchAllOis((long[]) XmlUtil.readNextValueWithName(in, XML_TAG_MATCH_ALL_OIS));
    homeSp.setMatchAnyOis((long[]) XmlUtil.readNextValueWithName(in, XML_TAG_MATCH_ANY_OIS));
    homeSp.setOtherHomePartners((String[]) XmlUtil.readNextValueWithName(in, XML_TAG_OTHER_HOME_PARTNERS));
    homeSp.setRoamingConsortiumOis((long[]) XmlUtil.readNextValueWithName(in, XML_TAG_ROAMING_CONSORTIUM_OIS));
    return homeSp;
}
#method_after
private static HomeSp deserializeHomeSP(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    HomeSp homeSp = new HomeSp();
    while (!XmlUtil.isNextSectionEnd(in, outerTagDepth)) {
        String[] valueName = new String[1];
        Object value = XmlUtil.readCurrentValue(in, valueName);
        if (valueName[0] == null) {
            throw new XmlPullParserException("Missing value name");
        }
        switch(valueName[0]) {
            case XML_TAG_FQDN:
                homeSp.setFqdn((String) value);
                break;
            case XML_TAG_FRIENDLY_NAME:
                homeSp.setFriendlyName((String) value);
                break;
            case XML_TAG_ICON_URL:
                homeSp.setIconUrl((String) value);
                break;
            case XML_TAG_HOME_NETWORK_IDS:
                homeSp.setHomeNetworkIds((Map<String, Long>) value);
                break;
            case XML_TAG_MATCH_ALL_OIS:
                homeSp.setMatchAllOis((long[]) value);
                break;
            case XML_TAG_MATCH_ANY_OIS:
                homeSp.setMatchAnyOis((long[]) value);
                break;
            case XML_TAG_ROAMING_CONSORTIUM_OIS:
                homeSp.setRoamingConsortiumOis((long[]) value);
                break;
            case XML_TAG_OTHER_HOME_PARTNERS:
                homeSp.setOtherHomePartners((String[]) value);
                break;
            default:
                throw new XmlPullParserException("Unknown data under HomeSP: " + valueName[0]);
        }
    }
    return homeSp;
}
#end_block

#method_before
private static Credential deserializeCredential(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Credential credential = new Credential();
    credential.setCreationTimeInMs((long) XmlUtil.readNextValueWithName(in, XML_TAG_CREATION_TIME));
    credential.setExpirationTimeInMs((long) XmlUtil.readNextValueWithName(in, XML_TAG_EXPIRATION_TIME));
    credential.setRealm((String) XmlUtil.readNextValueWithName(in, XML_TAG_REALM));
    credential.setCheckAaaServerCertStatus((boolean) XmlUtil.readNextValueWithName(in, XML_TAG_CHECK_AAA_SERVER_CERT_STATUS));
    String[] headerName = new String[1];
    while (XmlUtil.gotoNextSectionOrEnd(in, headerName, outerTagDepth)) {
        switch(headerName[0]) {
            case XML_TAG_SECTION_HEADER_USER_CREDENTIAL:
                credential.setUserCredential(deserializeUserCredential(in, outerTagDepth + 1));
                break;
            case XML_TAG_SECTION_HEADER_CERT_CREDENTIAL:
                credential.setCertCredential(deserializeCertCredential(in, outerTagDepth + 1));
                break;
            case XML_TAG_SECTION_HEADER_SIM_CREDENTIAL:
                credential.setSimCredential(deserializeSimCredential(in, outerTagDepth + 1));
                break;
            default:
                throw new XmlPullParserException("Unknown data under Credential: " + headerName[0]);
        }
    }
    return credential;
}
#method_after
private static Credential deserializeCredential(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Credential credential = new Credential();
    while (XmlUtils.nextElementWithin(in, outerTagDepth)) {
        if (isValueElement(in)) {
            // Value elements.
            String[] name = new String[1];
            Object value = XmlUtil.readCurrentValue(in, name);
            switch(name[0]) {
                case XML_TAG_CREATION_TIME:
                    credential.setCreationTimeInMs((long) value);
                    break;
                case XML_TAG_EXPIRATION_TIME:
                    credential.setExpirationTimeInMs((long) value);
                    break;
                case XML_TAG_REALM:
                    credential.setRealm((String) value);
                    break;
                case XML_TAG_CHECK_AAA_SERVER_CERT_STATUS:
                    credential.setCheckAaaServerCertStatus((boolean) value);
                    break;
                default:
                    throw new XmlPullParserException("Unknown value under Credential: " + name[0]);
            }
        } else {
            // Subsection elements.
            switch(in.getName()) {
                case XML_TAG_SECTION_HEADER_USER_CREDENTIAL:
                    credential.setUserCredential(deserializeUserCredential(in, outerTagDepth + 1));
                    break;
                case XML_TAG_SECTION_HEADER_CERT_CREDENTIAL:
                    credential.setCertCredential(deserializeCertCredential(in, outerTagDepth + 1));
                    break;
                case XML_TAG_SECTION_HEADER_SIM_CREDENTIAL:
                    credential.setSimCredential(deserializeSimCredential(in, outerTagDepth + 1));
                    break;
                default:
                    throw new XmlPullParserException("Unknown section under Credential: " + in.getName());
            }
        }
    }
    return credential;
}
#end_block

#method_before
private static Policy deserializePolicy(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Policy policy = new Policy();
    policy.setMinHomeDownlinkBandwidth((long) XmlUtil.readNextValueWithName(in, XML_TAG_MIN_HOME_DOWNLINK_BANDWIDTH));
    policy.setMinHomeUplinkBandwidth((long) XmlUtil.readNextValueWithName(in, XML_TAG_MIN_HOME_UPLINK_BANDWIDTH));
    policy.setMinRoamingDownlinkBandwidth((long) XmlUtil.readNextValueWithName(in, XML_TAG_MIN_ROAMING_DOWNLINK_BANDWIDTH));
    policy.setMinRoamingUplinkBandwidth((long) XmlUtil.readNextValueWithName(in, XML_TAG_MIN_ROAMING_UPLINK_BANDWIDTH));
    policy.setExcludedSsidList((String[]) XmlUtil.readNextValueWithName(in, XML_TAG_EXCLUDED_SSID_LIST));
    policy.setMaximumBssLoadValue((int) XmlUtil.readNextValueWithName(in, XML_TAG_MAXIMUM_BSS_LOAD_VALUE));
    String[] headerName = new String[1];
    while (XmlUtil.gotoNextSectionOrEnd(in, headerName, outerTagDepth)) {
        switch(headerName[0]) {
            case XML_TAG_SECTION_HEADER_REQUIRED_PROTO_PORT_MAP:
                policy.setRequiredProtoPortMap(deserializeProtoPortMap(in, outerTagDepth + 1));
                break;
            case XML_TAG_SECTION_HEADER_POLICY_UPDATE:
                policy.setPolicyUpdate(deserializeUpdateParameter(in, outerTagDepth + 1));
                break;
            case XML_TAG_SECTION_HEADER_PREFERRED_ROAMING_PARTNER_LIST:
                policy.setPreferredRoamingPartnerList(deserializePreferredRoamingPartnerList(in, outerTagDepth + 1));
                break;
            default:
                throw new XmlPullParserException("Unknown data under Policy: " + headerName[0]);
        }
    }
    return policy;
}
#method_after
private static Policy deserializePolicy(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Policy policy = new Policy();
    while (XmlUtils.nextElementWithin(in, outerTagDepth)) {
        if (isValueElement(in)) {
            // Value elements.
            String[] name = new String[1];
            Object value = XmlUtil.readCurrentValue(in, name);
            switch(name[0]) {
                case XML_TAG_MIN_HOME_DOWNLINK_BANDWIDTH:
                    policy.setMinHomeDownlinkBandwidth((long) value);
                    break;
                case XML_TAG_MIN_HOME_UPLINK_BANDWIDTH:
                    policy.setMinHomeUplinkBandwidth((long) value);
                    break;
                case XML_TAG_MIN_ROAMING_DOWNLINK_BANDWIDTH:
                    policy.setMinRoamingDownlinkBandwidth((long) value);
                    break;
                case XML_TAG_MIN_ROAMING_UPLINK_BANDWIDTH:
                    policy.setMinRoamingUplinkBandwidth((long) value);
                    break;
                case XML_TAG_EXCLUDED_SSID_LIST:
                    policy.setExcludedSsidList((String[]) value);
                    break;
                case XML_TAG_MAXIMUM_BSS_LOAD_VALUE:
                    policy.setMaximumBssLoadValue((int) value);
                    break;
            }
        } else {
            // Subsection elements.
            switch(in.getName()) {
                case XML_TAG_SECTION_HEADER_REQUIRED_PROTO_PORT_MAP:
                    policy.setRequiredProtoPortMap(deserializeProtoPortMap(in, outerTagDepth + 1));
                    break;
                case XML_TAG_SECTION_HEADER_POLICY_UPDATE:
                    policy.setPolicyUpdate(deserializeUpdateParameter(in, outerTagDepth + 1));
                    break;
                case XML_TAG_SECTION_HEADER_PREFERRED_ROAMING_PARTNER_LIST:
                    policy.setPreferredRoamingPartnerList(deserializePreferredRoamingPartnerList(in, outerTagDepth + 1));
                    break;
                default:
                    throw new XmlPullParserException("Unknown section under Policy: " + in.getName());
            }
        }
    }
    return policy;
}
#end_block

#method_before
private static Credential.UserCredential deserializeUserCredential(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Credential.UserCredential userCredential = new Credential.UserCredential();
    userCredential.setUsername((String) XmlUtil.readNextValueWithName(in, XML_TAG_USERNAME));
    userCredential.setPassword((String) XmlUtil.readNextValueWithName(in, XML_TAG_PASSWORD));
    userCredential.setMachineManaged((boolean) XmlUtil.readNextValueWithName(in, XML_TAG_MACHINE_MANAGED));
    userCredential.setSoftTokenApp((String) XmlUtil.readNextValueWithName(in, XML_TAG_SOFT_TOKEN_APP));
    userCredential.setAbleToShare((boolean) XmlUtil.readNextValueWithName(in, XML_TAG_ABLE_TO_SHARE));
    userCredential.setEapType((int) XmlUtil.readNextValueWithName(in, XML_TAG_EAP_TYPE));
    userCredential.setNonEapInnerMethod((String) XmlUtil.readNextValueWithName(in, XML_TAG_NON_EAP_INNER_METHOD));
    return userCredential;
}
#method_after
private static Credential.UserCredential deserializeUserCredential(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Credential.UserCredential userCredential = new Credential.UserCredential();
    while (!XmlUtil.isNextSectionEnd(in, outerTagDepth)) {
        String[] valueName = new String[1];
        Object value = XmlUtil.readCurrentValue(in, valueName);
        if (valueName[0] == null) {
            throw new XmlPullParserException("Missing value name");
        }
        switch(valueName[0]) {
            case XML_TAG_USERNAME:
                userCredential.setUsername((String) value);
                break;
            case XML_TAG_PASSWORD:
                userCredential.setPassword((String) value);
                break;
            case XML_TAG_MACHINE_MANAGED:
                userCredential.setMachineManaged((boolean) value);
                break;
            case XML_TAG_SOFT_TOKEN_APP:
                userCredential.setSoftTokenApp((String) value);
                break;
            case XML_TAG_ABLE_TO_SHARE:
                userCredential.setAbleToShare((boolean) value);
                break;
            case XML_TAG_EAP_TYPE:
                userCredential.setEapType((int) value);
                break;
            case XML_TAG_NON_EAP_INNER_METHOD:
                userCredential.setNonEapInnerMethod((String) value);
                break;
            default:
                throw new XmlPullParserException("Unknown value under UserCredential: " + valueName[0]);
        }
    }
    return userCredential;
}
#end_block

#method_before
private static Credential.CertificateCredential deserializeCertCredential(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
    certCredential.setCertType((String) XmlUtil.readNextValueWithName(in, XML_TAG_CERT_TYPE));
    certCredential.setCertSha256Fingerprint((byte[]) XmlUtil.readNextValueWithName(in, XML_TAG_CERT_SHA256_FINGERPRINT));
    return certCredential;
}
#method_after
private static Credential.CertificateCredential deserializeCertCredential(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
    while (!XmlUtil.isNextSectionEnd(in, outerTagDepth)) {
        String[] valueName = new String[1];
        Object value = XmlUtil.readCurrentValue(in, valueName);
        if (valueName[0] == null) {
            throw new XmlPullParserException("Missing value name");
        }
        switch(valueName[0]) {
            case XML_TAG_CERT_TYPE:
                certCredential.setCertType((String) value);
                break;
            case XML_TAG_CERT_SHA256_FINGERPRINT:
                certCredential.setCertSha256Fingerprint((byte[]) value);
                break;
            default:
                throw new XmlPullParserException("Unknown value under CertCredential: " + valueName[0]);
        }
    }
    return certCredential;
}
#end_block

#method_before
private static Credential.SimCredential deserializeSimCredential(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Credential.SimCredential simCredential = new Credential.SimCredential();
    simCredential.setImsi((String) XmlUtil.readNextValueWithName(in, XML_TAG_IMSI));
    simCredential.setEapType((int) XmlUtil.readNextValueWithName(in, XML_TAG_EAP_TYPE));
    return simCredential;
}
#method_after
private static Credential.SimCredential deserializeSimCredential(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    Credential.SimCredential simCredential = new Credential.SimCredential();
    while (!XmlUtil.isNextSectionEnd(in, outerTagDepth)) {
        String[] valueName = new String[1];
        Object value = XmlUtil.readCurrentValue(in, valueName);
        if (valueName[0] == null) {
            throw new XmlPullParserException("Missing value name");
        }
        switch(valueName[0]) {
            case XML_TAG_IMSI:
                simCredential.setImsi((String) value);
                break;
            case XML_TAG_EAP_TYPE:
                simCredential.setEapType((int) value);
                break;
            default:
                throw new XmlPullParserException("Unknown value under CertCredential: " + valueName[0]);
        }
    }
    return simCredential;
}
#end_block

#method_before
private static List<Policy.RoamingPartner> deserializePreferredRoamingPartnerList(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    List<Policy.RoamingPartner> roamingPartnerList = new ArrayList<>();
    while (XmlUtil.gotoNextSectionWithNameOrEnd(in, XML_TAG_SECTION_HEADER_ROAMING_PARTNER, outerTagDepth)) {
        Policy.RoamingPartner partner = new Policy.RoamingPartner();
        partner.setFqdn((String) XmlUtil.readNextValueWithName(in, XML_TAG_FQDN));
        partner.setFqdnExactMatch((boolean) XmlUtil.readNextValueWithName(in, XML_TAG_FQDN_EXACT_MATCH));
        partner.setPriority((int) XmlUtil.readNextValueWithName(in, XML_TAG_PRIORITY));
        partner.setCountries((String) XmlUtil.readNextValueWithName(in, XML_TAG_COUNTRIES));
        roamingPartnerList.add(partner);
    }
    return roamingPartnerList;
}
#method_after
private static List<Policy.RoamingPartner> deserializePreferredRoamingPartnerList(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    List<Policy.RoamingPartner> roamingPartnerList = new ArrayList<>();
    while (XmlUtil.gotoNextSectionWithNameOrEnd(in, XML_TAG_SECTION_HEADER_ROAMING_PARTNER, outerTagDepth)) {
        roamingPartnerList.add(deserializeRoamingPartner(in, outerTagDepth + 1));
    }
    return roamingPartnerList;
}
#end_block

#method_before
private static UpdateParameter deserializeUpdateParameter(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    UpdateParameter param = new UpdateParameter();
    param.setUpdateIntervalInMinutes((long) XmlUtil.readNextValueWithName(in, XML_TAG_UPDATE_INTERVAL));
    param.setUpdateMethod((String) XmlUtil.readNextValueWithName(in, XML_TAG_UPDATE_METHOD));
    param.setRestriction((String) XmlUtil.readNextValueWithName(in, XML_TAG_RESTRICTION));
    param.setServerUri((String) XmlUtil.readNextValueWithName(in, XML_TAG_SERVER_URI));
    param.setUsername((String) XmlUtil.readNextValueWithName(in, XML_TAG_USERNAME));
    param.setBase64EncodedPassword((String) XmlUtil.readNextValueWithName(in, XML_TAG_PASSWORD));
    param.setTrustRootCertUrl((String) XmlUtil.readNextValueWithName(in, XML_TAG_TRUST_ROOT_CERT_URL));
    param.setTrustRootCertSha256Fingerprint((byte[]) XmlUtil.readNextValueWithName(in, XML_TAG_TRUST_ROOT_CERT_SHA256_FINGERPRINT));
    return param;
}
#method_after
private static UpdateParameter deserializeUpdateParameter(XmlPullParser in, int outerTagDepth) throws XmlPullParserException, IOException {
    UpdateParameter param = new UpdateParameter();
    while (!XmlUtil.isNextSectionEnd(in, outerTagDepth)) {
        String[] valueName = new String[1];
        Object value = XmlUtil.readCurrentValue(in, valueName);
        if (valueName[0] == null) {
            throw new XmlPullParserException("Missing value name");
        }
        switch(valueName[0]) {
            case XML_TAG_UPDATE_INTERVAL:
                param.setUpdateIntervalInMinutes((long) value);
                break;
            case XML_TAG_UPDATE_METHOD:
                param.setUpdateMethod((String) value);
                break;
            case XML_TAG_RESTRICTION:
                param.setRestriction((String) value);
                break;
            case XML_TAG_SERVER_URI:
                param.setServerUri((String) value);
                break;
            case XML_TAG_USERNAME:
                param.setUsername((String) value);
                break;
            case XML_TAG_PASSWORD:
                param.setBase64EncodedPassword((String) value);
                break;
            case XML_TAG_TRUST_ROOT_CERT_URL:
                param.setTrustRootCertUrl((String) value);
                break;
            case XML_TAG_TRUST_ROOT_CERT_SHA256_FINGERPRINT:
                param.setTrustRootCertSha256Fingerprint((byte[]) value);
                break;
            default:
                throw new XmlPullParserException("Unknown value under UpdateParameter: " + valueName[0]);
        }
    }
    return param;
}
#end_block

#method_before
@Test
public void serializeAndDeserializeFullPasspointConfiguration() throws Exception {
    verifyPasspointConfigurationSerialization(createFullPasspointConfiguration());
}
#method_after
@Test
public void serializeAndDeserializeFullPasspointConfiguration() throws Exception {
    serializeAndDeserializePasspointConfiguration(createFullPasspointConfiguration());
}
#end_block

#method_before
private void handleWpsFailEvent(String dataString, String iface) {
    final Pattern p = Pattern.compile(WPS_FAIL_PATTERN);
    Matcher match = p.matcher(dataString);
    int reasonInt = 0;
    int cfgErrInt = 0;
    if (match.find()) {
        String cfgErrStr = match.group(1);
        String reasonStr = match.group(2);
        if (reasonStr != null) {
            reasonInt = Integer.parseInt(reasonStr);
        }
        if (cfgErrStr != null) {
            cfgErrInt = Integer.parseInt(cfgErrStr);
        }
    }
    handleWpsFailEvent(iface, cfgErrInt, reasonInt);
}
#method_after
private void handleWpsFailEvent(String dataString, String iface) {
    final Pattern p = Pattern.compile(WPS_FAIL_PATTERN);
    Matcher match = p.matcher(dataString);
    int vendorErrorCodeInt = 0;
    int cfgErrInt = 0;
    if (match.find()) {
        String cfgErrStr = match.group(1);
        String vendorErrorCodeStr = match.group(2);
        if (vendorErrorCodeStr != null) {
            vendorErrorCodeInt = Integer.parseInt(vendorErrorCodeStr);
        }
        if (cfgErrStr != null) {
            cfgErrInt = Integer.parseInt(cfgErrStr);
        }
    }
    broadcastWpsFailEvent(iface, cfgErrInt, vendorErrorCodeInt);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    final Constructor<WifiMonitor> wifiMonitorConstructor = WifiMonitor.class.getDeclaredConstructor();
    wifiMonitorConstructor.setAccessible(true);
    mWifiMonitor = spy(wifiMonitorConstructor.newInstance());
    mLooper = new TestLooper();
    mHandler = new Handler(mLooper.getLooper());
    mHandlerSpy = spy(mHandler);
    mWifiMonitor.setMonitoring(WLAN_IFACE_NAME, true);
}
#method_after
@Before
public void setUp() throws Exception {
    final Constructor<WifiMonitor> wifiMonitorConstructor = WifiMonitor.class.getDeclaredConstructor();
    wifiMonitorConstructor.setAccessible(true);
    mWifiMonitor = spy(wifiMonitorConstructor.newInstance());
    mLooper = new TestLooper();
    mHandlerSpy = spy(new Handler(mLooper.getLooper()));
    mWifiMonitor.setMonitoring(WLAN_IFACE_NAME, true);
}
#end_block

#method_before
private boolean dispatchEvent(String eventStr, String iface) {
    if (mVerboseLoggingEnabled) {
        // Dont log CTRL-EVENT-BSS-ADDED which are too verbose and not handled
        if (eventStr != null && !eventStr.contains("CTRL-EVENT-BSS-ADDED")) {
            Log.d(TAG, iface + " cnt=" + Integer.toString(eventLogCounter) + " dispatchEvent: " + eventStr);
        }
    }
    if (!eventStr.startsWith(EVENT_PREFIX_STR)) {
        if (eventStr.startsWith(WPS_SUCCESS_STR)) {
            handleWpsSuccessEvent(iface);
        } else if (eventStr.startsWith(WPS_FAIL_STR)) {
            handleWpsFailEvent(eventStr, iface);
        } else if (eventStr.startsWith(WPS_OVERLAP_STR)) {
            handleWpsOverlapEvent(iface);
        } else if (eventStr.startsWith(WPS_TIMEOUT_STR)) {
            handleWpsTimeoutEvent(iface);
        } else if (eventStr.startsWith(P2P_EVENT_PREFIX_STR)) {
            handleP2pEvents(eventStr, iface);
        } else if (eventStr.startsWith(HOST_AP_EVENT_PREFIX_STR)) {
            handleHostApEvents(eventStr, iface);
        } else if (eventStr.startsWith(ANQP_DONE_STR)) {
            try {
                handleAnqpResult(eventStr, iface);
            } catch (IllegalArgumentException iae) {
                Log.e(TAG, "Bad ANQP event string: '" + eventStr + "': " + iae);
            }
        } else if (eventStr.startsWith(HS20_ICON_STR)) {
            try {
                handleIconResult(eventStr, iface);
            } catch (IllegalArgumentException iae) {
                Log.e(TAG, "Bad Icon event string: '" + eventStr + "': " + iae);
            }
        } else if (eventStr.startsWith(HS20_SUB_REM_STR)) {
            // Tack on the last connected BSSID so we have some idea what AP the WNM pertains to
            handleWnmFrame(String.format("%012x %s", mLastConnectBSSIDs.get(iface), eventStr), iface);
        } else if (eventStr.startsWith(HS20_DEAUTH_STR)) {
            handleWnmFrame(String.format("%012x %s", mLastConnectBSSIDs.get(iface), eventStr), iface);
        } else if (eventStr.startsWith(REQUEST_PREFIX_STR)) {
            handleRequests(eventStr, iface);
        } else if (eventStr.startsWith(TARGET_BSSID_STR)) {
            handleTargetBSSIDEvent(eventStr, iface);
        } else if (eventStr.startsWith(ASSOCIATED_WITH_STR)) {
            handleAssociatedBSSIDEvent(eventStr, iface);
        } else if (eventStr.startsWith(AUTH_EVENT_PREFIX_STR) && eventStr.endsWith(AUTH_TIMEOUT_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_TIMEOUT);
        } else if (eventStr.startsWith(WPA_EVENT_PREFIX_STR) && eventStr.endsWith(PASSWORD_MAY_BE_INCORRECT_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_WRONG_PSWD);
        } else {
            if (mVerboseLoggingEnabled) {
                Log.w(TAG, "couldn't identify event type - " + eventStr);
            }
        }
        eventLogCounter++;
        return false;
    }
    String eventName = eventStr.substring(EVENT_PREFIX_LEN_STR);
    int nameEnd = eventName.indexOf(' ');
    if (nameEnd != -1)
        eventName = eventName.substring(0, nameEnd);
    if (eventName.length() == 0) {
        if (mVerboseLoggingEnabled) {
            Log.i(TAG, "Received wpa_supplicant event with empty event name");
        }
        eventLogCounter++;
        return false;
    }
    /*
        * Map event name into event enum
        */
    int event;
    if (eventName.equals(CONNECTED_STR)) {
        event = CONNECTED;
        long bssid = -1L;
        int prefix = eventStr.indexOf(ConnectPrefix);
        if (prefix >= 0) {
            int suffix = eventStr.indexOf(ConnectSuffix);
            if (suffix > prefix) {
                try {
                    bssid = Utils.parseMac(eventStr.substring(prefix + ConnectPrefix.length(), suffix));
                } catch (IllegalArgumentException iae) {
                    bssid = -1L;
                }
            }
        }
        mLastConnectBSSIDs.put(iface, bssid);
        if (bssid == -1L) {
            Log.w(TAG, "Failed to parse out BSSID from '" + eventStr + "'");
        }
    } else if (eventName.equals(DISCONNECTED_STR))
        event = DISCONNECTED;
    else if (eventName.equals(STATE_CHANGE_STR))
        event = STATE_CHANGE;
    else if (eventName.equals(SCAN_RESULTS_STR))
        event = SCAN_RESULTS;
    else if (eventName.equals(SCAN_FAILED_STR))
        event = SCAN_FAILED;
    else if (eventName.equals(LINK_SPEED_STR))
        event = LINK_SPEED;
    else if (eventName.equals(TERMINATING_STR))
        event = TERMINATING;
    else if (eventName.equals(DRIVER_STATE_STR))
        event = DRIVER_STATE;
    else if (eventName.equals(EAP_FAILURE_STR))
        event = EAP_FAILURE;
    else if (eventName.equals(ASSOC_REJECT_STR))
        event = ASSOC_REJECT;
    else if (eventName.equals(TEMP_DISABLED_STR)) {
        event = SSID_TEMP_DISABLE;
    } else if (eventName.equals(REENABLED_STR)) {
        event = SSID_REENABLE;
    } else if (eventName.equals(BSS_ADDED_STR)) {
        event = BSS_ADDED;
    } else if (eventName.equals(BSS_REMOVED_STR)) {
        event = BSS_REMOVED;
    } else
        event = UNKNOWN;
    String eventData = eventStr;
    if (event == DRIVER_STATE || event == LINK_SPEED)
        eventData = eventData.split(" ")[1];
    else if (event == STATE_CHANGE || event == EAP_FAILURE) {
        int ind = eventStr.indexOf(" ");
        if (ind != -1) {
            eventData = eventStr.substring(ind + 1);
        }
    } else {
        int ind = eventStr.indexOf(" - ");
        if (ind != -1) {
            eventData = eventStr.substring(ind + 3);
        }
    }
    if ((event == SSID_TEMP_DISABLE) || (event == SSID_REENABLE)) {
        String substr = null;
        int netId = -1;
        int ind = eventStr.indexOf(" ");
        if (ind != -1) {
            substr = eventStr.substring(ind + 1);
        }
        if (substr != null) {
            String[] status = substr.split(" ");
            for (String key : status) {
                if (key.regionMatches(0, "id=", 0, 3)) {
                    int idx = 3;
                    netId = 0;
                    while (idx < key.length()) {
                        char c = key.charAt(idx);
                        if ((c >= 0x30) && (c <= 0x39)) {
                            netId *= 10;
                            netId += c - 0x30;
                            idx++;
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        sendMessage(iface, (event == SSID_TEMP_DISABLE) ? SSID_TEMP_DISABLED : SSID_REENABLED, netId, 0, substr);
    } else if (event == STATE_CHANGE) {
        handleSupplicantStateChange(eventData, iface);
    } else if (event == DRIVER_STATE) {
        handleDriverEvent(eventData, iface);
    } else if (event == TERMINATING) {
        /**
         * Close the supplicant connection if we see
         * too many recv errors
         */
        if (eventData.startsWith(WPA_RECV_ERROR_STR)) {
            if (++mRecvErrors > MAX_RECV_ERRORS) {
                if (mVerboseLoggingEnabled) {
                    Log.d(TAG, "too many recv errors, closing connection");
                }
            } else {
                eventLogCounter++;
                return false;
            }
        }
        // Notify and exit
        sendMessage(null, SUP_DISCONNECTION_EVENT, eventLogCounter);
        return true;
    } else if (event == EAP_FAILURE) {
        if (eventData.startsWith(EAP_AUTH_FAILURE_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_EAP_FAILURE);
        }
    } else if (event == ASSOC_REJECT) {
        Matcher match = mAssocRejectEventPattern.matcher(eventData);
        String BSSID = "";
        int status = -1;
        if (!match.find()) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, "Assoc Reject: Could not parse assoc reject string");
            }
        } else {
            int groupNumber = match.groupCount();
            int statusGroupNumber = -1;
            if (groupNumber == 2) {
                BSSID = match.group(1);
                statusGroupNumber = 2;
            } else {
                // Under such case Supplicant does not report BSSID
                BSSID = null;
                statusGroupNumber = 1;
            }
            try {
                status = Integer.parseInt(match.group(statusGroupNumber));
            } catch (NumberFormatException e) {
                status = -1;
            }
        }
        sendMessage(iface, ASSOCIATION_REJECTION_EVENT, eventLogCounter, status, BSSID);
    } else if (event == BSS_ADDED && !DBG) {
    // Ignore that event - it is not handled, and dont log it as it is too verbose
    } else if (event == BSS_REMOVED && !DBG) {
    // Ignore that event - it is not handled, and dont log it as it is too verbose
    } else {
        handleEvent(event, eventData, iface);
    }
    mRecvErrors = 0;
    eventLogCounter++;
    return false;
}
#method_after
private boolean dispatchEvent(String eventStr, String iface) {
    if (mVerboseLoggingEnabled) {
        // Dont log CTRL-EVENT-BSS-ADDED which are too verbose and not handled
        if (eventStr != null && !eventStr.contains("CTRL-EVENT-BSS-ADDED")) {
            Log.d(TAG, iface + " cnt=" + Integer.toString(eventLogCounter) + " dispatchEvent: " + eventStr);
        }
    }
    if (!eventStr.startsWith(EVENT_PREFIX_STR)) {
        if (eventStr.startsWith(WPS_SUCCESS_STR)) {
            broadcastWpsSuccessEvent(iface);
        } else if (eventStr.startsWith(WPS_FAIL_STR)) {
            handleWpsFailEvent(eventStr, iface);
        } else if (eventStr.startsWith(WPS_OVERLAP_STR)) {
            broadcastWpsOverlapEvent(iface);
        } else if (eventStr.startsWith(WPS_TIMEOUT_STR)) {
            broadcastWpsTimeoutEvent(iface);
        } else if (eventStr.startsWith(P2P_EVENT_PREFIX_STR)) {
            handleP2pEvents(eventStr, iface);
        } else if (eventStr.startsWith(HOST_AP_EVENT_PREFIX_STR)) {
            handleHostApEvents(eventStr, iface);
        } else if (eventStr.startsWith(ANQP_DONE_STR)) {
            try {
                handleAnqpResult(eventStr, iface);
            } catch (IllegalArgumentException iae) {
                Log.e(TAG, "Bad ANQP event string: '" + eventStr + "': " + iae);
            }
        } else if (eventStr.startsWith(HS20_ICON_STR)) {
            try {
                handleIconResult(eventStr, iface);
            } catch (IllegalArgumentException iae) {
                Log.e(TAG, "Bad Icon event string: '" + eventStr + "': " + iae);
            }
        } else if (eventStr.startsWith(HS20_SUB_REM_STR)) {
            // Tack on the last connected BSSID so we have some idea what AP the WNM pertains to
            handleWnmFrame(String.format("%012x %s", mLastConnectBSSIDs.get(iface), eventStr), iface);
        } else if (eventStr.startsWith(HS20_DEAUTH_STR)) {
            handleWnmFrame(String.format("%012x %s", mLastConnectBSSIDs.get(iface), eventStr), iface);
        } else if (eventStr.startsWith(REQUEST_PREFIX_STR)) {
            handleRequests(eventStr, iface);
        } else if (eventStr.startsWith(TARGET_BSSID_STR)) {
            handleTargetBSSIDEvent(eventStr, iface);
        } else if (eventStr.startsWith(ASSOCIATED_WITH_STR)) {
            handleAssociatedBSSIDEvent(eventStr, iface);
        } else if (eventStr.startsWith(AUTH_EVENT_PREFIX_STR) && eventStr.endsWith(AUTH_TIMEOUT_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_TIMEOUT);
        } else if (eventStr.startsWith(WPA_EVENT_PREFIX_STR) && eventStr.endsWith(PASSWORD_MAY_BE_INCORRECT_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_WRONG_PSWD);
        } else {
            if (mVerboseLoggingEnabled) {
                Log.w(TAG, "couldn't identify event type - " + eventStr);
            }
        }
        eventLogCounter++;
        return false;
    }
    String eventName = eventStr.substring(EVENT_PREFIX_LEN_STR);
    int nameEnd = eventName.indexOf(' ');
    if (nameEnd != -1)
        eventName = eventName.substring(0, nameEnd);
    if (eventName.length() == 0) {
        if (mVerboseLoggingEnabled) {
            Log.i(TAG, "Received wpa_supplicant event with empty event name");
        }
        eventLogCounter++;
        return false;
    }
    /*
        * Map event name into event enum
        */
    int event;
    if (eventName.equals(CONNECTED_STR)) {
        event = CONNECTED;
        long bssid = -1L;
        int prefix = eventStr.indexOf(ConnectPrefix);
        if (prefix >= 0) {
            int suffix = eventStr.indexOf(ConnectSuffix);
            if (suffix > prefix) {
                try {
                    bssid = Utils.parseMac(eventStr.substring(prefix + ConnectPrefix.length(), suffix));
                } catch (IllegalArgumentException iae) {
                    bssid = -1L;
                }
            }
        }
        mLastConnectBSSIDs.put(iface, bssid);
        if (bssid == -1L) {
            Log.w(TAG, "Failed to parse out BSSID from '" + eventStr + "'");
        }
    } else if (eventName.equals(DISCONNECTED_STR))
        event = DISCONNECTED;
    else if (eventName.equals(STATE_CHANGE_STR))
        event = STATE_CHANGE;
    else if (eventName.equals(SCAN_RESULTS_STR))
        event = SCAN_RESULTS;
    else if (eventName.equals(SCAN_FAILED_STR))
        event = SCAN_FAILED;
    else if (eventName.equals(LINK_SPEED_STR))
        event = LINK_SPEED;
    else if (eventName.equals(TERMINATING_STR))
        event = TERMINATING;
    else if (eventName.equals(DRIVER_STATE_STR))
        event = DRIVER_STATE;
    else if (eventName.equals(EAP_FAILURE_STR))
        event = EAP_FAILURE;
    else if (eventName.equals(ASSOC_REJECT_STR))
        event = ASSOC_REJECT;
    else if (eventName.equals(TEMP_DISABLED_STR)) {
        event = SSID_TEMP_DISABLE;
    } else if (eventName.equals(REENABLED_STR)) {
        event = SSID_REENABLE;
    } else if (eventName.equals(BSS_ADDED_STR)) {
        event = BSS_ADDED;
    } else if (eventName.equals(BSS_REMOVED_STR)) {
        event = BSS_REMOVED;
    } else
        event = UNKNOWN;
    String eventData = eventStr;
    if (event == DRIVER_STATE || event == LINK_SPEED)
        eventData = eventData.split(" ")[1];
    else if (event == STATE_CHANGE || event == EAP_FAILURE) {
        int ind = eventStr.indexOf(" ");
        if (ind != -1) {
            eventData = eventStr.substring(ind + 1);
        }
    } else {
        int ind = eventStr.indexOf(" - ");
        if (ind != -1) {
            eventData = eventStr.substring(ind + 3);
        }
    }
    if ((event == SSID_TEMP_DISABLE) || (event == SSID_REENABLE)) {
        String substr = null;
        int netId = -1;
        int ind = eventStr.indexOf(" ");
        if (ind != -1) {
            substr = eventStr.substring(ind + 1);
        }
        if (substr != null) {
            String[] status = substr.split(" ");
            for (String key : status) {
                if (key.regionMatches(0, "id=", 0, 3)) {
                    int idx = 3;
                    netId = 0;
                    while (idx < key.length()) {
                        char c = key.charAt(idx);
                        if ((c >= 0x30) && (c <= 0x39)) {
                            netId *= 10;
                            netId += c - 0x30;
                            idx++;
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        sendMessage(iface, (event == SSID_TEMP_DISABLE) ? SSID_TEMP_DISABLED : SSID_REENABLED, netId, 0, substr);
    } else if (event == STATE_CHANGE) {
        handleSupplicantStateChange(eventData, iface);
    } else if (event == DRIVER_STATE) {
        handleDriverEvent(eventData, iface);
    } else if (event == TERMINATING) {
        /**
         * Close the supplicant connection if we see
         * too many recv errors
         */
        if (eventData.startsWith(WPA_RECV_ERROR_STR)) {
            if (++mRecvErrors > MAX_RECV_ERRORS) {
                if (mVerboseLoggingEnabled) {
                    Log.d(TAG, "too many recv errors, closing connection");
                }
            } else {
                eventLogCounter++;
                return false;
            }
        }
        // Notify and exit
        sendMessage(null, SUP_DISCONNECTION_EVENT, eventLogCounter);
        return true;
    } else if (event == EAP_FAILURE) {
        if (eventData.startsWith(EAP_AUTH_FAILURE_STR)) {
            sendMessage(iface, AUTHENTICATION_FAILURE_EVENT, eventLogCounter, AUTHENTICATION_FAILURE_REASON_EAP_FAILURE);
        }
    } else if (event == ASSOC_REJECT) {
        Matcher match = mAssocRejectEventPattern.matcher(eventData);
        String BSSID = "";
        int status = -1;
        if (!match.find()) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, "Assoc Reject: Could not parse assoc reject string");
            }
        } else {
            int groupNumber = match.groupCount();
            int statusGroupNumber = -1;
            if (groupNumber == 2) {
                BSSID = match.group(1);
                statusGroupNumber = 2;
            } else {
                // Under such case Supplicant does not report BSSID
                BSSID = null;
                statusGroupNumber = 1;
            }
            try {
                status = Integer.parseInt(match.group(statusGroupNumber));
            } catch (NumberFormatException e) {
                status = -1;
            }
        }
        sendMessage(iface, ASSOCIATION_REJECTION_EVENT, eventLogCounter, status, BSSID);
    } else if (event == BSS_ADDED && !DBG) {
    // Ignore that event - it is not handled, and dont log it as it is too verbose
    } else if (event == BSS_REMOVED && !DBG) {
    // Ignore that event - it is not handled, and dont log it as it is too verbose
    } else {
        handleEvent(event, eventData, iface);
    }
    mRecvErrors = 0;
    eventLogCounter++;
    return false;
}
#end_block

#method_before
private void handleWpsFailEvent(String dataString, String iface) {
    final Pattern p = Pattern.compile(WPS_FAIL_PATTERN);
    Matcher match = p.matcher(dataString);
    int reasonInt = 0;
    int cfgErrInt = 0;
    if (match.find()) {
        String cfgErrStr = match.group(1);
        String reasonStr = match.group(2);
        if (reasonStr != null) {
            reasonInt = Integer.parseInt(reasonStr);
        }
        if (cfgErrStr != null) {
            cfgErrInt = Integer.parseInt(cfgErrStr);
        }
    }
    handleWpsFailEvent(iface, cfgErrInt, reasonInt);
}
#method_after
private void handleWpsFailEvent(String dataString, String iface) {
    final Pattern p = Pattern.compile(WPS_FAIL_PATTERN);
    Matcher match = p.matcher(dataString);
    int vendorErrorCodeInt = 0;
    int cfgErrInt = 0;
    if (match.find()) {
        String cfgErrStr = match.group(1);
        String vendorErrorCodeStr = match.group(2);
        if (vendorErrorCodeStr != null) {
            vendorErrorCodeInt = Integer.parseInt(vendorErrorCodeStr);
        }
        if (cfgErrStr != null) {
            cfgErrInt = Integer.parseInt(cfgErrStr);
        }
    }
    broadcastWpsFailEvent(iface, cfgErrInt, vendorErrorCodeInt);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    final Constructor<WifiMonitor> wifiMonitorConstructor = WifiMonitor.class.getDeclaredConstructor();
    wifiMonitorConstructor.setAccessible(true);
    mWifiMonitor = spy(wifiMonitorConstructor.newInstance());
    mLooper = new TestLooper();
    mHandler = new Handler(mLooper.getLooper());
    mHandlerSpy = spy(mHandler);
    mWifiMonitor.setMonitoring(WLAN_IFACE_NAME, true);
}
#method_after
@Before
public void setUp() throws Exception {
    final Constructor<WifiMonitor> wifiMonitorConstructor = WifiMonitor.class.getDeclaredConstructor();
    wifiMonitorConstructor.setAccessible(true);
    mWifiMonitor = spy(wifiMonitorConstructor.newInstance());
    mLooper = new TestLooper();
    mHandlerSpy = spy(new Handler(mLooper.getLooper()));
    mWifiMonitor.setMonitoring(WLAN_IFACE_NAME, true);
}
#end_block

#method_before
private IRadio getRadioProxy(Message result) {
    if (!mIsMobileNetworkSupported) {
        riljLog("Not calling getService(): wifi-only");
        return null;
    }
    if (mRadioProxy != null) {
        return mRadioProxy;
    }
    try {
        mRadioProxy = IRadio.getService(SOCKET_NAME_RIL[mPhoneId == null ? 0 : mPhoneId]);
        if (mRadioProxy != null) {
            mRadioProxy.linkToDeath(mRadioProxyDeathRecipient, mRadioProxyCookie.incrementAndGet());
            mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
        } else {
            riljLoge("getRadioProxy: radioProxy == null");
        }
    } catch (RemoteException | RuntimeException e) {
        mRadioProxy = null;
        if (result != null) {
            AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
            result.sendToTarget();
        }
        // if service is not up, treat it like death notification to try to get service again
        mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.get()), IRADIO_GET_SERVICE_DELAY_MILLIS);
        riljLoge("setResponseFunctions", e);
    }
    return mRadioProxy;
}
#method_after
private IRadio getRadioProxy(Message result) {
    if (!mIsMobileNetworkSupported) {
        if (RILJ_LOGV)
            riljLog("Not calling getService(): wifi-only");
        return null;
    }
    if (mRadioProxy != null) {
        return mRadioProxy;
    }
    try {
        mRadioProxy = IRadio.getService(SOCKET_NAME_RIL[mPhoneId == null ? 0 : mPhoneId]);
        if (mRadioProxy != null) {
            mRadioProxy.linkToDeath(mRadioProxyDeathRecipient, mRadioProxyCookie.incrementAndGet());
            mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
        } else {
            riljLoge("getRadioProxy: radioProxy == null");
        }
    } catch (RemoteException | RuntimeException e) {
        mRadioProxy = null;
        if (result != null) {
            AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));
            result.sendToTarget();
        }
        // if service is not up, treat it like death notification to try to get service again
        mRilHandler.sendMessageDelayed(mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.get()), IRADIO_GET_SERVICE_DELAY_MILLIS);
        riljLoge("setResponseFunctions", e);
    }
    return mRadioProxy;
}
#end_block

#method_before
@Test
public void parseNetworkListWithOneNetworkIllegalArgException() throws Exception {
    WifiConfiguration openNetwork = WifiConfigurationTestUtil.createOpenNetwork();
    WifiConfiguration eapNetwork = WifiConfigurationTestUtil.createEapNetwork();
    String xmlString = new String(getTestNetworksXmlBytes(openNetwork, eapNetwork));
    // Manipulate the XML data to set the EAP method to None, this should raise an Illegal
    // argument exception in WifiEnterpriseConfig.setEapMethod().
    xmlString = xmlString.replaceAll(String.format(XmlUtilTest.XML_STRING_EAP_METHOD_REPLACE_FORMAT, eapNetwork.enterpriseConfig.getEapMethod()), String.format(XmlUtilTest.XML_STRING_EAP_METHOD_REPLACE_FORMAT, WifiEnterpriseConfig.Eap.NONE));
    List<WifiConfiguration> retrievedNetworkList = deserializeData(xmlString.getBytes(), true);
    // Retrieved network should not contain the eap network.
    assertEquals(1, retrievedNetworkList.size());
    for (WifiConfiguration network : retrievedNetworkList) {
        assertNotEquals(eapNetwork.SSID, network.SSID);
    }
}
#method_after
@Test
public void parseNetworkListWithOneNetworkIllegalArgException() throws Exception {
    WifiConfiguration openNetwork = WifiConfigurationTestUtil.createOpenNetwork();
    WifiConfiguration eapNetwork = WifiConfigurationTestUtil.createEapNetwork();
    String xmlString = new String(getTestNetworksXmlBytes(openNetwork, eapNetwork));
    // Manipulate the XML data to set the EAP method to None, this should raise an Illegal
    // argument exception in WifiEnterpriseConfig.setEapMethod().
    xmlString = xmlString.replaceAll(String.format(XmlUtilTest.XML_STRING_EAP_METHOD_REPLACE_FORMAT, eapNetwork.enterpriseConfig.getEapMethod()), String.format(XmlUtilTest.XML_STRING_EAP_METHOD_REPLACE_FORMAT, WifiEnterpriseConfig.Eap.NONE));
    List<WifiConfiguration> retrievedNetworkList = deserializeData(xmlString.getBytes(StandardCharsets.UTF_8), true);
    // Retrieved network should not contain the eap network.
    assertEquals(1, retrievedNetworkList.size());
    for (WifiConfiguration network : retrievedNetworkList) {
        assertNotEquals(eapNetwork.SSID, network.SSID);
    }
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void testWifiEnterpriseConfigSerializeDeserializeThrowsIllegalArgException() throws Exception {
    WifiEnterpriseConfig config = new WifiEnterpriseConfig();
    config.setFieldValue(WifiEnterpriseConfig.IDENTITY_KEY, TEST_IDENTITY);
    config.setFieldValue(WifiEnterpriseConfig.ANON_IDENTITY_KEY, TEST_ANON_IDENTITY);
    config.setFieldValue(WifiEnterpriseConfig.PASSWORD_KEY, TEST_PASSWORD);
    config.setFieldValue(WifiEnterpriseConfig.CLIENT_CERT_KEY, TEST_CLIENT_CERT);
    config.setFieldValue(WifiEnterpriseConfig.CA_CERT_KEY, TEST_CA_CERT);
    config.setFieldValue(WifiEnterpriseConfig.SUBJECT_MATCH_KEY, TEST_SUBJECT_MATCH);
    config.setFieldValue(WifiEnterpriseConfig.ENGINE_KEY, TEST_ENGINE);
    config.setFieldValue(WifiEnterpriseConfig.ENGINE_ID_KEY, TEST_ENGINE_ID);
    config.setFieldValue(WifiEnterpriseConfig.PRIVATE_KEY_ID_KEY, TEST_PRIVATE_KEY_ID);
    config.setFieldValue(WifiEnterpriseConfig.ALTSUBJECT_MATCH_KEY, TEST_ALTSUBJECT_MATCH);
    config.setFieldValue(WifiEnterpriseConfig.DOM_SUFFIX_MATCH_KEY, TEST_DOM_SUFFIX_MATCH);
    config.setFieldValue(WifiEnterpriseConfig.CA_PATH_KEY, TEST_CA_PATH);
    config.setEapMethod(TEST_EAP_METHOD);
    config.setPhase2Method(TEST_PHASE2_METHOD);
    String xmlString = new String(serializeWifiEnterpriseConfig(config));
    // Manipulate the XML data to set the EAP method to None, this should raise an Illegal
    // argument exception in WifiEnterpriseConfig.setEapMethod().
    xmlString = xmlString.replaceAll(String.format(XML_STRING_EAP_METHOD_REPLACE_FORMAT, TEST_EAP_METHOD), String.format(XML_STRING_EAP_METHOD_REPLACE_FORMAT, WifiEnterpriseConfig.Eap.NONE));
    deserializeWifiEnterpriseConfig(xmlString.getBytes());
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void testWifiEnterpriseConfigSerializeDeserializeThrowsIllegalArgException() throws Exception {
    WifiEnterpriseConfig config = new WifiEnterpriseConfig();
    config.setFieldValue(WifiEnterpriseConfig.IDENTITY_KEY, TEST_IDENTITY);
    config.setFieldValue(WifiEnterpriseConfig.ANON_IDENTITY_KEY, TEST_ANON_IDENTITY);
    config.setFieldValue(WifiEnterpriseConfig.PASSWORD_KEY, TEST_PASSWORD);
    config.setFieldValue(WifiEnterpriseConfig.CLIENT_CERT_KEY, TEST_CLIENT_CERT);
    config.setFieldValue(WifiEnterpriseConfig.CA_CERT_KEY, TEST_CA_CERT);
    config.setFieldValue(WifiEnterpriseConfig.SUBJECT_MATCH_KEY, TEST_SUBJECT_MATCH);
    config.setFieldValue(WifiEnterpriseConfig.ENGINE_KEY, TEST_ENGINE);
    config.setFieldValue(WifiEnterpriseConfig.ENGINE_ID_KEY, TEST_ENGINE_ID);
    config.setFieldValue(WifiEnterpriseConfig.PRIVATE_KEY_ID_KEY, TEST_PRIVATE_KEY_ID);
    config.setFieldValue(WifiEnterpriseConfig.ALTSUBJECT_MATCH_KEY, TEST_ALTSUBJECT_MATCH);
    config.setFieldValue(WifiEnterpriseConfig.DOM_SUFFIX_MATCH_KEY, TEST_DOM_SUFFIX_MATCH);
    config.setFieldValue(WifiEnterpriseConfig.CA_PATH_KEY, TEST_CA_PATH);
    config.setEapMethod(TEST_EAP_METHOD);
    config.setPhase2Method(TEST_PHASE2_METHOD);
    String xmlString = new String(serializeWifiEnterpriseConfig(config));
    // Manipulate the XML data to set the EAP method to None, this should raise an Illegal
    // argument exception in WifiEnterpriseConfig.setEapMethod().
    xmlString = xmlString.replaceAll(String.format(XML_STRING_EAP_METHOD_REPLACE_FORMAT, TEST_EAP_METHOD), String.format(XML_STRING_EAP_METHOD_REPLACE_FORMAT, WifiEnterpriseConfig.Eap.NONE));
    deserializeWifiEnterpriseConfig(xmlString.getBytes(StandardCharsets.UTF_8));
}
#end_block

#method_before
// Android changed: Removed retrieveFirstDayOfWeek and retrieveMinimalDaysInFirstWeek.
// use libcore.icu.LocaleData or android.icu.util.Calendar.WeekData instead
public static String retrieveFieldValueName(String id, int field, int value, int style, Locale locale) {
    // Android changed: delegate to ICU.
    if (field == Calendar.ERA) {
        // For era the field value does not always equal the index into the names array.
        switch(normalizeCalendarType(id)) {
            // These calendars have only one era, but represented it by the value 1.
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                value -= 1;
                break;
            case JAPANESE_CALENDAR:
                // CLDR contains full data for historical eras, java.time only supports the 4
                // modern eras and numbers the modern eras starting with 1 (MEIJI). There are
                // 232 historical eras in CLDR/ICU so to get the real offset, we add 231.
                value += 231;
                break;
            default:
                // Other eras use 0-based values (e.g. 0=BCE, 1=CE for gregorian).
                break;
        }
    }
    if (value < 0) {
        return null;
    }
    String[] names = getNames(id, field, style, locale);
    if (value >= names.length) {
        return null;
    }
    return names[value];
}
#method_after
// Android-changed: Removed retrieveFirstDayOfWeek and retrieveMinimalDaysInFirstWeek.
// use libcore.icu.LocaleData or android.icu.util.Calendar.WeekData instead
public static String retrieveFieldValueName(String id, int field, int value, int style, Locale locale) {
    // Android-changed: delegate to ICU.
    if (field == Calendar.ERA) {
        // For era the field value does not always equal the index into the names array.
        switch(normalizeCalendarType(id)) {
            // These calendars have only one era, but represented it by the value 1.
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                value -= 1;
                break;
            case JAPANESE_CALENDAR:
                // CLDR contains full data for historical eras, java.time only supports the 4
                // modern eras and numbers the modern eras starting with 1 (MEIJI). There are
                // 232 historical eras in CLDR/ICU so to get the real offset, we add 231.
                value += 231;
                break;
            default:
                // Other eras use 0-based values (e.g. 0=BCE, 1=CE for gregorian).
                break;
        }
    }
    if (value < 0) {
        return null;
    }
    String[] names = getNames(id, field, style, locale);
    if (value >= names.length) {
        return null;
    }
    return names[value];
}
#end_block

#method_before
public static String retrieveJavaTimeFieldValueName(String id, int field, int value, int style, Locale locale) {
    // Android changed: don't distinguish between retrieve* and retrieveJavaTime* methods.
    return retrieveFieldValueName(id, field, value, style, locale);
}
#method_after
public static String retrieveJavaTimeFieldValueName(String id, int field, int value, int style, Locale locale) {
    // Android-changed: don't distinguish between retrieve* and retrieveJavaTime* methods.
    return retrieveFieldValueName(id, field, value, style, locale);
}
#end_block

#method_before
public static Map<String, Integer> retrieveFieldValueNames(String id, int field, int style, Locale locale) {
    // Android changed: delegate to ICU.
    Map<String, Integer> names;
    if (style == ALL_STYLES) {
        names = retrieveFieldValueNamesImpl(id, field, SHORT_FORMAT, locale);
        for (int st : REST_OF_STYLES) {
            names.putAll(retrieveFieldValueNamesImpl(id, field, st, locale));
        }
    } else {
        // specific style
        names = retrieveFieldValueNamesImpl(id, field, style, locale);
    }
    return names.isEmpty() ? null : names;
}
#method_after
public static Map<String, Integer> retrieveFieldValueNames(String id, int field, int style, Locale locale) {
    // Android-changed: delegate to ICU.
    Map<String, Integer> names;
    if (style == ALL_STYLES) {
        names = retrieveFieldValueNamesImpl(id, field, SHORT_FORMAT, locale);
        for (int st : REST_OF_STYLES) {
            names.putAll(retrieveFieldValueNamesImpl(id, field, st, locale));
        }
    } else {
        // specific style
        names = retrieveFieldValueNamesImpl(id, field, style, locale);
    }
    return names.isEmpty() ? null : names;
}
#end_block

#method_before
private static Map<String, Integer> retrieveFieldValueNamesImpl(String id, int field, int style, Locale locale) {
    String[] names = getNames(id, field, style, locale);
    Map<String, Integer> result = new LinkedHashMap<>();
    if (hasDuplicates(names)) {
        return result;
    }
    int skipped = 0;
    int offset = 0;
    if (field == Calendar.ERA) {
        // See retrieveFieldValueName() for explanation of this code and the values used.
        switch(normalizeCalendarType(id)) {
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                offset = 1;
                break;
            case JAPANESE_CALENDAR:
                skipped = 232;
                offset = -231;
                break;
            default:
                break;
        }
    }
    for (int i = skipped; i < names.length; i++) {
        if (names[i].isEmpty()) {
            continue;
        }
        result.put(names[i], i + offset);
    }
    return result;
}
#method_after
private static Map<String, Integer> retrieveFieldValueNamesImpl(String id, int field, int style, Locale locale) {
    String[] names = getNames(id, field, style, locale);
    int skipped = 0;
    int offset = 0;
    if (field == Calendar.ERA) {
        // See retrieveFieldValueName() for explanation of this code and the values used.
        switch(normalizeCalendarType(id)) {
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                offset = 1;
                break;
            case JAPANESE_CALENDAR:
                skipped = 232;
                offset = -231;
                break;
            default:
                break;
        }
    }
    Map<String, Integer> result = new LinkedHashMap<>();
    for (int i = skipped; i < names.length; i++) {
        if (names[i].isEmpty()) {
            continue;
        }
        if (result.put(names[i], i + offset) != null) {
            // retrieveValueNames(), which is required by Calendar.getDisplayNames().
            return new LinkedHashMap<>();
        }
    }
    return result;
}
#end_block

#method_before
public static Map<String, Integer> retrieveJavaTimeFieldValueNames(String id, int field, int style, Locale locale) {
    // Android changed: don't distinguish between retrieve* and retrieveJavaTime* methods.
    return retrieveFieldValueNames(id, field, style, locale);
}
#method_after
public static Map<String, Integer> retrieveJavaTimeFieldValueNames(String id, int field, int style, Locale locale) {
    // Android-changed: don't distinguish between retrieve* and retrieveJavaTime* methods.
    return retrieveFieldValueNames(id, field, style, locale);
}
#end_block

#method_before
public void test_getDisplayNamesIILjava_util_Locale() {
    assertEquals(0, Calendar.ALL_STYLES);
    assertEquals(1, Calendar.SHORT);
    assertEquals(2, Calendar.LONG);
    Calendar cal = Calendar.getInstance(Locale.US);
    for (int field = 0; field < Calendar.FIELD_COUNT; field++) {
        for (Locale locale : locales) {
            Map<String, Integer> shortResult = cal.getDisplayNames(field, Calendar.SHORT, locale);
            Map<String, Integer> longResult = cal.getDisplayNames(field, Calendar.LONG, locale);
            Map<String, Integer> allResult = cal.getDisplayNames(field, Calendar.ALL_STYLES, locale);
            DateFormatSymbols symbols = new DateFormatSymbols(locale);
            String[] values = null;
            switch(field) {
                case Calendar.AM_PM:
                case Calendar.ERA:
                    values = (field == Calendar.AM_PM) ? symbols.getAmPmStrings() : symbols.getEras();
                    assertDisplayNameMap(values, shortResult, 0);
                    assertDisplayNameMap(values, longResult, 0);
                    // Android changed: allResults contains narrow values.
                    assertTrue(allResult.size() >= shortResult.size());
                    assertTrue(allResult.size() >= longResult.size());
                    break;
                case Calendar.MONTH:
                    values = symbols.getShortMonths();
                    assertDisplayNameMap(values, shortResult, 0);
                    values = symbols.getMonths();
                    assertDisplayNameMap(values, longResult, 0);
                    assertTrue(allResult.size() >= shortResult.size());
                    assertTrue(allResult.size() >= longResult.size());
                    // Android changed: allResults contains narrow values.
                    break;
                case Calendar.DAY_OF_WEEK:
                    values = symbols.getShortWeekdays();
                    assertDisplayNameMap(values, shortResult, 1);
                    values = symbols.getWeekdays();
                    assertDisplayNameMap(values, longResult, 1);
                    assertTrue(allResult.size() >= shortResult.size());
                    assertTrue(allResult.size() >= longResult.size());
                    // Android changed: allResults contains narrow values.
                    break;
                default:
                    assertNull(shortResult);
                    assertNull(longResult);
                    assertNull(allResult);
            }
        }
    }
    cal.setLenient(true);
    try {
        cal.getDisplayNames(-1, Calendar.SHORT, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.FIELD_COUNT, Calendar.LONG, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.MONTH, -1, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.MONTH, 3, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.MONTH, Calendar.SHORT, null);
        fail("Should throw NullPointerException");
    } catch (NullPointerException e) {
    // expected
    }
    try {
        cal.getDisplayNames(-1, Calendar.SHORT, null);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.MONTH, -1, null);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    cal.set(Calendar.SECOND, 999);
    cal.getDisplayNames(Calendar.MONTH, Calendar.SHORT, Locale.US);
    // RI fails here
    // invalid value for an un-related field when the calendar is not
    // lenient
    cal.setLenient(false);
    cal.set(Calendar.SECOND, 999);
    try {
        cal.getDisplayNames(Calendar.MONTH, Calendar.SHORT, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
}
#method_after
public void test_getDisplayNamesIILjava_util_Locale() {
    assertEquals(0, Calendar.ALL_STYLES);
    assertEquals(1, Calendar.SHORT);
    assertEquals(2, Calendar.LONG);
    Calendar cal = Calendar.getInstance(Locale.US);
    for (int field = 0; field < Calendar.FIELD_COUNT; field++) {
        for (Locale locale : locales) {
            Map<String, Integer> shortResult = cal.getDisplayNames(field, Calendar.SHORT, locale);
            Map<String, Integer> longResult = cal.getDisplayNames(field, Calendar.LONG, locale);
            Map<String, Integer> allResult = cal.getDisplayNames(field, Calendar.ALL_STYLES, locale);
            DateFormatSymbols symbols = new DateFormatSymbols(locale);
            String[] values = null;
            switch(field) {
                case Calendar.AM_PM:
                case Calendar.ERA:
                    values = (field == Calendar.AM_PM) ? symbols.getAmPmStrings() : symbols.getEras();
                    assertDisplayNameMap(values, shortResult, 0);
                    assertDisplayNameMap(values, longResult, 0);
                    assertTrue(allResult.size() >= shortResult.size());
                    assertTrue(allResult.size() >= longResult.size());
                    break;
                case Calendar.MONTH:
                    values = symbols.getShortMonths();
                    assertDisplayNameMap(values, shortResult, 0);
                    values = symbols.getMonths();
                    assertDisplayNameMap(values, longResult, 0);
                    assertTrue(allResult.size() >= shortResult.size());
                    assertTrue(allResult.size() >= longResult.size());
                    break;
                case Calendar.DAY_OF_WEEK:
                    values = symbols.getShortWeekdays();
                    assertDisplayNameMap(values, shortResult, 1);
                    values = symbols.getWeekdays();
                    assertDisplayNameMap(values, longResult, 1);
                    assertTrue(allResult.size() >= shortResult.size());
                    assertTrue(allResult.size() >= longResult.size());
                    break;
                default:
                    assertNull(shortResult);
                    assertNull(longResult);
                    assertNull(allResult);
            }
        }
    }
    cal.setLenient(true);
    try {
        cal.getDisplayNames(-1, Calendar.SHORT, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.FIELD_COUNT, Calendar.LONG, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.MONTH, -1, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.MONTH, 3, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.MONTH, Calendar.SHORT, null);
        fail("Should throw NullPointerException");
    } catch (NullPointerException e) {
    // expected
    }
    try {
        cal.getDisplayNames(-1, Calendar.SHORT, null);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        cal.getDisplayNames(Calendar.MONTH, -1, null);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
    cal.set(Calendar.SECOND, 999);
    cal.getDisplayNames(Calendar.MONTH, Calendar.SHORT, Locale.US);
    // RI fails here
    // invalid value for an un-related field when the calendar is not
    // lenient
    cal.setLenient(false);
    cal.set(Calendar.SECOND, 999);
    try {
        cal.getDisplayNames(Calendar.MONTH, Calendar.SHORT, Locale.US);
        fail("Should throw IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // expected
    }
}
#end_block

#method_before
public String getDisplayName(int field, int style, Locale locale) {
    // technically it's not allowed in getDisplayName().
    if (style == ALL_STYLES) {
        style = SHORT;
    }
    if (!checkDisplayNameParams(field, style, SHORT, NARROW_FORMAT, locale, ERA_MASK | MONTH_MASK | DAY_OF_WEEK_MASK | AM_PM_MASK)) {
        return null;
    }
    String calendarType = getCalendarType();
    int fieldValue = get(field);
    // the standalone and narrow styles are supported only through CalendarDataProviders.
    if (isStandaloneStyle(style) || isNarrowFormatStyle(style)) {
        String val = CalendarDataUtility.retrieveFieldValueName(calendarType, field, fieldValue, style, locale);
        // Perform fallback here to follow the CLDR rules
        if (val == null) {
            if (isNarrowFormatStyle(style)) {
                val = CalendarDataUtility.retrieveFieldValueName(calendarType, field, fieldValue, toStandaloneStyle(style), locale);
            } else if (isStandaloneStyle(style)) {
                val = CalendarDataUtility.retrieveFieldValueName(calendarType, field, fieldValue, getBaseStyle(style), locale);
            }
        }
        return val;
    }
    DateFormatSymbols symbols = DateFormatSymbols.getInstance(locale);
    String[] strings = getFieldStrings(field, style, symbols);
    if (strings != null) {
        if (fieldValue < strings.length) {
            return strings[fieldValue];
        }
    }
    return null;
}
#method_after
public String getDisplayName(int field, int style, Locale locale) {
    // it's not documented to be a valid value for style.
    if (style == ALL_STYLES) {
        style = SHORT;
    }
    if (!checkDisplayNameParams(field, style, SHORT, NARROW_FORMAT, locale, ERA_MASK | MONTH_MASK | DAY_OF_WEEK_MASK | AM_PM_MASK)) {
        return null;
    }
    String calendarType = getCalendarType();
    int fieldValue = get(field);
    // the standalone and narrow styles are supported only through CalendarDataProviders.
    if (isStandaloneStyle(style) || isNarrowFormatStyle(style)) {
        String val = CalendarDataUtility.retrieveFieldValueName(calendarType, field, fieldValue, style, locale);
        // Perform fallback here to follow the CLDR rules
        if (val == null) {
            if (isNarrowFormatStyle(style)) {
                val = CalendarDataUtility.retrieveFieldValueName(calendarType, field, fieldValue, toStandaloneStyle(style), locale);
            } else if (isStandaloneStyle(style)) {
                val = CalendarDataUtility.retrieveFieldValueName(calendarType, field, fieldValue, getBaseStyle(style), locale);
            }
        }
        return val;
    }
    DateFormatSymbols symbols = DateFormatSymbols.getInstance(locale);
    String[] strings = getFieldStrings(field, style, symbols);
    if (strings != null) {
        if (fieldValue < strings.length) {
            return strings[fieldValue];
        }
    }
    return null;
}
#end_block

#method_before
boolean checkDisplayNameParams(int field, int style, int minStyle, int maxStyle, Locale locale, int fieldMask) {
    // Ignore the standalone mask
    int baseStyle = getBaseStyle(style);
    if (field < 0 || field >= fields.length || baseStyle < minStyle || baseStyle > maxStyle) {
        throw new IllegalArgumentException();
    }
    // Android changed: 3 is not a valid base style (1, 2 and 4 are, 'though), throw if used.
    if (baseStyle == 3) {
        throw new IllegalArgumentException();
    }
    if (locale == null) {
        throw new NullPointerException();
    }
    return isFieldSet(fieldMask, field);
}
#method_after
boolean checkDisplayNameParams(int field, int style, int minStyle, int maxStyle, Locale locale, int fieldMask) {
    // Ignore the standalone mask
    int baseStyle = getBaseStyle(style);
    if (field < 0 || field >= fields.length || baseStyle < minStyle || baseStyle > maxStyle) {
        throw new IllegalArgumentException();
    }
    // Android-changed: 3 is not a valid base style (1, 2 and 4 are, though), throw if used.
    if (baseStyle == 3) {
        throw new IllegalArgumentException();
    }
    if (locale == null) {
        throw new NullPointerException();
    }
    return isFieldSet(fieldMask, field);
}
#end_block

#method_before
public static WifiSsid createFromByteArray(byte[] ssid) {
    WifiSsid wifiSsid = new WifiSsid();
    wifiSsid.octets.write(ssid, 0, /* the start offset */
    ssid.length);
    ;
    return wifiSsid;
}
#method_after
public static WifiSsid createFromByteArray(byte[] ssid) {
    WifiSsid wifiSsid = new WifiSsid();
    if (ssid != null) {
        wifiSsid.octets.write(ssid, 0, /* the start offset */
        ssid.length);
        ;
    }
    return wifiSsid;
}
#end_block

#method_before
@VisibleForTesting
int wifiFeatureMaskFromStaCapabilities(int capabilities) {
    // Always set this if we have a STA interface
    int features = WifiManager.WIFI_FEATURE_INFRA;
    for (int i = 0; i < sFeatureCapabilityTranslation.length; i++) {
        if ((capabilities & sFeatureCapabilityTranslation[i][1]) != 0) {
            features |= sFeatureCapabilityTranslation[i][0];
        }
    }
    return features;
}
#method_after
@VisibleForTesting
int wifiFeatureMaskFromStaCapabilities(int capabilities) {
    int features = 0;
    for (int i = 0; i < sFeatureCapabilityTranslation.length; i++) {
        if ((capabilities & sFeatureCapabilityTranslation[i][1]) != 0) {
            features |= sFeatureCapabilityTranslation[i][0];
        }
    }
    return features;
}
#end_block

#method_before
public int getSupportedFeatureSet() {
    try {
        final MutableInt feat = new MutableInt(0);
        synchronized (sLock) {
            if (mIWifiStaIface != null) {
                mIWifiStaIface.getCapabilities((status, capabilities) -> {
                    if (status.code != WifiStatusCode.SUCCESS)
                        return;
                    feat.value = wifiFeatureMaskFromStaCapabilities(capabilities);
                });
            }
        }
        return feat.value;
    } catch (RemoteException e) {
        handleRemoteException(e);
        return 0;
    }
}
#method_after
public int getSupportedFeatureSet() {
    int featureSet = 0;
    try {
        final MutableInt feat = new MutableInt(0);
        synchronized (sLock) {
            if (mIWifiStaIface != null) {
                mIWifiStaIface.getCapabilities((status, capabilities) -> {
                    if (status.code != WifiStatusCode.SUCCESS)
                        return;
                    feat.value = wifiFeatureMaskFromStaCapabilities(capabilities);
                });
            }
        }
        featureSet = feat.value;
    } catch (RemoteException e) {
        handleRemoteException(e);
        return 0;
    }
    Set<Integer> supportedIfaceTypes = mHalDeviceManager.getSupportedIfaceTypes();
    if (supportedIfaceTypes.contains(IfaceType.STA)) {
        featureSet |= WifiManager.WIFI_FEATURE_INFRA;
    }
    if (supportedIfaceTypes.contains(IfaceType.AP)) {
        featureSet |= WifiManager.WIFI_FEATURE_MOBILE_HOTSPOT;
    }
    if (supportedIfaceTypes.contains(IfaceType.P2P)) {
        featureSet |= WifiManager.WIFI_FEATURE_P2P;
    }
    if (supportedIfaceTypes.contains(IfaceType.NAN)) {
        featureSet |= WifiManager.WIFI_FEATURE_AWARE;
    }
    return featureSet;
}
#end_block

#method_before
public boolean setScanningMacOui(byte[] oui) {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public boolean setScanningMacOui(byte[] oui) {
    kilroy();
    if (oui == null)
        return false;
    kilroy();
    if (oui.length != 3)
        return false;
    kilroy();
    synchronized (sLock) {
        try {
            if (mIWifiStaIface == null)
                return false;
            WifiStatus status = mIWifiStaIface.setScanningMacOui(oui);
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            kilroy();
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean setCountryCodeHal(String countryCode) {
    kilroy();
    if (countryCode == null)
        return false;
    if (countryCode.length() != 2)
        return false;
    byte[] code = new byte[] { (byte) countryCode.charAt(0), (byte) countryCode.charAt(1) };
    synchronized (sLock) {
        try {
            if (mIWifiApIface == null)
                return false;
            kilroy();
            WifiStatus status = mIWifiApIface.setCountryCode(code);
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            kilroy();
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean setCountryCodeHal(String countryCode) {
    kilroy();
    if (countryCode == null)
        return false;
    if (countryCode.length() != 2)
        return false;
    byte[] code;
    try {
        code = NativeUtil.stringToByteArray(countryCode);
    } catch (IllegalArgumentException e) {
        kilroy();
        return false;
    }
    synchronized (sLock) {
        try {
            if (mIWifiApIface == null)
                return false;
            kilroy();
            WifiStatus status = mIWifiApIface.setCountryCode(code);
            if (status.code != WifiStatusCode.SUCCESS)
                return false;
            kilroy();
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
@Test
public void testFeatureMaskTranslation() {
    int caps = (IWifiStaIface.StaIfaceCapabilityMask.BACKGROUND_SCAN | IWifiStaIface.StaIfaceCapabilityMask.LINK_LAYER_STATS);
    int expected = (WifiManager.WIFI_FEATURE_INFRA | WifiManager.WIFI_FEATURE_SCANNER | WifiManager.WIFI_FEATURE_LINK_LAYER_STATS);
    assertEquals(expected, mWifiVendorHal.wifiFeatureMaskFromStaCapabilities(caps));
}
#method_after
@Test
public void testFeatureMaskTranslation() {
    int caps = (IWifiStaIface.StaIfaceCapabilityMask.BACKGROUND_SCAN | IWifiStaIface.StaIfaceCapabilityMask.LINK_LAYER_STATS);
    int expected = (WifiManager.WIFI_FEATURE_SCANNER | WifiManager.WIFI_FEATURE_LINK_LAYER_STATS);
    assertEquals(expected, mWifiVendorHal.wifiFeatureMaskFromStaCapabilities(caps));
}
#end_block

#method_before
/**
 * Returns the IMEI. Return null if IMEI is not available.
 *
 * <p>Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public String getImei() {
    return getImei(getDefaultSim());
}
#method_after
@SystemApi
public String getImei() {
    return getImei(getDefaultSim());
}
#end_block

#method_before
/**
 * Returns the IMEI. Return null if IMEI is not available.
 *
 * <p>Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param slotId of which deviceID is returned
 */
public String getImei(int slotId) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getImeiForSlot(slotId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
@SystemApi
public String getImei(int slotId) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getImeiForSlot(slotId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
public static int getNetworkClass(int networkType) {
    switch(networkType) {
        case NETWORK_TYPE_GPRS:
        case NETWORK_TYPE_GSM:
        case NETWORK_TYPE_EDGE:
        case NETWORK_TYPE_CDMA:
        case NETWORK_TYPE_1xRTT:
        case NETWORK_TYPE_IDEN:
            return NETWORK_CLASS_2_G;
        case NETWORK_TYPE_UMTS:
        case NETWORK_TYPE_EVDO_0:
        case NETWORK_TYPE_EVDO_A:
        case NETWORK_TYPE_HSDPA:
        case NETWORK_TYPE_HSUPA:
        case NETWORK_TYPE_HSPA:
        case NETWORK_TYPE_EVDO_B:
        case NETWORK_TYPE_EHRPD:
        case NETWORK_TYPE_HSPAP:
        case NETWORK_TYPE_TD_SCDMA:
            return NETWORK_CLASS_3_G;
        case NETWORK_TYPE_LTE:
        case NETWORK_TYPE_IWLAN:
            return NETWORK_CLASS_4_G;
        default:
            return NETWORK_CLASS_UNKNOWN;
    }
}
#method_after
public static int getNetworkClass(int networkType) {
    switch(networkType) {
        case NETWORK_TYPE_GPRS:
        case NETWORK_TYPE_GSM:
        case NETWORK_TYPE_EDGE:
        case NETWORK_TYPE_CDMA:
        case NETWORK_TYPE_1xRTT:
        case NETWORK_TYPE_IDEN:
            return NETWORK_CLASS_2_G;
        case NETWORK_TYPE_UMTS:
        case NETWORK_TYPE_EVDO_0:
        case NETWORK_TYPE_EVDO_A:
        case NETWORK_TYPE_HSDPA:
        case NETWORK_TYPE_HSUPA:
        case NETWORK_TYPE_HSPA:
        case NETWORK_TYPE_EVDO_B:
        case NETWORK_TYPE_EHRPD:
        case NETWORK_TYPE_HSPAP:
        case NETWORK_TYPE_TD_SCDMA:
            return NETWORK_CLASS_3_G;
        case NETWORK_TYPE_LTE:
        case NETWORK_TYPE_IWLAN:
        case NETWORK_TYPE_LTE_CA:
            return NETWORK_CLASS_4_G;
        default:
            return NETWORK_CLASS_UNKNOWN;
    }
}
#end_block

#method_before
/**
 * Returns a string representation of the radio technology (network type)
 * currently in use on the device.
 * @param subId for which network type is returned
 * @return the name of the radio technology
 */
public static String getNetworkTypeName(int type) {
    switch(type) {
        case NETWORK_TYPE_GPRS:
            return "GPRS";
        case NETWORK_TYPE_EDGE:
            return "EDGE";
        case NETWORK_TYPE_UMTS:
            return "UMTS";
        case NETWORK_TYPE_HSDPA:
            return "HSDPA";
        case NETWORK_TYPE_HSUPA:
            return "HSUPA";
        case NETWORK_TYPE_HSPA:
            return "HSPA";
        case NETWORK_TYPE_CDMA:
            return "CDMA";
        case NETWORK_TYPE_EVDO_0:
            return "CDMA - EvDo rev. 0";
        case NETWORK_TYPE_EVDO_A:
            return "CDMA - EvDo rev. A";
        case NETWORK_TYPE_EVDO_B:
            return "CDMA - EvDo rev. B";
        case NETWORK_TYPE_1xRTT:
            return "CDMA - 1xRTT";
        case NETWORK_TYPE_LTE:
            return "LTE";
        case NETWORK_TYPE_EHRPD:
            return "CDMA - eHRPD";
        case NETWORK_TYPE_IDEN:
            return "iDEN";
        case NETWORK_TYPE_HSPAP:
            return "HSPA+";
        case NETWORK_TYPE_GSM:
            return "GSM";
        case NETWORK_TYPE_TD_SCDMA:
            return "TD_SCDMA";
        case NETWORK_TYPE_IWLAN:
            return "IWLAN";
        default:
            return "UNKNOWN";
    }
}
#method_after
/**
 * Returns a string representation of the radio technology (network type)
 * currently in use on the device.
 * @param subId for which network type is returned
 * @return the name of the radio technology
 */
public static String getNetworkTypeName(int type) {
    switch(type) {
        case NETWORK_TYPE_GPRS:
            return "GPRS";
        case NETWORK_TYPE_EDGE:
            return "EDGE";
        case NETWORK_TYPE_UMTS:
            return "UMTS";
        case NETWORK_TYPE_HSDPA:
            return "HSDPA";
        case NETWORK_TYPE_HSUPA:
            return "HSUPA";
        case NETWORK_TYPE_HSPA:
            return "HSPA";
        case NETWORK_TYPE_CDMA:
            return "CDMA";
        case NETWORK_TYPE_EVDO_0:
            return "CDMA - EvDo rev. 0";
        case NETWORK_TYPE_EVDO_A:
            return "CDMA - EvDo rev. A";
        case NETWORK_TYPE_EVDO_B:
            return "CDMA - EvDo rev. B";
        case NETWORK_TYPE_1xRTT:
            return "CDMA - 1xRTT";
        case NETWORK_TYPE_LTE:
            return "LTE";
        case NETWORK_TYPE_EHRPD:
            return "CDMA - eHRPD";
        case NETWORK_TYPE_IDEN:
            return "iDEN";
        case NETWORK_TYPE_HSPAP:
            return "HSPA+";
        case NETWORK_TYPE_GSM:
            return "GSM";
        case NETWORK_TYPE_TD_SCDMA:
            return "TD_SCDMA";
        case NETWORK_TYPE_IWLAN:
            return "IWLAN";
        case NETWORK_TYPE_LTE_CA:
            return "LTE_CA";
        default:
            return "UNKNOWN";
    }
}
#end_block

#method_before
/**
 * Returns a constant indicating the state of the device SIM card in a slot.
 *
 * @param slotIdx
 *
 * @see #SIM_STATE_UNKNOWN
 * @see #SIM_STATE_ABSENT
 * @see #SIM_STATE_PIN_REQUIRED
 * @see #SIM_STATE_PUK_REQUIRED
 * @see #SIM_STATE_NETWORK_LOCKED
 * @see #SIM_STATE_READY
 * @see #SIM_STATE_NOT_READY
 * @see #SIM_STATE_PERM_DISABLED
 * @see #SIM_STATE_CARD_IO_ERROR
 */
public int getSimState(int slotIdx) {
    int simState = SubscriptionManager.getSimStateForSlotIdx(slotIdx);
    return simState;
}
#method_after
public int getSimState(int slotIdx) {
    int simState = SubscriptionManager.getSimStateForSlotIdx(slotIdx);
    return simState;
}
#end_block

#method_before
public boolean setVoiceActivationState(int subId, int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setVoiceActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
#method_after
public void setVoiceActivationState(int subId, int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setVoiceActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#end_block

#method_before
public boolean setDataActivationState(int subId, int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setDataActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
#method_after
public void setDataActivationState(int subId, int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setDataActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#end_block

#method_before
// 
// 
// PhoneStateListener
// 
// 
public void listen(PhoneStateListener listener, int events) {
    if (mContext == null)
        return;
    try {
        Boolean notifyNow = (getITelephony() != null);
        sRegistry.listenForSubscriber(listener.mSubId, getOpPackageName(), listener.callback, events, notifyNow);
    } catch (RemoteException ex) {
    // system process dead
    } catch (NullPointerException ex) {
    // system process dead
    }
}
#method_after
// 
// 
// PhoneStateListener
// 
// 
public void listen(PhoneStateListener listener, int events) {
    if (mContext == null)
        return;
    try {
        Boolean notifyNow = (getITelephony() != null);
        // telephony manager is created with.
        if (listener.mSubId == null) {
            listener.mSubId = mSubId;
        }
        sRegistry.listenForSubscriber(listener.mSubId, getOpPackageName(), listener.callback, events, notifyNow);
    } catch (RemoteException ex) {
    // system process dead
    } catch (NullPointerException ex) {
    // system process dead
    }
}
#end_block

#method_before
@SystemApi
public void setDataEnabled(boolean enable) {
    setDataEnabled(SubscriptionManager.getDefaultDataSubscriptionId(), enable);
}
#method_after
public void setDataEnabled(boolean enable) {
    setDataEnabled(getSubId(), enable);
}
#end_block

#method_before
@SystemApi
public boolean getDataEnabled() {
    return getDataEnabled(SubscriptionManager.getDefaultDataSubscriptionId());
}
#method_after
public boolean getDataEnabled() {
    return getDataEnabled(getSubId());
}
#end_block

#method_before
private void listen(String callingPackage, IPhoneStateListener callback, int events, boolean notifyNow, int subId) {
    int callerUserId = UserHandle.getCallingUserId();
    if (VDBG) {
        log("listen: E pkg=" + callingPackage + " events=0x" + Integer.toHexString(events) + " notifyNow=" + notifyNow + " subId=" + subId + " myUserId=" + UserHandle.myUserId() + " callerUserId=" + callerUserId);
    }
    if (events != PhoneStateListener.LISTEN_NONE) {
        /* Checks permission and throws Security exception */
        checkListenerPermission(events);
        if ((events & ENFORCE_PHONE_STATE_PERMISSION_MASK) != 0) {
            try {
                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
            // SKIP checking for run-time permission since caller or self has PRIVILEGED
            // permission
            } catch (SecurityException e) {
                if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
                    return;
                }
            }
        }
        synchronized (mRecords) {
            // register
            Record r;
            find_and_add: {
                IBinder b = callback.asBinder();
                final int N = mRecords.size();
                for (int i = 0; i < N; i++) {
                    r = mRecords.get(i);
                    if (b == r.binder) {
                        break find_and_add;
                    }
                }
                r = new Record();
                r.binder = b;
                mRecords.add(r);
                if (DBG)
                    log("listen: add new record");
            }
            r.callback = callback;
            r.callingPackage = callingPackage;
            r.callerUserId = callerUserId;
            boolean isPhoneStateEvent = (events & (CHECK_PHONE_STATE_PERMISSION_MASK | ENFORCE_PHONE_STATE_PERMISSION_MASK)) != 0;
            r.canReadPhoneState = isPhoneStateEvent && canReadPhoneState(callingPackage);
            // force all illegal subId to SubscriptionManager.DEFAULT_SUB_ID
            if (!SubscriptionManager.isValidSubscriptionId(subId)) {
                r.subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
            } else {
                // APP specify subID
                r.subId = subId;
            }
            r.phoneId = SubscriptionManager.getPhoneId(r.subId);
            int phoneId = r.phoneId;
            r.events = events;
            if (DBG) {
                log("listen:  Register r=" + r + " r.subId=" + r.subId + " phoneId=" + phoneId);
            }
            if (VDBG)
                toStringLogSSC("listen");
            if (notifyNow && validatePhoneId(phoneId)) {
                if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                    try {
                        if (VDBG)
                            log("listen: call onSSC state=" + mServiceState[phoneId]);
                        r.callback.onServiceStateChanged(new ServiceState(mServiceState[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
                    try {
                        int gsmSignalStrength = mSignalStrength[phoneId].getGsmSignalStrength();
                        r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1 : gsmSignalStrength));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
                    try {
                        r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
                    try {
                        r.callback.onCallForwardingIndicatorChanged(mCallForwarding[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellLocation = " + mCellLocation[phoneId]);
                        r.callback.onCellLocationChanged(new Bundle(mCellLocation[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
                    try {
                        r.callback.onCallStateChanged(mCallState[phoneId], getCallIncomingNumber(r, phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onDataConnectionStateChanged(mDataConnectionState[phoneId], mDataConnectionNetworkType[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
                    try {
                        r.callback.onDataActivity(mDataActivity[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
                    try {
                        r.callback.onSignalStrengthsChanged(mSignalStrength[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
                    try {
                        r.callback.onOtaspChanged(mOtaspMode);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellInfo[" + phoneId + "] = " + mCellInfo.get(phoneId));
                        r.callback.onCellInfoChanged(mCellInfo.get(phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_CALL_STATE) != 0) {
                    try {
                        r.callback.onPreciseCallStateChanged(mPreciseCallState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onPreciseDataConnectionStateChanged(mPreciseDataConnectionState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CARRIER_NETWORK_CHANGE) != 0) {
                    try {
                        r.callback.onCarrierNetworkChange(mCarrierNetworkChangeState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIM_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onSimActivationStateChanged(mSimActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
            }
        }
    } else {
        if (DBG)
            log("listen: Unregister");
        remove(callback.asBinder());
    }
}
#method_after
private void listen(String callingPackage, IPhoneStateListener callback, int events, boolean notifyNow, int subId) {
    int callerUserId = UserHandle.getCallingUserId();
    if (VDBG) {
        log("listen: E pkg=" + callingPackage + " events=0x" + Integer.toHexString(events) + " notifyNow=" + notifyNow + " subId=" + subId + " myUserId=" + UserHandle.myUserId() + " callerUserId=" + callerUserId);
    }
    if (events != PhoneStateListener.LISTEN_NONE) {
        /* Checks permission and throws Security exception */
        checkListenerPermission(events);
        if ((events & ENFORCE_PHONE_STATE_PERMISSION_MASK) != 0) {
            try {
                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
            // SKIP checking for run-time permission since caller or self has PRIVILEGED
            // permission
            } catch (SecurityException e) {
                if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
                    return;
                }
            }
        }
        synchronized (mRecords) {
            // register
            Record r;
            find_and_add: {
                IBinder b = callback.asBinder();
                final int N = mRecords.size();
                for (int i = 0; i < N; i++) {
                    r = mRecords.get(i);
                    if (b == r.binder) {
                        break find_and_add;
                    }
                }
                r = new Record();
                r.binder = b;
                mRecords.add(r);
                if (DBG)
                    log("listen: add new record");
            }
            r.callback = callback;
            r.callingPackage = callingPackage;
            r.callerUserId = callerUserId;
            boolean isPhoneStateEvent = (events & (CHECK_PHONE_STATE_PERMISSION_MASK | ENFORCE_PHONE_STATE_PERMISSION_MASK)) != 0;
            r.canReadPhoneState = isPhoneStateEvent && canReadPhoneState(callingPackage);
            // force all illegal subId to SubscriptionManager.DEFAULT_SUB_ID
            if (!SubscriptionManager.isValidSubscriptionId(subId)) {
                r.subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
            } else {
                // APP specify subID
                r.subId = subId;
            }
            r.phoneId = SubscriptionManager.getPhoneId(r.subId);
            int phoneId = r.phoneId;
            r.events = events;
            if (DBG) {
                log("listen:  Register r=" + r + " r.subId=" + r.subId + " phoneId=" + phoneId);
            }
            if (VDBG)
                toStringLogSSC("listen");
            if (notifyNow && validatePhoneId(phoneId)) {
                if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                    try {
                        if (VDBG)
                            log("listen: call onSSC state=" + mServiceState[phoneId]);
                        r.callback.onServiceStateChanged(new ServiceState(mServiceState[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
                    try {
                        int gsmSignalStrength = mSignalStrength[phoneId].getGsmSignalStrength();
                        r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1 : gsmSignalStrength));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
                    try {
                        r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
                    try {
                        r.callback.onCallForwardingIndicatorChanged(mCallForwarding[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellLocation = " + mCellLocation[phoneId]);
                        r.callback.onCellLocationChanged(new Bundle(mCellLocation[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
                    try {
                        r.callback.onCallStateChanged(mCallState[phoneId], getCallIncomingNumber(r, phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onDataConnectionStateChanged(mDataConnectionState[phoneId], mDataConnectionNetworkType[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
                    try {
                        r.callback.onDataActivity(mDataActivity[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
                    try {
                        r.callback.onSignalStrengthsChanged(mSignalStrength[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
                    try {
                        r.callback.onOtaspChanged(mOtaspMode);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellInfo[" + phoneId + "] = " + mCellInfo.get(phoneId));
                        r.callback.onCellInfoChanged(mCellInfo.get(phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_CALL_STATE) != 0) {
                    try {
                        r.callback.onPreciseCallStateChanged(mPreciseCallState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onPreciseDataConnectionStateChanged(mPreciseDataConnectionState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CARRIER_NETWORK_CHANGE) != 0) {
                    try {
                        r.callback.onCarrierNetworkChange(mCarrierNetworkChangeState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_VOICE_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onVoiceActivationStateChanged(mVoiceActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onDataActivationStateChanged(mDataActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
            }
        }
    } else {
        if (DBG)
            log("listen: Unregister");
        remove(callback.asBinder());
    }
}
#end_block

#method_before
public void notifySimActivationStateChangedForPhoneId(int phoneId, int subId, SimActivationState activationState) {
    if (!checkNotifyPermission("notifySimActivationState()")) {
        return;
    }
    if (VDBG) {
        log("notifySimActivationStateForPhoneId: subId=" + subId + " phoneId=" + phoneId + " state=" + activationState);
    }
    synchronized (mRecords) {
        if (validatePhoneId(phoneId)) {
            mSimActivationState[phoneId] = activationState;
            for (Record r : mRecords) {
                if (VDBG) {
                    log("notifySimActivationStateForPhoneId: r=" + r + " subId=" + subId + " phoneId=" + phoneId + " state=" + activationState);
                }
                if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_SIM_ACTIVATION_STATE) && idMatch(r.subId, subId, phoneId)) {
                    try {
                        if (DBG) {
                            log("notifySimActivationStateForPhoneId: callback.onSASC r=" + r + " subId=" + subId + " phoneId=" + phoneId + " state=" + activationState);
                        }
                        // TODO: a copy reference ?
                        r.callback.onSimActivationStateChanged(new SimActivationState(activationState));
                    } catch (RemoteException ex) {
                        mRemoveList.add(r.binder);
                    }
                }
            }
        } else {
            log("notifySimActivationStateForPhoneId: INVALID phoneId=" + phoneId);
        }
        handleRemoveListLocked();
    }
}
#method_after
public void notifySimActivationStateChangedForPhoneId(int phoneId, int subId, int activationType, int activationState) {
    if (!checkNotifyPermission("notifySimActivationState()")) {
        return;
    }
    if (VDBG) {
        log("notifySimActivationStateForPhoneId: subId=" + subId + " phoneId=" + phoneId + "type=" + activationType + " state=" + activationState);
    }
    synchronized (mRecords) {
        if (validatePhoneId(phoneId)) {
            switch(activationType) {
                case PhoneConstants.SIM_ACTIVATION_TYPE_VOICE:
                    mVoiceActivationState[phoneId] = activationState;
                    break;
                case PhoneConstants.SIM_ACTIVATION_TYPE_DATA:
                    mDataActivationState[phoneId] = activationState;
                    break;
                default:
                    return;
            }
            for (Record r : mRecords) {
                if (VDBG) {
                    log("notifySimActivationStateForPhoneId: r=" + r + " subId=" + subId + " phoneId=" + phoneId + "type=" + activationType + " state=" + activationState);
                }
                try {
                    if ((activationType == PhoneConstants.SIM_ACTIVATION_TYPE_VOICE) && r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_VOICE_ACTIVATION_STATE) && idMatch(r.subId, subId, phoneId)) {
                        if (DBG) {
                            log("notifyVoiceActivationStateForPhoneId: callback.onVASC r=" + r + " subId=" + subId + " phoneId=" + phoneId + " state=" + activationState);
                        }
                        r.callback.onVoiceActivationStateChanged(activationState);
                    }
                    if ((activationType == PhoneConstants.SIM_ACTIVATION_TYPE_DATA) && r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_DATA_ACTIVATION_STATE) && idMatch(r.subId, subId, phoneId)) {
                        if (DBG) {
                            log("notifyDataActivationStateForPhoneId: callback.onDASC r=" + r + " subId=" + subId + " phoneId=" + phoneId + " state=" + activationState);
                        }
                        r.callback.onDataActivationStateChanged(activationState);
                    }
                } catch (RemoteException ex) {
                    mRemoveList.add(r.binder);
                }
            }
        } else {
            log("notifySimActivationStateForPhoneId: INVALID phoneId=" + phoneId);
        }
        handleRemoveListLocked();
    }
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump telephony.registry from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    synchronized (mRecords) {
        final int recordCount = mRecords.size();
        pw.println("last known state:");
        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
            pw.println("  Phone Id=" + i);
            pw.println("  mCallState=" + mCallState[i]);
            pw.println("  mCallIncomingNumber=" + mCallIncomingNumber[i]);
            pw.println("  mServiceState=" + mServiceState[i]);
            pw.println("  mSimActivationState= " + mSimActivationState[i]);
            pw.println("  mSignalStrength=" + mSignalStrength[i]);
            pw.println("  mMessageWaiting=" + mMessageWaiting[i]);
            pw.println("  mCallForwarding=" + mCallForwarding[i]);
            pw.println("  mDataActivity=" + mDataActivity[i]);
            pw.println("  mDataConnectionState=" + mDataConnectionState[i]);
            pw.println("  mDataConnectionPossible=" + mDataConnectionPossible[i]);
            pw.println("  mDataConnectionReason=" + mDataConnectionReason[i]);
            pw.println("  mDataConnectionApn=" + mDataConnectionApn[i]);
            pw.println("  mDataConnectionLinkProperties=" + mDataConnectionLinkProperties[i]);
            pw.println("  mDataConnectionNetworkCapabilities=" + mDataConnectionNetworkCapabilities[i]);
            pw.println("  mCellLocation=" + mCellLocation[i]);
            pw.println("  mCellInfo=" + mCellInfo.get(i));
        }
        pw.println("registrations: count=" + recordCount);
        for (Record r : mRecords) {
            pw.println("  " + r);
        }
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump telephony.registry from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    synchronized (mRecords) {
        final int recordCount = mRecords.size();
        pw.println("last known state:");
        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
            pw.println("  Phone Id=" + i);
            pw.println("  mCallState=" + mCallState[i]);
            pw.println("  mCallIncomingNumber=" + mCallIncomingNumber[i]);
            pw.println("  mServiceState=" + mServiceState[i]);
            pw.println("  mVoiceActivationState= " + mVoiceActivationState[i]);
            pw.println("  mDataActivationState= " + mDataActivationState[i]);
            pw.println("  mSignalStrength=" + mSignalStrength[i]);
            pw.println("  mMessageWaiting=" + mMessageWaiting[i]);
            pw.println("  mCallForwarding=" + mCallForwarding[i]);
            pw.println("  mDataActivity=" + mDataActivity[i]);
            pw.println("  mDataConnectionState=" + mDataConnectionState[i]);
            pw.println("  mDataConnectionPossible=" + mDataConnectionPossible[i]);
            pw.println("  mDataConnectionReason=" + mDataConnectionReason[i]);
            pw.println("  mDataConnectionApn=" + mDataConnectionApn[i]);
            pw.println("  mDataConnectionLinkProperties=" + mDataConnectionLinkProperties[i]);
            pw.println("  mDataConnectionNetworkCapabilities=" + mDataConnectionNetworkCapabilities[i]);
            pw.println("  mCellLocation=" + mCellLocation[i]);
            pw.println("  mCellInfo=" + mCellInfo.get(i));
        }
        pw.println("registrations: count=" + recordCount);
        for (Record r : mRecords) {
            pw.println("  " + r);
        }
    }
}
#end_block

#method_before
private void broadcastSignalStrengthChanged(SignalStrength signalStrength, int phoneId, int subId) {
    long ident = Binder.clearCallingIdentity();
    try {
        mBatteryStats.notePhoneSignalStrength(signalStrength);
    } catch (RemoteException e) {
    /* The remote entity disappeared, we can safely ignore the exception. */
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    Intent intent = new Intent(TelephonyIntents.ACTION_SIGNAL_STRENGTH_CHANGED);
    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    Bundle data = new Bundle();
    signalStrength.fillInNotifierBundle(data);
    intent.putExtras(data);
    intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
    intent.putExtra(PhoneConstants.SLOT_KEY, phoneId);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
}
#method_after
private void broadcastSignalStrengthChanged(SignalStrength signalStrength, int phoneId, int subId) {
    long ident = Binder.clearCallingIdentity();
    try {
        mBatteryStats.notePhoneSignalStrength(signalStrength);
    } catch (RemoteException e) {
    /* The remote entity disappeared, we can safely ignore the exception. */
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    Intent intent = new Intent(TelephonyIntents.ACTION_SIGNAL_STRENGTH_CHANGED);
    Bundle data = new Bundle();
    signalStrength.fillInNotifierBundle(data);
    intent.putExtras(data);
    intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
    intent.putExtra(PhoneConstants.SLOT_KEY, phoneId);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
}
#end_block

#method_before
@Override
public void notifySimActivationStateChangedForPhoneId(int phoneId, int subId, SimActivationState state) {
    throw new RuntimeException("Not implemented");
}
#method_after
@Override
public void notifySimActivationStateChangedForPhoneId(int phoneId, int subId, int activationType, int state) {
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
public boolean setVoiceActivationState(int state) {
    if (!SimActivationState.isValidActivationState(state, false)) {
        loge("invalid voice activation state: " + state);
        return false;
    }
    if (mAS.setVoiceActivationState(state)) {
        logVoiceActivationStateChange();
        mPhone.notifySimActivationStateChanged(mAS);
    }
    return true;
}
#method_after
public void setVoiceActivationState(int state) {
    if (!isValidActivationState(state) || (SIM_ACTIVATION_STATE_RESTRICTED == state)) {
        throw new IllegalArgumentException("invalid voice activation state: " + state);
    }
    if (DBG)
        log("setVoiceActivationState=" + state);
    mVoiceActivationState = state;
    mVoiceActivationStateLog.log(toString(state));
    mPhone.notifyVoiceActivationStateChanged(state);
}
#end_block

#method_before
public boolean setDataActivationState(int state) {
    if (!SimActivationState.isValidActivationState(state, true)) {
        loge("invalid data activation state: " + state);
        return false;
    }
    if (mAS.setDataActivationState(state)) {
        logDataActivationStateChange();
        mPhone.notifySimActivationStateChanged(mAS);
    }
    return true;
}
#method_after
public void setDataActivationState(int state) {
    if (!isValidActivationState(state)) {
        throw new IllegalArgumentException("invalid data activation state: " + state);
    }
    if (DBG)
        log("setDataActivationState=" + state);
    mDataActivationState = state;
    mDataActivationStateLog.log(toString(state));
    mPhone.notifyDataActivationStateChanged(state);
}
#end_block

#method_before
public SimActivationTracker makeSimActivationTracker(GsmCdmaPhone phone) {
    return new SimActivationTracker(phone);
}
#method_after
public SimActivationTracker makeSimActivationTracker(Phone phone) {
    return new SimActivationTracker(phone);
}
#end_block

#method_before
public InboundSmsTracker makeInboundSmsTracker(Cursor cursor, boolean isCurrentFormat3gpp2) {
    return new InboundSmsTracker(cursor, isCurrentFormat3gpp2);
}
#method_after
public InboundSmsTracker makeInboundSmsTracker(byte[] pdu, long timestamp, int destPort, boolean is3gpp2, boolean is3gpp2WapPdu, String address, String displayAddr, String messageBody) {
    return new InboundSmsTracker(pdu, timestamp, destPort, is3gpp2, is3gpp2WapPdu, address, displayAddr, messageBody);
}
#end_block

#method_before
public ImsExternalCallTracker makeImsExternalCallTracker(ImsPhone imsPhone, ImsPullCall callPuller) {
    return new ImsExternalCallTracker(imsPhone, callPuller);
}
#method_after
public ImsExternalCallTracker makeImsExternalCallTracker(ImsPhone imsPhone) {
    return new ImsExternalCallTracker(imsPhone);
}
#end_block

#method_before
public void startMonitoringImsService() {
    if (getPhoneType() == PhoneConstants.PHONE_TYPE_SIP) {
        return;
    }
    synchronized (Phone.lockForRadioTechnologyChange) {
        IntentFilter filter = new IntentFilter();
        filter.addAction(ImsManager.ACTION_IMS_SERVICE_UP);
        filter.addAction(ImsManager.ACTION_IMS_SERVICE_DOWN);
        mContext.registerReceiver(mImsIntentReceiver, filter);
        // Monitor IMS service - but first poll to see if already up (could miss
        // intent)
        ImsManager imsManager = ImsManager.getInstance(mContext, getPhoneId());
        if (imsManager != null && imsManager.isServiceAvailable()) {
            mImsServiceReady = true;
            updateImsPhone();
            ImsManager.updateImsServiceConfig(mContext, mPhoneId, false);
        }
    }
}
#method_after
public void startMonitoringImsService() {
    if (getPhoneType() == PhoneConstants.PHONE_TYPE_SIP) {
        return;
    }
    synchronized (Phone.lockForRadioTechnologyChange) {
        IntentFilter filter = new IntentFilter();
        filter.addAction(ImsManager.ACTION_IMS_SERVICE_UP);
        filter.addAction(ImsManager.ACTION_IMS_SERVICE_DOWN);
        filter.addAction(ImsConfig.ACTION_IMS_CONFIG_CHANGED);
        mContext.registerReceiver(mImsIntentReceiver, filter);
        // Monitor IMS service - but first poll to see if already up (could miss
        // intent)
        ImsManager imsManager = ImsManager.getInstance(mContext, getPhoneId());
        if (imsManager != null && imsManager.isServiceAvailable()) {
            mImsServiceReady = true;
            updateImsPhone();
            ImsManager.updateImsServiceConfig(mContext, mPhoneId, false);
        }
    }
}
#end_block

#method_before
public boolean setVoiceActivationState(int state) {
    SimActivationTracker tracker = getSimActivationTracker();
    if (tracker != null) {
        return tracker.setVoiceActivationState(state);
    } else {
        Rlog.e(LOG_TAG, "no SAT instance");
        return false;
    }
}
#method_after
public void setVoiceActivationState(int state) {
    mSimActivationTracker.setVoiceActivationState(state);
}
#end_block

#method_before
public boolean setDataActivationState(int state) {
    SimActivationTracker tracker = getSimActivationTracker();
    if (tracker != null) {
        return tracker.setDataActivationState(state);
    } else {
        Rlog.e(LOG_TAG, "no SAT instance");
        return false;
    }
}
#method_after
public void setDataActivationState(int state) {
    mSimActivationTracker.setDataActivationState(state);
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("Phone: subId=" + getSubId());
    pw.println(" mPhoneId=" + mPhoneId);
    pw.println(" mCi=" + mCi);
    pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
    pw.println(" mDcTracker=" + mDcTracker);
    pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
    pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
    pw.println(" mCallRingDelay=" + mCallRingDelay);
    pw.println(" mIsVoiceCapable=" + mIsVoiceCapable);
    pw.println(" mIccRecords=" + mIccRecords.get());
    pw.println(" mUiccApplication=" + mUiccApplication.get());
    pw.println(" mSmsStorageMonitor=" + mSmsStorageMonitor);
    pw.println(" mSmsUsageMonitor=" + mSmsUsageMonitor);
    pw.flush();
    pw.println(" mLooper=" + mLooper);
    pw.println(" mContext=" + mContext);
    pw.println(" mNotifier=" + mNotifier);
    pw.println(" mSimulatedRadioControl=" + mSimulatedRadioControl);
    pw.println(" mUnitTestMode=" + mUnitTestMode);
    pw.println(" isDnsCheckDisabled()=" + isDnsCheckDisabled());
    pw.println(" getUnitTestMode()=" + getUnitTestMode());
    pw.println(" getState()=" + getState());
    pw.println(" getIccSerialNumber()=" + getIccSerialNumber());
    pw.println(" getIccRecordsLoaded()=" + getIccRecordsLoaded());
    pw.println(" getMessageWaitingIndicator()=" + getMessageWaitingIndicator());
    pw.println(" getCallForwardingIndicator()=" + getCallForwardingIndicator());
    pw.println(" isInEmergencyCall()=" + isInEmergencyCall());
    pw.flush();
    pw.println(" isInEcm()=" + isInEcm());
    pw.println(" getPhoneName()=" + getPhoneName());
    pw.println(" getPhoneType()=" + getPhoneType());
    pw.println(" getVoiceMessageCount()=" + getVoiceMessageCount());
    pw.println(" getActiveApnTypes()=" + getActiveApnTypes());
    pw.println(" isDataConnectivityPossible()=" + isDataConnectivityPossible());
    pw.println(" needsOtaServiceProvisioning=" + needsOtaServiceProvisioning());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    if (mImsPhone != null) {
        try {
            mImsPhone.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mDcTracker != null) {
        try {
            mDcTracker.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getServiceStateTracker() != null) {
        try {
            getServiceStateTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getCallTracker() != null) {
        try {
            getCallTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getSimActivationTracker() != null) {
        try {
            getSimActivationTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCi != null && mCi instanceof RIL) {
        try {
            ((RIL) mCi).dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("Phone: subId=" + getSubId());
    pw.println(" mPhoneId=" + mPhoneId);
    pw.println(" mCi=" + mCi);
    pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
    pw.println(" mDcTracker=" + mDcTracker);
    pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
    pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
    pw.println(" mCallRingDelay=" + mCallRingDelay);
    pw.println(" mIsVoiceCapable=" + mIsVoiceCapable);
    pw.println(" mIccRecords=" + mIccRecords.get());
    pw.println(" mUiccApplication=" + mUiccApplication.get());
    pw.println(" mSmsStorageMonitor=" + mSmsStorageMonitor);
    pw.println(" mSmsUsageMonitor=" + mSmsUsageMonitor);
    pw.flush();
    pw.println(" mLooper=" + mLooper);
    pw.println(" mContext=" + mContext);
    pw.println(" mNotifier=" + mNotifier);
    pw.println(" mSimulatedRadioControl=" + mSimulatedRadioControl);
    pw.println(" mUnitTestMode=" + mUnitTestMode);
    pw.println(" isDnsCheckDisabled()=" + isDnsCheckDisabled());
    pw.println(" getUnitTestMode()=" + getUnitTestMode());
    pw.println(" getState()=" + getState());
    pw.println(" getIccSerialNumber()=" + getIccSerialNumber());
    pw.println(" getIccRecordsLoaded()=" + getIccRecordsLoaded());
    pw.println(" getMessageWaitingIndicator()=" + getMessageWaitingIndicator());
    pw.println(" getCallForwardingIndicator()=" + getCallForwardingIndicator());
    pw.println(" isInEmergencyCall()=" + isInEmergencyCall());
    pw.flush();
    pw.println(" isInEcm()=" + isInEcm());
    pw.println(" getPhoneName()=" + getPhoneName());
    pw.println(" getPhoneType()=" + getPhoneType());
    pw.println(" getVoiceMessageCount()=" + getVoiceMessageCount());
    pw.println(" getActiveApnTypes()=" + getActiveApnTypes());
    pw.println(" isDataConnectivityPossible()=" + isDataConnectivityPossible());
    pw.println(" needsOtaServiceProvisioning=" + needsOtaServiceProvisioning());
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    if (mImsPhone != null) {
        try {
            mImsPhone.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mDcTracker != null) {
        try {
            mDcTracker.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getServiceStateTracker() != null) {
        try {
            getServiceStateTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCarrierActionAgent != null) {
        try {
            mCarrierActionAgent.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCarrierSignalAgent != null) {
        try {
            mCarrierSignalAgent.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (getCallTracker() != null) {
        try {
            getCallTracker().dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mSimActivationTracker != null) {
        try {
            mSimActivationTracker.dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
    if (mCi != null && mCi instanceof RIL) {
        try {
            ((RIL) mCi).dump(fd, pw, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        pw.flush();
        pw.println("++++++++++++++++++++++++++++++++");
    }
}
#end_block

#method_before
@Test
public void test_default_values() {
    // A builder with no values set should have the same values as a cleared calendar.
    assertBuildsExpected();
}
#method_after
@Test
public void test_default_values() {
    Calendar.Builder builder = new Calendar.Builder();
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test
public void test_setCalendarType_iso8601() {
    builder.setCalendarType("iso8601");
    // ISO 8601 represents a gregorian calendar with a specific configuration
    expected.setGregorianChange(new Date(Long.MIN_VALUE));
    expected.setFirstDayOfWeek(Calendar.MONDAY);
    expected.setMinimalDaysInFirstWeek(4);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setCalendarType_iso8601() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setCalendarType("iso8601");
    // ISO 8601 represents a gregorian calendar with a specific configuration
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.setGregorianChange(new Date(Long.MIN_VALUE));
    expected.setFirstDayOfWeek(Calendar.MONDAY);
    expected.setMinimalDaysInFirstWeek(4);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test
public void test_setCalendarType_invalid() {
    try {
        builder.setCalendarType(null);
        fail("Should have thrown NPE");
    } catch (NullPointerException e) {
    // expected
    }
    for (String unsupported : new String[] { "buddhist", "japanese", "notACalendarType" }) {
        try {
            // not supported
            builder.setCalendarType(unsupported);
            fail("Unsupported calendar type " + unsupported + " should have thrown.");
        } catch (IllegalArgumentException e) {
        // expected
        }
    }
}
#method_after
@Test
public void test_setCalendarType_invalid() {
    Calendar.Builder builder = new Calendar.Builder();
    try {
        builder.setCalendarType(null);
        fail("Should have thrown NPE");
    } catch (NullPointerException expected) {
    }
    for (String unsupported : new String[] { "buddhist", "japanese", "notACalendarType" }) {
        try {
            // not supported
            builder.setCalendarType(unsupported);
            fail("Unsupported calendar type " + unsupported + " should have thrown.");
        } catch (IllegalArgumentException expected) {
        }
    }
}
#end_block

#method_before
@Test
public void test_setCalendarType_reset() {
    builder.setCalendarType("gregorian");
    try {
        builder.setCalendarType("iso8601");
    } catch (IllegalStateException e) {
    // expected
    }
}
#method_after
@Test
public void test_setCalendarType_reset() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setCalendarType("gregorian");
    try {
        builder.setCalendarType("iso8601");
        fail("Should not accept second setCalendarType() call");
    } catch (IllegalStateException expected) {
    }
}
#end_block

#method_before
@Test
public void test_setDate() {
    builder.setDate(2000, Calendar.FEBRUARY, 3);
    expected.set(2000, Calendar.FEBRUARY, 3);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setDate() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setDate(2000, Calendar.FEBRUARY, 3);
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.set(2000, Calendar.FEBRUARY, 3);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test
public void test_setTimeOfDay() {
    builder.setTimeOfDay(10, 11, 12);
    expected.set(1970, Calendar.JANUARY, 1, 10, 11, 12);
    assertBuildsExpected();
    builder.setTimeOfDay(10, 11, 12, 13);
    expected.set(Calendar.MILLISECOND, 13);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setTimeOfDay() {
    Calendar.Builder builder = new Calendar.Builder();
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    builder.setTimeOfDay(10, 11, 12);
    expected.set(1970, Calendar.JANUARY, 1, 10, 11, 12);
    assertEquals(expected, builder.build());
    builder.setTimeOfDay(10, 11, 12, 13);
    expected.set(Calendar.MILLISECOND, 13);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test
public void test_setWeekDate() {
    builder.setWeekDate(1, 2000, Calendar.TUESDAY);
    expected.setWeekDate(1, 2000, Calendar.TUESDAY);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setWeekDate() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setWeekDate(1, 2000, Calendar.TUESDAY);
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.setWeekDate(1, 2000, Calendar.TUESDAY);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test
public void test_setLenient() {
    builder.set(Calendar.HOUR_OF_DAY, 25);
    builder.setLenient(false);
    try {
        builder.build();
        fail("Should have failed to build.");
    } catch (IllegalArgumentException e) {
    // expected
    }
    builder.setLenient(true);
    expected.setLenient(true);
    expected.set(Calendar.HOUR_OF_DAY, 25);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setLenient() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.set(Calendar.HOUR_OF_DAY, 25);
    builder.setLenient(false);
    try {
        builder.build();
        fail("Should have failed to build.");
    } catch (IllegalArgumentException expected) {
    }
    builder.setLenient(true);
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.setLenient(true);
    expected.set(Calendar.HOUR_OF_DAY, 25);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test
public void test_setLocale() {
    expected = new GregorianCalendar(Locale.GERMANY);
    expected.clear();
    builder.setLocale(Locale.GERMANY);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setLocale() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setLocale(Locale.GERMANY);
    GregorianCalendar expected = new GregorianCalendar(Locale.GERMANY);
    expected.clear();
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test
public void test_setLocale_thTH() {
    // See http://b/35138741
    Locale th = new Locale("th", "TH");
    expected = new GregorianCalendar(th);
    expected.clear();
    builder.setLocale(th);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setLocale_thTH() {
    // See http://b/35138741
    Calendar.Builder builder = new Calendar.Builder();
    Locale th = new Locale("th", "TH");
    builder.setLocale(th);
    GregorianCalendar expected = new GregorianCalendar(th);
    expected.clear();
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test
public void test_set() {
    builder.set(Calendar.YEAR, 2000);
    expected.set(Calendar.YEAR, 2000);
    assertBuildsExpected();
}
#method_after
@Test
public void test_set() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.set(Calendar.YEAR, 2000);
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.set(Calendar.YEAR, 2000);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void test_set_negative_field() {
    builder.set(-1, 1);
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void test_set_negative_field() {
    new Calendar.Builder().set(-1, 1);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void test_set_field_too_high() {
    builder.set(Calendar.FIELD_COUNT, 1);
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void test_set_field_too_high() {
    new Calendar.Builder().set(Calendar.FIELD_COUNT, 1);
}
#end_block

#method_before
@Test(expected = IllegalStateException.class)
public void test_set_after_setInstant() {
    builder.setInstant(0L);
    builder.set(Calendar.YEAR, 2000);
}
#method_after
@Test
public void test_set_after_setInstant() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setInstant(0L);
    try {
        builder.set(Calendar.YEAR, 2000);
        fail("Setting a field after setInstant should fail.");
    } catch (IllegalStateException expected) {
    }
}
#end_block

#method_before
@Test
public void test_setFields() {
    builder.setFields(Calendar.YEAR, 2000, Calendar.MONTH, Calendar.FEBRUARY);
    expected.set(Calendar.YEAR, 2000);
    expected.set(Calendar.MONTH, Calendar.FEBRUARY);
    assertBuildsExpected();
    // field values can be re-set and order of fields matter
    builder.setFields(Calendar.DAY_OF_WEEK_IN_MONTH, 1, // this will effectively be ignored
    Calendar.DAY_OF_MONTH, // this will effectively be ignored
    20, Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
    expected.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);
    expected.set(Calendar.DAY_OF_MONTH, 20);
    expected.set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
    assertBuildsExpected();
    // 20th February 2000 would have been a Sunday, but we set the DOW last.
    assertEquals("" + expected, Calendar.WEDNESDAY, builder.build().get(Calendar.DAY_OF_WEEK));
}
#method_after
@Test
public void test_setFields() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setFields(Calendar.YEAR, 2000, Calendar.MONTH, Calendar.FEBRUARY);
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.set(Calendar.YEAR, 2000);
    expected.set(Calendar.MONTH, Calendar.FEBRUARY);
    assertEquals(expected, builder.build());
    // field values can be re-set and order of fields matter
    builder.setFields(Calendar.DAY_OF_WEEK_IN_MONTH, 1, // this will effectively be ignored
    Calendar.DAY_OF_MONTH, // this will effectively be ignored
    20, Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
    expected.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);
    expected.set(Calendar.DAY_OF_MONTH, 20);
    expected.set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
    assertEquals(expected, builder.build());
    // 20th February 2000 would have been a Sunday, but we set the DOW last.
    assertEquals(Calendar.WEDNESDAY, builder.build().get(Calendar.DAY_OF_WEEK));
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void test_setFields_null() {
    builder.setFields(null);
}
#method_after
@Test(expected = NullPointerException.class)
public void test_setFields_null() {
    new Calendar.Builder().setFields(null);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void test_setFields_oddNumberOfArguments() {
    builder.setFields(Calendar.YEAR);
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void test_setFields_oddNumberOfArguments() {
    new Calendar.Builder().setFields(Calendar.YEAR);
}
#end_block

#method_before
@Test(expected = IllegalStateException.class)
public void test_setFields_after_setInstant() {
    builder.setInstant(0L);
    builder.setFields(Calendar.YEAR, 2000);
}
#method_after
@Test
public void test_setFields_after_setInstant() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setInstant(0L);
    try {
        builder.setFields(Calendar.YEAR, 2000);
        fail("Setting a field after setInstant should fail.");
    } catch (IllegalStateException expected) {
    }
}
#end_block

#method_before
@Test
public void test_setInstant() {
    builder.setInstant(Long.MIN_VALUE);
    expected.setTimeInMillis(Long.MIN_VALUE);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setInstant() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setInstant(Long.MIN_VALUE);
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.setTimeInMillis(Long.MIN_VALUE);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test(expected = IllegalStateException.class)
public void test_setInstant_after_set() {
    builder.set(Calendar.YEAR, 2000);
    builder.setInstant(0L);
}
#method_after
@Test
public void test_setInstant_after_set() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.set(Calendar.YEAR, 2000);
    try {
        builder.setInstant(0L);
        fail("Setting the instant after setting a field should fail.");
    } catch (IllegalStateException expected) {
    }
}
#end_block

#method_before
@Test
public void test_setInstant_Date() {
    builder.setInstant(new Date(Long.MAX_VALUE));
    expected.setTimeInMillis(Long.MAX_VALUE);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setInstant_Date() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setInstant(new Date(Long.MAX_VALUE));
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.setTimeInMillis(Long.MAX_VALUE);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void test_setInstant_Date_null() {
    builder.setInstant(null);
}
#method_after
@Test(expected = NullPointerException.class)
public void test_setInstant_Date_null() {
    new Calendar.Builder().setInstant(null);
}
#end_block

#method_before
@Test
public void test_setTimeZone() {
    TimeZone london = TimeZone.getTimeZone("Europe/London");
    builder.setTimeZone(london);
    expected.setTimeZone(london);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setTimeZone() {
    TimeZone london = TimeZone.getTimeZone("Europe/London");
    Calendar.Builder builder = new Calendar.Builder();
    builder.setTimeZone(london);
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.setTimeZone(london);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test(expected = NullPointerException.class)
public void test_setTimeZone_null() {
    builder.setTimeZone(null);
}
#method_after
@Test(expected = NullPointerException.class)
public void test_setTimeZone_null() {
    new Calendar.Builder().setTimeZone(null);
}
#end_block

#method_before
@Test
public void test_setWeekDefinition() {
    builder.setWeekDefinition(Calendar.TUESDAY, 7);
    expected.setFirstDayOfWeek(Calendar.TUESDAY);
    expected.setMinimalDaysInFirstWeek(7);
    assertBuildsExpected();
}
#method_after
@Test
public void test_setWeekDefinition() {
    Calendar.Builder builder = new Calendar.Builder();
    builder.setWeekDefinition(Calendar.TUESDAY, 7);
    GregorianCalendar expected = new GregorianCalendar();
    expected.clear();
    expected.setFirstDayOfWeek(Calendar.TUESDAY);
    expected.setMinimalDaysInFirstWeek(7);
    assertEquals(expected, builder.build());
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void test_setWeekDefinition_invalid_first_dow() {
    builder.setWeekDefinition(-1, 1);
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void test_setWeekDefinition_invalid_first_dow() {
    new Calendar.Builder().setWeekDefinition(-1, 1);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void test_setWeekDefinition_invalid_minimum_days() {
    builder.setWeekDefinition(Calendar.WEDNESDAY, 8);
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void test_setWeekDefinition_invalid_minimum_days() {
    new Calendar.Builder().setWeekDefinition(Calendar.WEDNESDAY, 8);
}
#end_block

#method_before
public Calendar build() {
    if (locale == null) {
        locale = Locale.getDefault();
    }
    if (zone == null) {
        zone = TimeZone.getDefault();
    }
    Calendar cal;
    if (type == null) {
        type = locale.getUnicodeLocaleType("ca");
    }
    if (type == null) {
        // Android-changed: don't return buddhist calendar.
        type = "gregory";
    }
    switch(type) {
        case "gregory":
            cal = new GregorianCalendar(zone, locale, true);
            break;
        case "iso8601":
            GregorianCalendar gcal = new GregorianCalendar(zone, locale, true);
            // make gcal a proleptic Gregorian
            gcal.setGregorianChange(new Date(Long.MIN_VALUE));
            // and week definition to be compatible with ISO 8601
            setWeekDefinition(MONDAY, 4);
            cal = gcal;
            break;
        default:
            throw new IllegalArgumentException("unknown calendar type: " + type);
    }
    cal.setLenient(lenient);
    if (firstDayOfWeek != 0) {
        cal.setFirstDayOfWeek(firstDayOfWeek);
        cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);
    }
    if (isInstantSet()) {
        cal.setTimeInMillis(instant);
        cal.complete();
        return cal;
    }
    if (fields != null) {
        boolean weekDate = isSet(WEEK_YEAR) && fields[WEEK_YEAR] > fields[YEAR];
        if (weekDate && !cal.isWeekDateSupported()) {
            throw new IllegalArgumentException("week date is unsupported by " + type);
        }
        // the fields resolution works in the Calendar.
        for (int stamp = MINIMUM_USER_STAMP; stamp < nextStamp; stamp++) {
            for (int index = 0; index <= maxFieldIndex; index++) {
                if (fields[index] == stamp) {
                    cal.set(index, fields[NFIELDS + index]);
                    break;
                }
            }
        }
        if (weekDate) {
            int weekOfYear = isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;
            int dayOfWeek = isSet(DAY_OF_WEEK) ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();
            cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);
        }
        cal.complete();
    }
    return cal;
}
#method_after
public Calendar build() {
    if (locale == null) {
        locale = Locale.getDefault();
    }
    if (zone == null) {
        zone = TimeZone.getDefault();
    }
    Calendar cal;
    if (type == null) {
        type = locale.getUnicodeLocaleType("ca");
    }
    if (type == null) {
        // Android-changed: don't switch to buddhist calendar based on locale.
        // See http://b/35138741
        /*
                if (locale.getCountry() == "TH"
                        && locale.getLanguage() == "th") {
                    type = "buddhist";
                } else {
                    type = "gregory";
                }
                */
        type = "gregory";
    }
    switch(type) {
        case "gregory":
            cal = new GregorianCalendar(zone, locale, true);
            break;
        case "iso8601":
            GregorianCalendar gcal = new GregorianCalendar(zone, locale, true);
            // make gcal a proleptic Gregorian
            gcal.setGregorianChange(new Date(Long.MIN_VALUE));
            // and week definition to be compatible with ISO 8601
            setWeekDefinition(MONDAY, 4);
            cal = gcal;
            break;
        // Android-changed: removed support for "buddhist" and "japanese".
        default:
            throw new IllegalArgumentException("unknown calendar type: " + type);
    }
    cal.setLenient(lenient);
    if (firstDayOfWeek != 0) {
        cal.setFirstDayOfWeek(firstDayOfWeek);
        cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);
    }
    if (isInstantSet()) {
        cal.setTimeInMillis(instant);
        cal.complete();
        return cal;
    }
    if (fields != null) {
        boolean weekDate = isSet(WEEK_YEAR) && fields[WEEK_YEAR] > fields[YEAR];
        if (weekDate && !cal.isWeekDateSupported()) {
            throw new IllegalArgumentException("week date is unsupported by " + type);
        }
        // the fields resolution works in the Calendar.
        for (int stamp = MINIMUM_USER_STAMP; stamp < nextStamp; stamp++) {
            for (int index = 0; index <= maxFieldIndex; index++) {
                if (fields[index] == stamp) {
                    cal.set(index, fields[NFIELDS + index]);
                    break;
                }
            }
        }
        if (weekDate) {
            int weekOfYear = isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;
            int dayOfWeek = isSet(DAY_OF_WEEK) ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();
            cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);
        }
        cal.complete();
    }
    return cal;
}
#end_block

#method_before
public void test_deserializedArrayLength() throws Exception {
    final float loadFactor = 0.75f;
    final int entriesCount = 100;
    // Create table
    Hashtable<Integer, Integer> hashtable1 = new Hashtable<>(1, loadFactor);
    for (int i = 0; i < entriesCount; i++) {
        hashtable1.put(i, 1);
    }
    // Serialize and deserialize
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    try (ObjectOutputStream oos = new ObjectOutputStream(bos)) {
        oos.writeObject(hashtable1);
    }
    Hashtable<Integer, Integer> hashtable2 = (Hashtable<Integer, Integer>) new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())).readObject();
    // check that table size is >= min expected size
    Field tableField = Hashtable.class.getDeclaredField("table");
    tableField.setAccessible(true);
    Object[] table2 = (Object[]) tableField.get(hashtable2);
    assertTrue(table2.length >= (entriesCount / loadFactor));
}
#method_after
public void test_deserializedArrayLength() throws Exception {
    final float loadFactor = 0.75f;
    final int entriesCount = 100;
    // Create table
    Hashtable<Integer, Integer> hashtable1 = new Hashtable<>(1, loadFactor);
    for (int i = 0; i < entriesCount; i++) {
        hashtable1.put(i, 1);
    }
    // Serialize and deserialize
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    try (ObjectOutputStream oos = new ObjectOutputStream(bos)) {
        oos.writeObject(hashtable1);
    }
    Hashtable<Integer, Integer> hashtable2 = (Hashtable<Integer, Integer>) new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())).readObject();
    // Check that table size is >= min expected size. Due to a bug in
    // Hashtable deserialization this wasn't the case.
    Field tableField = Hashtable.class.getDeclaredField("table");
    tableField.setAccessible(true);
    Object[] table2 = (Object[]) tableField.get(hashtable2);
    assertTrue(table2.length >= (entriesCount / loadFactor));
}
#end_block

#method_before
public static ArrayList<Byte> stringToByteArrayList(String str) {
    ArrayList<Byte> byteArrayList = new ArrayList<Byte>();
    for (byte b : str.getBytes(StandardCharsets.UTF_8)) {
        byteArrayList.add(new Byte(b));
    }
    return byteArrayList;
}
#method_after
public static ArrayList<Byte> stringToByteArrayList(String str) {
    if (str == null) {
        throw new IllegalArgumentException("null string");
    }
    ArrayList<Byte> byteArrayList = new ArrayList<Byte>();
    for (byte b : str.getBytes(StandardCharsets.UTF_8)) {
        byteArrayList.add(new Byte(b));
    }
    return byteArrayList;
}
#end_block

#method_before
public static String stringFromByteArrayList(ArrayList<Byte> byteArrayList) {
    if (byteArrayList == null)
        return null;
    byte[] byteArray = new byte[byteArrayList.size()];
    int i = 0;
    for (Byte b : byteArrayList) {
        byteArray[i] = b;
        i++;
    }
    return new String(byteArray, StandardCharsets.UTF_8);
}
#method_after
public static String stringFromByteArrayList(ArrayList<Byte> byteArrayList) {
    if (byteArrayList == null) {
        throw new IllegalArgumentException("null byte array list");
    }
    byte[] byteArray = new byte[byteArrayList.size()];
    int i = 0;
    for (Byte b : byteArrayList) {
        byteArray[i] = b;
        i++;
    }
    return new String(byteArray, StandardCharsets.UTF_8);
}
#end_block

#method_before
public static byte[] macAddressToByteArray(String bssidStr) {
    if (bssidStr == null) {
        throw new IllegalArgumentException("null bssid String");
    }
    if (ANY_BSSID_STR.equals(bssidStr))
        return ANY_BSSID_BYTES;
    String cleanBssid = bssidStr.replace(":", "");
    if (cleanBssid.length() != BSSID_LENGTH * 2) {
        throw new IllegalArgumentException("invalid bssid String length: " + cleanBssid);
    }
    return HexEncoding.decode(cleanBssid.toCharArray(), false);
}
#method_after
public static byte[] macAddressToByteArray(String macStr) {
    if (macStr == null) {
        throw new IllegalArgumentException("null mac string");
    }
    if (ANY_MAC_STR.equals(macStr))
        return ANY_MAC_BYTES;
    String cleanMac = macStr.replace(":", "");
    if (cleanMac.length() != MAC_LENGTH * 2) {
        throw new IllegalArgumentException("invalid mac string length: " + cleanMac);
    }
    return HexEncoding.decode(cleanMac.toCharArray(), false);
}
#end_block

#method_before
public static String macAddressFromByteArray(byte[] macArray) {
    if (macArray == null) {
        throw new IllegalArgumentException("null macArray");
    }
    if (macArray.length != BSSID_LENGTH) {
        throw new IllegalArgumentException("invalid macArray length: " + macArray.length);
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < macArray.length; i++) {
        sb.append(new String(HexEncoding.encode(macArray, i, 1))).append(":");
    }
    String mac = sb.toString();
    // remove trailing ':'
    return mac.substring(0, mac.length() - 1);
}
#method_after
public static String macAddressFromByteArray(byte[] macArray) {
    if (macArray == null) {
        throw new IllegalArgumentException("null mac bytes");
    }
    if (macArray.length != MAC_LENGTH) {
        throw new IllegalArgumentException("invalid macArray length: " + macArray.length);
    }
    StringBuilder sb = new StringBuilder(MAC_STR_LENGTH);
    for (int i = 0; i < macArray.length; i++) {
        if (i != 0)
            sb.append(":");
        sb.append(new String(HexEncoding.encode(macArray, i, 1)));
    }
    return sb.toString();
}
#end_block

#method_before
public static ArrayList<Byte> decodeSsid(String ssid) {
    int length = ssid.length();
    if ((length > 1) && (ssid.charAt(0) == '"') && (ssid.charAt(length - 1) == '"')) {
        ssid = ssid.substring(1, ssid.length() - 1);
    }
    return stringToByteArrayList(ssid);
}
#method_after
public static ArrayList<Byte> decodeSsid(String ssidStr) {
    if (ssidStr == null) {
        throw new IllegalArgumentException("null ssid string");
    }
    int length = ssidStr.length();
    if ((length > 1) && (ssidStr.charAt(0) == '"') && (ssidStr.charAt(length - 1) == '"')) {
        ssidStr = ssidStr.substring(1, ssidStr.length() - 1);
        return stringToByteArrayList(ssidStr);
    } else {
        return byteArrayToArrayList(hexStringToByteArray(ssidStr));
    }
}
#end_block

#method_before
public static String encodeSsid(ArrayList<Byte> ssidBytes) {
    if (ssidBytes == null)
        return null;
    if (ssidBytes.size() == 0)
        return "\"\"";
    byte[] ssidArray = new byte[ssidBytes.size()];
    int i = 0;
    for (Byte b : ssidBytes) {
        ssidArray[i] = b;
        i++;
    }
    return "\"" + (new String(ssidArray, StandardCharsets.UTF_8)) + "\"";
}
#method_after
public static String encodeSsid(ArrayList<Byte> ssidBytes) {
    if (ssidBytes == null) {
        throw new IllegalArgumentException("null ssid bytes");
    }
    byte[] ssidArray = byteArrayFromArrayList(ssidBytes);
    // Check for 0's in the byte stream in which case we cannot convert this into a string.
    if (!ssidBytes.contains(Byte.valueOf((byte) 0))) {
        CharsetDecoder decoder = StandardCharsets.US_ASCII.newDecoder();
        try {
            CharBuffer decoded = decoder.decode(ByteBuffer.wrap(ssidArray));
            return "\"" + decoded.toString() + "\"";
        } catch (CharacterCodingException cce) {
        }
    }
    return hexStringFromByteArray(ssidArray);
}
#end_block

#method_before
public static byte[] hexStringToByteArray(String hex) {
    return HexEncoding.decode(hex.toCharArray(), false);
}
#method_after
public static byte[] hexStringToByteArray(String hexStr) {
    if (hexStr == null) {
        throw new IllegalArgumentException("null hex string");
    }
    return HexEncoding.decode(hexStr.toCharArray(), false);
}
#end_block

#method_before
public static String hexStringFromByteArray(byte[] bytes) {
    return new String(HexEncoding.encode(bytes));
}
#method_after
public static String hexStringFromByteArray(byte[] bytes) {
    if (bytes == null) {
        throw new IllegalArgumentException("null hex bytes");
    }
    return new String(HexEncoding.encode(bytes));
}
#end_block

#method_before
public boolean initializeSupplicantHal() {
    if (!HIDL_ENABLE) {
        return true;
    }
    if (mSupplicantP2pIfaceHal != null) {
        if (!mSupplicantP2pIfaceHal.initialize()) {
            return false;
        }
    }
    return mSupplicantStaIfaceHal.initialize();
}
#method_after
public boolean initializeSupplicantHal() {
    if (!HIDL_ENABLE) {
        return true;
    }
    if (!mSupplicantP2pIfaceHal.initialize()) {
        return false;
    }
    return mSupplicantStaIfaceHal.initialize();
}
#end_block

#method_before
public boolean setNetworkExtra(int netId, String name, Map<String, String> values) {
    String encoded = createNetworkExtra(values);
    if (encoded == null) {
        return false;
    }
    return setNetworkVariable(netId, name, "\"" + encoded + "\"");
}
#method_after
public boolean setNetworkExtra(int netId, String name, Map<String, String> values) {
    String encoded = createNetworkExtra(values);
    if (encoded == null) {
        return false;
    }
    return setNetworkVariable(netId, name, encoded);
}
#end_block

#method_before
@VisibleForTesting
public static String createNetworkExtra(Map<String, String> values) {
    final String encoded;
    try {
        encoded = URLEncoder.encode(new JSONObject(values).toString(), "UTF-8");
    } catch (NullPointerException e) {
        Log.e(TAG, "Unable to serialize networkExtra: " + e.toString());
        return null;
    } catch (UnsupportedEncodingException e) {
        Log.e(TAG, "Unable to serialize networkExtra: " + e.toString());
        return null;
    }
    return encoded;
}
#method_after
@VisibleForTesting
public static String createNetworkExtra(Map<String, String> values) {
    final String encoded;
    try {
        encoded = URLEncoder.encode(new JSONObject(values).toString(), "UTF-8");
    } catch (NullPointerException e) {
        Log.e(TAG, "Unable to serialize networkExtra: " + e.toString());
        return null;
    } catch (UnsupportedEncodingException e) {
        Log.e(TAG, "Unable to serialize networkExtra: " + e.toString());
        return null;
    }
    return "\"" + encoded + "\"";
}
#end_block

#method_before
public ArrayList<ScanDetail> getScanResults() {
    int next_sid = 0;
    ArrayList<ScanDetail> results = new ArrayList<>();
    while (next_sid >= 0) {
        String rawResult = getRawScanResults(next_sid + "-");
        next_sid = -1;
        if (TextUtils.isEmpty(rawResult))
            break;
        String[] lines = rawResult.split("\n");
        // note that all these splits and substrings keep references to the original
        // huge string buffer while the amount we really want is generally pretty small
        // so make copies instead (one example b/11087956 wasted 400k of heap here).
        final int bssidStrLen = BSS_BSSID_STR.length();
        String bssid = "";
        int level = 0;
        int freq = 0;
        long tsf = 0;
        int cap = 0;
        String flags = "";
        WifiSsid wifiSsid = null;
        String infoElementsStr = null;
        List<String> anqpLines = null;
        for (String line : lines) {
            if (line.startsWith(BSS_ID_STR)) {
                // Will find the last id line
                try {
                    next_sid = Integer.parseInt(line.substring(BSS_ID_STR.length())) + 1;
                } catch (NumberFormatException e) {
                // Nothing to do
                }
            } else if (line.startsWith(BSS_BSSID_STR)) {
                bssid = new String(line.getBytes(), bssidStrLen, line.length() - bssidStrLen);
            } else if (line.startsWith(BSS_FREQ_STR)) {
                try {
                    freq = Integer.parseInt(line.substring(BSS_FREQ_STR.length()));
                } catch (NumberFormatException e) {
                    freq = 0;
                }
            } else if (line.startsWith(BSS_LEVEL_STR)) {
                try {
                    level = Integer.parseInt(line.substring(BSS_LEVEL_STR.length()));
                    /* some implementations avoid negative values by adding 256
                         * so we need to adjust for that here.
                         */
                    if (level > 0)
                        level -= 256;
                } catch (NumberFormatException e) {
                    level = 0;
                }
            } else if (line.startsWith(BSS_TSF_STR)) {
                try {
                    tsf = Long.parseLong(line.substring(BSS_TSF_STR.length()));
                } catch (NumberFormatException e) {
                    tsf = 0;
                }
            } else if (line.startsWith(BSS_CAPABILITIES_STR)) {
                try {
                    cap = Integer.decode(line.substring(BSS_CAPABILITIES_STR.length()));
                } catch (NumberFormatException e) {
                    cap = 0;
                }
            } else if (line.startsWith(BSS_SSID_STR)) {
                wifiSsid = WifiSsid.createFromAsciiEncoded(line.substring(BSS_SSID_STR.length()));
            } else if (line.startsWith(BSS_IE_STR)) {
                infoElementsStr = line;
            } else if (PasspointEventHandler.isAnqpAttribute(line)) {
                if (anqpLines == null) {
                    anqpLines = new ArrayList<>();
                }
                anqpLines.add(line);
            } else if (line.startsWith(BSS_DELIMITER_STR) || line.startsWith(BSS_END_STR)) {
                if (bssid != null) {
                    try {
                        if (infoElementsStr == null) {
                            throw new IllegalArgumentException("Null information element data");
                        }
                        int seperator = infoElementsStr.indexOf('=');
                        if (seperator < 0) {
                            throw new IllegalArgumentException("No element separator");
                        }
                        ScanResult.InformationElement[] infoElements = InformationElementUtil.parseInformationElements(Utils.hexToBytes(infoElementsStr.substring(seperator + 1)));
                        NetworkDetail networkDetail = new NetworkDetail(bssid, infoElements, anqpLines, freq);
                        String xssid = (wifiSsid != null) ? wifiSsid.toString() : WifiSsid.NONE;
                        if (!xssid.equals(networkDetail.getTrimmedSSID())) {
                            Log.d(TAG, String.format("Inconsistent SSID on BSSID '%s': '%s' vs '%s': %s", bssid, xssid, networkDetail.getSSID(), infoElementsStr));
                        }
                        if (networkDetail.hasInterworking()) {
                            if (DBG)
                                Log.d(TAG, "HSNwk: '" + networkDetail);
                        }
                        BitSet beaconCapBits = new BitSet(16);
                        for (int i = 0; i < 16; i++) {
                            if ((cap & (1 << i)) != 0) {
                                beaconCapBits.set(i);
                            }
                        }
                        InformationElementUtil.Capabilities capabilities = new InformationElementUtil.Capabilities();
                        capabilities.from(infoElements, beaconCapBits);
                        flags = capabilities.generateCapabilitiesString();
                        ScanDetail scan = new ScanDetail(networkDetail, wifiSsid, bssid, flags, level, freq, tsf, infoElements, anqpLines);
                        results.add(scan);
                    } catch (IllegalArgumentException iae) {
                        Log.d(TAG, "Failed to parse information elements: " + iae);
                    }
                }
                bssid = null;
                level = 0;
                freq = 0;
                tsf = 0;
                cap = 0;
                flags = "";
                wifiSsid = null;
                infoElementsStr = null;
                anqpLines = null;
            }
        }
    }
    return results;
}
#method_after
public ArrayList<ScanDetail> getScanResults() {
    return mWificondControl.getScanResults();
}
#end_block

#method_before
public boolean startWpsPbc(String bssid) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPbc(null, bssid);
    } else {
        if (TextUtils.isEmpty(bssid)) {
            return doBooleanCommand("WPS_PBC");
        } else {
            return doBooleanCommand("WPS_PBC " + bssid);
        }
    }
}
#method_after
public boolean startWpsPbc(String bssid) {
    if (TextUtils.isEmpty(bssid)) {
        return doBooleanCommand("WPS_PBC");
    } else {
        return doBooleanCommand("WPS_PBC " + bssid);
    }
}
#end_block

#method_before
public boolean startWpsPbc(String iface, String bssid) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPbc(iface, bssid);
    } else {
        synchronized (sLock) {
            if (TextUtils.isEmpty(bssid)) {
                return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC");
            } else {
                return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC " + bssid);
            }
        }
    }
}
#method_after
public boolean startWpsPbc(String iface, String bssid) {
    synchronized (sLock) {
        if (TextUtils.isEmpty(bssid)) {
            return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC");
        } else {
            return doBooleanCommandNative("IFNAME=" + iface + " WPS_PBC " + bssid);
        }
    }
}
#end_block

#method_before
public boolean startWpsPinKeypad(String pin) {
    if (TextUtils.isEmpty(pin))
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinKeypad(null, pin);
    } else {
        return doBooleanCommand("WPS_PIN any " + pin);
    }
}
#method_after
public boolean startWpsPinKeypad(String pin) {
    if (TextUtils.isEmpty(pin))
        return false;
    return doBooleanCommand("WPS_PIN any " + pin);
}
#end_block

#method_before
public boolean startWpsPinKeypad(String iface, String pin) {
    if (TextUtils.isEmpty(pin))
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinKeypad(iface, pin);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " WPS_PIN any " + pin);
        }
    }
}
#method_after
public boolean startWpsPinKeypad(String iface, String pin) {
    if (TextUtils.isEmpty(pin))
        return false;
    synchronized (sLock) {
        return doBooleanCommandNative("IFNAME=" + iface + " WPS_PIN any " + pin);
    }
}
#end_block

#method_before
public String startWpsPinDisplay(String bssid) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinDisplay(null, bssid);
    } else {
        if (TextUtils.isEmpty(bssid)) {
            return doStringCommand("WPS_PIN any");
        } else {
            return doStringCommand("WPS_PIN " + bssid);
        }
    }
}
#method_after
public String startWpsPinDisplay(String bssid) {
    if (TextUtils.isEmpty(bssid)) {
        return doStringCommand("WPS_PIN any");
    } else {
        return doStringCommand("WPS_PIN " + bssid);
    }
}
#end_block

#method_before
public String startWpsPinDisplay(String iface, String bssid) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.startWpsPinDisplay(iface, bssid);
    } else {
        synchronized (sLock) {
            if (TextUtils.isEmpty(bssid)) {
                return doStringCommandNative("IFNAME=" + iface + " WPS_PIN any");
            } else {
                return doStringCommandNative("IFNAME=" + iface + " WPS_PIN " + bssid);
            }
        }
    }
}
#method_after
public String startWpsPinDisplay(String iface, String bssid) {
    synchronized (sLock) {
        if (TextUtils.isEmpty(bssid)) {
            return doStringCommandNative("IFNAME=" + iface + " WPS_PIN any");
        } else {
            return doStringCommandNative("IFNAME=" + iface + " WPS_PIN " + bssid);
        }
    }
}
#end_block

#method_before
public boolean cancelWps() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.cancelWps(null);
    } else {
        return doBooleanCommand("WPS_CANCEL");
    }
}
#method_after
public boolean cancelWps() {
    return doBooleanCommand("WPS_CANCEL");
}
#end_block

#method_before
public boolean setP2pSsidPostfix(String postfix) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setSsidPostfix(postfix);
    } else {
        return doBooleanCommand("SET p2p_ssid_postfix " + postfix);
    }
}
#method_after
public boolean setP2pSsidPostfix(String postfix) {
    return doBooleanCommand("SET p2p_ssid_postfix " + postfix);
}
#end_block

#method_before
public boolean setP2pGroupIdle(String iface, int time) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setGroupIdle(iface, time);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " SET p2p_group_idle " + time);
        }
    }
}
#method_after
public boolean setP2pGroupIdle(String iface, int time) {
    synchronized (sLock) {
        return doBooleanCommandNative("IFNAME=" + iface + " SET p2p_group_idle " + time);
    }
}
#end_block

#method_before
public boolean setP2pPowerSave(String iface, boolean enabled) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setPowerSave(iface, enabled);
    } else {
        synchronized (sLock) {
            if (enabled) {
                return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 1");
            } else {
                return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 0");
            }
        }
    }
}
#method_after
public boolean setP2pPowerSave(String iface, boolean enabled) {
    synchronized (sLock) {
        if (enabled) {
            return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 1");
        } else {
            return doBooleanCommandNative("IFNAME=" + iface + " P2P_SET ps 0");
        }
    }
}
#end_block

#method_before
public boolean setWfdEnable(boolean enable) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.enableWfd(enable);
    } else {
        return doBooleanCommand("SET wifi_display " + (enable ? "1" : "0"));
    }
}
#method_after
public boolean setWfdEnable(boolean enable) {
    return doBooleanCommand("SET wifi_display " + (enable ? "1" : "0"));
}
#end_block

#method_before
public boolean setWfdDeviceInfo(String hex) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setWfdDeviceInfo(hex);
    } else {
        return doBooleanCommand("WFD_SUBELEM_SET 0 " + hex);
    }
}
#method_after
public boolean setWfdDeviceInfo(String hex) {
    return doBooleanCommand("WFD_SUBELEM_SET 0 " + hex);
}
#end_block

#method_before
public boolean p2pFind() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.find();
    } else {
        return doBooleanCommand("P2P_FIND");
    }
}
#method_after
public boolean p2pFind() {
    return doBooleanCommand("P2P_FIND");
}
#end_block

#method_before
public boolean p2pFind(int timeout) {
    if (timeout <= 0) {
        return p2pFind();
    }
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.find(timeout);
    } else {
        return doBooleanCommand("P2P_FIND " + timeout);
    }
}
#method_after
public boolean p2pFind(int timeout) {
    if (timeout <= 0) {
        return p2pFind();
    }
    return doBooleanCommand("P2P_FIND " + timeout);
}
#end_block

#method_before
public boolean p2pStopFind() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.stopFind();
    } else {
        return doBooleanCommand("P2P_STOP_FIND");
    }
}
#method_after
public boolean p2pStopFind() {
    return doBooleanCommand("P2P_STOP_FIND");
}
#end_block

#method_before
private boolean p2pListen() {
    return doBooleanCommand("P2P_LISTEN");
}
#method_after
public boolean p2pListen() {
    return doBooleanCommand("P2P_LISTEN");
}
#end_block

#method_before
private boolean p2pListen(int timeout) {
    if (timeout <= 0) {
        return p2pListen();
    }
    return doBooleanCommand("P2P_LISTEN " + timeout);
}
#method_after
public boolean p2pListen(int timeout) {
    if (timeout <= 0) {
        return p2pListen();
    }
    return doBooleanCommand("P2P_LISTEN " + timeout);
}
#end_block

#method_before
public boolean p2pExtListen(boolean enable, int period, int interval) {
    if (enable && interval < period) {
        return false;
    }
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.configureExtListen(enable, period, interval);
    } else {
        return doBooleanCommand("P2P_EXT_LISTEN" + (enable ? (" " + period + " " + interval) : ""));
    }
}
#method_after
public boolean p2pExtListen(boolean enable, int period, int interval) {
    if (enable && interval < period) {
        return false;
    }
    return doBooleanCommand("P2P_EXT_LISTEN" + (enable ? (" " + period + " " + interval) : ""));
}
#end_block

#method_before
public boolean p2pSetChannel(int lc, int oc) {
    if (DBG)
        Log.d(mTAG, "p2pSetChannel: lc=" + lc + ", oc=" + oc);
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.setListenChannel(lc, oc);
    } else {
        synchronized (sLock) {
            if (lc >= 1 && lc <= 11) {
                if (!doBooleanCommand("P2P_SET listen_channel " + lc)) {
                    return false;
                }
            } else if (lc != 0) {
                return false;
            }
            if (oc >= 1 && oc <= 165) {
                int freq = (oc <= 14 ? 2407 : 5000) + oc * 5;
                return doBooleanCommand("P2P_SET disallow_freq 1000-" + (freq - 5) + "," + (freq + 5) + "-6000");
            } else if (oc == 0) {
                /* oc==0 disables "P2P_SET disallow_freq" (enables all freqs) */
                return doBooleanCommand("P2P_SET disallow_freq \"\"");
            }
        }
        return false;
    }
}
#method_after
public boolean p2pSetChannel(int lc, int oc) {
    if (DBG)
        Log.d(mTAG, "p2pSetChannel: lc=" + lc + ", oc=" + oc);
    synchronized (sLock) {
        if (lc >= 1 && lc <= 11) {
            if (!doBooleanCommand("P2P_SET listen_channel " + lc)) {
                return false;
            }
        } else if (lc != 0) {
            return false;
        }
        if (oc >= 1 && oc <= 165) {
            int freq = (oc <= 14 ? 2407 : 5000) + oc * 5;
            return doBooleanCommand("P2P_SET disallow_freq 1000-" + (freq - 5) + "," + (freq + 5) + "-6000");
        } else if (oc == 0) {
            /* oc==0 disables "P2P_SET disallow_freq" (enables all freqs) */
            return doBooleanCommand("P2P_SET disallow_freq \"\"");
        }
    }
    return false;
}
#end_block

#method_before
public boolean p2pFlush() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.flush();
    } else {
        return doBooleanCommand("P2P_FLUSH");
    }
}
#method_after
public boolean p2pFlush() {
    return doBooleanCommand("P2P_FLUSH");
}
#end_block

#method_before
public boolean p2pCancelConnect() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.cancelConnect();
    } else {
        return doBooleanCommand("P2P_CANCEL");
    }
}
#method_after
public boolean p2pCancelConnect() {
    return doBooleanCommand("P2P_CANCEL");
}
#end_block

#method_before
public boolean p2pProvisionDiscovery(WifiP2pConfig config) {
    if (config == null)
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.provisionDiscovery(config);
    } else {
        switch(config.wps.setup) {
            case WpsInfo.PBC:
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " pbc");
            case WpsInfo.DISPLAY:
                // We are doing display, so provision discovery is keypad
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " keypad");
            case WpsInfo.KEYPAD:
                // We are doing keypad, so provision discovery is display
                return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " display");
            default:
                break;
        }
        return false;
    }
}
#method_after
public boolean p2pProvisionDiscovery(WifiP2pConfig config) {
    if (config == null)
        return false;
    switch(config.wps.setup) {
        case WpsInfo.PBC:
            return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " pbc");
        case WpsInfo.DISPLAY:
            // We are doing display, so provision discovery is keypad
            return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " keypad");
        case WpsInfo.KEYPAD:
            // We are doing keypad, so provision discovery is display
            return doBooleanCommand("P2P_PROV_DISC " + config.deviceAddress + " display");
        default:
            break;
    }
    return false;
}
#end_block

#method_before
public boolean p2pGroupAdd(boolean persistent) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupAdd(persistent);
    } else {
        if (persistent) {
            return doBooleanCommand("P2P_GROUP_ADD persistent");
        }
        return doBooleanCommand("P2P_GROUP_ADD");
    }
}
#method_after
public boolean p2pGroupAdd(boolean persistent) {
    if (persistent) {
        return doBooleanCommand("P2P_GROUP_ADD persistent");
    }
    return doBooleanCommand("P2P_GROUP_ADD");
}
#end_block

#method_before
public boolean p2pGroupAdd(int netId) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupAdd(netId, true);
    } else {
        return doBooleanCommand("P2P_GROUP_ADD persistent=" + netId);
    }
}
#method_after
public boolean p2pGroupAdd(int netId) {
    return doBooleanCommand("P2P_GROUP_ADD persistent=" + netId);
}
#end_block

#method_before
public boolean p2pGroupRemove(String iface) {
    if (TextUtils.isEmpty(iface))
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.groupRemove(iface);
    } else {
        synchronized (sLock) {
            return doBooleanCommandNative("IFNAME=" + iface + " P2P_GROUP_REMOVE " + iface);
        }
    }
}
#method_after
public boolean p2pGroupRemove(String iface) {
    if (TextUtils.isEmpty(iface))
        return false;
    synchronized (sLock) {
        return doBooleanCommandNative("IFNAME=" + iface + " P2P_GROUP_REMOVE " + iface);
    }
}
#end_block

#method_before
public boolean p2pReject(String deviceAddress) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.reject(deviceAddress);
    } else {
        return doBooleanCommand("P2P_REJECT " + deviceAddress);
    }
}
#method_after
public boolean p2pReject(String deviceAddress) {
    return doBooleanCommand("P2P_REJECT " + deviceAddress);
}
#end_block

#method_before
public boolean p2pInvite(WifiP2pGroup group, String deviceAddress) {
    if (TextUtils.isEmpty(deviceAddress))
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.invite(group, deviceAddress);
    } else {
        if (group == null) {
            return doBooleanCommand("P2P_INVITE peer=" + deviceAddress);
        } else {
            return doBooleanCommand("P2P_INVITE group=" + group.getInterface() + " peer=" + deviceAddress + " go_dev_addr=" + group.getOwner().deviceAddress);
        }
    }
}
#method_after
public boolean p2pInvite(WifiP2pGroup group, String deviceAddress) {
    if (TextUtils.isEmpty(deviceAddress))
        return false;
    if (group == null) {
        return doBooleanCommand("P2P_INVITE peer=" + deviceAddress);
    } else {
        return doBooleanCommand("P2P_INVITE group=" + group.getInterface() + " peer=" + deviceAddress + " go_dev_addr=" + group.getOwner().deviceAddress);
    }
}
#end_block

#method_before
public boolean p2pReinvoke(int netId, String deviceAddress) {
    if (TextUtils.isEmpty(deviceAddress) || netId < 0)
        return false;
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.reinvoke(netId, deviceAddress);
    } else {
        return doBooleanCommand("P2P_INVITE persistent=" + netId + " peer=" + deviceAddress);
    }
}
#method_after
public boolean p2pReinvoke(int netId, String deviceAddress) {
    if (TextUtils.isEmpty(deviceAddress) || netId < 0)
        return false;
    return doBooleanCommand("P2P_INVITE persistent=" + netId + " peer=" + deviceAddress);
}
#end_block

#method_before
public String p2pGetSsid(String deviceAddress) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getSsid(deviceAddress);
    } else {
        return p2pGetParam(deviceAddress, "oper_ssid");
    }
}
#method_after
public String p2pGetSsid(String deviceAddress) {
    return p2pGetParam(deviceAddress, "oper_ssid");
}
#end_block

#method_before
public String p2pGetDeviceAddress() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getDeviceAddress();
    } else {
        Log.d(TAG, "p2pGetDeviceAddress");
        String status = null;
        synchronized (sLock) {
            status = doStringCommandNative("STATUS");
        }
        String result = "";
        if (status != null) {
            String[] tokens = status.split("\n");
            for (String token : tokens) {
                if (token.startsWith("p2p_device_address=")) {
                    String[] nameValue = token.split("=");
                    if (nameValue.length != 2)
                        break;
                    result = nameValue[1];
                }
            }
        }
        Log.d(TAG, "p2pGetDeviceAddress returning " + result);
        return result;
    }
}
#method_after
public String p2pGetDeviceAddress() {
    Log.d(TAG, "p2pGetDeviceAddress");
    String status = null;
    synchronized (sLock) {
        status = doStringCommandNative("STATUS");
    }
    String result = "";
    if (status != null) {
        String[] tokens = status.split("\n");
        for (String token : tokens) {
            if (token.startsWith("p2p_device_address=")) {
                String[] nameValue = token.split("=");
                if (nameValue.length != 2)
                    break;
                result = nameValue[1];
            }
        }
    }
    Log.d(TAG, "p2pGetDeviceAddress returning " + result);
    return result;
}
#end_block

#method_before
public int getGroupCapability(String deviceAddress) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.getGroupCapability(deviceAddress);
    } else {
        int gc = 0;
        if (TextUtils.isEmpty(deviceAddress))
            return gc;
        String peerInfo = p2pPeer(deviceAddress);
        if (TextUtils.isEmpty(peerInfo))
            return gc;
        String[] tokens = peerInfo.split("\n");
        for (String token : tokens) {
            if (token.startsWith("group_capab=")) {
                String[] nameValue = token.split("=");
                if (nameValue.length != 2)
                    break;
                try {
                    return Integer.decode(nameValue[1]);
                } catch (NumberFormatException e) {
                    return gc;
                }
            }
        }
        return gc;
    }
}
#method_after
public int getGroupCapability(String deviceAddress) {
    int gc = 0;
    if (TextUtils.isEmpty(deviceAddress))
        return gc;
    String peerInfo = p2pPeer(deviceAddress);
    if (TextUtils.isEmpty(peerInfo))
        return gc;
    String[] tokens = peerInfo.split("\n");
    for (String token : tokens) {
        if (token.startsWith("group_capab=")) {
            String[] nameValue = token.split("=");
            if (nameValue.length != 2)
                break;
            try {
                return Integer.decode(nameValue[1]);
            } catch (NumberFormatException e) {
                return gc;
            }
        }
    }
    return gc;
}
#end_block

#method_before
private String p2pPeer(String deviceAddress) {
    return doStringCommand("P2P_PEER " + deviceAddress);
}
#method_after
public String p2pPeer(String deviceAddress) {
    return doStringCommand("P2P_PEER " + deviceAddress);
}
#end_block

#method_before
public boolean p2pServiceAdd(WifiP2pServiceInfo servInfo) {
    /*
         * P2P_SERVICE_ADD bonjour <query hexdump> <RDATA hexdump>
         * P2P_SERVICE_ADD upnp <version hex> <service>
         *
         * e.g)
         * [Bonjour]
         * # IP Printing over TCP (PTR) (RDATA=MyPrinter._ipp._tcp.local.)
         * P2P_SERVICE_ADD bonjour 045f697070c00c000c01 094d795072696e746572c027
         * # IP Printing over TCP (TXT) (RDATA=txtvers=1,pdl=application/postscript)
         * P2P_SERVICE_ADD bonjour 096d797072696e746572045f697070c00c001001
         *  09747874766572733d311a70646c3d6170706c69636174696f6e2f706f7374736372797074
         *
         * [UPnP]
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::upnp:rootdevice
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::urn:schemas-upnp
         * -org:device:InternetGatewayDevice:1
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9322-123456789012::urn:schemas-upnp
         * -org:service:ContentDirectory:2
         */
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceAdd(servInfo);
    } else {
        synchronized (sLock) {
            for (String s : servInfo.getSupplicantQueryList()) {
                String command = "P2P_SERVICE_ADD";
                command += (" " + s);
                if (!doBooleanCommand(command)) {
                    return false;
                }
            }
        }
        return true;
    }
}
#method_after
public boolean p2pServiceAdd(WifiP2pServiceInfo servInfo) {
    /*
         * P2P_SERVICE_ADD bonjour <query hexdump> <RDATA hexdump>
         * P2P_SERVICE_ADD upnp <version hex> <service>
         *
         * e.g)
         * [Bonjour]
         * # IP Printing over TCP (PTR) (RDATA=MyPrinter._ipp._tcp.local.)
         * P2P_SERVICE_ADD bonjour 045f697070c00c000c01 094d795072696e746572c027
         * # IP Printing over TCP (TXT) (RDATA=txtvers=1,pdl=application/postscript)
         * P2P_SERVICE_ADD bonjour 096d797072696e746572045f697070c00c001001
         *  09747874766572733d311a70646c3d6170706c69636174696f6e2f706f7374736372797074
         *
         * [UPnP]
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::upnp:rootdevice
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9332-123456789012::urn:schemas-upnp
         * -org:device:InternetGatewayDevice:1
         * P2P_SERVICE_ADD upnp 10 uuid:6859dede-8574-59ab-9322-123456789012::urn:schemas-upnp
         * -org:service:ContentDirectory:2
         */
    synchronized (sLock) {
        for (String s : servInfo.getSupplicantQueryList()) {
            String command = "P2P_SERVICE_ADD";
            command += (" " + s);
            if (!doBooleanCommand(command)) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
public boolean p2pServiceDel(WifiP2pServiceInfo servInfo) {
    /*
         * P2P_SERVICE_DEL bonjour <query hexdump>
         * P2P_SERVICE_DEL upnp <version hex> <service>
         */
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceRemove(servInfo);
    } else {
        synchronized (sLock) {
            for (String s : servInfo.getSupplicantQueryList()) {
                String command = "P2P_SERVICE_DEL ";
                String[] data = s.split(" ");
                if (data.length < 2) {
                    return false;
                }
                if ("upnp".equals(data[0])) {
                    command += s;
                } else if ("bonjour".equals(data[0])) {
                    command += data[0];
                    command += (" " + data[1]);
                } else {
                    return false;
                }
                if (!doBooleanCommand(command)) {
                    return false;
                }
            }
        }
        return true;
    }
}
#method_after
public boolean p2pServiceDel(WifiP2pServiceInfo servInfo) {
    /*
         * P2P_SERVICE_DEL bonjour <query hexdump>
         * P2P_SERVICE_DEL upnp <version hex> <service>
         */
    synchronized (sLock) {
        for (String s : servInfo.getSupplicantQueryList()) {
            String command = "P2P_SERVICE_DEL ";
            String[] data = s.split(" ");
            if (data.length < 2) {
                return false;
            }
            if ("upnp".equals(data[0])) {
                command += s;
            } else if ("bonjour".equals(data[0])) {
                command += data[0];
                command += (" " + data[1]);
            } else {
                return false;
            }
            if (!doBooleanCommand(command)) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
public boolean p2pServiceFlush() {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.serviceFlush();
    } else {
        return doBooleanCommand("P2P_SERVICE_FLUSH");
    }
}
#method_after
public boolean p2pServiceFlush() {
    return doBooleanCommand("P2P_SERVICE_FLUSH");
}
#end_block

#method_before
public String p2pServDiscReq(String addr, String query) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.requestServiceDiscovery(addr, query);
    } else {
        String command = "P2P_SERV_DISC_REQ";
        command += (" " + addr);
        command += (" " + query);
        return doStringCommand(command);
    }
}
#method_after
public String p2pServDiscReq(String addr, String query) {
    String command = "P2P_SERV_DISC_REQ";
    command += (" " + addr);
    command += (" " + query);
    return doStringCommand(command);
}
#end_block

#method_before
public boolean p2pServDiscCancelReq(String id) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        return mSupplicantP2pIfaceHal.cancelServiceDiscovery(id);
    } else {
        return doBooleanCommand("P2P_SERV_DISC_CANCEL_REQ " + id);
    }
}
#method_after
public boolean p2pServDiscCancelReq(String id) {
    return doBooleanCommand("P2P_SERV_DISC_CANCEL_REQ " + id);
}
#end_block

#method_before
public void setMiracastMode(int mode) {
    if (HIDL_ENABLE && mSupplicantP2pIfaceHal != null) {
        mSupplicantP2pIfaceHal.setMiracastMode(mode);
    } else {
        // Note: optional feature on the driver. It is ok for this to fail.
        doBooleanCommand("DRIVER MIRACAST " + mode);
    }
}
#method_after
public void setMiracastMode(int mode) {
    // Note: optional feature on the driver. It is ok for this to fail.
    doBooleanCommand("DRIVER MIRACAST " + mode);
}
#end_block

#method_before
public boolean initialize() {
    if (DBG)
        Log.i(TAG, "Registering ISupplicant service ready callback.");
    synchronized (mLock) {
        mISupplicant = null;
        mISupplicantP2pIface = null;
        if (mIServiceManager != null) {
            // don't register another.
            return true;
        }
        try {
            mIServiceManager = getServiceManagerMockable();
            if (mIServiceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!mIServiceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                    // Will need to register a new ServiceNotification
                    mIServiceManager = null;
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    synchronized (mLock) {
                        if (DBG) {
                            Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                        }
                        if (!initSupplicantService() || !initSupplicantP2pIface()) {
                            Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                            supplicantServiceDiedHandler();
                        } else {
                            Log.i(TAG, "Completed initialization of ISupplicant interfaces.");
                        }
                    }
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!mIServiceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
            supplicantServiceDiedHandler();
        }
        return true;
    }
}
#method_after
public boolean initialize() {
    if (DBG)
        Log.i(TAG, "Registering ISupplicant service ready callback.");
    synchronized (mLock) {
        if (mIServiceManager != null) {
            Log.i(TAG, "Supplicant HAL already initialized.");
            // don't register another.
            return true;
        }
        mISupplicant = null;
        mISupplicantP2pIface = null;
        try {
            mIServiceManager = getServiceManagerMockable();
            if (mIServiceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!mIServiceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                    // Will need to register a new ServiceNotification
                    mIServiceManager = null;
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    synchronized (mLock) {
                        if (DBG) {
                            Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                        }
                        if (!initSupplicantService() || !initSupplicantP2pIface()) {
                            Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                            supplicantServiceDiedHandler();
                        } else {
                            Log.i(TAG, "Completed initialization of ISupplicant interfaces.");
                        }
                    }
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!mIServiceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
            supplicantServiceDiedHandler();
        }
        return true;
    }
}
#end_block

#method_before
private boolean initSupplicantP2pIface() {
    synchronized (mLock) {
        /**
         * List all supplicant Ifaces
         */
        final ArrayList<ISupplicant.IfaceInfo> supplicantIfaces = new ArrayList();
        try {
            mISupplicant.listInterfaces((SupplicantStatus status, ArrayList<ISupplicant.IfaceInfo> ifaces) -> {
                if (status.code != SupplicantStatusCode.SUCCESS) {
                    Log.e(TAG, "Getting Supplicant Interfaces failed: " + status.code);
                    return;
                }
                supplicantIfaces.addAll(ifaces);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicant.listInterfaces exception: " + e);
            return false;
        }
        if (supplicantIfaces.size() == 0) {
            Log.e(TAG, "Got zero HIDL supplicant ifaces. Stopping supplicant HIDL startup.");
            return false;
        }
        SupplicantResult<ISupplicantIface> supplicantIface = new SupplicantResult("getInterface()");
        for (ISupplicant.IfaceInfo ifaceInfo : supplicantIfaces) {
            if (ifaceInfo.type == IfaceType.P2P) {
                try {
                    mISupplicant.getInterface(ifaceInfo, (SupplicantStatus status, ISupplicantIface iface) -> {
                        if (status.code != SupplicantStatusCode.SUCCESS) {
                            Log.e(TAG, "Failed to get ISupplicantIface " + status.code);
                            return;
                        }
                        supplicantIface.setResult(status, iface);
                    });
                } catch (RemoteException e) {
                    Log.e(TAG, "ISupplicant.getInterface exception: " + e);
                    return false;
                }
                break;
            }
        }
        if (supplicantIface.getResultOrFallbackValue() == null) {
            Log.e(TAG, "initSupplicantP2pIface got null iface");
            return false;
        }
        mISupplicantP2pIface = getP2pIfaceMockable(supplicantIface.getResultOrFallbackValue());
        return true;
    }
}
#method_after
private boolean initSupplicantP2pIface() {
    synchronized (mLock) {
        /**
         * List all supplicant Ifaces
         */
        final ArrayList<ISupplicant.IfaceInfo> supplicantIfaces = new ArrayList();
        try {
            mISupplicant.listInterfaces((SupplicantStatus status, ArrayList<ISupplicant.IfaceInfo> ifaces) -> {
                if (status.code != SupplicantStatusCode.SUCCESS) {
                    Log.e(TAG, "Getting Supplicant Interfaces failed: " + status.code);
                    return;
                }
                supplicantIfaces.addAll(ifaces);
            });
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicant.listInterfaces exception: " + e);
            return false;
        }
        if (supplicantIfaces.size() == 0) {
            Log.e(TAG, "Got zero HIDL supplicant ifaces. Stopping supplicant HIDL startup.");
            return false;
        }
        SupplicantResult<ISupplicantIface> supplicantIface = new SupplicantResult("getInterface()");
        for (ISupplicant.IfaceInfo ifaceInfo : supplicantIfaces) {
            if (ifaceInfo.type == IfaceType.P2P) {
                try {
                    mISupplicant.getInterface(ifaceInfo, (SupplicantStatus status, ISupplicantIface iface) -> {
                        if (status.code != SupplicantStatusCode.SUCCESS) {
                            Log.e(TAG, "Failed to get ISupplicantIface " + status.code);
                            return;
                        }
                        supplicantIface.setResult(status, iface);
                    });
                } catch (RemoteException e) {
                    Log.e(TAG, "ISupplicant.getInterface exception: " + e);
                    return false;
                }
                break;
            }
        }
        if (supplicantIface.getResult() == null) {
            Log.e(TAG, "initSupplicantP2pIface got null iface");
            return false;
        }
        mISupplicantP2pIface = getP2pIfaceMockable(supplicantIface.getResult());
        return true;
    }
}
#end_block

#method_before
public void testTimeZoneParsingErrorIndex() {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy z", Locale.ENGLISH);
    ParsePosition pos = new ParsePosition(0);
    Date parsed;
    parsed = dateFormat.parse("2000 foobar", pos);
    assertNull(parsed);
    assertEquals(5, pos.getErrorIndex());
}
#method_after
public void testTimeZoneParsingErrorIndex() {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy z", Locale.ENGLISH);
    checkTimeZoneParsingErrorIndex(dateFormat);
}
#end_block

#method_before
public void testTimeZoneParsingErrorIndexWithZoneStrings() {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy z", Locale.ENGLISH);
    // Force legacy code path using zone strings
    DateFormatSymbols dfs = dateFormat.getDateFormatSymbols();
    dfs.setZoneStrings(dfs.getZoneStrings());
    dateFormat.setDateFormatSymbols(dfs);
    ParsePosition pos = new ParsePosition(0);
    Date parsed;
    parsed = dateFormat.parse("2000 foobar", pos);
    assertNull(parsed);
    assertEquals(5, pos.getErrorIndex());
}
#method_after
public void testTimeZoneParsingErrorIndexWithZoneStrings() {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy z", Locale.ENGLISH);
    // Force legacy code path by using zone strings.
    DateFormatSymbols dfs = dateFormat.getDateFormatSymbols();
    dfs.setZoneStrings(dfs.getZoneStrings());
    dateFormat.setDateFormatSymbols(dfs);
    checkTimeZoneParsingErrorIndex(dateFormat);
}
#end_block

#method_before
public void test_toZonedDateTime() {
    GregorianCalendar cal = new GregorianCalendar();
    ZonedDateTime zonedDateTime = cal.toZonedDateTime();
    assertEquals(cal.getTimeZone().toZoneId(), zonedDateTime.getZone());
    assertEquals(cal.getTimeInMillis(), zonedDateTime.toInstant().toEpochMilli());
}
#method_after
public void test_toZonedDateTime() {
    TimeZone timeZone = TimeZone.getTimeZone("Europe/Paris");
    GregorianCalendar calendar = new GregorianCalendar(timeZone);
    calendar.set(2007, Calendar.DECEMBER, 3, 10, 15, 30);
    calendar.set(Calendar.MILLISECOND, 0);
    ZonedDateTime zdt = calendar.toZonedDateTime();
    assertEquals(ZonedDateTime.parse("2007-12-03T10:15:30+01:00[Europe/Paris]"), zdt);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    // Set up the inorder for verifications. This is needed to verify that the broadcasts,
    // store writes for network updates followed by network additions are in the expected order.
    mContextConfigStoreMockOrder = inOrder(mContext, mWifiConfigStore);
    mWifiNetworkListStoreDataMockOrder = inOrder(mWifiNetworkListStoreData);
    // Set up the package name stuff & permission override.
    when(mContext.getPackageManager()).thenReturn(mPackageManager);
    mResources = new MockResources();
    mResources.setBoolean(R.bool.config_wifi_only_link_same_credential_configurations, true);
    mResources.setInteger(R.integer.config_wifi_framework_associated_partial_scan_max_num_active_channels, TEST_MAX_NUM_ACTIVE_CHANNELS_FOR_PARTIAL_SCAN);
    when(mContext.getResources()).thenReturn(mResources);
    // Setup UserManager profiles for the default user.
    setupUserProfiles(TEST_DEFAULT_USER);
    doAnswer(new AnswerWithArguments() {

        public String answer(int uid) throws Exception {
            if (uid == TEST_CREATOR_UID) {
                return TEST_CREATOR_NAME;
            } else if (uid == TEST_UPDATE_UID) {
                return TEST_UPDATE_NAME;
            } else if (uid == TEST_SYSUI_UID) {
                return WifiConfigManager.SYSUI_PACKAGE_NAME;
            } else if (uid == TEST_NO_PERM_UID) {
                return TEST_NO_PERM_NAME;
            }
            fail("Unexpected UID: " + uid);
            return "";
        }
    }).when(mPackageManager).getNameForUid(anyInt());
    doAnswer(new AnswerWithArguments() {

        public int answer(String packageName, int flags, int userId) throws Exception {
            if (packageName.equals(WifiConfigManager.SYSUI_PACKAGE_NAME)) {
                return TEST_SYSUI_UID;
            } else {
                return 0;
            }
        }
    }).when(mPackageManager).getPackageUidAsUser(anyString(), anyInt(), anyInt());
    // Both the UID's in the test have the configuration override permission granted by
    // default. This maybe modified for particular tests if needed.
    doAnswer(new AnswerWithArguments() {

        public int answer(String permName, int uid) throws Exception {
            if (uid == TEST_CREATOR_UID || uid == TEST_UPDATE_UID || uid == TEST_SYSUI_UID) {
                return PackageManager.PERMISSION_GRANTED;
            }
            return PackageManager.PERMISSION_DENIED;
        }
    }).when(mFrameworkFacade).checkUidPermission(anyString(), anyInt());
    when(mWifiKeyStore.updateNetworkKeys(any(WifiConfiguration.class), any(WifiConfiguration.class))).thenReturn(true);
    when(mWifiConfigStore.areStoresPresent()).thenReturn(true);
    when(mDevicePolicyManagerInternal.isActiveAdminWithPolicy(anyInt(), anyInt())).thenReturn(false);
    when(mWifiPermissionsWrapper.getDevicePolicyManagerInternal()).thenReturn(mDevicePolicyManagerInternal);
    createWifiConfigManager();
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    // Set up the inorder for verifications. This is needed to verify that the broadcasts,
    // store writes for network updates followed by network additions are in the expected order.
    mContextConfigStoreMockOrder = inOrder(mContext, mWifiConfigStore);
    mNetworkListStoreDataMockOrder = inOrder(mNetworkListStoreData);
    // Set up the package name stuff & permission override.
    when(mContext.getPackageManager()).thenReturn(mPackageManager);
    mResources = new MockResources();
    mResources.setBoolean(R.bool.config_wifi_only_link_same_credential_configurations, true);
    mResources.setInteger(R.integer.config_wifi_framework_associated_partial_scan_max_num_active_channels, TEST_MAX_NUM_ACTIVE_CHANNELS_FOR_PARTIAL_SCAN);
    when(mContext.getResources()).thenReturn(mResources);
    // Setup UserManager profiles for the default user.
    setupUserProfiles(TEST_DEFAULT_USER);
    doAnswer(new AnswerWithArguments() {

        public String answer(int uid) throws Exception {
            if (uid == TEST_CREATOR_UID) {
                return TEST_CREATOR_NAME;
            } else if (uid == TEST_UPDATE_UID) {
                return TEST_UPDATE_NAME;
            } else if (uid == TEST_SYSUI_UID) {
                return WifiConfigManager.SYSUI_PACKAGE_NAME;
            } else if (uid == TEST_NO_PERM_UID) {
                return TEST_NO_PERM_NAME;
            }
            fail("Unexpected UID: " + uid);
            return "";
        }
    }).when(mPackageManager).getNameForUid(anyInt());
    doAnswer(new AnswerWithArguments() {

        public int answer(String packageName, int flags, int userId) throws Exception {
            if (packageName.equals(WifiConfigManager.SYSUI_PACKAGE_NAME)) {
                return TEST_SYSUI_UID;
            } else {
                return 0;
            }
        }
    }).when(mPackageManager).getPackageUidAsUser(anyString(), anyInt(), anyInt());
    // Both the UID's in the test have the configuration override permission granted by
    // default. This maybe modified for particular tests if needed.
    doAnswer(new AnswerWithArguments() {

        public int answer(String permName, int uid) throws Exception {
            if (uid == TEST_CREATOR_UID || uid == TEST_UPDATE_UID || uid == TEST_SYSUI_UID) {
                return PackageManager.PERMISSION_GRANTED;
            }
            return PackageManager.PERMISSION_DENIED;
        }
    }).when(mFrameworkFacade).checkUidPermission(anyString(), anyInt());
    when(mWifiKeyStore.updateNetworkKeys(any(WifiConfiguration.class), any(WifiConfiguration.class))).thenReturn(true);
    when(mWifiConfigStore.areStoresPresent()).thenReturn(true);
    when(mDevicePolicyManagerInternal.isActiveAdminWithPolicy(anyInt(), anyInt())).thenReturn(false);
    when(mWifiPermissionsWrapper.getDevicePolicyManagerInternal()).thenReturn(mDevicePolicyManagerInternal);
    createWifiConfigManager();
}
#end_block

#method_before
private void createWifiConfigManager() {
    mWifiConfigManager = new WifiConfigManager(mContext, mFrameworkFacade, mClock, mUserManager, mTelephonyManager, mWifiKeyStore, mWifiConfigStore, mWifiConfigStoreLegacy, mWifiPermissionsWrapper, mWifiNetworkListStoreData, mDeletedEphemeralSsidsStoreData);
    mWifiConfigManager.enableVerboseLogging(1);
}
#method_after
private void createWifiConfigManager() {
    mWifiConfigManager = new WifiConfigManager(mContext, mFrameworkFacade, mClock, mUserManager, mTelephonyManager, mWifiKeyStore, mWifiConfigStore, mWifiConfigStoreLegacy, mWifiPermissionsWrapper, mNetworkListStoreData, mDeletedEphemeralSsidsStoreData);
    mWifiConfigManager.enableVerboseLogging(1);
}
#end_block

#method_before
private Pair<List<WifiConfiguration>, List<WifiConfiguration>> captureWriteNetworksListStoreData() {
    try {
        ArgumentCaptor<ArrayList> sharedConfigsCaptor = ArgumentCaptor.forClass(ArrayList.class);
        ArgumentCaptor<ArrayList> userConfigsCaptor = ArgumentCaptor.forClass(ArrayList.class);
        mWifiNetworkListStoreDataMockOrder.verify(mWifiNetworkListStoreData).setSharedConfigurations(sharedConfigsCaptor.capture());
        mWifiNetworkListStoreDataMockOrder.verify(mWifiNetworkListStoreData).setUserConfigurations(userConfigsCaptor.capture());
        mContextConfigStoreMockOrder.verify(mWifiConfigStore).write(anyBoolean());
        return Pair.create(sharedConfigsCaptor.getValue(), userConfigsCaptor.getValue());
    } catch (Exception e) {
        fail("Exception encountered during write " + e);
    }
    return null;
}
#method_after
private Pair<List<WifiConfiguration>, List<WifiConfiguration>> captureWriteNetworksListStoreData() {
    try {
        ArgumentCaptor<ArrayList> sharedConfigsCaptor = ArgumentCaptor.forClass(ArrayList.class);
        ArgumentCaptor<ArrayList> userConfigsCaptor = ArgumentCaptor.forClass(ArrayList.class);
        mNetworkListStoreDataMockOrder.verify(mNetworkListStoreData).setSharedConfigurations(sharedConfigsCaptor.capture());
        mNetworkListStoreDataMockOrder.verify(mNetworkListStoreData).setUserConfigurations(userConfigsCaptor.capture());
        mContextConfigStoreMockOrder.verify(mWifiConfigStore).write(anyBoolean());
        return Pair.create(sharedConfigsCaptor.getValue(), userConfigsCaptor.getValue());
    } catch (Exception e) {
        fail("Exception encountered during write " + e);
    }
    return null;
}
#end_block

#method_before
private void setupStoreDataForRead(List<WifiConfiguration> sharedConfigurations, List<WifiConfiguration> userConfigurations, Set<String> deletedEphemeralSsids) {
    when(mWifiNetworkListStoreData.getSharedConfigurations()).thenReturn(sharedConfigurations);
    when(mWifiNetworkListStoreData.getUserConfigurations()).thenReturn(userConfigurations);
    when(mDeletedEphemeralSsidsStoreData.getSsidList()).thenReturn(deletedEphemeralSsids);
}
#method_after
private void setupStoreDataForRead(List<WifiConfiguration> sharedConfigurations, List<WifiConfiguration> userConfigurations, Set<String> deletedEphemeralSsids) {
    when(mNetworkListStoreData.getSharedConfigurations()).thenReturn(sharedConfigurations);
    when(mNetworkListStoreData.getUserConfigurations()).thenReturn(userConfigurations);
    when(mDeletedEphemeralSsidsStoreData.getSsidList()).thenReturn(deletedEphemeralSsids);
}
#end_block

#method_before
private void setupStoreDataForUserRead(List<WifiConfiguration> userConfigurations, Set<String> deletedEphemeralSsids) {
    when(mWifiNetworkListStoreData.getUserConfigurations()).thenReturn(userConfigurations);
    when(mDeletedEphemeralSsidsStoreData.getSsidList()).thenReturn(deletedEphemeralSsids);
}
#method_after
private void setupStoreDataForUserRead(List<WifiConfiguration> userConfigurations, Set<String> deletedEphemeralSsids) {
    when(mNetworkListStoreData.getUserConfigurations()).thenReturn(userConfigurations);
    when(mDeletedEphemeralSsidsStoreData.getSsidList()).thenReturn(deletedEphemeralSsids);
}
#end_block

#method_before
public boolean registerStoreData(StoreDataInterface storeData) {
    if (storeData == null) {
        Log.e(TAG, "Unable to register null store data");
        return false;
    }
    mStoreDataList.put(storeData.getTag(), storeData);
    return true;
}
#method_after
public boolean registerStoreData(StoreData storeData) {
    if (storeData == null) {
        Log.e(TAG, "Unable to register null store data");
        return false;
    }
    mStoreDataList.put(storeData.getName(), storeData);
    return true;
}
#end_block

#method_before
private byte[] serializeData(boolean shareData) throws XmlPullParserException, IOException {
    final XmlSerializer out = new FastXmlSerializer();
    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    out.setOutput(outputStream, StandardCharsets.UTF_8.name());
    XmlUtil.writeDocumentStart(out, XML_TAG_DOCUMENT_HEADER);
    XmlUtil.writeNextValue(out, XML_TAG_VERSION, CURRENT_CONFIG_STORE_DATA_VERSION);
    for (Map.Entry<String, StoreDataInterface> entry : mStoreDataList.entrySet()) {
        String tag = entry.getKey();
        StoreDataInterface storeData = entry.getValue();
        // share store.
        if (shareData && !storeData.supportShareData()) {
            continue;
        }
        XmlUtil.writeNextSectionStart(out, tag);
        storeData.serializeData(out, shareData);
        XmlUtil.writeNextSectionEnd(out, tag);
    }
    XmlUtil.writeDocumentEnd(out, XML_TAG_DOCUMENT_HEADER);
    return outputStream.toByteArray();
}
#method_after
private byte[] serializeData(boolean shareData) throws XmlPullParserException, IOException {
    final XmlSerializer out = new FastXmlSerializer();
    final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    out.setOutput(outputStream, StandardCharsets.UTF_8.name());
    XmlUtil.writeDocumentStart(out, XML_TAG_DOCUMENT_HEADER);
    XmlUtil.writeNextValue(out, XML_TAG_VERSION, CURRENT_CONFIG_STORE_DATA_VERSION);
    for (Map.Entry<String, StoreData> entry : mStoreDataList.entrySet()) {
        String tag = entry.getKey();
        StoreData storeData = entry.getValue();
        // share store.
        if (shareData && !storeData.supportShareData()) {
            continue;
        }
        XmlUtil.writeNextSectionStart(out, tag);
        storeData.serializeData(out, shareData);
        XmlUtil.writeNextSectionEnd(out, tag);
    }
    XmlUtil.writeDocumentEnd(out, XML_TAG_DOCUMENT_HEADER);
    return outputStream.toByteArray();
}
#end_block

#method_before
public void read() throws XmlPullParserException, IOException {
    // Reset both share and user store data.
    resetStoreData(true);
    resetStoreData(false);
    long readStartTime = mClock.getElapsedSinceBootMillis();
    byte[] sharedDataBytes = mSharedStore.readRawData();
    byte[] userDataBytes = null;
    if (mUserStore != null) {
        userDataBytes = mUserStore.readRawData();
    }
    long readTime = mClock.getElapsedSinceBootMillis() - readStartTime;
    Log.d(TAG, "Reading from stores completed in " + readTime + " ms.");
    parseData(sharedDataBytes, true);
    parseData(userDataBytes, false);
}
#method_after
public void read() throws XmlPullParserException, IOException {
    // Reset both share and user store data.
    resetStoreData(true);
    resetStoreData(false);
    long readStartTime = mClock.getElapsedSinceBootMillis();
    byte[] sharedDataBytes = mSharedStore.readRawData();
    byte[] userDataBytes = null;
    if (mUserStore != null) {
        userDataBytes = mUserStore.readRawData();
    }
    long readTime = mClock.getElapsedSinceBootMillis() - readStartTime;
    Log.d(TAG, "Reading from stores completed in " + readTime + " ms.");
    deserializeData(sharedDataBytes, true);
    deserializeData(userDataBytes, false);
}
#end_block

#method_before
public void switchUserStoreAndRead(StoreFile userStore) throws XmlPullParserException, IOException {
    // Reset user store data.
    resetStoreData(false);
    // Stop any pending buffered writes, if any.
    stopBufferedWriteAlarm();
    mUserStore = userStore;
    // Now read from the user store file.
    long readStartTime = mClock.getElapsedSinceBootMillis();
    byte[] userDataBytes = mUserStore.readRawData();
    long readTime = mClock.getElapsedSinceBootMillis() - readStartTime;
    Log.d(TAG, "Reading from user store completed in " + readTime + " ms.");
    parseData(userDataBytes, false);
}
#method_after
public void switchUserStoreAndRead(StoreFile userStore) throws XmlPullParserException, IOException {
    // Reset user store data.
    resetStoreData(false);
    // Stop any pending buffered writes, if any.
    stopBufferedWriteAlarm();
    mUserStore = userStore;
    // Now read from the user store file.
    long readStartTime = mClock.getElapsedSinceBootMillis();
    byte[] userDataBytes = mUserStore.readRawData();
    long readTime = mClock.getElapsedSinceBootMillis() - readStartTime;
    Log.d(TAG, "Reading from user store completed in " + readTime + " ms.");
    deserializeData(userDataBytes, false);
}
#end_block

#method_before
private void resetStoreData(boolean shareData) {
    for (Map.Entry<String, StoreDataInterface> entry : mStoreDataList.entrySet()) {
        entry.getValue().resetData(shareData);
    }
}
#method_after
private void resetStoreData(boolean shareData) {
    for (Map.Entry<String, StoreData> entry : mStoreDataList.entrySet()) {
        entry.getValue().resetData(shareData);
    }
}
#end_block

#method_before
public boolean loadFromStore() {
    if (!mWifiConfigStore.areStoresPresent()) {
        Log.d(TAG, "New store files not found. No saved networks loaded!");
        if (!mWifiConfigStoreLegacy.areStoresPresent()) {
            // No legacy store files either, so reset the pending store read flag.
            mPendingStoreRead = false;
        }
        return true;
    }
    try {
        mWifiConfigStore.read();
    } catch (IOException e) {
        Log.wtf(TAG, "Reading from new store failed. All saved networks are lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML deserialization of store failed. All saved networks are lost!", e);
        return false;
    }
    loadInternalData(mWifiNetworkListStoreData.getSharedConfigurations(), mWifiNetworkListStoreData.getUserConfigurations(), mDeletedEphemeralSsidsStoreData.getSsidList());
    // the load from store is triggered.
    if (mDeferredUserUnlockRead) {
        Log.i(TAG, "Handling user unlock after loading from store.");
        handleUserUnlockOrSwitch(mCurrentUserId);
        mDeferredUserUnlockRead = false;
    }
    return true;
}
#method_after
public boolean loadFromStore() {
    if (!mWifiConfigStore.areStoresPresent()) {
        Log.d(TAG, "New store files not found. No saved networks loaded!");
        if (!mWifiConfigStoreLegacy.areStoresPresent()) {
            // No legacy store files either, so reset the pending store read flag.
            mPendingStoreRead = false;
        }
        return true;
    }
    try {
        mWifiConfigStore.read();
    } catch (IOException e) {
        Log.wtf(TAG, "Reading from new store failed. All saved networks are lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML deserialization of store failed. All saved networks are lost!", e);
        return false;
    }
    loadInternalData(mNetworkListStoreData.getSharedConfigurations(), mNetworkListStoreData.getUserConfigurations(), mDeletedEphemeralSsidsStoreData.getSsidList());
    // the load from store is triggered.
    if (mDeferredUserUnlockRead) {
        Log.i(TAG, "Handling user unlock after loading from store.");
        handleUserUnlockOrSwitch(mCurrentUserId);
        mDeferredUserUnlockRead = false;
    }
    return true;
}
#end_block

#method_before
public boolean loadFromUserStoreAfterUnlockOrSwitch(int userId) {
    try {
        mWifiConfigStore.switchUserStoreAndRead(WifiConfigStore.createUserFile(userId));
    } catch (IOException e) {
        Log.wtf(TAG, "Reading from new store failed. All saved private networks are lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML deserialization of store failed. All saved private networks are" + "lost!", e);
        return false;
    }
    loadInternalDataFromUserStore(mWifiNetworkListStoreData.getUserConfigurations(), mDeletedEphemeralSsidsStoreData.getSsidList());
    return true;
}
#method_after
public boolean loadFromUserStoreAfterUnlockOrSwitch(int userId) {
    try {
        mWifiConfigStore.switchUserStoreAndRead(WifiConfigStore.createUserFile(userId));
    } catch (IOException e) {
        Log.wtf(TAG, "Reading from new store failed. All saved private networks are lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML deserialization of store failed. All saved private networks are" + "lost!", e);
        return false;
    }
    loadInternalDataFromUserStore(mNetworkListStoreData.getUserConfigurations(), mDeletedEphemeralSsidsStoreData.getSsidList());
    return true;
}
#end_block

#method_before
public boolean saveToStore(boolean forceWrite) {
    ArrayList<WifiConfiguration> sharedConfigurations = new ArrayList<>();
    ArrayList<WifiConfiguration> userConfigurations = new ArrayList<>();
    for (WifiConfiguration config : mConfiguredNetworks.valuesForAllUsers()) {
        // Don't persist ephemeral and passpoint networks to store.
        if (!config.ephemeral && !config.isPasspoint()) {
            // user logs in.
            if (config.shared || !WifiConfigurationUtil.doesUidBelongToAnyProfile(config.creatorUid, mUserManager.getProfiles(mCurrentUserId))) {
                sharedConfigurations.add(config);
            } else {
                userConfigurations.add(config);
            }
        }
    }
    // Setup store data for write.
    mWifiNetworkListStoreData.setSharedConfigurations(sharedConfigurations);
    mWifiNetworkListStoreData.setUserConfigurations(userConfigurations);
    mDeletedEphemeralSsidsStoreData.setSsidList(mDeletedEphemeralSSIDs);
    try {
        mWifiConfigStore.write(forceWrite);
    } catch (IOException e) {
        Log.wtf(TAG, "Writing to store failed. Saved networks maybe lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML serialization for store failed. Saved networks maybe lost!", e);
        return false;
    }
    return true;
}
#method_after
public boolean saveToStore(boolean forceWrite) {
    ArrayList<WifiConfiguration> sharedConfigurations = new ArrayList<>();
    ArrayList<WifiConfiguration> userConfigurations = new ArrayList<>();
    for (WifiConfiguration config : mConfiguredNetworks.valuesForAllUsers()) {
        // Don't persist ephemeral and passpoint networks to store.
        if (!config.ephemeral && !config.isPasspoint()) {
            // user logs in.
            if (config.shared || !WifiConfigurationUtil.doesUidBelongToAnyProfile(config.creatorUid, mUserManager.getProfiles(mCurrentUserId))) {
                sharedConfigurations.add(config);
            } else {
                userConfigurations.add(config);
            }
        }
    }
    // Setup store data for write.
    mNetworkListStoreData.setSharedConfigurations(sharedConfigurations);
    mNetworkListStoreData.setUserConfigurations(userConfigurations);
    mDeletedEphemeralSsidsStoreData.setSsidList(mDeletedEphemeralSSIDs);
    try {
        mWifiConfigStore.write(forceWrite);
    } catch (IOException e) {
        Log.wtf(TAG, "Writing to store failed. Saved networks maybe lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML serialization for store failed. Saved networks maybe lost!", e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testReadWifiConfigStoreData() throws Exception {
    // Setup network list.
    WifiNetworkListStoreData networkList = new WifiNetworkListStoreData();
    mWifiConfigStore.registerStoreData(networkList);
    WifiConfiguration openNetwork = WifiConfigurationTestUtil.createOpenNetwork();
    openNetwork.setIpConfiguration(WifiConfigurationTestUtil.createDHCPIpConfigurationWithNoProxy());
    List<WifiConfiguration> userConfigs = new ArrayList<>();
    userConfigs.add(openNetwork);
    // Setup deleted ephemeral SSID list.
    DeletedEphemeralSsidsStoreData deletedEphemeralSsids = new DeletedEphemeralSsidsStoreData();
    mWifiConfigStore.registerStoreData(deletedEphemeralSsids);
    String testSsid = "Test SSID";
    Set<String> ssidList = new HashSet<>();
    ssidList.add(testSsid);
    // Setup user store XML bytes.
    String xmlString = String.format(TEST_DATA_XML_STRING_FORMAT, openNetwork.configKey().replaceAll("\"", "&quot;"), openNetwork.SSID.replaceAll("\"", "&quot;"), openNetwork.shared, openNetwork.creatorUid, testSsid);
    byte[] xmlBytes = xmlString.getBytes(StandardCharsets.UTF_8);
    mUserStore.storeRawDataToWrite(xmlBytes);
    mWifiConfigStore.switchUserStoreAndRead(mUserStore);
    WifiConfigurationTestUtil.assertConfigurationsEqualForConfigStore(userConfigs, networkList.getUserConfigurations());
    assertEquals(ssidList, deletedEphemeralSsids.getSsidList());
}
#method_after
@Test
public void testReadWifiConfigStoreData() throws Exception {
    // Setup network list.
    NetworkListStoreData networkList = new NetworkListStoreData();
    mWifiConfigStore.registerStoreData(networkList);
    WifiConfiguration openNetwork = WifiConfigurationTestUtil.createOpenNetwork();
    openNetwork.setIpConfiguration(WifiConfigurationTestUtil.createDHCPIpConfigurationWithNoProxy());
    List<WifiConfiguration> userConfigs = new ArrayList<>();
    userConfigs.add(openNetwork);
    // Setup deleted ephemeral SSID list.
    DeletedEphemeralSsidsStoreData deletedEphemeralSsids = new DeletedEphemeralSsidsStoreData();
    mWifiConfigStore.registerStoreData(deletedEphemeralSsids);
    String testSsid = "Test SSID";
    Set<String> ssidList = new HashSet<>();
    ssidList.add(testSsid);
    // Setup user store XML bytes.
    String xmlString = String.format(TEST_DATA_XML_STRING_FORMAT, openNetwork.configKey().replaceAll("\"", "&quot;"), openNetwork.SSID.replaceAll("\"", "&quot;"), openNetwork.shared, openNetwork.creatorUid, testSsid);
    byte[] xmlBytes = xmlString.getBytes(StandardCharsets.UTF_8);
    mUserStore.storeRawDataToWrite(xmlBytes);
    mWifiConfigStore.switchUserStoreAndRead(mUserStore);
    WifiConfigurationTestUtil.assertConfigurationsEqualForConfigStore(userConfigs, networkList.getUserConfigurations());
    assertEquals(ssidList, deletedEphemeralSsids.getSsidList());
}
#end_block

#method_before
@Test
public void testWriteWifiConfigStoreData() throws Exception {
    // Setup user store.
    mWifiConfigStore.switchUserStoreAndRead(mUserStore);
    // Setup network list store data.
    WifiNetworkListStoreData networkList = new WifiNetworkListStoreData();
    mWifiConfigStore.registerStoreData(networkList);
    WifiConfiguration openNetwork = WifiConfigurationTestUtil.createOpenNetwork();
    openNetwork.setIpConfiguration(WifiConfigurationTestUtil.createDHCPIpConfigurationWithNoProxy());
    List<WifiConfiguration> userConfigs = new ArrayList<>();
    userConfigs.add(openNetwork);
    networkList.setUserConfigurations(userConfigs);
    // Setup deleted ephemeral SSID list store data.
    DeletedEphemeralSsidsStoreData deletedEphemeralSsids = new DeletedEphemeralSsidsStoreData();
    mWifiConfigStore.registerStoreData(deletedEphemeralSsids);
    String testSsid = "Test SSID";
    Set<String> ssidList = new HashSet<>();
    ssidList.add(testSsid);
    deletedEphemeralSsids.setSsidList(ssidList);
    // Setup expected XML bytes.
    String xmlString = String.format(TEST_DATA_XML_STRING_FORMAT, openNetwork.configKey().replaceAll("\"", "&quot;"), openNetwork.SSID.replaceAll("\"", "&quot;"), openNetwork.shared, openNetwork.creatorUid, testSsid);
    byte[] xmlBytes = xmlString.getBytes(StandardCharsets.UTF_8);
    mWifiConfigStore.write(true);
    assertEquals(xmlBytes.length, mUserStore.getStoreBytes().length);
    // Verify the user store content.
    assertTrue(Arrays.equals(xmlBytes, mUserStore.getStoreBytes()));
}
#method_after
@Test
public void testWriteWifiConfigStoreData() throws Exception {
    // Setup user store.
    mWifiConfigStore.switchUserStoreAndRead(mUserStore);
    // Setup network list store data.
    NetworkListStoreData networkList = new NetworkListStoreData();
    mWifiConfigStore.registerStoreData(networkList);
    WifiConfiguration openNetwork = WifiConfigurationTestUtil.createOpenNetwork();
    openNetwork.setIpConfiguration(WifiConfigurationTestUtil.createDHCPIpConfigurationWithNoProxy());
    List<WifiConfiguration> userConfigs = new ArrayList<>();
    userConfigs.add(openNetwork);
    networkList.setUserConfigurations(userConfigs);
    // Setup deleted ephemeral SSID list store data.
    DeletedEphemeralSsidsStoreData deletedEphemeralSsids = new DeletedEphemeralSsidsStoreData();
    mWifiConfigStore.registerStoreData(deletedEphemeralSsids);
    String testSsid = "Test SSID";
    Set<String> ssidList = new HashSet<>();
    ssidList.add(testSsid);
    deletedEphemeralSsids.setSsidList(ssidList);
    // Setup expected XML bytes.
    String xmlString = String.format(TEST_DATA_XML_STRING_FORMAT, openNetwork.configKey().replaceAll("\"", "&quot;"), openNetwork.SSID.replaceAll("\"", "&quot;"), openNetwork.shared, openNetwork.creatorUid, testSsid);
    byte[] xmlBytes = xmlString.getBytes(StandardCharsets.UTF_8);
    mWifiConfigStore.write(true);
    assertEquals(xmlBytes.length, mUserStore.getStoreBytes().length);
    // Verify the user store content.
    assertTrue(Arrays.equals(xmlBytes, mUserStore.getStoreBytes()));
}
#end_block

#method_before
@Test
public void test_cancel() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE
    Files.createFile(file);
    // Canceling the key may prevent the EVENT_CREATE from being picked-up...
    // TODO: Fix this.
    Thread.sleep(500);
    // Cancel the key
    directoryKey1.cancel();
    assertFalse(directoryKey1.isValid());
    // Shouldn't emit EVENT_MODIFY and EVENT_DELETE
    Files.write(file, "hello1".getBytes());
    Files.delete(file);
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1)), false);
    assertNull(watchService.poll());
    watchService.close();
}
#method_after
@Test
public void test_cancel() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE
    Files.createFile(file);
    // Canceling the key may prevent the EVENT_CREATE from being picked-up...
    // TODO: Fix this (b/35190858).
    Thread.sleep(500);
    // Cancel the key
    directoryKey1.cancel();
    assertFalse(directoryKey1.isValid());
    // Shouldn't emit EVENT_MODIFY and EVENT_DELETE
    Files.write(file, "hello1".getBytes());
    Files.delete(file);
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1)), false);
    assertNull(watchService.poll());
    watchService.close();
}
#end_block

#method_before
private static void wrapperInit(int targetSdkVersion, String[] argv) throws Zygote.MethodAndArgsCaller {
    if (RuntimeInit.DEBUG)
        Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from wrapper");
    RuntimeInit.applicationInit(targetSdkVersion, argv, null);
}
#method_after
private static void wrapperInit(int targetSdkVersion, String[] argv) throws Zygote.MethodAndArgsCaller {
    if (RuntimeInit.DEBUG) {
        Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from wrapper");
    }
    RuntimeInit.applicationInit(targetSdkVersion, argv, null);
}
#end_block

#method_before
public static void main(String[] argv) {
    ZygoteServer zygoteServer = new ZygoteServer();
    // Mark zygote start. This ensures that thread creation will throw
    // an error.
    ZygoteHooks.startZygoteNoThreadCreation();
    // Zygote goes into its own process group.
    try {
        Os.setpgid(0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to setpgid(0,0)", ex);
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygoteInit");
        RuntimeInit.enableDdms();
        // Start profiling the zygote initialization.
        SamplingProfilerIntegration.start();
        boolean startSystemServer = false;
        String socketName = "zygote";
        String abiList = null;
        for (int i = 1; i < argv.length; i++) {
            if ("start-system-server".equals(argv[i])) {
                startSystemServer = true;
            } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                abiList = argv[i].substring(ABI_LIST_ARG.length());
            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                socketName = argv[i].substring(SOCKET_NAME_ARG.length());
            } else {
                throw new RuntimeException("Unknown command line argument: " + argv[i]);
            }
        }
        if (abiList == null) {
            throw new RuntimeException("No ABI list supplied.");
        }
        zygoteServer.registerServerSocket(socketName);
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygotePreload");
        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis());
        preload();
        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis());
        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
        // Finish profiling the zygote initialization.
        SamplingProfilerIntegration.writeZygoteSnapshot();
        // Do an initial gc to clean up after startup
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PostZygoteInitGC");
        gcAndFinalize();
        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
        // Disable tracing so that forked processes do not inherit stale tracing tags from
        // Zygote.
        Trace.setTracingEnabled(false);
        // Zygote process unmounts root storage spaces.
        Zygote.nativeUnmountStorageOnInit();
        ZygoteHooks.stopZygoteNoThreadCreation();
        if (startSystemServer) {
            startSystemServer(abiList, socketName, zygoteServer);
        }
        Log.i(TAG, "Accepting command socket connections");
        zygoteServer.runSelectLoop(abiList);
        zygoteServer.closeServerSocket();
    } catch (Zygote.MethodAndArgsCaller caller) {
        caller.run();
    } catch (Throwable ex) {
        Log.e(TAG, "System zygote died with exception", ex);
        zygoteServer.closeServerSocket();
        throw ex;
    }
}
#method_after
public static void main(String[] argv) {
    ZygoteServer zygoteServer = new ZygoteServer();
    // Mark zygote start. This ensures that thread creation will throw
    // an error.
    ZygoteHooks.startZygoteNoThreadCreation();
    // Zygote goes into its own process group.
    try {
        Os.setpgid(0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to setpgid(0,0)", ex);
    }
    try {
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygoteInit");
        RuntimeInit.enableDdms();
        // Start profiling the zygote initialization.
        SamplingProfilerIntegration.start();
        boolean startSystemServer = false;
        String socketName = "zygote";
        String abiList = null;
        for (int i = 1; i < argv.length; i++) {
            if ("start-system-server".equals(argv[i])) {
                startSystemServer = true;
            } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                abiList = argv[i].substring(ABI_LIST_ARG.length());
            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                socketName = argv[i].substring(SOCKET_NAME_ARG.length());
            } else {
                throw new RuntimeException("Unknown command line argument: " + argv[i]);
            }
        }
        if (abiList == null) {
            throw new RuntimeException("No ABI list supplied.");
        }
        zygoteServer.registerServerSocket(socketName);
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygotePreload");
        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis());
        preload();
        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis());
        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
        // Finish profiling the zygote initialization.
        SamplingProfilerIntegration.writeZygoteSnapshot();
        // Do an initial gc to clean up after startup
        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PostZygoteInitGC");
        gcAndFinalize();
        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
        // Disable tracing so that forked processes do not inherit stale tracing tags from
        // Zygote.
        Trace.setTracingEnabled(false);
        // Zygote process unmounts root storage spaces.
        Zygote.nativeUnmountStorageOnInit();
        // Set seccomp policy
        Seccomp.setPolicy();
        ZygoteHooks.stopZygoteNoThreadCreation();
        if (startSystemServer) {
            startSystemServer(abiList, socketName, zygoteServer);
        }
        Log.i(TAG, "Accepting command socket connections");
        zygoteServer.runSelectLoop(abiList);
        zygoteServer.closeServerSocket();
    } catch (Zygote.MethodAndArgsCaller caller) {
        caller.run();
    } catch (Throwable ex) {
        Log.e(TAG, "System zygote died with exception", ex);
        zygoteServer.closeServerSocket();
        throw ex;
    }
}
#end_block

#method_before
public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws Zygote.MethodAndArgsCaller {
    if (RuntimeInit.DEBUG)
        Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from zygote");
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ZygoteInit");
    RuntimeInit.redirectLogStreams();
    RuntimeInit.commonInit();
    ZygoteInit.nativeZygoteInit();
    RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
}
#method_after
public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws Zygote.MethodAndArgsCaller {
    if (RuntimeInit.DEBUG) {
        Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from zygote");
    }
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ZygoteInit");
    RuntimeInit.redirectLogStreams();
    RuntimeInit.commonInit();
    ZygoteInit.nativeZygoteInit();
    RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
}
#end_block

#method_before
@Test
public void testGetScanResults() throws Exception {
    IWificond wificond = mock(IWificond.class);
    IClientInterface clientInterface = mock(IClientInterface.class);
    IWifiScannerImpl scanner = mock(IWifiScannerImpl.class);
    when(mWifiInjector.makeWificond()).thenReturn(wificond);
    when(wificond.createClientInterface()).thenReturn(clientInterface);
    when(clientInterface.getWifiScannerImpl()).thenReturn(scanner);
    // Mock the returned array of NativeScanResult.
    NativeScanResult[] mockScanResults = { MOCK_NATIVE_SCAN_RESULT };
    when(scanner.getScanResults()).thenReturn(mockScanResults);
    // Configure client interface.
    IClientInterface returnedClientInterface = mWificondControl.setupDriverForClientMode();
    assertEquals(clientInterface, returnedClientInterface);
    ArrayList<ScanDetail> returnedScanResults = mWificondControl.getScanResults();
    assertEquals(mockScanResults.length, returnedScanResults.size());
}
#method_after
@Test
public void testGetScanResults() throws Exception {
    IWificond wificond = mock(IWificond.class);
    IClientInterface clientInterface = mock(IClientInterface.class);
    IWifiScannerImpl scanner = mock(IWifiScannerImpl.class);
    when(mWifiInjector.makeWificond()).thenReturn(wificond);
    when(wificond.createClientInterface()).thenReturn(clientInterface);
    when(clientInterface.getWifiScannerImpl()).thenReturn(scanner);
    // Mock the returned array of NativeScanResult.
    NativeScanResult[] mockScanResults = { MOCK_NATIVE_SCAN_RESULT };
    when(scanner.getScanResults()).thenReturn(mockScanResults);
    // Configure client interface.
    IClientInterface returnedClientInterface = mWificondControl.setupDriverForClientMode();
    assertEquals(clientInterface, returnedClientInterface);
    ArrayList<ScanDetail> returnedScanResults = mWificondControl.getScanResults();
    assertEquals(mockScanResults.length, returnedScanResults.size());
    // a few fields.
    for (int i = 0; i < mockScanResults.length; i++) {
        assertArrayEquals(mockScanResults[i].ssid, returnedScanResults.get(i).getScanResult().SSID.getBytes());
        assertEquals(mockScanResults[i].frequency, returnedScanResults.get(i).getScanResult().frequency);
        assertEquals(mockScanResults[i].tsf, returnedScanResults.get(i).getScanResult().timestamp);
    }
}
#end_block

#method_before
private String parseMacToString(byte[] mac) {
    if (mac.length != 6) {
        Log.e(TAG, "Invalid MAC adddress size");
        return "";
    }
    StringBuilder sb = new StringBuilder(18);
    for (byte b : mac) {
        if (sb.length() > 0) {
            sb.append(':');
        }
        sb.append(String.format("%02x", b));
    }
    return sb.toString();
}
#method_after
private static String parseMacToString(byte[] mac) {
    if (mac == null || mac.length != MAC_ADDR_LEN) {
        Log.e(TAG, "Invalid MAC adddress size");
        return "";
    }
    return String.format("%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
}
#end_block

#method_before
public boolean initializeSupplicantHal() {
    if (!HIDL_ENABLE) {
        return true;
    }
    return mWifiSupplicantHal.initialize();
}
#method_after
public boolean initializeSupplicantHal() {
    if (!HIDL_ENABLE) {
        return true;
    }
    return mSupplicantStaIfaceHal.initialize();
}
#end_block

#method_before
public int[] signalPoll() {
    return mWificondControl.signalPoll();
}
#method_after
public SignalPollResult signalPoll() {
    return mWificondControl.signalPoll();
}
#end_block

#method_before
public int[] getTxPacketCounters() {
    return mWificondControl.getTxPacketCounters();
}
#method_after
public TxPacketCounters getTxPacketCounters() {
    return mWificondControl.getTxPacketCounters();
}
#end_block

#method_before
private void fetchRssiLinkSpeedAndFrequencyNative() {
    Integer newRssi = null;
    Integer newLinkSpeed = null;
    Integer newFrequency = null;
    int[] poll_result = mWifiNative.signalPoll();
    if (poll_result == null) {
        return;
    }
    newRssi = poll_result[0];
    newLinkSpeed = poll_result[1];
    newFrequency = poll_result[2];
    if (mVerboseLoggingEnabled) {
        logd("fetchRssiLinkSpeedAndFrequencyNative rssi=" + newRssi + " linkspeed=" + newLinkSpeed + " freq=" + newFrequency);
    }
    if (newRssi != null && newRssi > WifiInfo.INVALID_RSSI && newRssi < WifiInfo.MAX_RSSI) {
        /* some implementations avoid negative values by adding 256
             * so we need to adjust for that here.
             */
        if (newRssi > 0)
            newRssi -= 256;
        mWifiInfo.setRssi(newRssi);
        /*
             * Log the rssi poll value in metrics
             */
        mWifiMetrics.incrementRssiPollRssiCount(newRssi);
        /*
             * Rather then sending the raw RSSI out every time it
             * changes, we precalculate the signal level that would
             * be displayed in the status bar, and only send the
             * broadcast if that much more coarse-grained number
             * changes. This cuts down greatly on the number of
             * broadcasts, at the cost of not informing others
             * interested in RSSI of all the changes in signal
             * level.
             */
        int newSignalLevel = WifiManager.calculateSignalLevel(newRssi, WifiManager.RSSI_LEVELS);
        if (newSignalLevel != mLastSignalLevel) {
            updateCapabilities(getCurrentWifiConfiguration());
            sendRssiChangeBroadcast(newRssi);
        }
        mLastSignalLevel = newSignalLevel;
    } else {
        mWifiInfo.setRssi(WifiInfo.INVALID_RSSI);
        updateCapabilities(getCurrentWifiConfiguration());
    }
    if (newLinkSpeed != null) {
        mWifiInfo.setLinkSpeed(newLinkSpeed);
    }
    if (newFrequency != null && newFrequency > 0) {
        if (ScanResult.is5GHz(newFrequency)) {
            mWifiConnectionStatistics.num5GhzConnected++;
        }
        if (ScanResult.is24GHz(newFrequency)) {
            mWifiConnectionStatistics.num24GhzConnected++;
        }
        mWifiInfo.setFrequency(newFrequency);
    }
    mWifiConfigManager.updateScanDetailCacheFromWifiInfo(mWifiInfo);
}
#method_after
private void fetchRssiLinkSpeedAndFrequencyNative() {
    Integer newRssi = null;
    Integer newLinkSpeed = null;
    Integer newFrequency = null;
    WifiNative.SignalPollResult pollResult = mWifiNative.signalPoll();
    if (pollResult == null) {
        return;
    }
    newRssi = pollResult.currentRssi;
    newLinkSpeed = pollResult.txBitrate;
    newFrequency = pollResult.associationFrequency;
    if (mVerboseLoggingEnabled) {
        logd("fetchRssiLinkSpeedAndFrequencyNative rssi=" + newRssi + " linkspeed=" + newLinkSpeed + " freq=" + newFrequency);
    }
    if (newRssi != null && newRssi > WifiInfo.INVALID_RSSI && newRssi < WifiInfo.MAX_RSSI) {
        /* some implementations avoid negative values by adding 256
             * so we need to adjust for that here.
             */
        if (newRssi > 0)
            newRssi -= 256;
        mWifiInfo.setRssi(newRssi);
        /*
             * Log the rssi poll value in metrics
             */
        mWifiMetrics.incrementRssiPollRssiCount(newRssi);
        /*
             * Rather then sending the raw RSSI out every time it
             * changes, we precalculate the signal level that would
             * be displayed in the status bar, and only send the
             * broadcast if that much more coarse-grained number
             * changes. This cuts down greatly on the number of
             * broadcasts, at the cost of not informing others
             * interested in RSSI of all the changes in signal
             * level.
             */
        int newSignalLevel = WifiManager.calculateSignalLevel(newRssi, WifiManager.RSSI_LEVELS);
        if (newSignalLevel != mLastSignalLevel) {
            updateCapabilities(getCurrentWifiConfiguration());
            sendRssiChangeBroadcast(newRssi);
        }
        mLastSignalLevel = newSignalLevel;
    } else {
        mWifiInfo.setRssi(WifiInfo.INVALID_RSSI);
        updateCapabilities(getCurrentWifiConfiguration());
    }
    if (newLinkSpeed != null) {
        mWifiInfo.setLinkSpeed(newLinkSpeed);
    }
    if (newFrequency != null && newFrequency > 0) {
        if (ScanResult.is5GHz(newFrequency)) {
            mWifiConnectionStatistics.num5GhzConnected++;
        }
        if (ScanResult.is24GHz(newFrequency)) {
            mWifiConnectionStatistics.num24GhzConnected++;
        }
        mWifiInfo.setFrequency(newFrequency);
    }
    mWifiConfigManager.updateScanDetailCacheFromWifiInfo(mWifiInfo);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            int[] counters = mWifiNative.getTxPacketCounters();
            if (counters != null && counters.length == 2) {
                info.txgood = counters[0];
                info.txbad = counters[1];
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            } else {
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            WifiNative.TxPacketCounters counters = mWifiNative.getTxPacketCounters();
            if (counters != null) {
                info.txgood = counters.txSucceeded;
                info.txbad = counters.txFailed;
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            } else {
                replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
public int[] signalPoll() {
    if (mClientInterface == null) {
        Log.e(TAG, "No valid wificond client interface handler");
        return null;
    }
    int[] pollResult;
    try {
        pollResult = mClientInterface.signalPoll();
        if (pollResult == null || pollResult.length != 3) {
            Log.e(TAG, "Invalid signal poll result from wificond");
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to do signal polling  due to remote exception");
        return null;
    }
    return pollResult;
}
#method_after
public WifiNative.SignalPollResult signalPoll() {
    if (mClientInterface == null) {
        Log.e(TAG, "No valid wificond client interface handler");
        return null;
    }
    int[] resultArray;
    try {
        resultArray = mClientInterface.signalPoll();
        if (resultArray == null || resultArray.length != 3) {
            Log.e(TAG, "Invalid signal poll result from wificond");
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to do signal polling  due to remote exception");
        return null;
    }
    WifiNative.SignalPollResult pollResult = new WifiNative.SignalPollResult();
    pollResult.currentRssi = resultArray[0];
    pollResult.txBitrate = resultArray[1];
    pollResult.associationFrequency = resultArray[2];
    return pollResult;
}
#end_block

#method_before
public int[] getTxPacketCounters() {
    if (mClientInterface == null) {
        Log.e(TAG, "No valid wificond client interface handler");
        return null;
    }
    int[] counters;
    try {
        counters = mClientInterface.getPacketCounters();
        if (counters == null || counters.length != 2) {
            Log.e(TAG, "Invalid signal poll result from wificond");
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to do signal polling  due to remote exception");
        return null;
    }
    return counters;
}
#method_after
public WifiNative.TxPacketCounters getTxPacketCounters() {
    if (mClientInterface == null) {
        Log.e(TAG, "No valid wificond client interface handler");
        return null;
    }
    int[] resultArray;
    try {
        resultArray = mClientInterface.getPacketCounters();
        if (resultArray == null || resultArray.length != 2) {
            Log.e(TAG, "Invalid signal poll result from wificond");
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to do signal polling  due to remote exception");
        return null;
    }
    WifiNative.TxPacketCounters counters = new WifiNative.TxPacketCounters();
    counters.txSucceeded = resultArray[0];
    counters.txFailed = resultArray[1];
    return counters;
}
#end_block

#method_before
public boolean initializeSupplicantHal() {
    /* Deactivated until HAL integration is ready
           mWifiSupplicantHal.initialize();
           */
    return true;
}
#method_after
public boolean initializeSupplicantHal() {
    if (!HIDL_ENABLE) {
        return true;
    }
    return mSupplicantStaIfaceHal.initialize();
}
#end_block

#method_before
public IClientInterface setupDriverForClientMode(IWificond wificond) {
    return mWificondControl.setupDriverForClientMode(wificond);
}
#method_after
public IClientInterface setupDriverForClientMode() {
    IClientInterface clientInterface = mWificondControl.setupDriverForClientMode();
    if (!startHal(true)) {
        // TODO(b/34859006): Handle failures.
        Log.e(TAG, "Failed to start HAL for client mode");
    }
    return clientInterface;
}
#end_block

#method_before
public IApInterface setupDriverForSoftApMode(IWificond wificond) {
    IApInterface apInterface = mWificondControl.setupDriverForSoftApMode(wificond);
    if (!startHal()) {
        // starting HAL is optional
        Log.e(TAG, "Failed to start HAL for AP mode");
    }
    return apInterface;
}
#method_after
public IApInterface setupDriverForSoftApMode() {
    IApInterface apInterface = mWificondControl.setupDriverForSoftApMode();
    if (!startHal(false)) {
        // TODO(b/34859006): Handle failures.
        Log.e(TAG, "Failed to start HAL for AP mode");
    }
    return apInterface;
}
#end_block

#method_before
public boolean startHal() {
    String debugLog = "startHal stack: ";
    java.lang.StackTraceElement[] elements = Thread.currentThread().getStackTrace();
    for (int i = 2; i < elements.length && i <= 7; i++) {
        debugLog = debugLog + " - " + elements[i].getMethodName();
    }
    sLocalLog.log(debugLog);
    synchronized (sLock) {
        if (startHalNative()) {
            int wlan0Index = queryInterfaceIndex(mInterfaceName);
            if (wlan0Index == -1) {
                if (DBG)
                    sLocalLog.log("Could not find interface with name: " + mInterfaceName);
                return false;
            }
            sWlan0Index = wlan0Index;
            sThread = new MonitorThread();
            sThread.start();
            return true;
        } else {
            if (DBG)
                sLocalLog.log("Could not start hal");
            Log.e(TAG, "Could not start hal");
            return false;
        }
    }
}
#method_after
public boolean startHal(boolean isStaMode) {
    String debugLog = "startHal stack: ";
    java.lang.StackTraceElement[] elements = Thread.currentThread().getStackTrace();
    for (int i = 2; i < elements.length && i <= 7; i++) {
        debugLog = debugLog + " - " + elements[i].getMethodName();
    }
    sLocalLog.log(debugLog);
    synchronized (sLock) {
        if (startHalNative()) {
            int wlan0Index = queryInterfaceIndex(mInterfaceName);
            if (wlan0Index == -1) {
                if (DBG)
                    sLocalLog.log("Could not find interface with name: " + mInterfaceName);
                return false;
            }
            sWlan0Index = wlan0Index;
            sThread = new MonitorThread();
            sThread.start();
            return true;
        } else {
            if (DBG)
                sLocalLog.log("Could not start hal");
            Log.e(TAG, "Could not start hal");
            return false;
        }
    }
}
#end_block

#method_before
public IClientInterface setupDriverForClientMode(IWificond wificond) {
    if (wificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IClientInterface clientInterface = null;
    try {
        clientInterface = wificond.createClientInterface();
    } catch (RemoteException e1) {
    }
    if (clientInterface == null) {
        Log.e(TAG, "Could not get IClientInterface instance from wificond");
        return null;
    } else {
        Binder.allowBlocking(clientInterface.asBinder());
    }
    // Refresh Handlers
    mWificond = wificond;
    mClientInterface = clientInterface;
    return clientInterface;
}
#method_after
public IClientInterface setupDriverForClientMode() {
    mWificond = mWifiInjector.makeWificond();
    if (mWificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IClientInterface clientInterface = null;
    try {
        clientInterface = mWificond.createClientInterface();
    } catch (RemoteException e1) {
        Log.e(TAG, "Failed to get IClientInterface due to remote exception");
        return null;
    }
    if (clientInterface == null) {
        Log.e(TAG, "Could not get IClientInterface instance from wificond");
        return null;
    }
    Binder.allowBlocking(clientInterface.asBinder());
    // Refresh Handlers
    mClientInterface = clientInterface;
    return clientInterface;
}
#end_block

#method_before
public IApInterface setupDriverForSoftApMode(IWificond wificond) {
    if (wificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IApInterface apInterface = null;
    try {
        apInterface = wificond.createApInterface();
    } catch (RemoteException e1) {
    }
    if (apInterface == null) {
        Log.e(TAG, "Could not get IApInterface instance from wificond");
        return null;
    } else {
        Binder.allowBlocking(apInterface.asBinder());
    }
    // Refresh Handlers
    mWificond = wificond;
    mApInterface = apInterface;
    return apInterface;
}
#method_after
public IApInterface setupDriverForSoftApMode() {
    mWificond = mWifiInjector.makeWificond();
    if (mWificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IApInterface apInterface = null;
    try {
        apInterface = mWificond.createApInterface();
    } catch (RemoteException e1) {
        Log.e(TAG, "Failed to get IApInterface due to remote exception");
        return null;
    }
    if (apInterface == null) {
        Log.e(TAG, "Could not get IApInterface instance from wificond");
        return null;
    }
    Binder.allowBlocking(apInterface.asBinder());
    // Refresh Handlers
    mApInterface = apInterface;
    return apInterface;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (args.length > 1 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0]) && WifiMetrics.CLEAN_DUMP_ARG.equals(args[1])) {
        // Dump only wifi metrics serialized proto bytes (base64)
        updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
        return;
    }
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("Supplicant status " + mWifiNative.status(true));
    pw.println("mSystemSupportsFastBssTransition " + mWifiSupplicantControl.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (args.length > 1 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0]) && WifiMetrics.CLEAN_DUMP_ARG.equals(args[1])) {
        // Dump only wifi metrics serialized proto bytes (base64)
        updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
        return;
    }
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("mSystemSupportsFastBssTransition " + mWifiSupplicantControl.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#end_block

#method_before
private SupplicantState handleSupplicantStateChange(Message message) {
    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
    SupplicantState state = stateChangeResult.state;
    // Supplicant state change
    // [31-13] Reserved for future use
    // [8 - 0] Supplicant state (as defined in SupplicantState.java)
    // 50023 supplicant_state_changed (custom|1|5)
    mWifiInfo.setSupplicantState(state);
    // We should pretend we are still connected when linkDebouncing is on.
    if ((stateChangeResult.wifiSsid == null || stateChangeResult.wifiSsid.toString().isEmpty()) && isLinkDebouncing()) {
        return state;
    }
    // Network id is only valid when we start connecting
    if (SupplicantState.isConnecting(state)) {
        mWifiInfo.setNetworkId(lookupFrameworkNetworkId(stateChangeResult.networkId));
    } else {
        mWifiInfo.setNetworkId(WifiConfiguration.INVALID_NETWORK_ID);
    }
    mWifiInfo.setBSSID(stateChangeResult.BSSID);
    mWifiInfo.setSSID(stateChangeResult.wifiSsid);
    WifiConfiguration config = getCurrentWifiConfiguration();
    if (config != null) {
        mWifiInfo.setEphemeral(config.ephemeral);
        if (!mWifiInfo.getMeteredHint()) {
            // don't override the value if already set.
            mWifiInfo.setMeteredHint(config.meteredHint);
        }
    }
    mSupplicantStateTracker.sendMessage(Message.obtain(message));
    return state;
}
#method_after
private SupplicantState handleSupplicantStateChange(Message message) {
    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
    SupplicantState state = stateChangeResult.state;
    // Supplicant state change
    // [31-13] Reserved for future use
    // [8 - 0] Supplicant state (as defined in SupplicantState.java)
    // 50023 supplicant_state_changed (custom|1|5)
    mWifiInfo.setSupplicantState(state);
    // We should pretend we are still connected when linkDebouncing is on.
    if ((stateChangeResult.wifiSsid == null || stateChangeResult.wifiSsid.toString().isEmpty()) && isLinkDebouncing()) {
        return state;
    }
    // Network id is only valid when we start connecting
    if (SupplicantState.isConnecting(state)) {
        mWifiInfo.setNetworkId(lookupFrameworkNetworkId(stateChangeResult.networkId));
    } else {
        mWifiInfo.setNetworkId(WifiConfiguration.INVALID_NETWORK_ID);
    }
    mWifiInfo.setBSSID(stateChangeResult.BSSID);
    mWifiInfo.setSSID(stateChangeResult.wifiSsid);
    WifiConfiguration config = getCurrentWifiConfiguration();
    if (config != null) {
        // Set meteredHint to true if the access network type of the connecting/connected AP
        // is a chargeable public network.
        ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(config.networkId);
        if (scanDetailCache != null) {
            ScanDetail scanDetail = scanDetailCache.getScanDetail(stateChangeResult.BSSID);
            if (scanDetail != null) {
                NetworkDetail networkDetail = scanDetail.getNetworkDetail();
                if (networkDetail != null && networkDetail.getAnt() == NetworkDetail.Ant.ChargeablePublic) {
                    mWifiInfo.setMeteredHint(true);
                }
            }
        }
        mWifiInfo.setEphemeral(config.ephemeral);
        if (!mWifiInfo.getMeteredHint()) {
            // don't override the value if already set.
            mWifiInfo.setMeteredHint(config.meteredHint);
        }
    }
    mSupplicantStateTracker.sendMessage(Message.obtain(message));
    return state;
}
#end_block

#method_before
private void handleSupplicantConnectionLoss(boolean killSupplicant) {
    /* Socket connection can be lost when we do a graceful shutdown
        * or when the driver is hung. Ensure supplicant is stopped here.
        */
    if (killSupplicant) {
        mWifiMonitor.stopAllMonitoring();
        try {
            if (!mClientInterface.disableSupplicant()) {
                loge("Failed to disable supplicant after connection loss");
            }
        } catch (RemoteException e) {
        // Remote interface has died, there is no cleanup we can do.
        }
    }
    mWifiNative.closeSupplicantConnection();
    sendSupplicantConnectionChangedBroadcast(false);
    setWifiState(WIFI_STATE_DISABLED);
}
#method_after
private void handleSupplicantConnectionLoss(boolean killSupplicant) {
    /* Socket connection can be lost when we do a graceful shutdown
        * or when the driver is hung. Ensure supplicant is stopped here.
        */
    if (killSupplicant) {
        mWifiMonitor.stopAllMonitoring();
        if (!mWifiNative.disableSupplicant()) {
            loge("Failed to disable supplicant after connection loss");
        }
    }
    mWifiNative.closeSupplicantConnection();
    sendSupplicantConnectionChangedBroadcast(false);
    setWifiState(WIFI_STATE_DISABLED);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                    } else {
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
private void cleanup() {
    // Tearing down the client interfaces below is going to stop our supplicant.
    mWifiMonitor.stopAllMonitoring();
    mDeathRecipient.unlinkToDeath();
    if (mWificond != null) {
        try {
            mWificond.tearDownInterfaces();
        } catch (RemoteException e) {
            // There is very little we can do here
            Log.e(TAG, "Failed to tear down interfaces via wificond");
        }
        mWificond = null;
    }
    mWifiNative.stopHal();
}
#method_after
private void cleanup() {
    // Tearing down the client interfaces below is going to stop our supplicant.
    mWifiMonitor.stopAllMonitoring();
    mDeathRecipient.unlinkToDeath();
    mWifiNative.tearDownInterfaces();
    mWifiNative.stopHal();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            mClientInterface = mWifiNative.setupDriverForClientMode(mWificond);
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.startHal()) {
                // starting HAL is optional
                Log.e(TAG, "Failed to start HAL for client mode");
            }
            try {
                if (!mClientInterface.enableSupplicant()) {
                    loge("Failed to start supplicant!");
                    setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                    cleanup();
                    break;
                }
            } catch (RemoteException e) {
                cleanup();
                break;
            }
            if (!mWifiNative.initializeSupplicantHal()) {
                Log.e(TAG, "Failed to start supplicant Hal");
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            mClientInterface = mWifiNative.setupDriverForClientMode();
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.enableSupplicant()) {
                loge("Failed to start supplicant!");
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            if (!mWifiNative.initializeSupplicantHal()) {
                Log.e(TAG, "Failed to start supplicant Hal");
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            // Attempt to migrate data out of legacy store.
            if (!mWifiConfigManager.migrateFromLegacyStore()) {
                Log.e(TAG, "Failed to migrate from legacy config store");
            }
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                try {
                    mClientInterface.disableSupplicant();
                } catch (RemoteException e) {
                // The client interface is dead, there is nothing more we can do.
                }
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            // Attempt to migrate data out of legacy store.
            if (!mWifiConfigManager.migrateFromLegacyStore()) {
                Log.e(TAG, "Failed to migrate from legacy config store");
            }
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                mWifiNative.disableSupplicant();
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mAwareSupported) {
        if (mWifiAwareManager == null) {
            mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
        }
        if (mWifiAwareManager == null) {
            Log.e(TAG, "Can't get WifiAwareManager to enable usage!");
        } else {
            if (mOperationalMode == CONNECT_MODE) {
                mWifiAwareManager.enableUsage();
            } else {
            /*
                     * Aware state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
            }
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
@Override
public void exit() {
    mWifiDiagnostics.stopLogging();
    mIsRunning = false;
    updateBatteryWorkSource(null);
    mScanResults = new ArrayList<>();
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    mBufferedScanMsg.clear();
    if (mAwareSupported) {
        if (mWifiAwareManager == null) {
            mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
        }
        if (mWifiAwareManager == null) {
            Log.e(TAG, "Can't get WifiAwareManager (to disable usage)!");
        } else {
            mWifiAwareManager.disableUsage();
        }
    }
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    mCountryCode.setReadyForChange(false);
}
#method_after
@Override
public void exit() {
    mWifiDiagnostics.stopLogging();
    mIsRunning = false;
    updateBatteryWorkSource(null);
    mScanResults = new ArrayList<>();
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    mBufferedScanMsg.clear();
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    mCountryCode.setReadyForChange(false);
}
#end_block

#method_before
@Override
public void enter() {
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
}
#method_after
@Override
public void enter() {
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
    // Inform p2p service that wifi is up and ready when applicable
    p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            // the WifiConfigManager
            if ((message.arg2 != WifiMonitor.AUTHENTICATION_FAILURE_REASON_WRONG_PSWD) && (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID)) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    final Message message = getCurrentMessage();
    if (message.what != CMD_START_AP) {
        throw new RuntimeException("Illegal transition to SoftApState: " + message);
    }
    IApInterface apInterface = mWifiNative.setupDriverForSoftApMode(mWificond);
    if (apInterface == null) {
        setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
        /**
         * Transition to InitialState to reset the
         * driver/HAL back to the initial state.
         */
        transitionTo(mInitialState);
        return;
    }
    WifiConfiguration config = (WifiConfiguration) message.obj;
    checkAndSetConnectivityInstance();
    mSoftApManager = mWifiInjector.makeSoftApManager(mNwService, new SoftApListener(), apInterface, config);
    mSoftApManager.start();
}
#method_after
@Override
public void enter() {
    final Message message = getCurrentMessage();
    if (message.what != CMD_START_AP) {
        throw new RuntimeException("Illegal transition to SoftApState: " + message);
    }
    IApInterface apInterface = mWifiNative.setupDriverForSoftApMode();
    if (apInterface == null) {
        setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
        /**
         * Transition to InitialState to reset the
         * driver/HAL back to the initial state.
         */
        transitionTo(mInitialState);
        return;
    }
    WifiConfiguration config = (WifiConfiguration) message.obj;
    checkAndSetConnectivityInstance();
    mSoftApManager = mWifiInjector.makeSoftApManager(mNwService, new SoftApListener(), apInterface, config);
    mSoftApManager.start();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Log.d(TAG, "Setting up ...");
    // Ensure looper exists
    mLooper = new TestLooper();
    MockitoAnnotations.initMocks(this);
    /**
     * uncomment this to enable logs from WifiStateMachines
     */
    // enableDebugLogs();
    mWifiMonitor = new MockWifiMonitor();
    when(mWifiInjector.getWifiMetrics()).thenReturn(mWifiMetrics);
    when(mWifiInjector.getClock()).thenReturn(mock(Clock.class));
    when(mWifiInjector.getWifiLastResortWatchdog()).thenReturn(mWifiLastResortWatchdog);
    when(mWifiInjector.getPropertyService()).thenReturn(mPropertyService);
    when(mWifiInjector.getBuildProperties()).thenReturn(mBuildProperties);
    when(mWifiInjector.getKeyStore()).thenReturn(mock(KeyStore.class));
    when(mWifiInjector.getWifiBackupRestore()).thenReturn(mock(WifiBackupRestore.class));
    when(mWifiInjector.makeWifiDiagnostics(anyObject())).thenReturn(mock(BaseWifiDiagnostics.class));
    when(mWifiInjector.makeWificond()).thenReturn(mWificond);
    when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
    when(mWifiInjector.getWifiSupplicantControl()).thenReturn(mWifiSupplicantControl);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    when(mWifiInjector.getWifiNetworkSelector()).thenReturn(mock(WifiNetworkSelector.class));
    when(mWifiInjector.makeWifiConnectivityManager(any(WifiInfo.class), anyBoolean())).thenReturn(mWifiConnectivityManager);
    when(mWifiNative.setupDriverForClientMode(any(IWificond.class))).thenReturn(mClientInterface);
    when(mWifiNative.getInterfaceName()).thenReturn("mockWlan");
    when(mWifiSupplicantControl.getFrameworkNetworkId(anyInt())).thenReturn(0);
    FrameworkFacade factory = getFrameworkFacade();
    Context context = getContext();
    Resources resources = getMockResources();
    when(context.getResources()).thenReturn(resources);
    when(factory.getIntegerSetting(context, Settings.Global.WIFI_FREQUENCY_BAND, WifiManager.WIFI_FREQUENCY_BAND_AUTO)).thenReturn(WifiManager.WIFI_FREQUENCY_BAND_AUTO);
    when(factory.makeApConfigStore(eq(context), eq(mBackupManagerProxy))).thenReturn(mApConfigStore);
    when(factory.makeSupplicantStateTracker(any(Context.class), any(WifiConfigManager.class), any(Handler.class))).thenReturn(mSupplicantStateTracker);
    when(mUserManager.getProfileParent(11)).thenReturn(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0));
    when(mUserManager.getProfiles(UserHandle.USER_SYSTEM)).thenReturn(Arrays.asList(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0), new UserInfo(11, "managed profile", 0)));
    when(mClientInterface.asBinder()).thenReturn(mClientInterfaceBinder);
    when(mClientInterface.enableSupplicant()).thenReturn(true);
    when(mClientInterface.disableSupplicant()).thenReturn(true);
    mWsm = new WifiStateMachine(context, factory, mLooper.getLooper(), mUserManager, mWifiInjector, mBackupManagerProxy, mCountryCode, mWifiNative);
    mWsmThread = getWsmHandlerThread(mWsm);
    final AsyncChannel channel = new AsyncChannel();
    Handler handler = new Handler(mLooper.getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        mWsmAsyncChannel = channel;
                    } else {
                        Log.d(TAG, "Failed to connect Command channel " + this);
                    }
                    break;
                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
                    Log.d(TAG, "Command channel disconnected" + this);
                    break;
            }
        }
    };
    channel.connect(context, handler, mWsm.getMessenger());
    mLooper.dispatchAll();
    /* Now channel is supposed to be connected */
    mBinderToken = Binder.clearCallingIdentity();
}
#method_after
@Before
public void setUp() throws Exception {
    Log.d(TAG, "Setting up ...");
    // Ensure looper exists
    mLooper = new TestLooper();
    MockitoAnnotations.initMocks(this);
    /**
     * uncomment this to enable logs from WifiStateMachines
     */
    // enableDebugLogs();
    mWifiMonitor = new MockWifiMonitor();
    when(mWifiInjector.getWifiMetrics()).thenReturn(mWifiMetrics);
    when(mWifiInjector.getClock()).thenReturn(mock(Clock.class));
    when(mWifiInjector.getWifiLastResortWatchdog()).thenReturn(mWifiLastResortWatchdog);
    when(mWifiInjector.getPropertyService()).thenReturn(mPropertyService);
    when(mWifiInjector.getBuildProperties()).thenReturn(mBuildProperties);
    when(mWifiInjector.getKeyStore()).thenReturn(mock(KeyStore.class));
    when(mWifiInjector.getWifiBackupRestore()).thenReturn(mock(WifiBackupRestore.class));
    when(mWifiInjector.makeWifiDiagnostics(anyObject())).thenReturn(mock(BaseWifiDiagnostics.class));
    when(mWifiInjector.makeWificond()).thenReturn(mWificond);
    when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
    when(mWifiInjector.getWifiSupplicantControl()).thenReturn(mWifiSupplicantControl);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    when(mWifiInjector.getWifiNetworkSelector()).thenReturn(mock(WifiNetworkSelector.class));
    when(mWifiInjector.makeWifiConnectivityManager(any(WifiInfo.class), anyBoolean())).thenReturn(mWifiConnectivityManager);
    when(mWifiInjector.makeSoftApManager(any(INetworkManagementService.class), any(SoftApManager.Listener.class), any(IApInterface.class), any(WifiConfiguration.class))).thenReturn(mSoftApManager);
    when(mWifiNative.setupDriverForClientMode()).thenReturn(mClientInterface);
    when(mWifiNative.setupDriverForSoftApMode()).thenReturn(mApInterface);
    when(mWifiNative.getInterfaceName()).thenReturn("mockWlan");
    when(mWifiNative.enableSupplicant()).thenReturn(true);
    when(mWifiNative.disableSupplicant()).thenReturn(true);
    when(mWifiSupplicantControl.getFrameworkNetworkId(anyInt())).thenReturn(0);
    FrameworkFacade factory = getFrameworkFacade();
    Context context = getContext();
    Resources resources = getMockResources();
    when(context.getResources()).thenReturn(resources);
    when(factory.getIntegerSetting(context, Settings.Global.WIFI_FREQUENCY_BAND, WifiManager.WIFI_FREQUENCY_BAND_AUTO)).thenReturn(WifiManager.WIFI_FREQUENCY_BAND_AUTO);
    when(factory.makeApConfigStore(eq(context), eq(mBackupManagerProxy))).thenReturn(mApConfigStore);
    when(factory.makeSupplicantStateTracker(any(Context.class), any(WifiConfigManager.class), any(Handler.class))).thenReturn(mSupplicantStateTracker);
    when(mUserManager.getProfileParent(11)).thenReturn(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0));
    when(mUserManager.getProfiles(UserHandle.USER_SYSTEM)).thenReturn(Arrays.asList(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0), new UserInfo(11, "managed profile", 0)));
    when(mApInterface.asBinder()).thenReturn(mApInterfaceBinder);
    when(mClientInterface.asBinder()).thenReturn(mClientInterfaceBinder);
    mWsm = new WifiStateMachine(context, factory, mLooper.getLooper(), mUserManager, mWifiInjector, mBackupManagerProxy, mCountryCode, mWifiNative);
    mWsmThread = getWsmHandlerThread(mWsm);
    final AsyncChannel channel = new AsyncChannel();
    Handler handler = new Handler(mLooper.getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        mWsmAsyncChannel = channel;
                    } else {
                        Log.d(TAG, "Failed to connect Command channel " + this);
                    }
                    break;
                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
                    Log.d(TAG, "Command channel disconnected" + this);
                    break;
            }
        }
    };
    channel.connect(context, handler, mWsm.getMessenger());
    mLooper.dispatchAll();
    /* Now channel is supposed to be connected */
    mBinderToken = Binder.clearCallingIdentity();
}
#end_block

#method_before
@Test
public void shouldRequireSupplicantStartupToLeaveInitialState() throws Exception {
    when(mClientInterface.enableSupplicant()).thenReturn(false);
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
}
#method_after
@Test
public void shouldRequireSupplicantStartupToLeaveInitialState() throws Exception {
    when(mWifiNative.enableSupplicant()).thenReturn(false);
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
}
#end_block

#method_before
@Test
public void loadComponentsFailure() throws Exception {
    when(mWifiNative.startHal()).thenReturn(false);
    when(mClientInterface.enableSupplicant()).thenReturn(false);
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
    when(mWifiNative.startHal()).thenReturn(true);
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
}
#method_after
@Test
public void loadComponentsFailure() throws Exception {
    when(mWifiNative.startHal(anyBoolean())).thenReturn(false);
    when(mWifiNative.enableSupplicant()).thenReturn(false);
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
    when(mWifiNative.startHal(anyBoolean())).thenReturn(true);
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
}
#end_block

#method_before
@Test
public void shouldStartSupplicantWhenConnectModeRequested() throws Exception {
    when(mWifiNative.startHal()).thenReturn(true);
    // The first time we start out in InitialState, we sit around here.
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
    assertEquals(WifiStateMachine.CONNECT_MODE, mWsm.getOperationalModeForTest());
    // But if someone tells us to enter connect mode, we start up supplicant
    mWsm.setOperationalMode(WifiStateMachine.CONNECT_MODE);
    mLooper.dispatchAll();
    assertEquals("SupplicantStartingState", getCurrentState().getName());
}
#method_after
@Test
public void shouldStartSupplicantWhenConnectModeRequested() throws Exception {
    when(mWifiNative.startHal(anyBoolean())).thenReturn(true);
    // The first time we start out in InitialState, we sit around here.
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
    assertEquals(WifiStateMachine.CONNECT_MODE, mWsm.getOperationalModeForTest());
    // But if someone tells us to enter connect mode, we start up supplicant
    mWsm.setOperationalMode(WifiStateMachine.CONNECT_MODE);
    mLooper.dispatchAll();
    assertEquals("SupplicantStartingState", getCurrentState().getName());
}
#end_block

#method_before
@Test
public void checkStartInCorrectStateAfterChangingInitialState() throws Exception {
    when(mWifiNative.startHal()).thenReturn(true);
    // Check initial state
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
    assertEquals(WifiStateMachine.CONNECT_MODE, mWsm.getOperationalModeForTest());
    // Update the mode
    mWsm.setOperationalMode(WifiStateMachine.SCAN_ONLY_MODE);
    mLooper.dispatchAll();
    assertEquals(WifiStateMachine.SCAN_ONLY_MODE, mWsm.getOperationalModeForTest());
    // Start supplicant so we move to the next state
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("SupplicantStartingState", getCurrentState().getName());
    when(mWifiNative.setDeviceName(anyString())).thenReturn(true);
    when(mWifiNative.setManufacturer(anyString())).thenReturn(true);
    when(mWifiNative.setModelName(anyString())).thenReturn(true);
    when(mWifiNative.setModelNumber(anyString())).thenReturn(true);
    when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
    when(mWifiNative.setConfigMethods(anyString())).thenReturn(true);
    when(mWifiNative.setDeviceType(anyString())).thenReturn(true);
    when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
    when(mWifiNative.setScanningMacOui(any(byte[].class))).thenReturn(true);
    mWsm.sendMessage(WifiMonitor.SUP_CONNECTION_EVENT);
    mLooper.dispatchAll();
    assertEquals("ScanModeState", getCurrentState().getName());
}
#method_after
@Test
public void checkStartInCorrectStateAfterChangingInitialState() throws Exception {
    when(mWifiNative.startHal(anyBoolean())).thenReturn(true);
    // Check initial state
    mLooper.dispatchAll();
    assertEquals("InitialState", getCurrentState().getName());
    assertEquals(WifiStateMachine.CONNECT_MODE, mWsm.getOperationalModeForTest());
    // Update the mode
    mWsm.setOperationalMode(WifiStateMachine.SCAN_ONLY_MODE);
    mLooper.dispatchAll();
    assertEquals(WifiStateMachine.SCAN_ONLY_MODE, mWsm.getOperationalModeForTest());
    // Start supplicant so we move to the next state
    mWsm.setSupplicantRunning(true);
    mLooper.dispatchAll();
    assertEquals("SupplicantStartingState", getCurrentState().getName());
    when(mWifiNative.setDeviceName(anyString())).thenReturn(true);
    when(mWifiNative.setManufacturer(anyString())).thenReturn(true);
    when(mWifiNative.setModelName(anyString())).thenReturn(true);
    when(mWifiNative.setModelNumber(anyString())).thenReturn(true);
    when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
    when(mWifiNative.setConfigMethods(anyString())).thenReturn(true);
    when(mWifiNative.setDeviceType(anyString())).thenReturn(true);
    when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
    when(mWifiNative.setScanningMacOui(any(byte[].class))).thenReturn(true);
    mWsm.sendMessage(WifiMonitor.SUP_CONNECTION_EVENT);
    mLooper.dispatchAll();
    assertEquals("ScanModeState", getCurrentState().getName());
}
#end_block

#method_before
private void addNetworkAndVerifySuccess(boolean isHidden) throws Exception {
    loadComponents();
    WifiConfiguration config = new WifiConfiguration();
    config.SSID = sSSID;
    config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
    config.hiddenSSID = isHidden;
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(0));
    when(mWifiConfigManager.getSavedNetworks()).thenReturn(Arrays.asList(config));
    when(mWifiConfigManager.getConfiguredNetwork(0)).thenReturn(config);
    mLooper.startAutoDispatch();
    mWsm.syncAddOrUpdateNetwork(mWsmAsyncChannel, config);
    mLooper.stopAutoDispatch();
    verify(mWifiConfigManager).addOrUpdateNetwork(eq(config), anyInt());
    mLooper.startAutoDispatch();
    List<WifiConfiguration> configs = mWsm.syncGetConfiguredNetworks(-1, mWsmAsyncChannel);
    mLooper.stopAutoDispatch();
    assertEquals(1, configs.size());
    WifiConfiguration config2 = configs.get(0);
    assertEquals("\"GoogleGuest\"", config2.SSID);
    assertTrue(config2.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE));
}
#method_after
private void addNetworkAndVerifySuccess(boolean isHidden) throws Exception {
    loadComponentsInStaMode();
    WifiConfiguration config = new WifiConfiguration();
    config.SSID = sSSID;
    config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
    config.hiddenSSID = isHidden;
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(0));
    when(mWifiConfigManager.getSavedNetworks()).thenReturn(Arrays.asList(config));
    when(mWifiConfigManager.getConfiguredNetwork(0)).thenReturn(config);
    mLooper.startAutoDispatch();
    mWsm.syncAddOrUpdateNetwork(mWsmAsyncChannel, config);
    mLooper.stopAutoDispatch();
    verify(mWifiConfigManager).addOrUpdateNetwork(eq(config), anyInt());
    mLooper.startAutoDispatch();
    List<WifiConfiguration> configs = mWsm.syncGetConfiguredNetworks(-1, mWsmAsyncChannel);
    mLooper.stopAutoDispatch();
    assertEquals(1, configs.size());
    WifiConfiguration config2 = configs.get(0);
    assertEquals("\"GoogleGuest\"", config2.SSID);
    assertTrue(config2.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE));
}
#end_block

#method_before
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
                mountExternal = mountServiceInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[2];
            } else {
                gids = new int[permGids.length + 2];
                System.arraycopy(permGids, 0, gids, 2, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid));
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int debugFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            debugFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            debugFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        Process.ProcessStartResult startResult;
        if (hostingType.equals("webview_service")) {
            startResult = Process.startWebView(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);
        } else {
            startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);
        }
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, app.info.seinfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(startResult.pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#method_after
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
                mountExternal = mountServiceInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[3];
            } else {
                gids = new int[permGids.length + 3];
                System.arraycopy(permGids, 0, gids, 3, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));
            gids[2] = UserHandle.getUserGid(UserHandle.getUserId(uid));
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int debugFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            debugFlags |= Zygote.DEBUG_ENABLE_JDWP;
            debugFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            debugFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            debugFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        String invokeWith = null;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            // Debuggable apps may include a wrapper script with their library directory.
            String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh";
            if (new File(wrapperFileName).exists()) {
                invokeWith = "/system/bin/logwrapper " + wrapperFileName;
            }
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        Process.ProcessStartResult startResult;
        if (hostingType.equals("webview_service")) {
            startResult = Process.startWebView(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, null, entryPointArgs);
        } else {
            startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);
        }
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, app.info.seinfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(startResult.pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#end_block

#method_before
private static void dumpStackTraces(String tracesPath, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, String[] nativeProcs) {
    // Use a FileObserver to detect when traces finish writing.
    // The order of traces is considered important to maintain for legibility.
    FileObserver observer = new FileObserver(tracesPath, FileObserver.CLOSE_WRITE) {

        @Override
        public synchronized void onEvent(int event, String path) {
            notify();
        }
    };
    try {
        observer.startWatching();
        // First collect all of the stacks of the most important pids.
        if (firstPids != null) {
            try {
                int num = firstPids.size();
                for (int i = 0; i < num; i++) {
                    synchronized (observer) {
                        if (DEBUG_ANR)
                            Slog.d(TAG, "Collecting stacks for pid " + firstPids.get(i));
                        final long sime = SystemClock.elapsedRealtime();
                        Process.sendSignal(firstPids.get(i), Process.SIGNAL_QUIT);
                        // Wait for write-close, give up after 1 sec
                        observer.wait(1000);
                        if (DEBUG_ANR)
                            Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + (SystemClock.elapsedRealtime() - sime) + "ms");
                    }
                }
            } catch (InterruptedException e) {
                Slog.wtf(TAG, e);
            }
        }
        // Next collect the stacks of the native pids
        if (nativeProcs != null) {
            int[] pids = Process.getPidsForCommands(nativeProcs);
            if (pids != null) {
                // The time of dump native backtrace shouldn't exceed 30 seconds.
                int timeoutSecs = 30;
                long startTime = System.currentTimeMillis();
                for (int pid : pids) {
                    if (DEBUG_ANR)
                        Slog.d(TAG, "Collecting stacks for native pid " + pid);
                    final long sime = SystemClock.elapsedRealtime();
                    Debug.dumpNativeBacktraceToFileTimeout(pid, tracesPath, timeoutSecs);
                    if (DEBUG_ANR)
                        Slog.d(TAG, "Done with native pid " + pid + " in " + (SystemClock.elapsedRealtime() - sime) + "ms");
                    timeoutSecs -= (int) (System.currentTimeMillis() - startTime) / 1000;
                    if (timeoutSecs <= 0) {
                        break;
                    }
                }
            }
        }
        // Lastly, measure CPU usage.
        if (processCpuTracker != null) {
            processCpuTracker.init();
            System.gc();
            processCpuTracker.update();
            try {
                synchronized (processCpuTracker) {
                    // measure over 1/2 second.
                    processCpuTracker.wait(500);
                }
            } catch (InterruptedException e) {
            }
            processCpuTracker.update();
            // We'll take the stack crawls of just the top apps using CPU.
            final int N = processCpuTracker.countWorkingStats();
            int numProcs = 0;
            for (int i = 0; i < N && numProcs < 5; i++) {
                ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);
                if (lastPids.indexOfKey(stats.pid) >= 0) {
                    numProcs++;
                    try {
                        synchronized (observer) {
                            if (DEBUG_ANR)
                                Slog.d(TAG, "Collecting stacks for extra pid " + stats.pid);
                            final long stime = SystemClock.elapsedRealtime();
                            Process.sendSignal(stats.pid, Process.SIGNAL_QUIT);
                            // Wait for write-close, give up after 1 sec
                            observer.wait(1000);
                            if (DEBUG_ANR)
                                Slog.d(TAG, "Done with extra pid " + stats.pid + " in " + (SystemClock.elapsedRealtime() - stime) + "ms");
                        }
                    } catch (InterruptedException e) {
                        Slog.wtf(TAG, e);
                    }
                } else if (DEBUG_ANR) {
                    Slog.d(TAG, "Skipping next CPU consuming process, not a java proc: " + stats.pid);
                }
            }
        }
    } finally {
        observer.stopWatching();
    }
}
#method_after
private static void dumpStackTraces(String tracesPath, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, String[] nativeProcs) {
    // Use a FileObserver to detect when traces finish writing.
    // The order of traces is considered important to maintain for legibility.
    FileObserver observer = new FileObserver(tracesPath, FileObserver.CLOSE_WRITE) {

        @Override
        public synchronized void onEvent(int event, String path) {
            notify();
        }
    };
    try {
        observer.startWatching();
        // First collect all of the stacks of the most important pids.
        if (firstPids != null) {
            try {
                int num = firstPids.size();
                for (int i = 0; i < num; i++) {
                    synchronized (observer) {
                        if (DEBUG_ANR)
                            Slog.d(TAG, "Collecting stacks for pid " + firstPids.get(i));
                        final long sime = SystemClock.elapsedRealtime();
                        Process.sendSignal(firstPids.get(i), Process.SIGNAL_QUIT);
                        // Wait for write-close, give up after 1 sec
                        observer.wait(1000);
                        if (DEBUG_ANR)
                            Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + (SystemClock.elapsedRealtime() - sime) + "ms");
                    }
                }
            } catch (InterruptedException e) {
                Slog.wtf(TAG, e);
            }
        }
        // Next collect the stacks of the native pids
        if (nativeProcs != null) {
            int[] pids = Process.getPidsForCommands(nativeProcs);
            if (pids != null) {
                for (int pid : pids) {
                    if (DEBUG_ANR)
                        Slog.d(TAG, "Collecting stacks for native pid " + pid);
                    final long sime = SystemClock.elapsedRealtime();
                    Debug.dumpNativeBacktraceToFileTimeout(pid, tracesPath, 10);
                    if (DEBUG_ANR)
                        Slog.d(TAG, "Done with native pid " + pid + " in " + (SystemClock.elapsedRealtime() - sime) + "ms");
                }
            }
        }
        // Lastly, measure CPU usage.
        if (processCpuTracker != null) {
            processCpuTracker.init();
            System.gc();
            processCpuTracker.update();
            try {
                synchronized (processCpuTracker) {
                    // measure over 1/2 second.
                    processCpuTracker.wait(500);
                }
            } catch (InterruptedException e) {
            }
            processCpuTracker.update();
            // We'll take the stack crawls of just the top apps using CPU.
            final int N = processCpuTracker.countWorkingStats();
            int numProcs = 0;
            for (int i = 0; i < N && numProcs < 5; i++) {
                ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);
                if (lastPids.indexOfKey(stats.pid) >= 0) {
                    numProcs++;
                    try {
                        synchronized (observer) {
                            if (DEBUG_ANR)
                                Slog.d(TAG, "Collecting stacks for extra pid " + stats.pid);
                            final long stime = SystemClock.elapsedRealtime();
                            Process.sendSignal(stats.pid, Process.SIGNAL_QUIT);
                            // Wait for write-close, give up after 1 sec
                            observer.wait(1000);
                            if (DEBUG_ANR)
                                Slog.d(TAG, "Done with extra pid " + stats.pid + " in " + (SystemClock.elapsedRealtime() - stime) + "ms");
                        }
                    } catch (InterruptedException e) {
                        Slog.wtf(TAG, e);
                    }
                } else if (DEBUG_ANR) {
                    Slog.d(TAG, "Skipping next CPU consuming process, not a java proc: " + stats.pid);
                }
            }
        }
    } finally {
        observer.stopWatching();
    }
}
#end_block

#method_before
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            Process.killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = IApplicationThread.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        String profileFile = app.instrumentationProfileFile;
        ParcelFileDescriptor profileFd = null;
        int samplingInterval = 0;
        boolean profileAutoStop = false;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            profileFile = mProfileFile;
            profileFd = mProfileFd;
            samplingInterval = mSamplingInterval;
            profileAutoStop = mAutoStopProfiler;
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= Process.FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instrumentationClass != null) {
            notifyPackageUse(app.instrumentationClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + mConfiguration);
        ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        if (profileFd != null) {
            profileFd = profileFd.dup();
        }
        ProfilerInfo profilerInfo = profileFile == null ? null : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked());
        updateLruProcessLocked(app, false, null);
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
    }
    return true;
}
#method_after
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            Process.killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = IApplicationThread.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        String profileFile = app.instrumentationProfileFile;
        ParcelFileDescriptor profileFd = null;
        int samplingInterval = 0;
        boolean profileAutoStop = false;
        boolean profileStreamingOutput = false;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            profileFile = mProfileFile;
            profileFd = mProfileFd;
            samplingInterval = mSamplingInterval;
            profileAutoStop = mAutoStopProfiler;
            profileStreamingOutput = mStreamingOutput;
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= Process.FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instrumentationClass != null) {
            notifyPackageUse(app.instrumentationClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + mConfiguration);
        ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        if (profileFd != null) {
            profileFd = profileFd.dup();
        }
        ProfilerInfo profilerInfo = profileFile == null ? null : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop, profileStreamingOutput);
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked());
        updateLruProcessLocked(app, false, null);
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
    }
    return true;
}
#end_block

#method_before
void setProfileApp(ApplicationInfo app, String processName, ProfilerInfo profilerInfo) {
    synchronized (this) {
        boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
        if (!isDebuggable) {
            if ((app.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                throw new SecurityException("Process not debuggable: " + app.packageName);
            }
        }
        mProfileApp = processName;
        mProfileFile = profilerInfo.profileFile;
        if (mProfileFd != null) {
            try {
                mProfileFd.close();
            } catch (IOException e) {
            }
            mProfileFd = null;
        }
        mProfileFd = profilerInfo.profileFd;
        mSamplingInterval = profilerInfo.samplingInterval;
        mAutoStopProfiler = profilerInfo.autoStopProfiler;
        mProfileType = 0;
    }
}
#method_after
void setProfileApp(ApplicationInfo app, String processName, ProfilerInfo profilerInfo) {
    synchronized (this) {
        boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
        if (!isDebuggable) {
            if ((app.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                throw new SecurityException("Process not debuggable: " + app.packageName);
            }
        }
        mProfileApp = processName;
        mProfileFile = profilerInfo.profileFile;
        if (mProfileFd != null) {
            try {
                mProfileFd.close();
            } catch (IOException e) {
            }
            mProfileFd = null;
        }
        mProfileFd = profilerInfo.profileFd;
        mSamplingInterval = profilerInfo.samplingInterval;
        mAutoStopProfiler = profilerInfo.autoStopProfiler;
        mStreamingOutput = profilerInfo.streamingOutput;
        mProfileType = 0;
    }
}
#end_block

#method_before
void handleApplicationCrashInner(String eventType, final ProcessRecord r, String processName, final ApplicationErrorReport.CrashInfo crashInfo) {
    EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber);
    addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);
    new Thread(new Runnable() {

        @Override
        public void run() {
            mAppErrors.crashApplication(r, crashInfo);
        }
    }).start();
}
#method_after
void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) {
    EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber);
    addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);
    mAppErrors.crashApplication(r, crashInfo);
}
#end_block

#method_before
void dumpProcessesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
    boolean needSep = false;
    boolean printedAnything = false;
    int numPers = 0;
    pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
    if (dumpAll) {
        final int NP = mProcessNames.getMap().size();
        for (int ip = 0; ip < NP; ip++) {
            SparseArray<ProcessRecord> procs = mProcessNames.getMap().valueAt(ip);
            final int NA = procs.size();
            for (int ia = 0; ia < NA; ia++) {
                ProcessRecord r = procs.valueAt(ia);
                if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                    continue;
                }
                if (!needSep) {
                    pw.println("  All known processes:");
                    needSep = true;
                    printedAnything = true;
                }
                pw.print(r.persistent ? "  *PERS*" : "  *APP*");
                pw.print(" UID ");
                pw.print(procs.keyAt(ia));
                pw.print(" ");
                pw.println(r);
                r.dump(pw, "    ");
                if (r.persistent) {
                    numPers++;
                }
            }
        }
    }
    if (mIsolatedProcesses.size() > 0) {
        boolean printed = false;
        for (int i = 0; i < mIsolatedProcesses.size(); i++) {
            ProcessRecord r = mIsolatedProcesses.valueAt(i);
            if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                continue;
            }
            if (!printed) {
                if (needSep) {
                    pw.println();
                }
                pw.println("  Isolated process list (sorted by uid):");
                printedAnything = true;
                printed = true;
                needSep = true;
            }
            pw.println(String.format("%sIsolated #%2d: %s", "    ", i, r.toString()));
        }
    }
    if (mActiveUids.size() > 0) {
        if (dumpUids(pw, dumpPackage, mActiveUids, "UID states:", needSep)) {
            printedAnything = needSep = true;
        }
    }
    if (mValidateUids.size() > 0) {
        if (dumpUids(pw, dumpPackage, mValidateUids, "UID validation:", needSep)) {
            printedAnything = needSep = true;
        }
    }
    if (mLruProcesses.size() > 0) {
        if (needSep) {
            pw.println();
        }
        pw.print("  Process LRU list (sorted by oom_adj, ");
        pw.print(mLruProcesses.size());
        pw.print(" total, non-act at ");
        pw.print(mLruProcesses.size() - mLruProcessActivityStart);
        pw.print(", non-svc at ");
        pw.print(mLruProcesses.size() - mLruProcessServiceStart);
        pw.println("):");
        dumpProcessOomList(pw, this, mLruProcesses, "    ", "Proc", "PERS", false, dumpPackage);
        needSep = true;
        printedAnything = true;
    }
    if (dumpAll || dumpPackage != null) {
        synchronized (mPidsSelfLocked) {
            boolean printed = false;
            for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                ProcessRecord r = mPidsSelfLocked.valueAt(i);
                if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  PID mappings:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    PID #");
                pw.print(mPidsSelfLocked.keyAt(i));
                pw.print(": ");
                pw.println(mPidsSelfLocked.valueAt(i));
            }
        }
    }
    if (mForegroundProcesses.size() > 0) {
        synchronized (mPidsSelfLocked) {
            boolean printed = false;
            for (int i = 0; i < mForegroundProcesses.size(); i++) {
                ProcessRecord r = mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
                if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  Foreground Processes:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    PID #");
                pw.print(mForegroundProcesses.keyAt(i));
                pw.print(": ");
                pw.println(mForegroundProcesses.valueAt(i));
            }
        }
    }
    if (mPersistentStartingProcesses.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Persisent processes that are starting:");
        dumpProcessList(pw, this, mPersistentStartingProcesses, "    ", "Starting Norm", "Restarting PERS", dumpPackage);
    }
    if (mRemovedProcesses.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Processes that are being removed:");
        dumpProcessList(pw, this, mRemovedProcesses, "    ", "Removed Norm", "Removed PERS", dumpPackage);
    }
    if (mProcessesOnHold.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Processes that are on old until the system is ready:");
        dumpProcessList(pw, this, mProcessesOnHold, "    ", "OnHold Norm", "OnHold PERS", dumpPackage);
    }
    needSep = dumpProcessesToGc(fd, pw, args, opti, needSep, dumpAll, dumpPackage);
    needSep = mAppErrors.dumpLocked(fd, pw, needSep, dumpPackage);
    if (needSep) {
        printedAnything = true;
    }
    if (dumpPackage == null) {
        pw.println();
        needSep = false;
        mUserController.dump(pw, dumpAll);
    }
    if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mHomeProcess: " + mHomeProcess);
    }
    if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mPreviousProcess: " + mPreviousProcess);
    }
    if (dumpAll) {
        StringBuilder sb = new StringBuilder(128);
        sb.append("  mPreviousProcessVisibleTime: ");
        TimeUtils.formatDuration(mPreviousProcessVisibleTime, sb);
        pw.println(sb);
    }
    if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mHeavyWeightProcess: " + mHeavyWeightProcess);
    }
    if (dumpPackage == null) {
        pw.println("  mConfiguration: " + mConfiguration);
    }
    if (dumpAll) {
        pw.println("  mConfigWillChange: " + getFocusedStack().mConfigWillChange);
        if (mCompatModePackages.getPackages().size() > 0) {
            boolean printed = false;
            for (Map.Entry<String, Integer> entry : mCompatModePackages.getPackages().entrySet()) {
                String pkg = entry.getKey();
                int mode = entry.getValue();
                if (dumpPackage != null && !dumpPackage.equals(pkg)) {
                    continue;
                }
                if (!printed) {
                    pw.println("  mScreenCompatPackages:");
                    printed = true;
                }
                pw.print("    ");
                pw.print(pkg);
                pw.print(": ");
                pw.print(mode);
                pw.println();
            }
        }
    }
    if (dumpPackage == null) {
        pw.println("  mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness));
        pw.println("  mSleepTokens=" + mSleepTokens);
        pw.println("  mSleeping=" + mSleeping + " mLockScreenShown=" + lockScreenShownToString());
        pw.println("  mShuttingDown=" + mShuttingDown + " mTestPssMode=" + mTestPssMode);
        if (mRunningVoice != null) {
            pw.println("  mRunningVoice=" + mRunningVoice);
            pw.println("  mVoiceWakeLock" + mVoiceWakeLock);
        }
    }
    if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
        if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mDebugApp=" + mDebugApp + "/orig=" + mOrigDebugApp + " mDebugTransient=" + mDebugTransient + " mOrigWaitForDebugger=" + mOrigWaitForDebugger);
        }
    }
    if (mCurAppTimeTracker != null) {
        mCurAppTimeTracker.dumpWithHeader(pw, "  ", true);
    }
    if (mMemWatchProcesses.getMap().size() > 0) {
        pw.println("  Mem watch processes:");
        final ArrayMap<String, SparseArray<Pair<Long, String>>> procs = mMemWatchProcesses.getMap();
        for (int i = 0; i < procs.size(); i++) {
            final String proc = procs.keyAt(i);
            final SparseArray<Pair<Long, String>> uids = procs.valueAt(i);
            for (int j = 0; j < uids.size(); j++) {
                if (needSep) {
                    pw.println();
                    needSep = false;
                }
                StringBuilder sb = new StringBuilder();
                sb.append("    ").append(proc).append('/');
                UserHandle.formatUid(sb, uids.keyAt(j));
                Pair<Long, String> val = uids.valueAt(j);
                sb.append(": ");
                DebugUtils.sizeValueToString(val.first, sb);
                if (val.second != null) {
                    sb.append(", report to ").append(val.second);
                }
                pw.println(sb.toString());
            }
        }
        pw.print("  mMemWatchDumpProcName=");
        pw.println(mMemWatchDumpProcName);
        pw.print("  mMemWatchDumpFile=");
        pw.println(mMemWatchDumpFile);
        pw.print("  mMemWatchDumpPid=");
        pw.print(mMemWatchDumpPid);
        pw.print(" mMemWatchDumpUid=");
        pw.println(mMemWatchDumpUid);
    }
    if (mTrackAllocationApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mTrackAllocationApp=" + mTrackAllocationApp);
        }
    }
    if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
        if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mProfileApp=" + mProfileApp + " mProfileProc=" + mProfileProc);
            pw.println("  mProfileFile=" + mProfileFile + " mProfileFd=" + mProfileFd);
            pw.println("  mSamplingInterval=" + mSamplingInterval + " mAutoStopProfiler=" + mAutoStopProfiler);
            pw.println("  mProfileType=" + mProfileType);
        }
    }
    if (mNativeDebuggingApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mNativeDebuggingApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mNativeDebuggingApp=" + mNativeDebuggingApp);
        }
    }
    if (dumpPackage == null) {
        if (mAlwaysFinishActivities || mLenientBackgroundCheck) {
            pw.println("  mAlwaysFinishActivities=" + mAlwaysFinishActivities + " mLenientBackgroundCheck=" + mLenientBackgroundCheck);
        }
        if (mController != null) {
            pw.println("  mController=" + mController + " mControllerIsAMonkey=" + mControllerIsAMonkey);
        }
        if (dumpAll) {
            pw.println("  Total persistent processes: " + numPers);
            pw.println("  mProcessesReady=" + mProcessesReady + " mSystemReady=" + mSystemReady + " mBooted=" + mBooted + " mFactoryTest=" + mFactoryTest);
            pw.println("  mBooting=" + mBooting + " mCallFinishBooting=" + mCallFinishBooting + " mBootAnimationComplete=" + mBootAnimationComplete);
            pw.print("  mLastPowerCheckRealtime=");
            TimeUtils.formatDuration(mLastPowerCheckRealtime, pw);
            pw.println("");
            pw.print("  mLastPowerCheckUptime=");
            TimeUtils.formatDuration(mLastPowerCheckUptime, pw);
            pw.println("");
            pw.println("  mGoingToSleep=" + mStackSupervisor.mGoingToSleep);
            pw.println("  mLaunchingActivity=" + mStackSupervisor.mLaunchingActivity);
            pw.println("  mAdjSeq=" + mAdjSeq + " mLruSeq=" + mLruSeq);
            pw.println("  mNumNonCachedProcs=" + mNumNonCachedProcs + " (" + mLruProcesses.size() + " total)" + " mNumCachedHiddenProcs=" + mNumCachedHiddenProcs + " mNumServiceProcs=" + mNumServiceProcs + " mNewNumServiceProcs=" + mNewNumServiceProcs);
            pw.println("  mAllowLowerMemLevel=" + mAllowLowerMemLevel + " mLastMemoryLevel=" + mLastMemoryLevel + " mLastNumProcesses=" + mLastNumProcesses);
            long now = SystemClock.uptimeMillis();
            pw.print("  mLastIdleTime=");
            TimeUtils.formatDuration(now, mLastIdleTime, pw);
            pw.print(" mLowRamSinceLastIdle=");
            TimeUtils.formatDuration(getLowRamTimeSinceIdle(now), pw);
            pw.println();
        }
    }
    if (!printedAnything) {
        pw.println("  (nothing)");
    }
}
#method_after
void dumpProcessesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
    boolean needSep = false;
    boolean printedAnything = false;
    int numPers = 0;
    pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
    if (dumpAll) {
        final int NP = mProcessNames.getMap().size();
        for (int ip = 0; ip < NP; ip++) {
            SparseArray<ProcessRecord> procs = mProcessNames.getMap().valueAt(ip);
            final int NA = procs.size();
            for (int ia = 0; ia < NA; ia++) {
                ProcessRecord r = procs.valueAt(ia);
                if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                    continue;
                }
                if (!needSep) {
                    pw.println("  All known processes:");
                    needSep = true;
                    printedAnything = true;
                }
                pw.print(r.persistent ? "  *PERS*" : "  *APP*");
                pw.print(" UID ");
                pw.print(procs.keyAt(ia));
                pw.print(" ");
                pw.println(r);
                r.dump(pw, "    ");
                if (r.persistent) {
                    numPers++;
                }
            }
        }
    }
    if (mIsolatedProcesses.size() > 0) {
        boolean printed = false;
        for (int i = 0; i < mIsolatedProcesses.size(); i++) {
            ProcessRecord r = mIsolatedProcesses.valueAt(i);
            if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                continue;
            }
            if (!printed) {
                if (needSep) {
                    pw.println();
                }
                pw.println("  Isolated process list (sorted by uid):");
                printedAnything = true;
                printed = true;
                needSep = true;
            }
            pw.println(String.format("%sIsolated #%2d: %s", "    ", i, r.toString()));
        }
    }
    if (mActiveUids.size() > 0) {
        if (dumpUids(pw, dumpPackage, mActiveUids, "UID states:", needSep)) {
            printedAnything = needSep = true;
        }
    }
    if (mValidateUids.size() > 0) {
        if (dumpUids(pw, dumpPackage, mValidateUids, "UID validation:", needSep)) {
            printedAnything = needSep = true;
        }
    }
    if (mLruProcesses.size() > 0) {
        if (needSep) {
            pw.println();
        }
        pw.print("  Process LRU list (sorted by oom_adj, ");
        pw.print(mLruProcesses.size());
        pw.print(" total, non-act at ");
        pw.print(mLruProcesses.size() - mLruProcessActivityStart);
        pw.print(", non-svc at ");
        pw.print(mLruProcesses.size() - mLruProcessServiceStart);
        pw.println("):");
        dumpProcessOomList(pw, this, mLruProcesses, "    ", "Proc", "PERS", false, dumpPackage);
        needSep = true;
        printedAnything = true;
    }
    if (dumpAll || dumpPackage != null) {
        synchronized (mPidsSelfLocked) {
            boolean printed = false;
            for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                ProcessRecord r = mPidsSelfLocked.valueAt(i);
                if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  PID mappings:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    PID #");
                pw.print(mPidsSelfLocked.keyAt(i));
                pw.print(": ");
                pw.println(mPidsSelfLocked.valueAt(i));
            }
        }
    }
    if (mForegroundProcesses.size() > 0) {
        synchronized (mPidsSelfLocked) {
            boolean printed = false;
            for (int i = 0; i < mForegroundProcesses.size(); i++) {
                ProcessRecord r = mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
                if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  Foreground Processes:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    PID #");
                pw.print(mForegroundProcesses.keyAt(i));
                pw.print(": ");
                pw.println(mForegroundProcesses.valueAt(i));
            }
        }
    }
    if (mPersistentStartingProcesses.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Persisent processes that are starting:");
        dumpProcessList(pw, this, mPersistentStartingProcesses, "    ", "Starting Norm", "Restarting PERS", dumpPackage);
    }
    if (mRemovedProcesses.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Processes that are being removed:");
        dumpProcessList(pw, this, mRemovedProcesses, "    ", "Removed Norm", "Removed PERS", dumpPackage);
    }
    if (mProcessesOnHold.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Processes that are on old until the system is ready:");
        dumpProcessList(pw, this, mProcessesOnHold, "    ", "OnHold Norm", "OnHold PERS", dumpPackage);
    }
    needSep = dumpProcessesToGc(fd, pw, args, opti, needSep, dumpAll, dumpPackage);
    needSep = mAppErrors.dumpLocked(fd, pw, needSep, dumpPackage);
    if (needSep) {
        printedAnything = true;
    }
    if (dumpPackage == null) {
        pw.println();
        needSep = false;
        mUserController.dump(pw, dumpAll);
    }
    if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mHomeProcess: " + mHomeProcess);
    }
    if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mPreviousProcess: " + mPreviousProcess);
    }
    if (dumpAll) {
        StringBuilder sb = new StringBuilder(128);
        sb.append("  mPreviousProcessVisibleTime: ");
        TimeUtils.formatDuration(mPreviousProcessVisibleTime, sb);
        pw.println(sb);
    }
    if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mHeavyWeightProcess: " + mHeavyWeightProcess);
    }
    if (dumpPackage == null) {
        pw.println("  mConfiguration: " + mConfiguration);
    }
    if (dumpAll) {
        pw.println("  mConfigWillChange: " + getFocusedStack().mConfigWillChange);
        if (mCompatModePackages.getPackages().size() > 0) {
            boolean printed = false;
            for (Map.Entry<String, Integer> entry : mCompatModePackages.getPackages().entrySet()) {
                String pkg = entry.getKey();
                int mode = entry.getValue();
                if (dumpPackage != null && !dumpPackage.equals(pkg)) {
                    continue;
                }
                if (!printed) {
                    pw.println("  mScreenCompatPackages:");
                    printed = true;
                }
                pw.print("    ");
                pw.print(pkg);
                pw.print(": ");
                pw.print(mode);
                pw.println();
            }
        }
    }
    if (dumpPackage == null) {
        pw.println("  mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness));
        pw.println("  mSleepTokens=" + mSleepTokens);
        pw.println("  mSleeping=" + mSleeping + " mLockScreenShown=" + lockScreenShownToString());
        pw.println("  mShuttingDown=" + mShuttingDown + " mTestPssMode=" + mTestPssMode);
        if (mRunningVoice != null) {
            pw.println("  mRunningVoice=" + mRunningVoice);
            pw.println("  mVoiceWakeLock" + mVoiceWakeLock);
        }
    }
    if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
        if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mDebugApp=" + mDebugApp + "/orig=" + mOrigDebugApp + " mDebugTransient=" + mDebugTransient + " mOrigWaitForDebugger=" + mOrigWaitForDebugger);
        }
    }
    if (mCurAppTimeTracker != null) {
        mCurAppTimeTracker.dumpWithHeader(pw, "  ", true);
    }
    if (mMemWatchProcesses.getMap().size() > 0) {
        pw.println("  Mem watch processes:");
        final ArrayMap<String, SparseArray<Pair<Long, String>>> procs = mMemWatchProcesses.getMap();
        for (int i = 0; i < procs.size(); i++) {
            final String proc = procs.keyAt(i);
            final SparseArray<Pair<Long, String>> uids = procs.valueAt(i);
            for (int j = 0; j < uids.size(); j++) {
                if (needSep) {
                    pw.println();
                    needSep = false;
                }
                StringBuilder sb = new StringBuilder();
                sb.append("    ").append(proc).append('/');
                UserHandle.formatUid(sb, uids.keyAt(j));
                Pair<Long, String> val = uids.valueAt(j);
                sb.append(": ");
                DebugUtils.sizeValueToString(val.first, sb);
                if (val.second != null) {
                    sb.append(", report to ").append(val.second);
                }
                pw.println(sb.toString());
            }
        }
        pw.print("  mMemWatchDumpProcName=");
        pw.println(mMemWatchDumpProcName);
        pw.print("  mMemWatchDumpFile=");
        pw.println(mMemWatchDumpFile);
        pw.print("  mMemWatchDumpPid=");
        pw.print(mMemWatchDumpPid);
        pw.print(" mMemWatchDumpUid=");
        pw.println(mMemWatchDumpUid);
    }
    if (mTrackAllocationApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mTrackAllocationApp=" + mTrackAllocationApp);
        }
    }
    if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
        if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mProfileApp=" + mProfileApp + " mProfileProc=" + mProfileProc);
            pw.println("  mProfileFile=" + mProfileFile + " mProfileFd=" + mProfileFd);
            pw.println("  mSamplingInterval=" + mSamplingInterval + " mAutoStopProfiler=" + mAutoStopProfiler + " mStreamingOutput=" + mStreamingOutput);
            pw.println("  mProfileType=" + mProfileType);
        }
    }
    if (mNativeDebuggingApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mNativeDebuggingApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mNativeDebuggingApp=" + mNativeDebuggingApp);
        }
    }
    if (dumpPackage == null) {
        if (mAlwaysFinishActivities || mLenientBackgroundCheck) {
            pw.println("  mAlwaysFinishActivities=" + mAlwaysFinishActivities + " mLenientBackgroundCheck=" + mLenientBackgroundCheck);
        }
        if (mController != null) {
            pw.println("  mController=" + mController + " mControllerIsAMonkey=" + mControllerIsAMonkey);
        }
        if (dumpAll) {
            pw.println("  Total persistent processes: " + numPers);
            pw.println("  mProcessesReady=" + mProcessesReady + " mSystemReady=" + mSystemReady + " mBooted=" + mBooted + " mFactoryTest=" + mFactoryTest);
            pw.println("  mBooting=" + mBooting + " mCallFinishBooting=" + mCallFinishBooting + " mBootAnimationComplete=" + mBootAnimationComplete);
            pw.print("  mLastPowerCheckRealtime=");
            TimeUtils.formatDuration(mLastPowerCheckRealtime, pw);
            pw.println("");
            pw.print("  mLastPowerCheckUptime=");
            TimeUtils.formatDuration(mLastPowerCheckUptime, pw);
            pw.println("");
            pw.println("  mGoingToSleep=" + mStackSupervisor.mGoingToSleep);
            pw.println("  mLaunchingActivity=" + mStackSupervisor.mLaunchingActivity);
            pw.println("  mAdjSeq=" + mAdjSeq + " mLruSeq=" + mLruSeq);
            pw.println("  mNumNonCachedProcs=" + mNumNonCachedProcs + " (" + mLruProcesses.size() + " total)" + " mNumCachedHiddenProcs=" + mNumCachedHiddenProcs + " mNumServiceProcs=" + mNumServiceProcs + " mNewNumServiceProcs=" + mNewNumServiceProcs);
            pw.println("  mAllowLowerMemLevel=" + mAllowLowerMemLevel + " mLastMemoryLevel=" + mLastMemoryLevel + " mLastNumProcesses=" + mLastNumProcesses);
            long now = SystemClock.uptimeMillis();
            pw.print("  mLastIdleTime=");
            TimeUtils.formatDuration(now, mLastIdleTime, pw);
            pw.print(" mLowRamSinceLastIdle=");
            TimeUtils.formatDuration(getLowRamTimeSinceIdle(now), pw);
            pw.println();
        }
    }
    if (!printedAnything) {
        pw.println("  (nothing)");
    }
}
#end_block

#method_before
public void unbindBackupAgent(ApplicationInfo appInfo) {
    if (DEBUG_BACKUP)
        Slog.v(TAG_BACKUP, "unbindBackupAgent: " + appInfo);
    if (appInfo == null) {
        Slog.w(TAG, "unbind backup agent for null app");
        return;
    }
    synchronized (this) {
        try {
            if (mBackupAppName == null) {
                Slog.w(TAG, "Unbinding backup agent with no active backup");
                return;
            }
            if (!mBackupAppName.equals(appInfo.packageName)) {
                Slog.e(TAG, "Unbind of " + appInfo + " but is not the current backup target");
                return;
            }
            // Not backing this app up any more; reset its OOM adjustment
            final ProcessRecord proc = mBackupTarget.app;
            updateOomAdjLocked(proc);
            // If the app crashed during backup, 'thread' will be null here
            if (proc.thread != null) {
                try {
                    proc.thread.scheduleDestroyBackupAgent(appInfo, compatibilityInfoForPackageLocked(appInfo));
                } catch (Exception e) {
                    Slog.e(TAG, "Exception when unbinding backup agent:");
                    e.printStackTrace();
                }
            }
        } finally {
            mBackupTarget = null;
            mBackupAppName = null;
        }
    }
}
#method_after
public void unbindBackupAgent(ApplicationInfo appInfo) {
    if (DEBUG_BACKUP)
        Slog.v(TAG_BACKUP, "unbindBackupAgent: " + appInfo);
    if (appInfo == null) {
        Slog.w(TAG, "unbind backup agent for null app");
        return;
    }
    synchronized (this) {
        try {
            if (mBackupAppName == null) {
                Slog.w(TAG, "Unbinding backup agent with no active backup");
                return;
            }
            if (!mBackupAppName.equals(appInfo.packageName)) {
                Slog.e(TAG, "Unbind of " + appInfo + " but is not the current backup target");
                return;
            }
            // Not backing this app up any more; reset its OOM adjustment
            final ProcessRecord proc = mBackupTarget.app;
            updateOomAdjLocked(proc);
            proc.inFullBackup = false;
            // If the app crashed during backup, 'thread' will be null here
            if (proc.thread != null) {
                try {
                    proc.thread.scheduleDestroyBackupAgent(appInfo, compatibilityInfoForPackageLocked(appInfo));
                } catch (Exception e) {
                    Slog.e(TAG, "Exception when unbinding backup agent:");
                    e.printStackTrace();
                }
            }
        } finally {
            mBackupTarget = null;
            mBackupAppName = null;
        }
    }
}
#end_block

#method_before
private void clearProfilerLocked() {
    if (mProfileFd != null) {
        try {
            mProfileFd.close();
        } catch (IOException e) {
        }
    }
    mProfileApp = null;
    mProfileProc = null;
    mProfileFile = null;
    mProfileType = 0;
    mAutoStopProfiler = false;
    mSamplingInterval = 0;
}
#method_after
private void clearProfilerLocked() {
    if (mProfileFd != null) {
        try {
            mProfileFd.close();
        } catch (IOException e) {
        }
    }
    mProfileApp = null;
    mProfileProc = null;
    mProfileFile = null;
    mProfileType = 0;
    mAutoStopProfiler = false;
    mStreamingOutput = false;
    mSamplingInterval = 0;
}
#end_block

#method_before
public static void startMethodTracing(String traceName, FileDescriptor fd, int bufferSize, int flags) {
    VMDebug.startMethodTracing(traceName, fd, bufferSize, flags, false, 0);
}
#method_after
public static void startMethodTracing(String traceName, FileDescriptor fd, int bufferSize, int flags, boolean streamOutput) {
    VMDebug.startMethodTracing(traceName, fd, bufferSize, flags, false, 0, streamOutput);
}
#end_block

#method_before
public void test_constructor() {
    IOException mockIOException = mock(IOException.class);
    DirectoryIteratorException exception = new DirectoryIteratorException(mockIOException);
    assertEquals(mockIOException, exception.getCause());
    // When cause is null.
    try {
        new DirectoryIteratorException(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void test_constructor() {
    IOException ioException = new IOException();
    DirectoryIteratorException exception = new DirectoryIteratorException(ioException);
    assertSame(ioException, exception.getCause());
    try {
        new DirectoryIteratorException(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_constructor$String() {
    String message = "message";
    FileSystemAlreadyExistsException exception = new FileSystemAlreadyExistsException(message);
    assertEquals(message, exception.getMessage());
    // When message is null.
    message = null;
    exception = new FileSystemAlreadyExistsException(message);
    assertEquals(message, exception.getMessage());
}
#method_after
public void test_constructor$String() {
    String message = "message";
    FileSystemAlreadyExistsException exception = new FileSystemAlreadyExistsException(message);
    assertEquals(message, exception.getMessage());
    message = null;
    exception = new FileSystemAlreadyExistsException(message);
    assertEquals(message, exception.getMessage());
}
#end_block

#method_before
public void test_constructor$String() {
    String message = "message";
    ProviderNotFoundException exception = new ProviderNotFoundException(message);
    assertEquals(message, exception.getMessage());
    // When message is null.
    message = null;
    exception = new ProviderNotFoundException(message);
    assertEquals(message, exception.getMessage());
}
#method_after
public void test_constructor$String() {
    String message = "message";
    ProviderNotFoundException exception = new ProviderNotFoundException(message);
    assertEquals(message, exception.getMessage());
    message = null;
    exception = new ProviderNotFoundException(message);
    assertEquals(message, exception.getMessage());
}
#end_block

#method_before
public void test_preVisitDirectory() throws IOException {
    Path mockPath = mock(Path.class);
    BasicFileAttributes mockAttributes = mock(BasicFileAttributes.class);
    SimpleFileVisitor<Path> fileVisitor = new MockSimpleFileVisitor();
    assertEquals(FileVisitResult.CONTINUE, fileVisitor.preVisitDirectory(mockPath, mockAttributes));
    // When path is null.
    try {
        fileVisitor.preVisitDirectory(null, mockAttributes);
        fail();
    } catch (NullPointerException expected) {
    }
    // When attributes are null.
    try {
        fileVisitor.preVisitDirectory(mockPath, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void test_preVisitDirectory() throws IOException {
    Path stubPath = mock(Path.class);
    BasicFileAttributes stubAttributes = mock(BasicFileAttributes.class);
    SimpleFileVisitor<Path> fileVisitor = new TestSimpleFileVisitor();
    assertEquals(FileVisitResult.CONTINUE, fileVisitor.preVisitDirectory(stubPath, stubAttributes));
    try {
        fileVisitor.preVisitDirectory(null, stubAttributes);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        fileVisitor.preVisitDirectory(stubPath, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_postVisitDirectory() throws IOException {
    Path mockPath = mock(Path.class);
    IOException mockIOException = mock(IOException.class);
    SimpleFileVisitor<Path> fileVisitor = new MockSimpleFileVisitor();
    // When IOException is null and Path is not null, it return CONTINUE.
    assertEquals(FileVisitResult.CONTINUE, fileVisitor.postVisitDirectory(mockPath, null));
    // When path is null and ioException is not null.
    try {
        fileVisitor.postVisitDirectory(null, mockIOException);
        fail();
    } catch (NullPointerException expected) {
    }
    // When both path and ioException are not null.
    try {
        fileVisitor.postVisitDirectory(mockPath, mockIOException);
        fail();
    } catch (IOException actual) {
        assertEquals(mockIOException, actual);
    }
}
#method_after
public void test_postVisitDirectory() throws IOException {
    Path stubPath = mock(Path.class);
    IOException ioException = new IOException();
    SimpleFileVisitor<Path> fileVisitor = new TestSimpleFileVisitor();
    assertEquals(FileVisitResult.CONTINUE, fileVisitor.postVisitDirectory(stubPath, null));
    try {
        fileVisitor.postVisitDirectory(null, ioException);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        fileVisitor.postVisitDirectory(stubPath, ioException);
        fail();
    } catch (IOException actual) {
        assertSame(ioException, actual);
    }
}
#end_block

#method_before
public void test_visitFile() throws IOException {
    Path mockPath = mock(Path.class);
    BasicFileAttributes mockAttributes = mock(BasicFileAttributes.class);
    SimpleFileVisitor<Path> fileVisitor = new MockSimpleFileVisitor();
    assertEquals(FileVisitResult.CONTINUE, fileVisitor.visitFile(mockPath, mockAttributes));
    // When path is null.
    try {
        fileVisitor.visitFile(null, mockAttributes);
        fail();
    } catch (NullPointerException expected) {
    }
    // When attributes are null.
    try {
        fileVisitor.visitFile(mockPath, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void test_visitFile() throws IOException {
    Path stubPath = mock(Path.class);
    BasicFileAttributes stubAttributes = mock(BasicFileAttributes.class);
    SimpleFileVisitor<Path> fileVisitor = new TestSimpleFileVisitor();
    assertEquals(FileVisitResult.CONTINUE, fileVisitor.visitFile(stubPath, stubAttributes));
    try {
        fileVisitor.visitFile(null, stubAttributes);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        fileVisitor.visitFile(stubPath, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_visitFileFailed() throws IOException {
    Path mockPath = mock(Path.class);
    IOException mockIOException = mock(IOException.class);
    SimpleFileVisitor<Path> fileVisitor = new MockSimpleFileVisitor();
    // When IOException is null and Path is not null.
    try {
        assertEquals(FileVisitResult.CONTINUE, fileVisitor.visitFileFailed(mockPath, null));
        fail();
    } catch (NullPointerException expected) {
    }
    // When IOException is not null and Path is null.
    try {
        assertEquals(FileVisitResult.CONTINUE, fileVisitor.visitFileFailed(null, mockIOException));
        fail();
    } catch (NullPointerException expected) {
    }
    // When both IOException and Path are not null.
    try {
        assertEquals(FileVisitResult.CONTINUE, fileVisitor.visitFileFailed(mockPath, mockIOException));
        fail();
    } catch (IOException actual) {
        assertEquals(mockIOException, actual);
    }
}
#method_after
public void test_visitFileFailed() throws IOException {
    Path stubPath = mock(Path.class);
    IOException ioException = new IOException();
    SimpleFileVisitor<Path> fileVisitor = new TestSimpleFileVisitor();
    try {
        assertEquals(FileVisitResult.CONTINUE, fileVisitor.visitFileFailed(stubPath, null));
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        assertEquals(FileVisitResult.CONTINUE, fileVisitor.visitFileFailed(null, ioException));
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        assertEquals(FileVisitResult.CONTINUE, fileVisitor.visitFileFailed(stubPath, ioException));
        fail();
    } catch (IOException actual) {
        assertSame(ioException, actual);
    }
}
#end_block

#method_before
public void test_Constructor$String$String$Int() {
    String reason = "reason";
    String input = "input";
    int index = 0;
    InvalidPathException exception = new InvalidPathException(input, reason, index);
    assertEquals(index, exception.getIndex());
    assertEquals(reason, exception.getReason());
    assertEquals(input, exception.getInput());
    // When index is -1;
    index = -1;
    exception = new InvalidPathException(input, reason, index);
    assertEquals(index, exception.getIndex());
    assertEquals(reason, exception.getReason());
    assertEquals(input, exception.getInput());
    // When index is less than -1;
    index = -2;
    try {
        new InvalidPathException(input, reason, index);
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // When input is null, reason is not null and index >= -1.
    try {
        index = 0;
        new InvalidPathException(null, reason, index);
        fail();
    } catch (NullPointerException expected) {
    }
    // When input is null, reason is not null and index < -1.
    try {
        index = -1;
        new InvalidPathException(null, reason, index);
        fail();
    } catch (NullPointerException expected) {
    }
    // When reason is null, input is not null and index >= -1.
    try {
        index = 0;
        new InvalidPathException(input, null, index);
        fail();
    } catch (NullPointerException expected) {
    }
    // When input is not null, reason is null and index < -1.
    try {
        index = -1;
        new InvalidPathException(input, null, index);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void test_Constructor$String$String$Int() {
    String reason = "reason";
    String input = "input";
    int index = 0;
    InvalidPathException exception = new InvalidPathException(input, reason, index);
    assertEquals(index, exception.getIndex());
    assertEquals(reason, exception.getReason());
    assertEquals(input, exception.getInput());
    // Test the case where index = -1.
    index = -1;
    exception = new InvalidPathException(input, reason, index);
    assertEquals(index, exception.getIndex());
    assertEquals(reason, exception.getReason());
    assertEquals(input, exception.getInput());
    // Test the case where index < -1;
    index = -2;
    try {
        new InvalidPathException(input, reason, index);
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // Test the case where input is null, reason is not null and index >= -1.
    try {
        index = 0;
        new InvalidPathException(null, reason, index);
        fail();
    } catch (NullPointerException expected) {
    }
    // Test the case where input is null, reason is not null and index < -1.
    try {
        index = -1;
        new InvalidPathException(null, reason, index);
        fail();
    } catch (NullPointerException expected) {
    }
    // Test the case where reason is null, input is not null and index >= -1.
    try {
        index = 0;
        new InvalidPathException(input, null, index);
        fail();
    } catch (NullPointerException expected) {
    }
    // Test the case where input is not null, reason is null and index < -1.
    try {
        index = -1;
        new InvalidPathException(input, null, index);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_Constructor$String$String() {
    String reason = "reason";
    String input = "input";
    InvalidPathException exception = new InvalidPathException(input, reason);
    assertEquals(-1, exception.getIndex());
    assertEquals(reason, exception.getReason());
    assertEquals(input, exception.getInput());
    // When input is null, reason is not null.
    try {
        new InvalidPathException(null, reason);
        fail();
    } catch (NullPointerException expected) {
    }
    // When reason is null, input is not null.
    try {
        new InvalidPathException(input, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void test_Constructor$String$String() {
    String reason = "reason";
    String input = "input";
    InvalidPathException exception = new InvalidPathException(input, reason);
    assertEquals(-1, exception.getIndex());
    assertEquals(reason, exception.getReason());
    assertEquals(input, exception.getInput());
    // Test the case where input is null and reason is not null.
    try {
        new InvalidPathException(null, reason);
        fail();
    } catch (NullPointerException expected) {
    }
    // Test the case where reason is null and input is not null.
    try {
        new InvalidPathException(input, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (!intent.getAction().equals(A2DP_INTENT))
        return;
    boolean alarm = intent.hasExtra(A2DP_ALARM);
    if (alarm) {
        Log.d(TAG, "Received Alarm broadcast message");
        handleAlarm(intent);
    } else {
        processParameters(intent);
        Log.d(TAG, "Received PMC command message");
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (!intent.getAction().equals(A2DP_INTENT))
        return;
    boolean alarm = intent.hasExtra(A2DP_ALARM);
    if (alarm) {
        Log.d(TAG, "Received Alarm broadcast message");
        handleAlarm(intent);
    } else {
        Log.d(TAG, "Received PMC command message");
        processParameters(intent);
    }
}
#end_block

#method_before
private void processParameters(Intent intent) {
    int codecType = BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID;
    int sampleRate = BluetoothCodecConfig.SAMPLE_RATE_NONE;
    int bitsPerSample = BluetoothCodecConfig.BITS_PER_SAMPLE_NONE;
    // codecSpecific1 is for LDAC quality so far
    long codecSpecific1 = 0;
    int startTime = 0, playTime = 0, idleTime = 0, repetitions = 1;
    String musicUrl;
    String tmpStr;
    Bundle extras = intent.getExtras();
    if (extras == null) {
        Log.e(TAG, "No parameters specified");
        return;
    }
    if (!extras.containsKey("CodecType")) {
        Log.e(TAG, "No Codec Type specified");
        return;
    }
    tmpStr = extras.getString("CodecType");
    Log.d(TAG, "Codec Type= " + tmpStr);
    codecType = Integer.valueOf(tmpStr);
    if (!extras.containsKey("SampleRate")) {
        Log.e(TAG, "No Sample Rate specified");
        return;
    }
    tmpStr = extras.getString("SampleRate");
    Log.d(TAG, "Sample Rate = " + tmpStr);
    sampleRate = Integer.valueOf(tmpStr);
    if (!extras.containsKey("BitsPweSample")) {
        Log.e(TAG, "No BitsPweSample specified");
        return;
    }
    tmpStr = extras.getString("BitsPweSample");
    Log.d(TAG, "BitsPweSample = " + tmpStr);
    bitsPerSample = Integer.valueOf(tmpStr);
    if (!extras.containsKey("LDACPlaybackQuality")) {
        Log.e(TAG, "No LDACPlaybackQuality specified");
    } else {
        tmpStr = extras.getString("LDACPlaybackQuality");
        Log.d(TAG, "LDACPlaybackQuality = " + tmpStr);
        codecSpecific1 = Integer.valueOf(tmpStr);
    }
    if (!extras.containsKey("StartTime")) {
        Log.e(TAG, "No Start Time specified");
        return;
    }
    tmpStr = extras.getString("StartTime");
    Log.d(TAG, "Start Time = " + tmpStr);
    startTime = Integer.valueOf(tmpStr);
    if (!extras.containsKey("PlayTime")) {
        Log.e(TAG, "No Play Time specified");
        return;
    }
    tmpStr = extras.getString("PlayTime");
    Log.d(TAG, "Play Time = " + tmpStr);
    playTime = Integer.valueOf(tmpStr);
    if (!extras.containsKey("IdleTime")) {
        Log.e(TAG, "No Idle Time specified");
    } else {
        tmpStr = extras.getString("IdleTime");
        Log.d(TAG, "Idle Time = " + tmpStr);
        idleTime = Integer.valueOf(tmpStr);
    }
    if (!extras.containsKey("Repetitions")) {
        Log.e(TAG, "No Repetitions specified");
    } else {
        tmpStr = extras.getString("Repetitions");
        Log.d(TAG, "Repetitions = " + tmpStr);
        repetitions = Integer.valueOf(tmpStr);
    }
    if (!extras.containsKey("MusicURL")) {
        Log.e(TAG, "No Music URL specified");
        return;
    }
    musicUrl = extras.getString("MusicURL");
    Log.d(TAG, "Music URL = " + musicUrl);
    if (playTime == 0 || startTime == 0 || musicUrl.isEmpty() || musicUrl == null || codecType == BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID || sampleRate == BluetoothCodecConfig.SAMPLE_RATE_NONE || bitsPerSample == BluetoothCodecConfig.BITS_PER_SAMPLE_NONE) {
        Log.d(TAG, "Invalid paramters");
        return;
    }
    if (prepare(codecType, sampleRate, bitsPerSample, codecSpecific1, playTime, idleTime, repetitions, musicUrl)) {
        startAlarm(startTime, null);
    }
}
#method_after
private void processParameters(Intent intent) {
    int codecType = BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID;
    int sampleRate = BluetoothCodecConfig.SAMPLE_RATE_NONE;
    int bitsPerSample = BluetoothCodecConfig.BITS_PER_SAMPLE_NONE;
    int channelMode = BluetoothCodecConfig.CHANNEL_MODE_STEREO;
    // codecSpecific1 is for LDAC quality so far
    // Other code specific values are not used now
    long codecSpecific1 = 0, codecSpecific2 = 0, codecSpecific3 = 0, codecSpecific4 = 0;
    int startTime = 0, playTime = 0, idleTime = 0, repetitions = 1;
    String musicUrl;
    String tmpStr;
    // Reset these values for each test cases
    // For a baseline case when music is not play but BT is enabled.
    mNotPlay = false;
    // For a baseline case when BT is off but music is playing with speaker is muted
    mMute = false;
    Bundle extras = intent.getExtras();
    if (extras == null) {
        Log.e(TAG, "No parameters specified");
        return;
    }
    if (!extras.containsKey("CodecType")) {
        Log.e(TAG, "No Codec Type specified");
        return;
    }
    tmpStr = extras.getString("CodecType");
    Log.d(TAG, "Codec Type= " + tmpStr);
    codecType = Integer.valueOf(tmpStr);
    if (!extras.containsKey("SampleRate")) {
        Log.e(TAG, "No Sample Rate specified");
        return;
    }
    tmpStr = extras.getString("SampleRate");
    Log.d(TAG, "Sample Rate = " + tmpStr);
    sampleRate = Integer.valueOf(tmpStr);
    if (!extras.containsKey("BitsPerSample")) {
        Log.e(TAG, "No BitsPerSample specified");
        return;
    }
    tmpStr = extras.getString("BitsPerSample");
    Log.d(TAG, "BitsPerSample = " + tmpStr);
    bitsPerSample = Integer.valueOf(tmpStr);
    if (extras.containsKey("ChannelMode")) {
        tmpStr = extras.getString("ChannelMode");
        Log.d(TAG, "ChannelMode = " + tmpStr);
        channelMode = Integer.valueOf(tmpStr);
    }
    if (extras.containsKey("LdacPlaybackQuality")) {
        tmpStr = extras.getString("LdacPlaybackQuality");
        Log.d(TAG, "LdacPlaybackQuality = " + tmpStr);
        codecSpecific1 = Integer.valueOf(tmpStr);
    }
    if (extras.containsKey("CodecSpecific2")) {
        tmpStr = extras.getString("CodecSpecific2");
        Log.d(TAG, "CodecSpecific2 = " + tmpStr);
        codecSpecific1 = Integer.valueOf(tmpStr);
    }
    if (extras.containsKey("CodecSpecific3")) {
        tmpStr = extras.getString("CodecSpecific3");
        Log.d(TAG, "CodecSpecific3 = " + tmpStr);
        codecSpecific1 = Integer.valueOf(tmpStr);
    }
    if (extras.containsKey("CodecSpecific4")) {
        tmpStr = extras.getString("CodecSpecific4");
        Log.d(TAG, "CodecSpecific4 = " + tmpStr);
        codecSpecific1 = Integer.valueOf(tmpStr);
    }
    if (!extras.containsKey("StartTime")) {
        Log.e(TAG, "No Start Time specified");
        return;
    }
    tmpStr = extras.getString("StartTime");
    Log.d(TAG, "Start Time = " + tmpStr);
    startTime = Integer.valueOf(tmpStr);
    if (!extras.containsKey("PlayTime")) {
        Log.e(TAG, "No Play Time specified");
        return;
    }
    tmpStr = extras.getString("PlayTime");
    Log.d(TAG, "Play Time = " + tmpStr);
    playTime = Integer.valueOf(tmpStr);
    if (extras.containsKey("IdleTime")) {
        tmpStr = extras.getString("IdleTime");
        Log.d(TAG, "Idle Time = " + tmpStr);
        idleTime = Integer.valueOf(tmpStr);
    }
    if (extras.containsKey("Repetitions")) {
        tmpStr = extras.getString("Repetitions");
        Log.d(TAG, "Repetitions = " + tmpStr);
        repetitions = Integer.valueOf(tmpStr);
    }
    if (!extras.containsKey("MusicURL")) {
        Log.e(TAG, "No Music URL specified");
        return;
    }
    musicUrl = extras.getString("MusicURL");
    Log.d(TAG, "Music URL = " + musicUrl);
    if (extras.containsKey("NotPlay")) {
        Log.v(TAG, "NotPlay is specified for baseline case of only BT on");
        mNotPlay = true;
    }
    if (extras.containsKey("Mute")) {
        Log.v(TAG, "Mute is specified for BT off baseline case");
        mMute = true;
    }
    if (playTime == 0 || startTime == 0 || musicUrl.isEmpty() || musicUrl == null || codecType == BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID || sampleRate == BluetoothCodecConfig.SAMPLE_RATE_NONE || bitsPerSample == BluetoothCodecConfig.BITS_PER_SAMPLE_NONE) {
        Log.d(TAG, "Invalid paramters");
        return;
    }
    if (prepare(codecType, sampleRate, bitsPerSample, channelMode, codecSpecific1, codecSpecific2, codecSpecific3, codecSpecific4, playTime, idleTime, repetitions, musicUrl)) {
        startAlarm(startTime, null);
    }
}
#end_block

#method_before
private void handleAlarm(Intent intent) {
    int action = intent.getIntExtra(A2DP_ACTION, 0);
    Log.d(TAG, "onReceive() Action: " + action);
    if (action == -1) {
        Log.e(TAG, "Received Alarm with no Action");
        return;
    }
    if (action == START_PLAY) {
        Log.v(TAG, "Before Start Play");
        mPlayer.start();
        mPlayer.setLooping(true);
        startAlarm(mPlayTime, intent);
    } else if (action == PAUSE_PLAY) {
        Log.v(TAG, "Before Pause play");
        mPlayer.pause();
        startAlarm(mIdleTime, intent);
    } else if (action == STOP_PLAY) {
        Log.v(TAG, "Before Stop play");
        mPlayer.stop();
        mPlayer.release();
    } else {
        Log.e(TAG, "Unknown Action");
    }
}
#method_after
private void handleAlarm(Intent intent) {
    int action = intent.getIntExtra(A2DP_ACTION, 0);
    Log.d(TAG, "handleAlarm() Action: " + action);
    if (action == -1) {
        Log.e(TAG, "Received Alarm with no Action");
        return;
    }
    if (mPlayer == null) {
        Log.e(TAG, "Media Player is null");
        return;
    }
    if (mNotPlay) {
        notPlayCase(intent, action);
        return;
    }
    if (action == START_PLAY) {
        Log.v(TAG, "Before Start Play");
        mPlayer.start();
        mPlayer.setLooping(true);
        startAlarm(mPlayTime, intent);
    } else if (action == PAUSE_PLAY) {
        Log.v(TAG, "Before Pause play");
        mPlayer.pause();
        startAlarm(mIdleTime, intent);
    } else if (action == STOP_PLAY) {
        Log.v(TAG, "Before Stop play");
        mPlayer.stop();
        // Release the Media Player
        mPlayer.release();
    } else {
        Log.e(TAG, "Unknown Action");
    }
}
#end_block

#method_before
private boolean prepare(int codecType, int sampleRate, int bitsPerSample, long codecSpecific1, int playTime, int idleTime, int repetitions, String musicURL) {
    ArrayList<BluetoothDevice> results = new ArrayList<BluetoothDevice>();
    for (BluetoothDevice bd : mBluetoothAdapter.getBondedDevices()) {
        if (bd.isConnected()) {
            results.add(bd);
        }
    }
    if (results.isEmpty()) {
        Log.e(TAG, "No device is connected");
        return false;
    }
    Log.d(TAG, "playTime: " + playTime + " idleTime: " + idleTime + " repetitions: " + repetitions);
    // Set the requested Codecs on the device
    setCodecValue(codecType, sampleRate, bitsPerSample, codecSpecific1);
    // Wait here to see if the codec is changed to new value
    for (int i = 0; i < WAIT_SECONDS; i++) {
        if (getCodecValue() == codecType)
            break;
        try {
            Thread.sleep(THOUSAND);
        } catch (InterruptedException e) {
            Log.d(TAG, "Sleep is interrupted");
        }
    }
    if (getCodecValue() != codecType) {
        Log.d(TAG, "Can't set the codec type to " + codecType);
        return false;
    }
    mPlayTime = playTime;
    mIdleTime = idleTime;
    mNumAlarms = repetitions * 2;
    mPlayer = MediaPlayer.create(mContext, Uri.parse(musicURL));
    Log.d(TAG, "Media Player created: " + musicURL);
    return true;
}
#method_after
private boolean prepare(int codecType, int sampleRate, int bitsPerSample, int channelMode, long codecSpecific1, long codecSpecific2, long codecSpecific3, long codecSpecific4, int playTime, int idleTime, int repetitions, String musicURL) {
    ArrayList<BluetoothDevice> results = new ArrayList<BluetoothDevice>();
    // When mMute is specific Bluetooth will be disabled by Python script
    if (!mMute) {
        for (BluetoothDevice bd : mBluetoothAdapter.getBondedDevices()) {
            if (bd.isConnected()) {
                results.add(bd);
            }
        }
        if (results.isEmpty()) {
            Log.e(TAG, "No device is connected");
            return false;
        }
        // Set the requested Codecs on the device
        setCodecValue(codecType, sampleRate, bitsPerSample, channelMode, codecSpecific1, codecSpecific2, codecSpecific3, codecSpecific4);
        // Wait here to see if the codec is changed to new value
        for (int i = 0; i < WAIT_SECONDS; i++) {
            if (verifyCodeConfig(codecType, sampleRate, bitsPerSample, channelMode, codecSpecific1)) {
                break;
            }
            try {
                Thread.sleep(THOUSAND);
            } catch (InterruptedException e) {
                Log.d(TAG, "Sleep is interrupted");
            }
        }
        if (!verifyCodeConfig(codecType, sampleRate, bitsPerSample, channelMode, codecSpecific1)) {
            Log.e(TAG, "Codec config is NOT set correctly");
            return false;
        }
    }
    mPlayTime = playTime;
    mIdleTime = idleTime;
    mNumAlarms = repetitions * 2;
    mPlayer = MediaPlayer.create(mContext, Uri.parse(musicURL));
    if (mPlayer == null) {
        Log.e(TAG, "Failed to create Media Player");
        return false;
    }
    Log.d(TAG, "Media Player created: " + musicURL);
    if (mMute) {
        Log.v(TAG, "Mute Speakers for BT off baseline case");
        mPlayer.setVolume(ZERO_VOLUME, ZERO_VOLUME);
    } else {
        Log.d(TAG, "Set Normal Volume for speakers");
        mPlayer.setVolume(NORMAL_VOLUME, NORMAL_VOLUME);
    }
    return true;
}
#end_block

#method_before
private int getCodecValue() {
    mCodecConfig = null;
    if (mBluetoothA2dp != null) {
        mCodecConfig = mBluetoothA2dp.getCodecConfig();
    }
    if (mCodecConfig == null)
        return -1;
    Log.d(TAG, "Codec Type: " + mCodecConfig.getCodecType() + " 0 - SBC; 1 - AptX; 2 - AptX-HD; 3 - LDAC");
    Log.d(TAG, "Sample Rate: " + mCodecConfig.getSampleRate() + " 2 - 44100; 4 - 48000");
    Log.d(TAG, "Bits Per Sample: " + mCodecConfig.getBitsPerSample());
    Log.d(TAG, "Channel Mode: " + mCodecConfig.getChannelMode());
    return mCodecConfig.getCodecType();
}
#method_after
private BluetoothCodecConfig getCodecValue(boolean printCapabilities) {
    BluetoothCodecStatus codecStatus = null;
    BluetoothCodecConfig codecConfig = null;
    BluetoothCodecConfig[] codecsLocalCapabilities = null;
    BluetoothCodecConfig[] codecsSelectableCapabilities = null;
    // In the mute case BT is off there will be not Codec Info available
    if (mMute)
        return null;
    if (mBluetoothA2dp != null) {
        codecStatus = mBluetoothA2dp.getCodecStatus();
        if (codecStatus != null) {
            codecConfig = codecStatus.getCodecConfig();
            codecsLocalCapabilities = codecStatus.getCodecsLocalCapabilities();
            codecsSelectableCapabilities = codecStatus.getCodecsSelectableCapabilities();
        }
    }
    if (codecConfig == null)
        return null;
    Log.d(TAG, "GetCodecValue: " + codecConfig.toString());
    if (printCapabilities) {
        Log.d(TAG, "Local Codec Capabilities ");
        for (BluetoothCodecConfig config : codecsLocalCapabilities) {
            Log.d(TAG, config.toString());
        }
        Log.d(TAG, "Codec Selectable Capabilities: ");
        for (BluetoothCodecConfig config : codecsSelectableCapabilities) {
            Log.d(TAG, config.toString());
        }
    }
    return codecConfig;
}
#end_block

#method_before
private void setCodecValue(int codecType, int sampleRate, int bitsPerSample, long codecSpecific1) {
    Log.d(TAG, "setCodecValue Codec Type: " + codecType + " sampleRate: " + sampleRate + " bitsPerSample: " + bitsPerSample + " LDAC quality: " + codecSpecific1);
    BluetoothCodecConfig codecConfig = new BluetoothCodecConfig(codecType, BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST, sampleRate, bitsPerSample, BluetoothCodecConfig.CHANNEL_MODE_NONE, codecSpecific1, 0, 0, 0);
    if (mBluetoothA2dp != null) {
        mBluetoothA2dp.setCodecConfigPreference(codecConfig);
    }
}
#method_after
private void setCodecValue(int codecType, int sampleRate, int bitsPerSample, int channelMode, long codecSpecific1, long codecSpecific2, long codecSpecific3, long codecSpecific4) {
    Log.d(TAG, "SetCodecValue: Codec Type: " + codecType + " sampleRate: " + sampleRate + " bitsPerSample: " + bitsPerSample + " Channel Mode: " + channelMode + " LDAC quality: " + codecSpecific1);
    // In the mute case BT is off there will be not Codec Info available
    if (mMute)
        return;
    BluetoothCodecConfig codecConfig = new BluetoothCodecConfig(codecType, BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST, sampleRate, bitsPerSample, channelMode, codecSpecific1, codecSpecific2, codecSpecific3, codecSpecific4);
    if (mBluetoothA2dp != null) {
        Log.d(TAG, "setCodecConfigPreference()");
        mBluetoothA2dp.setCodecConfigPreference(codecConfig);
    } else {
        Log.e(TAG, "mBluetoothA2dp is null. Codec is not set");
    }
}
#end_block

#method_before
@VisibleForTesting
int wifiFeatureMaskFromStaCapabilities(int capabilities) {
    int features = 0;
    for (int i = 0; i < sFeatureCapabilityTranslation.length; i++) {
        if ((capabilities & sFeatureCapabilityTranslation[i][1]) != 0) {
            features |= sFeatureCapabilityTranslation[i][0];
        }
    }
    return features;
}
#method_after
@VisibleForTesting
int wifiFeatureMaskFromStaCapabilities(int capabilities) {
    // Always set this if we have a STA interface
    int features = WifiManager.WIFI_FEATURE_INFRA;
    for (int i = 0; i < sFeatureCapabilityTranslation.length; i++) {
        if ((capabilities & sFeatureCapabilityTranslation[i][1]) != 0) {
            features |= sFeatureCapabilityTranslation[i][0];
        }
    }
    return features;
}
#end_block

#method_before
public int getSupportedFeatureSet() {
    kilroy();
    try {
        final MutableInt feat = new MutableInt(0);
        synchronized (sLock) {
            if (mIWifiStaIface != null) {
                mIWifiStaIface.getCapabilities((status, capabilities) -> {
                    if (status.code != WifiStatusCode.SUCCESS)
                        return;
                    kilroy();
                    feat.value |= wifiFeatureMaskFromStaCapabilities(capabilities);
                });
            }
        }
        return feat.value;
    } catch (RemoteException e) {
        kilroy();
        handleRemoteException(e);
        return 0;
    }
}
#method_after
public int getSupportedFeatureSet() {
    try {
        final MutableInt feat = new MutableInt(0);
        synchronized (sLock) {
            if (mIWifiStaIface != null) {
                mIWifiStaIface.getCapabilities((status, capabilities) -> {
                    if (status.code != WifiStatusCode.SUCCESS)
                        return;
                    feat.value = wifiFeatureMaskFromStaCapabilities(capabilities);
                });
            }
        }
        return feat.value;
    } catch (RemoteException e) {
        handleRemoteException(e);
        return 0;
    }
}
#end_block

#method_before
@Test
@TestInfo(id = "14578843")
public void testPhonePermissions() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 23) {
        SettingsUtil.openItem(instrumentation, "Apps");
        device.findObject(new UiSelector().resourceId(Res.SETTINGS_ADVANCED_OPTION_RES)).clickAndWaitForNewWindow();
        device.findObject(new UiSelector().text("App permissions")).clickAndWaitForNewWindow();
        UiScrollable appPermissionsList = new UiScrollable(new UiSelector().resourceId(Res.ANDROID_CONTENT_RES));
        assertTrue(appPermissionsList.exists());
        appPermissionsList.setAsVerticalList();
        appPermissionsList.scrollIntoView(new UiSelector().text("Phone"));
        device.findObject(new UiSelector().text("Phone")).click();
        UiScrollable phonePermissionsList = new UiScrollable(new UiSelector().resourceId(Res.ANDROID_CONTENT_RES));
        assertTrue(phonePermissionsList.exists());
        phonePermissionsList.setAsVerticalList();
        phonePermissionsList.scrollIntoView(new UiSelector().text("Phone"));
        UiObject phoneToggle = device.findObject(new UiSelector().text("Phone"));
        phoneToggle.click();
        final UiObject denyButton;
        if (testFramework.getApi() == 23) {
            denyButton = device.findObject(new UiSelector().text("Deny"));
        } else
            denyButton = device.findObject(new UiSelector().text("DENY ANYWAY"));
        boolean isSuccess = new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                return denyButton.exists();
            }
        });
        if (!isSuccess)
            phoneToggle.clickAndWaitForNewWindow();
        denyButton.click();
        device.pressHome();
        device.findObject(new UiSelector().text("Phone")).click();
        device.findObject(new UiSelector().description("dial pad")).click();
        for (int i = 0; i < 3; i++) device.findObject(new UiSelector().text("JKL")).click();
        device.findObject(new UiSelector().resourceId(Res.DIALER_BUTTON_RES)).clickAndWaitForNewWindow();
        assertTrue("Did not prompt for lack of Phone permission.", new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                return device.findObject(new UiSelector().text("This application cannot make outgoing calls " + "without the Phone permission.")).exists();
            }
        }));
        SettingsUtil.openItem(instrumentation, "Apps");
        device.findObject(new UiSelector().resourceId(Res.SETTINGS_ADVANCED_OPTION_RES)).clickAndWaitForNewWindow();
        device.findObject(new UiSelector().text("App permissions")).clickAndWaitForNewWindow();
        assertTrue(appPermissionsList.exists());
        appPermissionsList.setAsVerticalList();
        appPermissionsList.scrollIntoView(new UiSelector().text("Phone"));
        device.findObject(new UiSelector().text("Phone")).click();
        assertTrue(phonePermissionsList.exists());
        phonePermissionsList.setAsVerticalList();
        phonePermissionsList.scrollIntoView(new UiSelector().text("Phone"));
        phoneToggle.click();
        device.pressHome();
    }
}
#method_after
@Test
@TestInfo(id = "14578843")
public void testPhonePermissions() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = UiDevice.getInstance(instrumentation);
    if (testFramework.getApi() >= 23) {
        SettingsUtil.openItem(instrumentation, "Apps");
        device.findObject(new UiSelector().resourceId(Res.SETTINGS_ADVANCED_OPTION_RES)).clickAndWaitForNewWindow();
        device.findObject(new UiSelector().text("App permissions")).clickAndWaitForNewWindow();
        UiScrollable appPermissionsList = new UiScrollable(new UiSelector().resourceId(Res.ANDROID_CONTENT_RES));
        assertTrue(appPermissionsList.exists());
        appPermissionsList.setAsVerticalList();
        appPermissionsList.scrollIntoView(new UiSelector().text("Phone"));
        device.findObject(new UiSelector().text("Phone")).click();
        UiScrollable phonePermissionsList = new UiScrollable(new UiSelector().resourceId(Res.ANDROID_CONTENT_RES));
        assertTrue(phonePermissionsList.exists());
        phonePermissionsList.setAsVerticalList();
        phonePermissionsList.scrollIntoView(new UiSelector().text("Phone"));
        UiObject phoneToggle = device.findObject(new UiSelector().text("Phone"));
        phoneToggle.click();
        final UiObject denyButton;
        if (testFramework.getApi() == 23) {
            denyButton = device.findObject(new UiSelector().text("Deny"));
        } else {
            denyButton = device.findObject(new UiSelector().text("DENY ANYWAY"));
        }
        boolean isSuccess = new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                return denyButton.exists();
            }
        });
        if (!isSuccess) {
            phoneToggle.clickAndWaitForNewWindow();
        }
        denyButton.click();
        device.pressHome();
        device.findObject(new UiSelector().text("Phone")).click();
        device.findObject(new UiSelector().description("dial pad")).click();
        for (int i = 0; i < 3; i++) {
            device.findObject(new UiSelector().text("JKL")).click();
        }
        device.findObject(new UiSelector().resourceId(Res.DIALER_BUTTON_RES)).clickAndWaitForNewWindow();
        assertTrue("Did not prompt for lack of Phone permission.", new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws Exception {
                return device.findObject(new UiSelector().text("This application cannot make outgoing calls " + "without the Phone permission.")).exists();
            }
        }));
        SettingsUtil.openItem(instrumentation, "Apps");
        device.findObject(new UiSelector().resourceId(Res.SETTINGS_ADVANCED_OPTION_RES)).clickAndWaitForNewWindow();
        device.findObject(new UiSelector().text("App permissions")).clickAndWaitForNewWindow();
        assertTrue(appPermissionsList.exists());
        appPermissionsList.setAsVerticalList();
        appPermissionsList.scrollIntoView(new UiSelector().text("Phone"));
        device.findObject(new UiSelector().text("Phone")).click();
        assertTrue(phonePermissionsList.exists());
        phonePermissionsList.setAsVerticalList();
        phonePermissionsList.scrollIntoView(new UiSelector().text("Phone"));
        phoneToggle.click();
        device.pressHome();
    }
}
#end_block

#method_before
private static void doAllThreadsTests() {
    Thread[] threads = getAllThreads();
    List<Thread> threadList = new ArrayList<>(Arrays.asList(threads));
    // Filter out JIT thread.
    Iterator<Thread> it = threadList.iterator();
    while (it.hasNext()) {
        Thread t = it.next();
        if (t.getName().equals("Jit thread pool worker thread 0")) {
            it.remove();
            break;
        }
    }
    Collections.sort(threadList, THREAD_COMP);
    System.out.println(threadList);
}
#method_after
private static void doAllThreadsTests() {
    Thread[] threads = getAllThreads();
    List<Thread> threadList = new ArrayList<>(Arrays.asList(threads));
    // Filter out JIT thread. It may or may not be there depending on configuration.
    Iterator<Thread> it = threadList.iterator();
    while (it.hasNext()) {
        Thread t = it.next();
        if (t.getName().startsWith("Jit thread pool worker")) {
            it.remove();
            break;
        }
    }
    Collections.sort(threadList, THREAD_COMP);
    System.out.println(threadList);
}
#end_block

#method_before
public static void printAll(Object[][] stacks) {
    List<String> stringified = new ArrayList<String>(stacks.length);
    for (Object[] stackInfo : stacks) {
        Thread t = (Thread) stackInfo[0];
        String name = (t != null) ? t.getName() : "null";
        String stackSerialization;
        if (name.contains("Daemon")) {
            // Do not print daemon stacks, as they're non-deterministic.
            stackSerialization = "<not printed>";
        } else if (name.contains("Jit thread pool worker thread 0")) {
            // Skip JIT thread pool.
            continue;
        } else {
            StringBuilder sb = new StringBuilder();
            for (String[] stackElement : (String[][]) stackInfo[1]) {
                for (String part : stackElement) {
                    sb.append(' ');
                    sb.append(part);
                }
                sb.append('\n');
            }
            stackSerialization = sb.toString();
        }
        stringified.add(name + "\n" + stackSerialization);
    }
    Collections.sort(stringified);
    for (String s : stringified) {
        System.out.println("---------");
        System.out.println(s);
    }
}
#method_after
public static void printAll(Object[][] stacks) {
    List<String> stringified = new ArrayList<String>(stacks.length);
    for (Object[] stackInfo : stacks) {
        Thread t = (Thread) stackInfo[0];
        String name = (t != null) ? t.getName() : "null";
        String stackSerialization;
        if (name.contains("Daemon")) {
            // Do not print daemon stacks, as they're non-deterministic.
            stackSerialization = "<not printed>";
        } else if (name.startsWith("Jit thread pool worker")) {
            // Skip JIT thread pool. It may or may not be there depending on configuration.
            continue;
        } else {
            StringBuilder sb = new StringBuilder();
            for (String[] stackElement : (String[][]) stackInfo[1]) {
                for (String part : stackElement) {
                    sb.append(' ');
                    sb.append(part);
                }
                sb.append('\n');
            }
            stackSerialization = sb.toString();
        }
        stringified.add(name + "\n" + stackSerialization);
    }
    Collections.sort(stringified);
    for (String s : stringified) {
        System.out.println("---------");
        System.out.println(s);
    }
}
#end_block

#method_before
private static void checkChildren(ThreadGroup tg) {
    Object[] data = getThreadGroupChildren(tg);
    Thread[] threads = (Thread[]) data[0];
    ThreadGroup[] groups = (ThreadGroup[]) data[1];
    List<Thread> threadList = new ArrayList<>(Arrays.asList(threads));
    // Filter out JIT thread.
    Iterator<Thread> it = threadList.iterator();
    while (it.hasNext()) {
        Thread t = it.next();
        if (t.getName().equals("Jit thread pool worker thread 0")) {
            it.remove();
            break;
        }
    }
    Collections.sort(threadList, THREAD_COMP);
    Arrays.sort(groups, THREADGROUP_COMP);
    System.out.println(tg.getName() + ":");
    System.out.println("  " + threadList);
    System.out.println("  " + Arrays.toString(groups));
    if (tg.getParent() != null) {
        checkChildren(tg.getParent());
    }
}
#method_after
private static void checkChildren(ThreadGroup tg) {
    Object[] data = getThreadGroupChildren(tg);
    Thread[] threads = (Thread[]) data[0];
    ThreadGroup[] groups = (ThreadGroup[]) data[1];
    List<Thread> threadList = new ArrayList<>(Arrays.asList(threads));
    // Filter out JIT thread. It may or may not be there depending on configuration.
    Iterator<Thread> it = threadList.iterator();
    while (it.hasNext()) {
        Thread t = it.next();
        if (t.getName().startsWith("Jit thread pool worker")) {
            it.remove();
            break;
        }
    }
    Collections.sort(threadList, THREAD_COMP);
    Arrays.sort(groups, THREADGROUP_COMP);
    System.out.println(tg.getName() + ":");
    System.out.println("  " + threadList);
    System.out.println("  " + Arrays.toString(groups));
    if (tg.getParent() != null) {
        checkChildren(tg.getParent());
    }
}
#end_block

#method_before
public boolean startVendorHal(boolean isStaMode) {
    if (!mHalDeviceManager.start()) {
        Log.e(TAG, "Failed to start the vendor HAL");
        return false;
    }
    if (isStaMode) {
        mIWifiStaIface = mHalDeviceManager.createStaIface(null, null);
        if (mIWifiStaIface == null) {
            Log.e(TAG, "Failed to create STA Iface");
            return false;
        }
    } else {
        mIWifiApIface = mHalDeviceManager.createApIface(null, null);
        if (mIWifiApIface == null) {
            Log.e(TAG, "Failed to create AP Iface");
            return false;
        }
    }
    IWifiIface iface = (IWifiIface) (mIWifiStaIface != null ? mIWifiStaIface : mIWifiApIface);
    mIWifiChip = mHalDeviceManager.getChip(iface);
    if (mIWifiStaIface == null) {
        Log.e(TAG, "Failed to get the chip created for the Iface");
        return false;
    }
    mIWifiRttController = mHalDeviceManager.createRttController(iface);
    if (mIWifiStaIface == null) {
        Log.e(TAG, "Failed to create RTT controller");
        return false;
    }
    Log.i(TAG, "Vendor Hal started successfully");
    return true;
}
#method_after
public boolean startVendorHal(boolean isStaMode) {
    if (!mHalDeviceManager.start()) {
        Log.e(TAG, "Failed to start the vendor HAL");
        return false;
    }
    IWifiIface iface;
    if (isStaMode) {
        mIWifiStaIface = mHalDeviceManager.createStaIface(null, null);
        if (mIWifiStaIface == null) {
            Log.e(TAG, "Failed to create STA Iface. Vendor Hal start failed");
            mHalDeviceManager.stop();
            return false;
        }
        iface = (IWifiIface) mIWifiStaIface;
        mIWifiRttController = mHalDeviceManager.createRttController(iface);
        if (mIWifiRttController == null) {
            Log.e(TAG, "Failed to create RTT controller. Vendor Hal start failed");
            stopVendorHal();
            return false;
        }
        enableLinkLayerStats();
    } else {
        mIWifiApIface = mHalDeviceManager.createApIface(null, null);
        if (mIWifiApIface == null) {
            Log.e(TAG, "Failed to create AP Iface. Vendor Hal start failed");
            stopVendorHal();
            return false;
        }
        iface = (IWifiIface) mIWifiApIface;
    }
    mIWifiChip = mHalDeviceManager.getChip(iface);
    if (mIWifiChip == null) {
        Log.e(TAG, "Failed to get the chip created for the Iface. Vendor Hal start failed");
        stopVendorHal();
        return false;
    }
    Log.i(TAG, "Vendor Hal started successfully");
    return true;
}
#end_block

#method_before
public WifiLinkLayerStats getWifiLinkLayerStats(String iface) {
    kilroy();
    synchronized (sLock) {
        try {
            if (!linkLayerStatsEnabled())
                return null;
            if (iface == null)
                return null;
            WifiLinkLayerStats out = new WifiLinkLayerStats();
            MutableBoolean ok = new MutableBoolean(false);
            kilroy();
            mIWifiStaIface.getLinkLayerStats((status, stats) -> {
                kilroy();
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                // TODO
                out.status = 0;
                // TODO
                out.SSID = null;
                // TODO
                out.BSSID = null;
                out.beacon_rx = stats.iface.beaconRx;
                out.rssi_mgmt = stats.iface.avgRssiMgmt;
                /* WME Best Effort Access Category */
                out.rxmpdu_be = stats.iface.wmeBePktStats.rxMpdu;
                out.txmpdu_be = stats.iface.wmeBePktStats.txMpdu;
                out.lostmpdu_be = stats.iface.wmeBePktStats.lostMpdu;
                out.retries_be = stats.iface.wmeBePktStats.retries;
                /* WME Background Access Category */
                out.rxmpdu_bk = stats.iface.wmeBkPktStats.rxMpdu;
                out.txmpdu_bk = stats.iface.wmeBkPktStats.txMpdu;
                out.lostmpdu_bk = stats.iface.wmeBkPktStats.lostMpdu;
                out.retries_bk = stats.iface.wmeBkPktStats.retries;
                /* WME Video Access Category */
                out.rxmpdu_vi = stats.iface.wmeViPktStats.rxMpdu;
                out.txmpdu_vi = stats.iface.wmeViPktStats.txMpdu;
                out.lostmpdu_vi = stats.iface.wmeViPktStats.lostMpdu;
                out.retries_vi = stats.iface.wmeViPktStats.retries;
                /* WME Voice Access Category */
                out.rxmpdu_vo = stats.iface.wmeVoPktStats.rxMpdu;
                out.txmpdu_vo = stats.iface.wmeVoPktStats.txMpdu;
                out.lostmpdu_vo = stats.iface.wmeVoPktStats.lostMpdu;
                out.retries_vo = stats.iface.wmeVoPktStats.retries;
                out.on_time = stats.radio.onTimeInMs;
                out.tx_time = stats.radio.txTimeInMs;
                out.tx_time_per_level = new int[stats.radio.txTimeInMsPerLevel.size()];
                for (int i = 0; i < out.tx_time_per_level.length; i++) {
                    out.tx_time_per_level[i] = stats.radio.txTimeInMsPerLevel.get(i);
                }
                out.rx_time = stats.radio.rxTimeInMs;
                out.on_time_scan = stats.radio.onTimeInMsForScan;
                kilroy();
                ok.value = true;
            });
            return ok.value ? out : null;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return null;
        }
    }
}
#method_after
public WifiLinkLayerStats getWifiLinkLayerStats() {
    kilroy();
    synchronized (sLock) {
        try {
            if (mIWifiStaIface == null)
                return null;
            kilroy();
            WifiLinkLayerStats out = new WifiLinkLayerStats();
            MutableBoolean ok = new MutableBoolean(false);
            kilroy();
            mIWifiStaIface.getLinkLayerStats((status, stats) -> {
                kilroy();
                if (status.code != WifiStatusCode.SUCCESS)
                    return;
                // TODO
                out.status = 0;
                // TODO
                out.SSID = null;
                // TODO
                out.BSSID = null;
                out.beacon_rx = stats.iface.beaconRx;
                out.rssi_mgmt = stats.iface.avgRssiMgmt;
                /* WME Best Effort Access Category */
                out.rxmpdu_be = stats.iface.wmeBePktStats.rxMpdu;
                out.txmpdu_be = stats.iface.wmeBePktStats.txMpdu;
                out.lostmpdu_be = stats.iface.wmeBePktStats.lostMpdu;
                out.retries_be = stats.iface.wmeBePktStats.retries;
                /* WME Background Access Category */
                out.rxmpdu_bk = stats.iface.wmeBkPktStats.rxMpdu;
                out.txmpdu_bk = stats.iface.wmeBkPktStats.txMpdu;
                out.lostmpdu_bk = stats.iface.wmeBkPktStats.lostMpdu;
                out.retries_bk = stats.iface.wmeBkPktStats.retries;
                /* WME Video Access Category */
                out.rxmpdu_vi = stats.iface.wmeViPktStats.rxMpdu;
                out.txmpdu_vi = stats.iface.wmeViPktStats.txMpdu;
                out.lostmpdu_vi = stats.iface.wmeViPktStats.lostMpdu;
                out.retries_vi = stats.iface.wmeViPktStats.retries;
                /* WME Voice Access Category */
                out.rxmpdu_vo = stats.iface.wmeVoPktStats.rxMpdu;
                out.txmpdu_vo = stats.iface.wmeVoPktStats.txMpdu;
                out.lostmpdu_vo = stats.iface.wmeVoPktStats.lostMpdu;
                out.retries_vo = stats.iface.wmeVoPktStats.retries;
                out.on_time = stats.radio.onTimeInMs;
                out.tx_time = stats.radio.txTimeInMs;
                out.tx_time_per_level = new int[stats.radio.txTimeInMsPerLevel.size()];
                for (int i = 0; i < out.tx_time_per_level.length; i++) {
                    out.tx_time_per_level[i] = stats.radio.txTimeInMsPerLevel.get(i);
                }
                out.rx_time = stats.radio.rxTimeInMs;
                out.on_time_scan = stats.radio.onTimeInMsForScan;
                kilroy();
                ok.value = true;
            });
            return ok.value ? out : null;
        } catch (RemoteException e) {
            kilroy();
            handleRemoteException(e);
            return null;
        }
    }
}
#end_block

#method_before
private void parseUnquotedMacStrToByteArray(String macWithColons, byte[] mac) {
    String[] macAddrStr = macWithColons.split(":");
    for (int i = 0; i < 6; i++) {
        Integer hexVal = Integer.parseInt(macAddrStr[i], 16);
        mac[i] = hexVal.byteValue();
    }
}
#method_after
@VisibleForTesting
void parseUnquotedMacStrToByteArray(String macWithColons, byte[] mac) {
    String[] macAddrStr = macWithColons.split(":");
    for (int i = 0; i < 6; i++) {
        Integer hexVal = Integer.parseInt(macAddrStr[i], 16);
        mac[i] = hexVal.byteValue();
    }
}
#end_block

#method_before
@Override
public void onStatusChanged() {
    Log.i(TAG, "Device Manager onStatusChanged. isReady(): " + mHalDeviceManager.isReady() + ", isStarted(): " + mHalDeviceManager.isStarted());
    // Reset all our cached handles.
    if (!mHalDeviceManager.isReady() || !mHalDeviceManager.isStarted()) {
        mIWifiChip = null;
        mIWifiStaIface = null;
        mIWifiApIface = null;
        mIWifiRttController = null;
        mDriverDescription = null;
        mFirmwareDescription = null;
    }
}
#method_after
@Override
public void onStatusChanged() {
    boolean isReady = mHalDeviceManager.isReady();
    boolean isStarted = mHalDeviceManager.isStarted();
    Log.i(TAG, "Device Manager onStatusChanged. isReady(): " + isReady + ", isStarted(): " + isStarted);
    // Reset all our cached handles.
    if (!isReady || !isStarted) {
        kilroy();
        mIWifiChip = null;
        mIWifiStaIface = null;
        mIWifiApIface = null;
        mIWifiRttController = null;
        mDriverDescription = null;
        mFirmwareDescription = null;
    }
}
#end_block

#method_before
public void test_shutdownOutput() throws IOException {
    try (SocketChannel channel1 = SocketChannel.open();
        ServerSocket server1 = new ServerSocket(0)) {
        InetSocketAddress localAddr1 = new InetSocketAddress("127.0.0.1", server1.getLocalPort());
        // initialize write content
        ByteBuffer writeContent = ByteBuffer.allocate(10);
        for (int i = 0; i < 10; i++) {
            writeContent.put((byte) i);
        }
        writeContent.flip();
        try {
            channel1.shutdownOutput();
            fail();
        } catch (NotYetConnectedException expected) {
        }
        // establish connection
        channel1.connect(localAddr1);
        channel1.shutdownOutput();
        try {
            channel1.write(writeContent);
            fail();
        } catch (ClosedChannelException expected) {
        }
        channel1.close();
        try {
            channel1.shutdownOutput();
            fail();
        } catch (ClosedChannelException expected) {
        }
    }
}
#method_after
public void test_shutdownOutput() throws IOException {
    try (SocketChannel channel1 = SocketChannel.open();
        ServerSocket server1 = new ServerSocket(0)) {
        InetSocketAddress localAddr1 = new InetSocketAddress("127.0.0.1", server1.getLocalPort());
        // initialize write content
        ByteBuffer writeContent = ByteBuffer.allocate(10);
        for (int i = 0; i < 10; i++) {
            writeContent.put((byte) i);
        }
        writeContent.flip();
        try {
            channel1.shutdownOutput();
            fail();
        } catch (NotYetConnectedException expected) {
        }
        // establish connection
        channel1.connect(localAddr1);
        channel1.shutdownOutput();
        try {
            channel1.write(writeContent);
            fail();
        } catch (ClosedChannelException expected) {
        }
        // Closing the channel early to verify that is CloseChannelException thrown by
        // #shutdownOutput.
        channel1.close();
        try {
            channel1.shutdownOutput();
            fail();
        } catch (ClosedChannelException expected) {
        }
    }
}
#end_block

#method_before
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#method_after
protected void finalize() throws Throwable {
    try {
        if (guard != null) {
            guard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}
#end_block

#method_before
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#method_after
protected void finalize() throws Throwable {
    try {
        if (guard != null) {
            guard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}
#end_block

#method_before
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#method_after
protected void finalize() throws Throwable {
    try {
        if (guard != null) {
            guard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}
#end_block

#method_before
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#method_after
protected void finalize() throws Throwable {
    try {
        if (guard != null) {
            guard.warnIfOpen();
        }
        close();
    } finally {
        super.finalize();
    }
}
#end_block

#method_before
protected void finalize() throws IOException {
    guard.warnIfOpen();
    // fd is null if constructor threw exception
    if (fd != null)
        close();
}
#method_after
protected void finalize() throws Throwable {
    try {
        guard.warnIfOpen();
        // fd is null if constructor threw exception
        if (fd != null)
            close();
    } finally {
        super.finalize();
    }
}
#end_block

#method_before
public synchronized Set<Service> getServices() {
    checkInitialized();
    if (legacyChanged || servicesChanged) {
        serviceSet = null;
    }
    if (serviceSet == null) {
        ensureLegacyParsed();
        Set<Service> set = new LinkedHashSet<>();
        if (serviceMap != null) {
            set.addAll(serviceMap.values());
        }
        if (legacyMap != null) {
            set.addAll(legacyMap.values());
        }
        serviceSet = Collections.unmodifiableSet(set);
        servicesChanged = false;
    }
    return serviceSet;
}
#method_after
// END ANDROID-CHANGED
public synchronized Set<Service> getServices() {
    checkInitialized();
    if (legacyChanged || servicesChanged) {
        serviceSet = null;
    }
    if (serviceSet == null) {
        ensureLegacyParsed();
        Set<Service> set = new LinkedHashSet<>();
        if (serviceMap != null) {
            set.addAll(serviceMap.values());
        }
        if (legacyMap != null) {
            set.addAll(legacyMap.values());
        }
        serviceSet = Collections.unmodifiableSet(set);
        servicesChanged = false;
    }
    return serviceSet;
}
#end_block

#method_before
private NetworkUpdateResult verifyAddPasspointNetworkToWifiConfigManager(WifiConfiguration configuration) throws Exception {
    NetworkUpdateResult result = addNetworkToWifiConfigManager(configuration);
    assertTrue(result.getNetworkId() != WifiConfiguration.INVALID_NETWORK_ID);
    assertTrue(result.isNewNetwork());
    assertTrue(result.hasIpChanged());
    assertTrue(result.hasProxyChanged());
    verifyNetworkAddBroadcast(configuration);
    // Ensure that the write was not invoked for Passpoint network addition.
    mContextConfigStoreMockOrder.verify(mWifiConfigStore, never()).write(anyBoolean(), any(WifiConfigStoreData.class));
    return result;
}
#method_after
private NetworkUpdateResult verifyAddPasspointNetworkToWifiConfigManager(WifiConfiguration configuration) throws Exception {
    NetworkUpdateResult result = addNetworkToWifiConfigManager(configuration);
    assertTrue(result.getNetworkId() != WifiConfiguration.INVALID_NETWORK_ID);
    assertTrue(result.isNewNetwork());
    assertTrue(result.hasIpChanged());
    assertTrue(result.hasProxyChanged());
    // Verify keys are not being installed.
    verify(mWifiKeyStore, never()).updateNetworkKeys(any(WifiConfiguration.class), any(WifiConfiguration.class));
    verifyNetworkAddBroadcast(configuration);
    // Ensure that the write was not invoked for Passpoint network addition.
    mContextConfigStoreMockOrder.verify(mWifiConfigStore, never()).write(anyBoolean(), any(WifiConfigStoreData.class));
    return result;
}
#end_block

#method_before
private void verifyRemovePasspointNetworkFromWifiConfigManager(WifiConfiguration configuration) throws Exception {
    assertTrue(mWifiConfigManager.removeNetwork(configuration.networkId, TEST_CREATOR_UID));
    verifyNetworkRemoveBroadcast(configuration);
    // Ensure that the write was not invoked for Passpoint network remove.
    mContextConfigStoreMockOrder.verify(mWifiConfigStore, never()).write(anyBoolean(), any(WifiConfigStoreData.class));
}
#method_after
private void verifyRemovePasspointNetworkFromWifiConfigManager(WifiConfiguration configuration) throws Exception {
    assertTrue(mWifiConfigManager.removeNetwork(configuration.networkId, TEST_CREATOR_UID));
    // Verify keys are not being removed.
    verify(mWifiKeyStore, never()).removeKeys(any(WifiEnterpriseConfig.class));
    verifyNetworkRemoveBroadcast(configuration);
    // Ensure that the write was not invoked for Passpoint network remove.
    mContextConfigStoreMockOrder.verify(mWifiConfigStore, never()).write(anyBoolean(), any(WifiConfigStoreData.class));
}
#end_block

#method_before
public boolean initialize() {
    Log.i(TAG, "Registering SupplicantHidl service ready callback.");
    synchronized (mLock) {
        mISupplicantHal = null;
        mISupplicantStaIfaceHal = null;
        mISupplicantP2pIfaceHal = null;
        try {
            final IServiceManager serviceManager = getServiceManagerMockable();
            if (serviceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!serviceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                    if (!getSupplicantService() || !getSupplicantStaIface() || !getSupplicantP2pIface()) {
                        Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                        supplicantServiceDiedHandler();
                    } else {
                        Log.i(TAG, "Completed initialization of ISupplicant interfaces.");
                        initializationComplete = true;
                    }
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!serviceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
        }
        mHalDeviceManager.initialize();
        mHalDeviceManager.registerStatusListener(mHalDeviceManagerStatusCallbacks, mWifiStateMachineHandlerThread.getLooper());
        return true;
    }
}
#method_after
public boolean initialize() {
    if (DBG)
        Log.i(TAG, "Registering ISupplicant service ready callback.");
    synchronized (mLock) {
        mISupplicant = null;
        mISupplicantStaIface = null;
        if (mIServiceManager != null) {
            // don't register another.
            return true;
        }
        try {
            mIServiceManager = getServiceManagerMockable();
            if (mIServiceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!mIServiceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                    // Will need to register a new ServiceNotification
                    mIServiceManager = null;
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    synchronized (mLock) {
                        if (DBG) {
                            Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                        }
                        if (!initSupplicantService() || !initSupplicantStaIface()) {
                            Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                            supplicantServiceDiedHandler();
                        } else {
                            Log.i(TAG, "Completed initialization of ISupplicant interfaces.");
                        }
                    }
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!mIServiceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                // Will need to register a new ServiceNotification
                mIServiceManager = null;
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
            supplicantServiceDiedHandler();
        }
        return true;
    }
}
#end_block

#method_before
void supplicantServiceDiedHandler() {
    resetHandles();
}
#method_after
private void supplicantServiceDiedHandler() {
    synchronized (mLock) {
        mISupplicant = null;
        mISupplicantStaIface = null;
    }
}
#end_block

#method_before
protected IServiceManager getServiceManagerMockable() throws RemoteException {
    return IServiceManager.getService("manager");
}
#method_after
protected IServiceManager getServiceManagerMockable() throws RemoteException {
    return IServiceManager.getService(SERVICE_MANAGER_NAME);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mObject = new Object();
    mTestLooper = new TestLooper();
    setupIfaceInfos();
    MockitoAnnotations.initMocks(this);
    when(mServiceManagerMock.linkToDeath(any(IHwBinder.DeathRecipient.class), anyLong())).thenReturn(true);
    when(mServiceManagerMock.registerForNotifications(anyString(), anyString(), any(IServiceNotification.Stub.class))).thenReturn(true);
    when(mHandlerThread.getLooper()).thenReturn(mTestLooper.getLooper());
    mDut = new WifiSupplicantHalSpy(mHalDeviceManager, mHandlerThread, mSupplicantStaIfaceHal, mObject);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mTestLooper = new TestLooper();
    mStatusSuccess = createSupplicantStatus(SupplicantStatusCode.SUCCESS);
    mStaIface = createIfaceInfo(IfaceType.STA, "wlan0");
    mP2pIface = createIfaceInfo(IfaceType.P2P, "p2p0");
    mIfaceInfoList = new ArrayList<>();
    mIfaceInfoList.add(mStaIface);
    mIfaceInfoList.add(mP2pIface);
    when(mServiceManagerMock.linkToDeath(any(IHwBinder.DeathRecipient.class), anyLong())).thenReturn(true);
    when(mServiceManagerMock.registerForNotifications(anyString(), anyString(), any(IServiceNotification.Stub.class))).thenReturn(true);
    when(mHandlerThread.getLooper()).thenReturn(mTestLooper.getLooper());
    mDut = new WifiSupplicantHalSpy(mHandlerThread);
}
#end_block

#method_before
private void executeAndValidateInitializationSequence(boolean causeRemoteException, boolean getZeroInterfaces, boolean getNullInterface) throws Exception {
    boolean shouldSucceed = !causeRemoteException && !getZeroInterfaces && !getNullInterface;
    // Setup callback mock answers
    ArrayList<ISupplicant.IfaceInfo> interfaces;
    if (getZeroInterfaces) {
        interfaces = new ArrayList<>();
    } else {
        interfaces = mIfaceInfoList;
    }
    doAnswer(new GetListInterfacesAnswer(interfaces)).when(mISupplicantMock).listInterfaces(any(ISupplicant.listInterfacesCallback.class));
    if (causeRemoteException) {
        doThrow(new RemoteException("Some error!!!")).when(mISupplicantMock).getInterface(any(ISupplicant.IfaceInfo.class), any(ISupplicant.getInterfaceCallback.class));
    } else {
        doAnswer(new GetGetInterfaceAnswer(getNullInterface)).when(mISupplicantMock).getInterface(any(ISupplicant.IfaceInfo.class), any(ISupplicant.getInterfaceCallback.class));
    }
    mInOrder = inOrder(mServiceManagerMock, mISupplicantMock, mSupplicantStaIfaceHal);
    // Initialize WifiSupplicantHal, should call serviceManager.registerForNotifications
    assertTrue(mDut.initialize());
    // verify: service manager initialization sequence
    mInOrder.verify(mServiceManagerMock).linkToDeath(any(IHwBinder.DeathRecipient.class), anyLong());
    mInOrder.verify(mServiceManagerMock).registerForNotifications(eq(ISupplicant.kInterfaceName), eq(""), mServiceNotificationCaptor.capture());
    // act: cause the onRegistration(...) callback to execute
    mServiceNotificationCaptor.getValue().onRegistration(ISupplicant.kInterfaceName, "", true);
    assertTrue(mDut.initializationComplete == shouldSucceed);
    // verify: listInterfaces is called
    mInOrder.verify(mISupplicantMock).listInterfaces(any(ISupplicant.listInterfacesCallback.class));
    if (!getZeroInterfaces) {
        mInOrder.verify(mISupplicantMock).getInterface(any(ISupplicant.IfaceInfo.class), any(ISupplicant.getInterfaceCallback.class));
        if (!causeRemoteException && !getNullInterface) {
            mInOrder.verify(mSupplicantStaIfaceHal).initialize(any(ISupplicantStaIface.class), any(WifiSupplicantHal.ServiceDiedListener.class));
            mInOrder.verify(mISupplicantMock).getInterface(any(ISupplicant.IfaceInfo.class), any(ISupplicant.getInterfaceCallback.class));
            return;
        }
    }
    mInOrder.verify(mSupplicantStaIfaceHal).reset();
}
#method_after
private void executeAndValidateInitializationSequence(boolean causeRemoteException, boolean getZeroInterfaces, boolean getNullInterface) throws Exception {
    boolean shouldSucceed = !causeRemoteException && !getZeroInterfaces && !getNullInterface;
    // Setup callback mock answers
    ArrayList<ISupplicant.IfaceInfo> interfaces;
    if (getZeroInterfaces) {
        interfaces = new ArrayList<>();
    } else {
        interfaces = mIfaceInfoList;
    }
    doAnswer(new GetListInterfacesAnswer(interfaces)).when(mISupplicantMock).listInterfaces(any(ISupplicant.listInterfacesCallback.class));
    if (causeRemoteException) {
        doThrow(new RemoteException("Some error!!!")).when(mISupplicantMock).getInterface(any(ISupplicant.IfaceInfo.class), any(ISupplicant.getInterfaceCallback.class));
    } else {
        doAnswer(new GetGetInterfaceAnswer(getNullInterface)).when(mISupplicantMock).getInterface(any(ISupplicant.IfaceInfo.class), any(ISupplicant.getInterfaceCallback.class));
    }
    mInOrder = inOrder(mServiceManagerMock, mISupplicantMock);
    // Initialize WifiSupplicantHal, should call serviceManager.registerForNotifications
    assertTrue(mDut.initialize());
    // verify: service manager initialization sequence
    mInOrder.verify(mServiceManagerMock).linkToDeath(any(IHwBinder.DeathRecipient.class), anyLong());
    mInOrder.verify(mServiceManagerMock).registerForNotifications(eq(ISupplicant.kInterfaceName), eq(""), mServiceNotificationCaptor.capture());
    // act: cause the onRegistration(...) callback to execute
    mServiceNotificationCaptor.getValue().onRegistration(ISupplicant.kInterfaceName, "", true);
    assertTrue(mDut.isInitializationComplete() == shouldSucceed);
    // verify: listInterfaces is called
    mInOrder.verify(mISupplicantMock).listInterfaces(any(ISupplicant.listInterfacesCallback.class));
    if (!getZeroInterfaces) {
        mInOrder.verify(mISupplicantMock).getInterface(any(ISupplicant.IfaceInfo.class), any(ISupplicant.getInterfaceCallback.class));
    }
}
#end_block

#method_before
public static void doTest(Transform t) {
    final TestWatcher reporter = new TestWatcher();
    Method say_hi_method;
    Method private_say_hi_method;
    // Figure out if we can even JIT at all.
    final boolean has_jit = hasJit();
    try {
        say_hi_method = Transform.class.getDeclaredMethod("sayHi", int.class, Consumer.class, Runnable.class);
        private_say_hi_method = Transform.class.getDeclaredMethod("privateSayHi", int.class, Consumer.class, Runnable.class);
    } catch (Exception e) {
        System.out.println("Unable to find methods!");
        e.printStackTrace();
        return;
    }
    // Makes sure the stack is the way we want it for the test and does the redefinition. It will
    // set the retry boolean to true if we need to go around again due to a bad stack.
    Runnable do_redefinition = () -> {
        if (has_jit && (Main.isInterpretedFunction(say_hi_method, true) || Main.isInterpretedFunction(private_say_hi_method, true))) {
            // Try again. We are not running the right jitted methods/cannot redefine them now.
            retry = true;
        } else {
            // Actually do the redefinition. The stack looks good.
            retry = false;
            reporter.accept("transforming calling function");
            doCommonClassRedefinition(Transform.class, CLASS_BYTES, DEX_BYTES);
        }
    };
    do {
        // Run ensureJitCompiled here since it might get GCd
        ensureJitCompiled(Transform.class, "sayHi");
        ensureJitCompiled(Transform.class, "privateSayHi");
        // Clear output.
        reporter.clear();
        t.sayHi(2, reporter, () -> {
            reporter.accept("Not doing anything here");
        });
        t.sayHi(2, reporter, do_redefinition);
        t.sayHi(2, reporter, () -> {
            reporter.accept("Not doing anything here");
        });
    } while (retry);
    System.out.println(reporter.getOutput());
}
#method_after
public static void doTest(Transform t) {
    final TestWatcher reporter = new TestWatcher();
    Method say_hi_method;
    Method private_say_hi_method;
    // Figure out if we can even JIT at all.
    final boolean has_jit = hasJit();
    try {
        say_hi_method = Transform.class.getDeclaredMethod("sayHi", int.class, Consumer.class, Runnable.class);
        private_say_hi_method = Transform.class.getDeclaredMethod("privateSayHi", int.class, Consumer.class, Runnable.class);
    } catch (Exception e) {
        System.out.println("Unable to find methods!");
        e.printStackTrace();
        return;
    }
    // Makes sure the stack is the way we want it for the test and does the redefinition. It will
    // set the retry boolean to true if we need to go around again due to jit code being GCd.
    Runnable do_redefinition = () -> {
        if (has_jit && (Main.isInterpretedFunction(say_hi_method, true) || Main.isInterpretedFunction(private_say_hi_method, true))) {
            // Try again. We are not running the right jitted methods/cannot redefine them now.
            retry = true;
        } else {
            // Actually do the redefinition. The stack looks good.
            retry = false;
            reporter.accept("transforming calling function");
            doCommonClassRedefinition(Transform.class, CLASS_BYTES, DEX_BYTES);
        }
    };
    do {
        // Run ensureJitCompiled here since it might get GCd
        ensureJitCompiled(Transform.class, "sayHi");
        ensureJitCompiled(Transform.class, "privateSayHi");
        // Clear output.
        reporter.clear();
        t.sayHi(2, reporter, () -> {
            reporter.accept("Not doing anything here");
        });
        t.sayHi(2, reporter, do_redefinition);
        t.sayHi(2, reporter, () -> {
            reporter.accept("Not doing anything here");
        });
    } while (retry);
    System.out.println(reporter.getOutput());
}
#end_block

#method_before
public static void doTest(Transform t) {
    final TestWatcher reporter = new TestWatcher();
    Method say_hi_method;
    // Figure out if we can even JIT at all.
    final boolean has_jit = hasJit();
    try {
        say_hi_method = Transform.class.getDeclaredMethod("sayHi", int.class, Consumer.class, Runnable.class);
    } catch (Exception e) {
        System.out.println("Unable to find methods!");
        e.printStackTrace();
        return;
    }
    // Makes sure the stack is the way we want it for the test and does the redefinition. It will
    // set the retry boolean to true if we need to go around again due to a bad stack.
    Runnable do_redefinition = () -> {
        if (has_jit && Main.isInterpretedFunction(say_hi_method, true)) {
            // Try again. We are not running the right jitted methods/cannot redefine them now.
            retry = true;
        } else {
            // Actually do the redefinition. The stack looks good.
            retry = false;
            reporter.accept("transforming calling function");
            doCommonClassRedefinition(Transform.class, CLASS_BYTES, DEX_BYTES);
        }
    };
    do {
        // Run ensureJitCompiled here since it might get GCd
        ensureJitCompiled(Transform.class, "sayHi");
        // Clear output.
        reporter.clear();
        t.sayHi(2, reporter, () -> {
            reporter.accept("Not doing anything here");
        });
        t.sayHi(2, reporter, do_redefinition);
        t.sayHi(2, reporter, () -> {
            reporter.accept("Not doing anything here");
        });
    } while (retry);
    System.out.println(reporter.getOutput());
}
#method_after
public static void doTest(Transform t) {
    final TestWatcher reporter = new TestWatcher();
    Method say_hi_method;
    // Figure out if we can even JIT at all.
    final boolean has_jit = hasJit();
    try {
        say_hi_method = Transform.class.getDeclaredMethod("sayHi", int.class, Consumer.class, Runnable.class);
    } catch (Exception e) {
        System.out.println("Unable to find methods!");
        e.printStackTrace();
        return;
    }
    // Makes sure the stack is the way we want it for the test and does the redefinition. It will
    // set the retry boolean to true if we need to go around again due to jit code being GCd.
    Runnable do_redefinition = () -> {
        if (has_jit && Main.isInterpretedFunction(say_hi_method, true)) {
            // Try again. We are not running the right jitted methods/cannot redefine them now.
            retry = true;
        } else {
            // Actually do the redefinition. The stack looks good.
            retry = false;
            reporter.accept("transforming calling function");
            doCommonClassRedefinition(Transform.class, CLASS_BYTES, DEX_BYTES);
        }
    };
    do {
        // Run ensureJitCompiled here since it might get GCd
        ensureJitCompiled(Transform.class, "sayHi");
        // Clear output.
        reporter.clear();
        t.sayHi(2, reporter, () -> {
            reporter.accept("Not doing anything here");
        });
        t.sayHi(2, reporter, do_redefinition);
        t.sayHi(2, reporter, () -> {
            reporter.accept("Not doing anything here");
        });
    } while (retry);
    System.out.println(reporter.getOutput());
}
#end_block

#method_before
static RILRequest obtain(int request, Message result) {
    RILRequest rr = null;
    synchronized (sPoolSync) {
        if (sPool != null) {
            rr = sPool;
            sPool = rr.mNext;
            rr.mNext = null;
            sPoolSize--;
        }
    }
    if (rr == null) {
        rr = new RILRequest();
    }
    rr.mSerial = sNextSerial.getAndIncrement();
    rr.mRequest = request;
    rr.mResult = result;
    rr.mParcel = Parcel.obtain();
    rr.mWakeLockType = RIL.INVALID_WAKELOCK;
    if (result != null && result.getTarget() == null) {
        throw new NullPointerException("Message target must not be null");
    }
    // first elements in any RIL Parcel
    rr.mParcel.writeInt(request);
    rr.mParcel.writeInt(rr.mSerial);
    return rr;
}
#method_after
static RILRequest obtain(int request, Message result) {
    RILRequest rr = null;
    synchronized (sPoolSync) {
        if (sPool != null) {
            rr = sPool;
            sPool = rr.mNext;
            rr.mNext = null;
            sPoolSize--;
        }
    }
    if (rr == null) {
        rr = new RILRequest();
    }
    rr.mSerial = sNextSerial.getAndIncrement();
    rr.mRequest = request;
    rr.mResult = result;
    rr.mParcel = Parcel.obtain();
    rr.mWakeLockType = RIL.INVALID_WAKELOCK;
    rr.mStartTimeMs = SystemClock.elapsedRealtime();
    if (result != null && result.getTarget() == null) {
        throw new NullPointerException("Message target must not be null");
    }
    // first elements in any RIL Parcel
    rr.mParcel.writeInt(request);
    rr.mParcel.writeInt(rr.mSerial);
    return rr;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    RILRequest rr = (RILRequest) (msg.obj);
    RILRequest req = null;
    switch(msg.what) {
        case EVENT_SEND:
        case EVENT_SEND_ACK:
            try {
                LocalSocket s;
                s = mSocket;
                if (s == null) {
                    rr.onError(RADIO_NOT_AVAILABLE, null);
                    decrementWakeLock(rr);
                    rr.release();
                    return;
                }
                // Acks should not be stored in list before sending
                if (msg.what != EVENT_SEND_ACK) {
                    synchronized (mRequestList) {
                        mRequestList.append(rr.mSerial, rr);
                    }
                }
                byte[] data;
                data = rr.mParcel.marshall();
                rr.mParcel.recycle();
                rr.mParcel = null;
                if (data.length > RIL_MAX_COMMAND_BYTES) {
                    throw new RuntimeException("Parcel larger than max bytes allowed! " + data.length);
                }
                // parcel length in big endian
                dataLength[0] = dataLength[1] = 0;
                dataLength[2] = (byte) ((data.length >> 8) & 0xff);
                dataLength[3] = (byte) ((data.length) & 0xff);
                // Rlog.v(RILJ_LOG_TAG, "writing packet: " + data.length + " bytes");
                s.getOutputStream().write(dataLength);
                s.getOutputStream().write(data);
            } catch (IOException ex) {
                Rlog.e(RILJ_LOG_TAG, "IOException", ex);
                req = findAndRemoveRequestFromList(rr.mSerial);
                // eg, if RILReceiver cleared the list.
                if (req != null) {
                    rr.onError(RADIO_NOT_AVAILABLE, null);
                    decrementWakeLock(rr);
                    rr.release();
                }
            } catch (RuntimeException exc) {
                Rlog.e(RILJ_LOG_TAG, "Uncaught exception ", exc);
                req = findAndRemoveRequestFromList(rr.mSerial);
                // eg, if RILReceiver cleared the list.
                if (req != null) {
                    rr.onError(GENERIC_FAILURE, null);
                    decrementWakeLock(rr);
                    rr.release();
                }
            }
            break;
        case EVENT_WAKE_LOCK_TIMEOUT:
            synchronized (mRequestList) {
                if (msg.arg1 == mWlSequenceNum && clearWakeLock(FOR_WAKELOCK)) {
                    if (RILJ_LOGD) {
                        int count = mRequestList.size();
                        Rlog.d(RILJ_LOG_TAG, "WAKE_LOCK_TIMEOUT " + " mRequestList=" + count);
                        for (int i = 0; i < count; i++) {
                            rr = mRequestList.valueAt(i);
                            Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] " + requestToString(rr.mRequest));
                        }
                    }
                }
            }
            break;
        case EVENT_ACK_WAKE_LOCK_TIMEOUT:
            if (msg.arg1 == mAckWlSequenceNum && clearWakeLock(FOR_ACK_WAKELOCK)) {
                if (RILJ_LOGD) {
                    Rlog.d(RILJ_LOG_TAG, "ACK_WAKE_LOCK_TIMEOUT");
                }
            }
            break;
        case EVENT_BLOCKING_RESPONSE_TIMEOUT:
            int serial = msg.arg1;
            rr = findAndRemoveRequestFromList(serial);
            // If the request has already been processed, do nothing
            if (rr == null) {
                break;
            }
            // build a response if expected
            if (rr.mResult != null) {
                Object timeoutResponse = getResponseForTimedOutRILRequest(rr);
                AsyncResult.forMessage(rr.mResult, timeoutResponse, null);
                rr.mResult.sendToTarget();
                mEventLog.writeOnRilTimeoutResponse(rr.mSerial, rr.mRequest);
            }
            decrementWakeLock(rr);
            rr.release();
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    RILRequest rr = (RILRequest) (msg.obj);
    RILRequest req = null;
    switch(msg.what) {
        case EVENT_SEND:
        case EVENT_SEND_ACK:
            try {
                LocalSocket s;
                s = mSocket;
                if (s == null) {
                    rr.onError(RADIO_NOT_AVAILABLE, null);
                    decrementWakeLock(rr);
                    rr.release();
                    return;
                }
                // Acks should not be stored in list before sending
                if (msg.what != EVENT_SEND_ACK) {
                    synchronized (mRequestList) {
                        rr.mStartTimeMs = SystemClock.elapsedRealtime();
                        mRequestList.append(rr.mSerial, rr);
                    }
                }
                byte[] data;
                data = rr.mParcel.marshall();
                rr.mParcel.recycle();
                rr.mParcel = null;
                if (data.length > RIL_MAX_COMMAND_BYTES) {
                    throw new RuntimeException("Parcel larger than max bytes allowed! " + data.length);
                }
                // parcel length in big endian
                dataLength[0] = dataLength[1] = 0;
                dataLength[2] = (byte) ((data.length >> 8) & 0xff);
                dataLength[3] = (byte) ((data.length) & 0xff);
                // Rlog.v(RILJ_LOG_TAG, "writing packet: " + data.length + " bytes");
                s.getOutputStream().write(dataLength);
                s.getOutputStream().write(data);
                if (msg.what == EVENT_SEND_ACK) {
                    rr.release();
                    return;
                }
            } catch (IOException ex) {
                riljLoge("IOException ", ex);
                req = findAndRemoveRequestFromList(rr.mSerial);
                // eg, if RILReceiver cleared the list.
                if (req != null) {
                    rr.onError(RADIO_NOT_AVAILABLE, null);
                    decrementWakeLock(rr);
                    rr.release();
                    return;
                }
            } catch (RuntimeException exc) {
                riljLoge("Uncaught exception ", exc);
                req = findAndRemoveRequestFromList(rr.mSerial);
                // eg, if RILReceiver cleared the list.
                if (req != null) {
                    rr.onError(GENERIC_FAILURE, null);
                    decrementWakeLock(rr);
                    rr.release();
                    return;
                }
            }
            break;
        case EVENT_WAKE_LOCK_TIMEOUT:
            synchronized (mRequestList) {
                if (msg.arg1 == mWlSequenceNum && clearWakeLock(FOR_WAKELOCK)) {
                    if (RILJ_LOGD) {
                        int count = mRequestList.size();
                        Rlog.d(RILJ_LOG_TAG, "WAKE_LOCK_TIMEOUT " + " mRequestList=" + count);
                        for (int i = 0; i < count; i++) {
                            rr = mRequestList.valueAt(i);
                            Rlog.d(RILJ_LOG_TAG, i + ": [" + rr.mSerial + "] " + requestToString(rr.mRequest));
                        }
                    }
                }
            }
            break;
        case EVENT_ACK_WAKE_LOCK_TIMEOUT:
            if (msg.arg1 == mAckWlSequenceNum && clearWakeLock(FOR_ACK_WAKELOCK)) {
                if (RILJ_LOGV) {
                    Rlog.d(RILJ_LOG_TAG, "ACK_WAKE_LOCK_TIMEOUT");
                }
            }
            break;
        case EVENT_BLOCKING_RESPONSE_TIMEOUT:
            int serial = msg.arg1;
            rr = findAndRemoveRequestFromList(serial);
            // If the request has already been processed, do nothing
            if (rr == null) {
                break;
            }
            // build a response if expected
            if (rr.mResult != null) {
                Object timeoutResponse = getResponseForTimedOutRILRequest(rr);
                AsyncResult.forMessage(rr.mResult, timeoutResponse, null);
                rr.mResult.sendToTarget();
                mMetrics.writeOnRilTimeoutResponse(mInstanceId, rr.mSerial, rr.mRequest);
            }
            decrementWakeLock(rr);
            rr.release();
            break;
    }
}
#end_block

#method_before
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mInstanceId == null || mInstanceId == 0) {
                rilSocket = SOCKET_NAME_RIL[0];
            } else {
                rilSocket = SOCKET_NAME_RIL[mInstanceId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    Rlog.e(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '" + rilSocket + "' socket");
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#method_after
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mInstanceId == null || mInstanceId == 0) {
                rilSocket = SOCKET_NAME_RIL[0];
            } else {
                rilSocket = SOCKET_NAME_RIL[mInstanceId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    riljLoge("Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '" + rilSocket + "' socket");
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                riljLoge("Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#end_block

#method_before
private IRadio getRadioProxy() {
    IRadio radioProxy = null;
    try {
        radioProxy = IRadio.getService(SOCKET_NAME_RIL[mInstanceId == null ? 0 : mInstanceId]);
        if (radioProxy != null) {
            Log.d(RILJ_LOG_TAG, "getRadioProxy: radioProxy != null;" + "calling setResponseFunctions()");
            // todo(b/31632518): should not need to be called every time
            radioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
            Log.d(RILJ_LOG_TAG, "getRadioProxy: setResponseFunctions() done");
        } else {
            Log.d(RILJ_LOG_TAG, "getRadioProxy: radioProxy == null");
        }
    } catch (Exception e) {
        Log.d(RILJ_LOG_TAG, "getRadioProxy: exception " + e.toString());
    }
    return radioProxy;
}
#method_after
private IRadio getRadioProxy() {
    IRadio radioProxy = null;
    try {
        radioProxy = IRadio.getService(SOCKET_NAME_RIL[mInstanceId == null ? 0 : mInstanceId]);
        if (radioProxy != null) {
            riljLog("getRadioProxy: radioProxy != null; calling setResponseFunctions()");
            // todo(b/31632518): should not need to be called every time
            radioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);
        } else {
            riljLoge("getRadioProxy: radioProxy == null");
        }
    } catch (Exception e) {
        riljLoge("getRadioProxy: exception", e);
    }
    return radioProxy;
}
#end_block

#method_before
@Override
public void getIccCardStatus(Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_SIM_STATUS, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    IRadio radioProxy = getRadioProxy();
    if (radioProxy != null) {
        acquireWakeLock(rr, FOR_WAKELOCK);
        synchronized (mRequestList) {
            mRequestList.append(rr.mSerial, rr);
        }
        try {
            radioProxy.getIccCardStatus(rr.mSerial);
        } catch (Exception e) {
            riljLog("getIccCardStatus: exception " + e);
            rr.onError(RADIO_NOT_AVAILABLE, null);
            rr.release();
        }
    } else {
        rr.onError(RADIO_NOT_AVAILABLE, null);
        rr.release();
    }
}
#method_after
@Override
public void getIccCardStatus(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_SIM_STATUS, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    IRadio radioProxy = getRadioProxy();
    if (radioProxy != null) {
        addRequest(rr);
        try {
            radioProxy.getIccCardStatus(rr.mSerial);
        } catch (Exception e) {
            riljLoge("getIccCardStatus", e);
            rr.onError(RADIO_NOT_AVAILABLE, null);
            decrementWakeLock(rr);
            rr.release();
        }
    } else {
        rr.onError(RADIO_NOT_AVAILABLE, null);
        rr.release();
    }
}
#end_block

#method_before
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    if (uusInfo == null) {
        // UUS information is absent
        rr.mParcel.writeInt(0);
    } else {
        // UUS information is present
        rr.mParcel.writeInt(1);
        rr.mParcel.writeInt(uusInfo.getType());
        rr.mParcel.writeInt(uusInfo.getDcs());
        rr.mParcel.writeByteArray(uusInfo.getUserData());
    }
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilDial(rr.mSerial, clirMode, uusInfo);
    send(rr);
}
#method_after
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    if (uusInfo == null) {
        // UUS information is absent
        rr.mParcel.writeInt(0);
    } else {
        // UUS information is present
        rr.mParcel.writeInt(1);
        rr.mParcel.writeInt(uusInfo.getType());
        rr.mParcel.writeInt(uusInfo.getDcs());
        rr.mParcel.writeByteArray(uusInfo.getUserData());
    }
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilDial(mInstanceId, rr.mSerial, clirMode, uusInfo);
    send(rr);
}
#end_block

#method_before
@Override
public void hangupConnection(int gsmIndex, Message result) {
    if (RILJ_LOGD)
        riljLog("hangupConnection: gsmIndex=" + gsmIndex);
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + gsmIndex);
    mEventLog.writeRilHangup(rr.mSerial, RIL_REQUEST_HANGUP, gsmIndex);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(gsmIndex);
    send(rr);
}
#method_after
@Override
public void hangupConnection(int gsmIndex, Message result) {
    if (RILJ_LOGD)
        riljLog("hangupConnection: gsmIndex=" + gsmIndex);
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + gsmIndex);
    mMetrics.writeRilHangup(mInstanceId, rr.mSerial, gsmIndex);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(gsmIndex);
    send(rr);
}
#end_block

#method_before
@Override
public void hangupWaitingOrBackground(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilHangup(rr.mSerial, RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, -1);
    send(rr);
}
#method_after
@Override
public void hangupWaitingOrBackground(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilHangup(mInstanceId, rr.mSerial, -1);
    send(rr);
}
#end_block

#method_before
@Override
public void hangupForegroundResumeBackground(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilHangup(rr.mSerial, RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, -1);
    send(rr);
}
#method_after
@Override
public void hangupForegroundResumeBackground(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilHangup(mInstanceId, rr.mSerial, -1);
    send(rr);
}
#end_block

#method_before
@Override
public void acceptCall(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ANSWER, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilAnswer(rr.mSerial);
    send(rr);
}
#method_after
@Override
public void acceptCall(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ANSWER, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilAnswer(mInstanceId, rr.mSerial);
    send(rr);
}
#end_block

#method_before
public void sendSMS(String smscPDU, String pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_SMS, result);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilSendSms(rr.mSerial, rr.mRequest);
    send(rr);
}
#method_after
public void sendSMS(String smscPDU, String pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_SMS, result);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_GSM, SmsSession.Event.Format.SMS_FORMAT_3GPP);
    send(rr);
}
#end_block

#method_before
@Override
public void sendSMSExpectMore(String smscPDU, String pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_SMS_EXPECT_MORE, result);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilSendSms(rr.mSerial, rr.mRequest);
    send(rr);
}
#method_after
@Override
public void sendSMSExpectMore(String smscPDU, String pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_SMS_EXPECT_MORE, result);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_GSM, SmsSession.Event.Format.SMS_FORMAT_3GPP);
    send(rr);
}
#end_block

#method_before
public void sendCdmaSms(byte[] pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_SEND_SMS, result);
    constructCdmaSendSmsRilRequest(rr, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilSendSms(rr.mSerial, rr.mRequest);
    send(rr);
}
#method_after
public void sendCdmaSms(byte[] pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_SEND_SMS, result);
    constructCdmaSendSmsRilRequest(rr, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_CDMA, SmsSession.Event.Format.SMS_FORMAT_3GPP2);
    send(rr);
}
#end_block

#method_before
public void sendImsGsmSms(String smscPDU, String pdu, int retry, int messageRef, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_IMS_SEND_SMS, result);
    rr.mParcel.writeInt(RILConstants.GSM_PHONE);
    rr.mParcel.writeByte((byte) retry);
    rr.mParcel.writeInt(messageRef);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilSendSms(rr.mSerial, rr.mRequest);
    send(rr);
}
#method_after
public void sendImsGsmSms(String smscPDU, String pdu, int retry, int messageRef, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_IMS_SEND_SMS, result);
    rr.mParcel.writeInt(RILConstants.GSM_PHONE);
    rr.mParcel.writeByte((byte) retry);
    rr.mParcel.writeInt(messageRef);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_IMS, SmsSession.Event.Format.SMS_FORMAT_3GPP);
    send(rr);
}
#end_block

#method_before
public void sendImsCdmaSms(byte[] pdu, int retry, int messageRef, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_IMS_SEND_SMS, result);
    rr.mParcel.writeInt(RILConstants.CDMA_PHONE);
    rr.mParcel.writeByte((byte) retry);
    rr.mParcel.writeInt(messageRef);
    constructCdmaSendSmsRilRequest(rr, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mEventLog.writeRilSendSms(rr.mSerial, rr.mRequest);
    send(rr);
}
#method_after
public void sendImsCdmaSms(byte[] pdu, int retry, int messageRef, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_IMS_SEND_SMS, result);
    rr.mParcel.writeInt(RILConstants.CDMA_PHONE);
    rr.mParcel.writeByte((byte) retry);
    rr.mParcel.writeInt(messageRef);
    constructCdmaSendSmsRilRequest(rr, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_IMS, SmsSession.Event.Format.SMS_FORMAT_3GPP2);
    send(rr);
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
    rr.mParcel.writeInt(7);
    rr.mParcel.writeString(Integer.toString(radioTechnology + 2));
    rr.mParcel.writeString(Integer.toString(profile));
    rr.mParcel.writeString(apn);
    rr.mParcel.writeString(user);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(authType));
    rr.mParcel.writeString(protocol);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + radioTechnology + " " + profile + " " + apn + " " + user + " " + password + " " + authType + " " + protocol);
    mEventLog.writeRilSetupDataCall(rr.mSerial, radioTechnology, profile, apn, user, password, authType, protocol);
    send(rr);
}
#method_after
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
    rr.mParcel.writeInt(7);
    rr.mParcel.writeString(Integer.toString(radioTechnology + 2));
    rr.mParcel.writeString(Integer.toString(profile));
    rr.mParcel.writeString(apn);
    rr.mParcel.writeString(user);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(authType));
    rr.mParcel.writeString(protocol);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + radioTechnology + " " + profile + " " + apn + " " + user + " " + password + " " + authType + " " + protocol);
    mMetrics.writeRilSetupDataCall(mInstanceId, rr.mSerial, radioTechnology, profile, apn, authType, protocol);
    send(rr);
}
#end_block

#method_before
@Override
public void deactivateDataCall(int cid, int reason, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DEACTIVATE_DATA_CALL, result);
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(Integer.toString(cid));
    rr.mParcel.writeString(Integer.toString(reason));
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + cid + " " + reason);
    mEventLog.writeRilDeactivateDataCall(rr.mSerial, cid, reason);
    send(rr);
}
#method_after
@Override
public void deactivateDataCall(int cid, int reason, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DEACTIVATE_DATA_CALL, result);
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(Integer.toString(cid));
    rr.mParcel.writeString(Integer.toString(reason));
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + cid + " " + reason);
    mMetrics.writeRilDeactivateDataCall(mInstanceId, rr.mSerial, cid, reason);
    send(rr);
}
#end_block

#method_before
@Override
public void setPreferredNetworkType(int networkType, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(networkType);
    mPreferredNetworkType = networkType;
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + networkType);
    mEventLog.writeSetPreferredNetworkType(networkType);
    send(rr);
}
#method_after
@Override
public void setPreferredNetworkType(int networkType, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(networkType);
    mPreferredNetworkType = networkType;
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + networkType);
    mMetrics.writeSetPreferredNetworkType(mInstanceId, networkType);
    send(rr);
}
#end_block

#method_before
private void processResponse(Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED || type == RESPONSE_UNSOLICITED_ACK_EXP) {
        processUnsolicited(p, type);
    } else if (type == RESPONSE_SOLICITED || type == RESPONSE_SOLICITED_ACK_EXP) {
        RILRequest rr = processSolicited(p, type);
        if (rr != null) {
            if (type == RESPONSE_SOLICITED) {
                decrementWakeLock(rr);
            }
            rr.release();
        }
    } else if (type == RESPONSE_SOLICITED_ACK) {
        int serial;
        serial = p.readInt();
        RILRequest rr;
        synchronized (mRequestList) {
            rr = mRequestList.get(serial);
        }
        if (rr == null) {
            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited ack response! sn: " + serial);
        } else {
            decrementWakeLock(rr);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + " Ack < " + requestToString(rr.mRequest));
            }
        }
    }
}
#method_after
RILRequest processResponse(RadioResponseInfo responseInfo) {
    int serial = responseInfo.serial;
    int error = responseInfo.error;
    int type = responseInfo.type;
    RILRequest rr;
    if (type == RadioResponseType.SOLICITED_ACK) {
        synchronized (mRequestList) {
            rr = mRequestList.get(serial);
        }
        if (rr == null) {
            Rlog.w(RIL.RILJ_LOG_TAG, "processResponse: Unexpected solicited ack response! " + "sn: " + serial);
        } else {
            decrementWakeLock(rr);
            if (RIL.RILJ_LOGD) {
                riljLog(rr.serialString() + " Ack < " + RIL.requestToString(rr.mRequest));
            }
        }
    } else {
        rr = findAndRemoveRequestFromList(serial);
        if (rr == null) {
            Rlog.w(RIL.RILJ_LOG_TAG, "processResponse: Unexpected response! sn: " + serial + " error: " + error);
            return null;
        }
        if (type == RadioResponseType.SOLICITED_ACK_EXP) {
            sendAck();
            if (RIL.RILJ_LOGD) {
                riljLog("Response received for " + rr.serialString() + " " + RIL.requestToString(rr.mRequest) + " Sending ack to ril.cpp");
            }
        } else {
        // ack sent for SOLICITED_ACK_EXP above; nothing to do for SOLICITED
        }
    }
    return rr;
}
#end_block

#method_before
private void processResponse(Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED || type == RESPONSE_UNSOLICITED_ACK_EXP) {
        processUnsolicited(p, type);
    } else if (type == RESPONSE_SOLICITED || type == RESPONSE_SOLICITED_ACK_EXP) {
        RILRequest rr = processSolicited(p, type);
        if (rr != null) {
            if (type == RESPONSE_SOLICITED) {
                decrementWakeLock(rr);
            }
            rr.release();
        }
    } else if (type == RESPONSE_SOLICITED_ACK) {
        int serial;
        serial = p.readInt();
        RILRequest rr;
        synchronized (mRequestList) {
            rr = mRequestList.get(serial);
        }
        if (rr == null) {
            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited ack response! sn: " + serial);
        } else {
            decrementWakeLock(rr);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + " Ack < " + requestToString(rr.mRequest));
            }
        }
    }
}
#method_after
private void processResponse(Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED || type == RESPONSE_UNSOLICITED_ACK_EXP) {
        processUnsolicited(p, type);
    } else if (type == RESPONSE_SOLICITED || type == RESPONSE_SOLICITED_ACK_EXP) {
        RILRequest rr = processSolicited(p, type);
        if (rr != null) {
            if (type == RESPONSE_SOLICITED) {
                decrementWakeLock(rr);
            }
            rr.release();
            return;
        }
    } else if (type == RESPONSE_SOLICITED_ACK) {
        int serial;
        serial = p.readInt();
        RILRequest rr;
        synchronized (mRequestList) {
            rr = mRequestList.get(serial);
        }
        if (rr == null) {
            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited ack response! sn: " + serial);
        } else {
            decrementWakeLock(rr);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + " Ack < " + requestToString(rr.mRequest));
            }
        }
    }
}
#end_block

#method_before
private RILRequest findAndRemoveRequestFromList(int serial) {
    RILRequest rr = null;
    synchronized (mRequestList) {
        rr = mRequestList.get(serial);
        if (rr != null) {
            mRequestList.remove(serial);
        }
    }
    if (rr != null) {
    }
    return rr;
}
#method_after
private RILRequest findAndRemoveRequestFromList(int serial) {
    RILRequest rr = null;
    synchronized (mRequestList) {
        rr = mRequestList.get(serial);
        if (rr != null) {
            mRequestList.remove(serial);
        }
    }
    return rr;
}
#end_block

#method_before
private RILRequest processSolicited(Parcel p, int type) {
    int serial, error;
    boolean found = false;
    serial = p.readInt();
    error = p.readInt();
    RILRequest rr;
    rr = findAndRemoveRequestFromList(serial);
    if (rr == null) {
        Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: " + serial + " error: " + error);
        return null;
    }
    if (getRilVersion() >= 13 && type == RESPONSE_SOLICITED_ACK_EXP) {
        Message msg;
        RILRequest response = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, response);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Response received for " + rr.serialString() + " " + requestToString(rr.mRequest) + " Sending ack to ril.cpp");
        }
        response.release();
    }
    Object ret = null;
    if (error == 0 || p.dataAvail() > 0) {
        // either command succeeds or command fails but with data payload
        try {
            switch(rr.mRequest) {
                /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
             */
                case RIL_REQUEST_ENTER_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CURRENT_CALLS:
                    ret = responseCallList(p);
                    break;
                case RIL_REQUEST_DIAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMSI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_HANGUP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
                    {
                        if (mTestingEmergencyCall.getAndSet(false)) {
                            if (mEmergencyCallbackModeRegistrant != null) {
                                riljLog("testing emergency call, notify ECM Registrants");
                                mEmergencyCallbackModeRegistrant.notifyRegistrant();
                            }
                        }
                        ret = responseVoid(p);
                        break;
                    }
                case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CONFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_UDUB:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
                    ret = responseFailCause(p);
                    break;
                case RIL_REQUEST_SIGNAL_STRENGTH:
                    ret = responseSignalStrength(p);
                    break;
                case RIL_REQUEST_VOICE_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_DATA_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_OPERATOR:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_RADIO_POWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SETUP_DATA_CALL:
                    ret = responseSetupDataCall(p);
                    break;
                case RIL_REQUEST_SIM_IO:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SEND_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CANCEL_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_CLIR:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CLIR:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
                    ret = responseCallForward(p);
                    break;
                case RIL_REQUEST_SET_CALL_FORWARD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_WAITING:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CALL_WAITING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMEI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_GET_IMEISV:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ANSWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEACTIVATE_DATA_CALL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
                    ret = responseOperatorInfos(p);
                    break;
                case RIL_REQUEST_DTMF_START:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF_STOP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_BASEBAND_VERSION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SEPARATE_CONNECTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_MUTE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_MUTE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_QUERY_CLIP:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DATA_CALL_LIST:
                    ret = responseDataCallList(p);
                    break;
                case RIL_REQUEST_RESET_RADIO:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_RAW:
                    ret = responseRaw(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_STRINGS:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_SCREEN_STATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_WRITE_SMS_TO_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DELETE_SMS_ON_SIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_BAND_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_STK_GET_PROFILE:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SET_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
                    ret = responseGetPreferredNetworkType(p);
                    break;
                case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
                    ret = responseCellList(p);
                    break;
                case RIL_REQUEST_SET_LOCATION_UPDATES:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_TTY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_TTY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_FLASH:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BURST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
                    ret = responseGmsBroadcastConfig(p);
                    break;
                case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
                    ret = responseCdmaBroadcastConfig(p);
                    break;
                case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SUBSCRIPTION:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEVICE_IDENTITY:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_GET_SMSC_ADDRESS:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SET_SMSC_ADDRESS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ISIM_AUTHENTICATION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_VOICE_RADIO_TECH:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CELL_INFO_LIST:
                    ret = responseCellInfoList(p);
                    break;
                case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_DATA_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_IMS_REGISTRATION_STATE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_IMS_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_OPEN_CHANNEL:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SIM_CLOSE_CHANNEL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_NV_READ_ITEM:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_WRITE_ITEM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_WRITE_CDMA_PRL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_RESET_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_ALLOW_DATA:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_HARDWARE_CONFIG:
                    ret = responseHardwareConfig(p);
                    break;
                case RIL_REQUEST_SIM_AUTHENTICATION:
                    ret = responseICC_IOBase64(p);
                    break;
                case RIL_REQUEST_SHUTDOWN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_SET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_START_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_STOP_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_PULL_LCEDATA:
                    ret = responseLceData(p);
                    break;
                case RIL_REQUEST_GET_ACTIVITY_INFO:
                    ret = responseActivityData(p);
                    break;
                default:
                    throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
            }
        } catch (Throwable tr) {
            // Exceptions here usually mean invalid RIL responses
            Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< " + requestToString(rr.mRequest) + " exception, possible invalid RIL response", tr);
            if (rr.mResult != null) {
                AsyncResult.forMessage(rr.mResult, null, tr);
                rr.mResult.sendToTarget();
            }
            return rr;
        }
    }
    if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
        // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
        // regardless of error code to continue shutdown procedure.
        riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " + error + " Setting Radio State to Unavailable regardless of error.");
        setRadioState(RadioState.RADIO_UNAVAILABLE);
    }
    // screen when the pin or puk is entered incorrectly.
    switch(rr.mRequest) {
        case RIL_REQUEST_ENTER_SIM_PUK:
        case RIL_REQUEST_ENTER_SIM_PUK2:
            if (mIccStatusChangedRegistrants != null) {
                if (RILJ_LOGD) {
                    riljLog("ON enter sim puk fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                }
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
    }
    if (error != 0) {
        switch(rr.mRequest) {
            case RIL_REQUEST_ENTER_SIM_PIN:
            case RIL_REQUEST_ENTER_SIM_PIN2:
            case RIL_REQUEST_CHANGE_SIM_PIN:
            case RIL_REQUEST_CHANGE_SIM_PIN2:
            case RIL_REQUEST_SET_FACILITY_LOCK:
                if (mIccStatusChangedRegistrants != null) {
                    if (RILJ_LOGD) {
                        riljLog("ON some errors fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                    }
                    mIccStatusChangedRegistrants.notifyRegistrants();
                }
                break;
            case RIL_REQUEST_GET_RADIO_CAPABILITY:
                {
                    // TODO - remove GENERIC_FAILURE catching: b/21079604
                    if (REQUEST_NOT_SUPPORTED == error || GENERIC_FAILURE == error) {
                        // we should construct the RAF bitmask the radio
                        // supports based on preferred network bitmasks
                        ret = makeStaticRadioCapability();
                        error = 0;
                    }
                    break;
                }
            case RIL_REQUEST_GET_ACTIVITY_INFO:
                ret = new ModemActivityInfo(0, 0, 0, new int[ModemActivityInfo.TX_POWER_LEVELS], 0, 0);
                error = 0;
                break;
        }
        if (error != 0)
            rr.onError(error, ret);
    }
    if (error == 0) {
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "< " + requestToString(rr.mRequest) + " " + retToString(rr.mRequest, ret));
        if (rr.mResult != null) {
            AsyncResult.forMessage(rr.mResult, ret, null);
            rr.mResult.sendToTarget();
        }
    }
    mEventLog.writeOnRilSolicitedResponse(rr.mSerial, error, rr.mRequest, ret);
    return rr;
}
#method_after
private RILRequest processSolicited(Parcel p, int type) {
    int serial, error;
    boolean found = false;
    serial = p.readInt();
    error = p.readInt();
    RILRequest rr;
    rr = findAndRemoveRequestFromList(serial);
    if (rr == null) {
        Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: " + serial + " error: " + error);
        return null;
    }
    // Time logging for RIL command and storing it in TelephonyHistogram.
    addToRilHistogram(rr);
    if (getRilVersion() >= 13 && type == RESPONSE_SOLICITED_ACK_EXP) {
        Message msg;
        RILRequest response = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, response);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Response received for " + rr.serialString() + " " + requestToString(rr.mRequest) + " Sending ack to ril.cpp");
        }
    }
    Object ret = null;
    if (error == 0 || p.dataAvail() > 0) {
        // either command succeeds or command fails but with data payload
        try {
            switch(rr.mRequest) {
                /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
             */
                case RIL_REQUEST_ENTER_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_SIM_PUK2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_SIM_PIN2:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CURRENT_CALLS:
                    ret = responseCallList(p);
                    break;
                case RIL_REQUEST_DIAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMSI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_HANGUP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
                    {
                        if (mTestingEmergencyCall.getAndSet(false)) {
                            if (mEmergencyCallbackModeRegistrant != null) {
                                riljLog("testing emergency call, notify ECM Registrants");
                                mEmergencyCallbackModeRegistrant.notifyRegistrant();
                            }
                        }
                        ret = responseVoid(p);
                        break;
                    }
                case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CONFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_UDUB:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
                    ret = responseFailCause(p);
                    break;
                case RIL_REQUEST_SIGNAL_STRENGTH:
                    ret = responseSignalStrength(p);
                    break;
                case RIL_REQUEST_VOICE_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_DATA_REGISTRATION_STATE:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_OPERATOR:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_RADIO_POWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SETUP_DATA_CALL:
                    ret = responseSetupDataCall(p);
                    break;
                case RIL_REQUEST_SIM_IO:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SEND_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CANCEL_USSD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_CLIR:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CLIR:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
                    ret = responseCallForward(p);
                    break;
                case RIL_REQUEST_SET_CALL_FORWARD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_CALL_WAITING:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_CALL_WAITING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_IMEI:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_GET_IMEISV:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ANSWER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEACTIVATE_DATA_CALL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_FACILITY_LOCK:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
                    ret = responseOperatorInfos(p);
                    break;
                case RIL_REQUEST_DTMF_START:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DTMF_STOP:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_BASEBAND_VERSION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SEPARATE_CONNECTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_MUTE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_MUTE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_QUERY_CLIP:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DATA_CALL_LIST:
                    ret = responseDataCallList(p);
                    break;
                case RIL_REQUEST_RESET_RADIO:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_RAW:
                    ret = responseRaw(p);
                    break;
                case RIL_REQUEST_OEM_HOOK_STRINGS:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_SCREEN_STATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_WRITE_SMS_TO_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_DELETE_SMS_ON_SIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_BAND_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_STK_GET_PROFILE:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SET_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
                    ret = responseGetPreferredNetworkType(p);
                    break;
                case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
                    ret = responseCellList(p);
                    break;
                case RIL_REQUEST_SET_LOCATION_UPDATES:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SET_TTY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_QUERY_TTY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_FLASH:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BURST_DTMF:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
                    ret = responseGmsBroadcastConfig(p);
                    break;
                case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
                    ret = responseCdmaBroadcastConfig(p);
                    break;
                case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_SUBSCRIPTION:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_DEVICE_IDENTITY:
                    ret = responseStrings(p);
                    break;
                case RIL_REQUEST_GET_SMSC_ADDRESS:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_SET_SMSC_ADDRESS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_ISIM_AUTHENTICATION:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_VOICE_RADIO_TECH:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_CELL_INFO_LIST:
                    ret = responseCellInfoList(p);
                    break;
                case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_DATA_PROFILE:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_IMS_REGISTRATION_STATE:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_IMS_SEND_SMS:
                    ret = responseSMS(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_SIM_OPEN_CHANNEL:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_SIM_CLOSE_CHANNEL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
                    ret = responseICC_IO(p);
                    break;
                case RIL_REQUEST_NV_READ_ITEM:
                    ret = responseString(p);
                    break;
                case RIL_REQUEST_NV_WRITE_ITEM:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_WRITE_CDMA_PRL:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_NV_RESET_CONFIG:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_ALLOW_DATA:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_HARDWARE_CONFIG:
                    ret = responseHardwareConfig(p);
                    break;
                case RIL_REQUEST_SIM_AUTHENTICATION:
                    ret = responseICC_IOBase64(p);
                    break;
                case RIL_REQUEST_SHUTDOWN:
                    ret = responseVoid(p);
                    break;
                case RIL_REQUEST_GET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_SET_RADIO_CAPABILITY:
                    ret = responseRadioCapability(p);
                    break;
                case RIL_REQUEST_START_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_STOP_LCE:
                    ret = responseLceStatus(p);
                    break;
                case RIL_REQUEST_PULL_LCEDATA:
                    ret = responseLceData(p);
                    break;
                case RIL_REQUEST_GET_ACTIVITY_INFO:
                    ret = responseActivityData(p);
                    break;
                case RIL_REQUEST_SET_ALLOWED_CARRIERS:
                    ret = responseInts(p);
                    break;
                case RIL_REQUEST_GET_ALLOWED_CARRIERS:
                    ret = responseCarrierIdentifiers(p);
                    break;
                default:
                    throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
            }
        } catch (Throwable tr) {
            // Exceptions here usually mean invalid RIL responses
            Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< " + requestToString(rr.mRequest) + " exception, possible invalid RIL response", tr);
            if (rr.mResult != null) {
                AsyncResult.forMessage(rr.mResult, null, tr);
                rr.mResult.sendToTarget();
            }
            return rr;
        }
    }
    if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
        // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
        // regardless of error code to continue shutdown procedure.
        riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " + error + " Setting Radio State to Unavailable regardless of error.");
        setRadioState(RadioState.RADIO_UNAVAILABLE);
    }
    // screen when the pin or puk is entered incorrectly.
    switch(rr.mRequest) {
        case RIL_REQUEST_ENTER_SIM_PUK:
        case RIL_REQUEST_ENTER_SIM_PUK2:
            if (mIccStatusChangedRegistrants != null) {
                if (RILJ_LOGD) {
                    riljLog("ON enter sim puk fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                }
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
    }
    if (error != 0) {
        switch(rr.mRequest) {
            case RIL_REQUEST_ENTER_SIM_PIN:
            case RIL_REQUEST_ENTER_SIM_PIN2:
            case RIL_REQUEST_CHANGE_SIM_PIN:
            case RIL_REQUEST_CHANGE_SIM_PIN2:
            case RIL_REQUEST_SET_FACILITY_LOCK:
                if (mIccStatusChangedRegistrants != null) {
                    if (RILJ_LOGD) {
                        riljLog("ON some errors fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                    }
                    mIccStatusChangedRegistrants.notifyRegistrants();
                }
                break;
            case RIL_REQUEST_GET_RADIO_CAPABILITY:
                {
                    // TODO - remove GENERIC_FAILURE catching: b/21079604
                    if (REQUEST_NOT_SUPPORTED == error || GENERIC_FAILURE == error) {
                        // we should construct the RAF bitmask the radio
                        // supports based on preferred network bitmasks
                        ret = makeStaticRadioCapability();
                        error = 0;
                    }
                    break;
                }
            case RIL_REQUEST_GET_ACTIVITY_INFO:
                ret = new ModemActivityInfo(0, 0, 0, new int[ModemActivityInfo.TX_POWER_LEVELS], 0, 0);
                error = 0;
                break;
        }
        if (error != 0)
            rr.onError(error, ret);
    }
    if (error == 0) {
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "< " + requestToString(rr.mRequest) + " " + retToString(rr.mRequest, ret));
        if (rr.mResult != null) {
            AsyncResult.forMessage(rr.mResult, ret, null);
            rr.mResult.sendToTarget();
        }
    }
    mMetrics.writeOnRilSolicitedResponse(mInstanceId, rr.mSerial, error, rr.mRequest, ret);
    return rr;
}
#end_block

#method_before
private void processUnsolicited(Parcel p, int type) {
    int response;
    Object ret;
    response = p.readInt();
    // Follow new symantics of sending an Ack starting from RIL version 13
    if (getRilVersion() >= 13 && type == RESPONSE_UNSOLICITED_ACK_EXP) {
        Message msg;
        RILRequest rr = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, rr);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Unsol response received for " + responseToString(response) + " Sending ack to ril.cpp");
        }
        rr.release();
    }
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                mEventLog.writeRilNewSms(response);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            mEventLog.writeRilNewSms(response);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                Rlog.e(RILJ_LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                // When modem crashes, if user turns the screen off before RIL reconnects, screen
                // state cannot be sent to modem. Resend the display state here so that modem
                // has the correct state (to stop signal strength reporting, etc).
                updateScreenState(true);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                mEventLog.writeRilSrvcc(((int[]) ret)[0]);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
    }
}
#method_after
private void processUnsolicited(Parcel p, int type) {
    int response;
    Object ret;
    response = p.readInt();
    // Follow new symantics of sending an Ack starting from RIL version 13
    if (getRilVersion() >= 13 && type == RESPONSE_UNSOLICITED_ACK_EXP) {
        Message msg;
        RILRequest rr = RILRequest.obtain(RIL_RESPONSE_ACKNOWLEDGEMENT, null);
        msg = mSender.obtainMessage(EVENT_SEND_ACK, rr);
        acquireWakeLock(rr, FOR_ACK_WAKELOCK);
        msg.sendToTarget();
        if (RILJ_LOGD) {
            riljLog("Unsol response received for " + responseToString(response) + " Sending ack to ril.cpp");
        }
    }
    try {
        switch(response) {
            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
                ret = responseString(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_ON_USSD:
                ret = responseStrings(p);
                break;
            case RIL_UNSOL_NITZ_TIME_RECEIVED:
                ret = responseString(p);
                break;
            case RIL_UNSOL_SIGNAL_STRENGTH:
                ret = responseSignalStrength(p);
                break;
            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                ret = responseDataCallList(p);
                break;
            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
                ret = responseSuppServiceNotification(p);
                break;
            case RIL_UNSOL_STK_SESSION_END:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_EVENT_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_STK_CALL_SETUP:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_SIM_REFRESH:
                ret = responseSimRefresh(p);
                break;
            case RIL_UNSOL_CALL_RING:
                ret = responseCallRing(p);
                break;
            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
                ret = responseCdmaSms(p);
                break;
            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_CALL_WAITING:
                ret = responseCdmaCallWaiting(p);
                break;
            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CDMA_INFO_REC:
                ret = responseCdmaInformationRecord(p);
                break;
            case RIL_UNSOL_OEM_HOOK_RAW:
                ret = responseRaw(p);
                break;
            case RIL_UNSOL_RINGBACK_TONE:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_RESEND_INCALL_MUTE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOl_CDMA_PRL_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_RIL_CONNECTED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_CELL_INFO_LIST:
                ret = responseCellInfoList(p);
                break;
            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
                ret = responseVoid(p);
                break;
            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                ret = responseInts(p);
                break;
            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
                ret = responseHardwareConfig(p);
                break;
            case RIL_UNSOL_RADIO_CAPABILITY:
                ret = responseRadioCapability(p);
                break;
            case RIL_UNSOL_ON_SS:
                ret = responseSsData(p);
                break;
            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
                ret = responseString(p);
                break;
            case RIL_UNSOL_LCEDATA_RECV:
                ret = responseLceData(p);
                break;
            case RIL_UNSOL_PCO_DATA:
                ret = responsePcoData(p);
                break;
            default:
                throw new RuntimeException("Unrecognized unsol response: " + response);
        }
    } catch (Throwable tr) {
        riljLoge("Exception processing unsol response: " + response + "Exception:" + tr.toString());
        return;
    }
    switch(response) {
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mImsNetworkStateChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mCallStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            {
                if (RILJ_LOGD)
                    unsljLog(response);
                mMetrics.writeRilNewSms(mInstanceId, SmsSession.Event.Tech.SMS_GSM, SmsSession.Event.Format.SMS_FORMAT_3GPP);
                // FIXME this should move up a layer
                String[] a = new String[2];
                a[1] = (String) ret;
                SmsMessage sms;
                sms = SmsMessage.newFromCMT(a);
                if (mGsmSmsRegistrant != null) {
                    mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
                }
                break;
            }
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSmsStatusRegistrant != null) {
                mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            int[] smsIndex = (int[]) ret;
            if (smsIndex.length == 1) {
                if (mSmsOnSimRegistrant != null) {
                    mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null, smsIndex, null));
                }
            } else {
                if (RILJ_LOGD)
                    riljLog(" NEW_SMS_ON_SIM ERROR with wrong length " + smsIndex.length);
            }
            break;
        case RIL_UNSOL_ON_USSD:
            String[] resp = (String[]) ret;
            if (resp.length < 2) {
                resp = new String[2];
                resp[0] = ((String[]) ret)[0];
                resp[1] = null;
            }
            if (RILJ_LOGD)
                unsljLogMore(response, resp[0]);
            if (mUSSDRegistrant != null) {
                mUSSDRegistrant.notifyRegistrant(new AsyncResult(null, resp, null));
            }
            break;
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            // has bonus long containing milliseconds since boot that the NITZ
            // time was received
            long nitzReceiveTime = p.readLong();
            Object[] result = new Object[2];
            result[0] = ret;
            result[1] = Long.valueOf(nitzReceiveTime);
            boolean ignoreNitz = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false);
            if (ignoreNitz) {
                if (RILJ_LOGD)
                    riljLog("ignoring UNSOL_NITZ_TIME_RECEIVED");
            } else {
                if (mNITZTimeRegistrant != null) {
                    mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null, result, null));
                }
                // in case NITZ time registrant isn't registered yet, or a new registrant
                // registers later
                mLastNITZTimeInfo = result;
            }
            break;
        case RIL_UNSOL_SIGNAL_STRENGTH:
            // frequently
            if (RILJ_LOGV)
                unsljLogvRet(response, ret);
            if (mSignalStrengthRegistrant != null) {
                mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsnRegistrant != null) {
                mSsnRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_SESSION_END:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatSessionEndRegistrant != null) {
                mCatSessionEndRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatProCmdRegistrant != null) {
                mCatProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mCatEventRegistrant != null) {
                mCatEventRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CALL_SETUP:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCallSetUpRegistrant != null) {
                mCatCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_SIM_REFRESH:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mIccRefreshRegistrants != null) {
                mIccRefreshRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CALL_RING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mRingRegistrant != null) {
                mRingRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRestrictedStateRegistrant != null) {
                mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccStatusChangedRegistrants != null) {
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            if (RILJ_LOGD)
                unsljLog(response);
            mMetrics.writeRilNewSms(mInstanceId, SmsSession.Event.Tech.SMS_CDMA, SmsSession.Event.Format.SMS_FORMAT_3GPP2);
            SmsMessage sms = (SmsMessage) ret;
            if (mCdmaSmsRegistrant != null) {
                mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null));
            }
            break;
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mGsmBroadcastSmsRegistrant != null) {
                mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mIccSmsFullRegistrant != null) {
                mIccSmsFullRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLog(response);
            if (mEmergencyCallbackModeRegistrant != null) {
                mEmergencyCallbackModeRegistrant.notifyRegistrant();
            }
            break;
        case RIL_UNSOL_CDMA_CALL_WAITING:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCallWaitingInfoRegistrants != null) {
                mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mOtaProvisionRegistrants != null) {
                mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_INFO_REC:
            ArrayList<CdmaInformationRecords> listInfoRecs;
            try {
                listInfoRecs = (ArrayList<CdmaInformationRecords>) ret;
            } catch (ClassCastException e) {
                riljLoge("Unexpected exception casting to listInfoRecs", e);
                break;
            }
            for (CdmaInformationRecords rec : listInfoRecs) {
                if (RILJ_LOGD)
                    unsljLogRet(response, rec);
                notifyRegistrantsCdmaInfoRec(rec);
            }
            break;
        case RIL_UNSOL_OEM_HOOK_RAW:
            if (RILJ_LOGD)
                unsljLogvRet(response, IccUtils.bytesToHexString((byte[]) ret));
            if (mUnsolOemHookRawRegistrant != null) {
                mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RINGBACK_TONE:
            if (RILJ_LOGD)
                unsljLogvRet(response, ret);
            if (mRingbackToneRegistrants != null) {
                boolean playtone = (((int[]) ret)[0] == 1);
                mRingbackToneRegistrants.notifyRegistrants(new AsyncResult(null, playtone, null));
            }
            break;
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mResendIncallMuteRegistrants != null) {
                mResendIncallMuteRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mVoiceRadioTechChangedRegistrants != null) {
                mVoiceRadioTechChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaSubscriptionChangedRegistrants != null) {
                mCdmaSubscriptionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCdmaPrlChangedRegistrants != null) {
                mCdmaPrlChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mExitEmergencyCallbackModeRegistrants != null) {
                mExitEmergencyCallbackModeRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
            }
            break;
        case RIL_UNSOL_RIL_CONNECTED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                // Initial conditions
                setRadioPower(false, null);
                setCdmaSubscriptionSource(mCdmaSubscription, null);
                setCellInfoListRate(Integer.MAX_VALUE, null);
                notifyRegistrantsRilConnectionChanged(((int[]) ret)[0]);
                // When modem crashes, if user turns the screen off before RIL reconnects, screen
                // state cannot be sent to modem. Resend the display state here so that modem
                // has the correct state (to stop signal strength reporting, etc).
                updateScreenState(true);
                break;
            }
        case RIL_UNSOL_CELL_INFO_LIST:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mRilCellInfoListRegistrants != null) {
                    mRilCellInfoListRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                if (mSubscriptionStatusRegistrants != null) {
                    mSubscriptionStatusRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            {
                if (RILJ_LOGD)
                    unsljLogRet(response, ret);
                mMetrics.writeRilSrvcc(mInstanceId, ((int[]) ret)[0]);
                if (mSrvccStateRegistrants != null) {
                    mSrvccStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
                }
                break;
            }
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mHardwareConfigChangeRegistrants != null) {
                mHardwareConfigChangeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_RADIO_CAPABILITY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mPhoneRadioCapabilityChangedRegistrants != null) {
                mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_ON_SS:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mSsRegistrant != null) {
                mSsRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mCatCcAlphaRegistrant != null) {
                mCatCcAlphaRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_LCEDATA_RECV:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            if (mLceInfoRegistrant != null) {
                mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
            }
            break;
        case RIL_UNSOL_PCO_DATA:
            if (RILJ_LOGD)
                unsljLogRet(response, ret);
            mPcoDataRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
            break;
    }
}
#end_block

#method_before
private Object responseDataCallList(Parcel p) {
    ArrayList<DataCallResponse> response;
    int ver = p.readInt();
    int num = p.readInt();
    riljLog("responseDataCallList ver=" + ver + " num=" + num);
    response = new ArrayList<DataCallResponse>(num);
    for (int i = 0; i < num; i++) {
        response.add(getDataCallResponse(p, ver));
    }
    mEventLog.writeRilDataCallList(response);
    return response;
}
#method_after
private Object responseDataCallList(Parcel p) {
    ArrayList<DataCallResponse> response;
    int ver = p.readInt();
    int num = p.readInt();
    riljLog("responseDataCallList ver=" + ver + " num=" + num);
    response = new ArrayList<DataCallResponse>(num);
    for (int i = 0; i < num; i++) {
        response.add(getDataCallResponse(p, ver));
    }
    return response;
}
#end_block

#method_before
private Object responseCallRing(Parcel p) {
    char[] response = new char[4];
    // isPresent
    response[0] = (char) p.readInt();
    // signalType
    response[1] = (char) p.readInt();
    // alertPitch
    response[2] = (char) p.readInt();
    // signal
    response[3] = (char) p.readInt();
    mEventLog.writeRilCallRing(response);
    return response;
}
#method_after
private Object responseCallRing(Parcel p) {
    char[] response = new char[4];
    // isPresent
    response[0] = (char) p.readInt();
    // signalType
    response[1] = (char) p.readInt();
    // alertPitch
    response[2] = (char) p.readInt();
    // signal
    response[3] = (char) p.readInt();
    mMetrics.writeRilCallRing(mInstanceId, response);
    return response;
}
#end_block

#method_before
static String requestToString(int request) {
    /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
*/
    switch(request) {
        case RIL_REQUEST_GET_SIM_STATUS:
            return "GET_SIM_STATUS";
        case RIL_REQUEST_ENTER_SIM_PIN:
            return "ENTER_SIM_PIN";
        case RIL_REQUEST_ENTER_SIM_PUK:
            return "ENTER_SIM_PUK";
        case RIL_REQUEST_ENTER_SIM_PIN2:
            return "ENTER_SIM_PIN2";
        case RIL_REQUEST_ENTER_SIM_PUK2:
            return "ENTER_SIM_PUK2";
        case RIL_REQUEST_CHANGE_SIM_PIN:
            return "CHANGE_SIM_PIN";
        case RIL_REQUEST_CHANGE_SIM_PIN2:
            return "CHANGE_SIM_PIN2";
        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
            return "ENTER_NETWORK_DEPERSONALIZATION";
        case RIL_REQUEST_GET_CURRENT_CALLS:
            return "GET_CURRENT_CALLS";
        case RIL_REQUEST_DIAL:
            return "DIAL";
        case RIL_REQUEST_GET_IMSI:
            return "GET_IMSI";
        case RIL_REQUEST_HANGUP:
            return "HANGUP";
        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
            return "HANGUP_WAITING_OR_BACKGROUND";
        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
            return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
            return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
        case RIL_REQUEST_CONFERENCE:
            return "CONFERENCE";
        case RIL_REQUEST_UDUB:
            return "UDUB";
        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
            return "LAST_CALL_FAIL_CAUSE";
        case RIL_REQUEST_SIGNAL_STRENGTH:
            return "SIGNAL_STRENGTH";
        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
            return "VOICE_REGISTRATION_STATE";
        case RIL_REQUEST_DATA_REGISTRATION_STATE:
            return "DATA_REGISTRATION_STATE";
        case RIL_REQUEST_OPERATOR:
            return "OPERATOR";
        case RIL_REQUEST_RADIO_POWER:
            return "RADIO_POWER";
        case RIL_REQUEST_DTMF:
            return "DTMF";
        case RIL_REQUEST_SEND_SMS:
            return "SEND_SMS";
        case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
            return "SEND_SMS_EXPECT_MORE";
        case RIL_REQUEST_SETUP_DATA_CALL:
            return "SETUP_DATA_CALL";
        case RIL_REQUEST_SIM_IO:
            return "SIM_IO";
        case RIL_REQUEST_SEND_USSD:
            return "SEND_USSD";
        case RIL_REQUEST_CANCEL_USSD:
            return "CANCEL_USSD";
        case RIL_REQUEST_GET_CLIR:
            return "GET_CLIR";
        case RIL_REQUEST_SET_CLIR:
            return "SET_CLIR";
        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
            return "QUERY_CALL_FORWARD_STATUS";
        case RIL_REQUEST_SET_CALL_FORWARD:
            return "SET_CALL_FORWARD";
        case RIL_REQUEST_QUERY_CALL_WAITING:
            return "QUERY_CALL_WAITING";
        case RIL_REQUEST_SET_CALL_WAITING:
            return "SET_CALL_WAITING";
        case RIL_REQUEST_SMS_ACKNOWLEDGE:
            return "SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GET_IMEI:
            return "GET_IMEI";
        case RIL_REQUEST_GET_IMEISV:
            return "GET_IMEISV";
        case RIL_REQUEST_ANSWER:
            return "ANSWER";
        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
            return "DEACTIVATE_DATA_CALL";
        case RIL_REQUEST_QUERY_FACILITY_LOCK:
            return "QUERY_FACILITY_LOCK";
        case RIL_REQUEST_SET_FACILITY_LOCK:
            return "SET_FACILITY_LOCK";
        case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
            return "CHANGE_BARRING_PASSWORD";
        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
            return "QUERY_NETWORK_SELECTION_MODE";
        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
            return "SET_NETWORK_SELECTION_AUTOMATIC";
        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
            return "SET_NETWORK_SELECTION_MANUAL";
        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
            return "QUERY_AVAILABLE_NETWORKS ";
        case RIL_REQUEST_DTMF_START:
            return "DTMF_START";
        case RIL_REQUEST_DTMF_STOP:
            return "DTMF_STOP";
        case RIL_REQUEST_BASEBAND_VERSION:
            return "BASEBAND_VERSION";
        case RIL_REQUEST_SEPARATE_CONNECTION:
            return "SEPARATE_CONNECTION";
        case RIL_REQUEST_SET_MUTE:
            return "SET_MUTE";
        case RIL_REQUEST_GET_MUTE:
            return "GET_MUTE";
        case RIL_REQUEST_QUERY_CLIP:
            return "QUERY_CLIP";
        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
            return "LAST_DATA_CALL_FAIL_CAUSE";
        case RIL_REQUEST_DATA_CALL_LIST:
            return "DATA_CALL_LIST";
        case RIL_REQUEST_RESET_RADIO:
            return "RESET_RADIO";
        case RIL_REQUEST_OEM_HOOK_RAW:
            return "OEM_HOOK_RAW";
        case RIL_REQUEST_OEM_HOOK_STRINGS:
            return "OEM_HOOK_STRINGS";
        case RIL_REQUEST_SCREEN_STATE:
            return "SCREEN_STATE";
        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
            return "SET_SUPP_SVC_NOTIFICATION";
        case RIL_REQUEST_WRITE_SMS_TO_SIM:
            return "WRITE_SMS_TO_SIM";
        case RIL_REQUEST_DELETE_SMS_ON_SIM:
            return "DELETE_SMS_ON_SIM";
        case RIL_REQUEST_SET_BAND_MODE:
            return "SET_BAND_MODE";
        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
            return "QUERY_AVAILABLE_BAND_MODE";
        case RIL_REQUEST_STK_GET_PROFILE:
            return "REQUEST_STK_GET_PROFILE";
        case RIL_REQUEST_STK_SET_PROFILE:
            return "REQUEST_STK_SET_PROFILE";
        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
            return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
            return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
            return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
            return "REQUEST_EXPLICIT_CALL_TRANSFER";
        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
            return "REQUEST_GET_NEIGHBORING_CELL_IDS";
        case RIL_REQUEST_SET_LOCATION_UPDATES:
            return "REQUEST_SET_LOCATION_UPDATES";
        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
        case RIL_REQUEST_SET_TTY_MODE:
            return "RIL_REQUEST_SET_TTY_MODE";
        case RIL_REQUEST_QUERY_TTY_MODE:
            return "RIL_REQUEST_QUERY_TTY_MODE";
        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_FLASH:
            return "RIL_REQUEST_CDMA_FLASH";
        case RIL_REQUEST_CDMA_BURST_DTMF:
            return "RIL_REQUEST_CDMA_BURST_DTMF";
        case RIL_REQUEST_CDMA_SEND_SMS:
            return "RIL_REQUEST_CDMA_SEND_SMS";
        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
            return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
            return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
        case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_SUBSCRIPTION:
            return "RIL_REQUEST_CDMA_SUBSCRIPTION";
        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
            return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
            return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
        case RIL_REQUEST_DEVICE_IDENTITY:
            return "RIL_REQUEST_DEVICE_IDENTITY";
        case RIL_REQUEST_GET_SMSC_ADDRESS:
            return "RIL_REQUEST_GET_SMSC_ADDRESS";
        case RIL_REQUEST_SET_SMSC_ADDRESS:
            return "RIL_REQUEST_SET_SMSC_ADDRESS";
        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
            return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
            return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
            return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_ISIM_AUTHENTICATION:
            return "RIL_REQUEST_ISIM_AUTHENTICATION";
        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
            return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
            return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
        case RIL_REQUEST_VOICE_RADIO_TECH:
            return "RIL_REQUEST_VOICE_RADIO_TECH";
        case RIL_REQUEST_GET_CELL_INFO_LIST:
            return "RIL_REQUEST_GET_CELL_INFO_LIST";
        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
            return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
            return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
        case RIL_REQUEST_SET_DATA_PROFILE:
            return "RIL_REQUEST_SET_DATA_PROFILE";
        case RIL_REQUEST_IMS_REGISTRATION_STATE:
            return "RIL_REQUEST_IMS_REGISTRATION_STATE";
        case RIL_REQUEST_IMS_SEND_SMS:
            return "RIL_REQUEST_IMS_SEND_SMS";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
            return "RIL_REQUEST_SIM_OPEN_CHANNEL";
        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
            return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
        case RIL_REQUEST_NV_READ_ITEM:
            return "RIL_REQUEST_NV_READ_ITEM";
        case RIL_REQUEST_NV_WRITE_ITEM:
            return "RIL_REQUEST_NV_WRITE_ITEM";
        case RIL_REQUEST_NV_WRITE_CDMA_PRL:
            return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
        case RIL_REQUEST_NV_RESET_CONFIG:
            return "RIL_REQUEST_NV_RESET_CONFIG";
        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
            return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
        case RIL_REQUEST_ALLOW_DATA:
            return "RIL_REQUEST_ALLOW_DATA";
        case RIL_REQUEST_GET_HARDWARE_CONFIG:
            return "GET_HARDWARE_CONFIG";
        case RIL_REQUEST_SIM_AUTHENTICATION:
            return "RIL_REQUEST_SIM_AUTHENTICATION";
        case RIL_REQUEST_SHUTDOWN:
            return "RIL_REQUEST_SHUTDOWN";
        case RIL_REQUEST_SET_RADIO_CAPABILITY:
            return "RIL_REQUEST_SET_RADIO_CAPABILITY";
        case RIL_REQUEST_GET_RADIO_CAPABILITY:
            return "RIL_REQUEST_GET_RADIO_CAPABILITY";
        case RIL_REQUEST_START_LCE:
            return "RIL_REQUEST_START_LCE";
        case RIL_REQUEST_STOP_LCE:
            return "RIL_REQUEST_STOP_LCE";
        case RIL_REQUEST_PULL_LCEDATA:
            return "RIL_REQUEST_PULL_LCEDATA";
        case RIL_REQUEST_GET_ACTIVITY_INFO:
            return "RIL_REQUEST_GET_ACTIVITY_INFO";
        case RIL_RESPONSE_ACKNOWLEDGEMENT:
            return "RIL_RESPONSE_ACKNOWLEDGEMENT";
        default:
            return "<unknown request>";
    }
}
#method_after
static String requestToString(int request) {
    /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
*/
    switch(request) {
        case RIL_REQUEST_GET_SIM_STATUS:
            return "GET_SIM_STATUS";
        case RIL_REQUEST_ENTER_SIM_PIN:
            return "ENTER_SIM_PIN";
        case RIL_REQUEST_ENTER_SIM_PUK:
            return "ENTER_SIM_PUK";
        case RIL_REQUEST_ENTER_SIM_PIN2:
            return "ENTER_SIM_PIN2";
        case RIL_REQUEST_ENTER_SIM_PUK2:
            return "ENTER_SIM_PUK2";
        case RIL_REQUEST_CHANGE_SIM_PIN:
            return "CHANGE_SIM_PIN";
        case RIL_REQUEST_CHANGE_SIM_PIN2:
            return "CHANGE_SIM_PIN2";
        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
            return "ENTER_NETWORK_DEPERSONALIZATION";
        case RIL_REQUEST_GET_CURRENT_CALLS:
            return "GET_CURRENT_CALLS";
        case RIL_REQUEST_DIAL:
            return "DIAL";
        case RIL_REQUEST_GET_IMSI:
            return "GET_IMSI";
        case RIL_REQUEST_HANGUP:
            return "HANGUP";
        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
            return "HANGUP_WAITING_OR_BACKGROUND";
        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
            return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
            return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
        case RIL_REQUEST_CONFERENCE:
            return "CONFERENCE";
        case RIL_REQUEST_UDUB:
            return "UDUB";
        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
            return "LAST_CALL_FAIL_CAUSE";
        case RIL_REQUEST_SIGNAL_STRENGTH:
            return "SIGNAL_STRENGTH";
        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
            return "VOICE_REGISTRATION_STATE";
        case RIL_REQUEST_DATA_REGISTRATION_STATE:
            return "DATA_REGISTRATION_STATE";
        case RIL_REQUEST_OPERATOR:
            return "OPERATOR";
        case RIL_REQUEST_RADIO_POWER:
            return "RADIO_POWER";
        case RIL_REQUEST_DTMF:
            return "DTMF";
        case RIL_REQUEST_SEND_SMS:
            return "SEND_SMS";
        case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
            return "SEND_SMS_EXPECT_MORE";
        case RIL_REQUEST_SETUP_DATA_CALL:
            return "SETUP_DATA_CALL";
        case RIL_REQUEST_SIM_IO:
            return "SIM_IO";
        case RIL_REQUEST_SEND_USSD:
            return "SEND_USSD";
        case RIL_REQUEST_CANCEL_USSD:
            return "CANCEL_USSD";
        case RIL_REQUEST_GET_CLIR:
            return "GET_CLIR";
        case RIL_REQUEST_SET_CLIR:
            return "SET_CLIR";
        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
            return "QUERY_CALL_FORWARD_STATUS";
        case RIL_REQUEST_SET_CALL_FORWARD:
            return "SET_CALL_FORWARD";
        case RIL_REQUEST_QUERY_CALL_WAITING:
            return "QUERY_CALL_WAITING";
        case RIL_REQUEST_SET_CALL_WAITING:
            return "SET_CALL_WAITING";
        case RIL_REQUEST_SMS_ACKNOWLEDGE:
            return "SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GET_IMEI:
            return "GET_IMEI";
        case RIL_REQUEST_GET_IMEISV:
            return "GET_IMEISV";
        case RIL_REQUEST_ANSWER:
            return "ANSWER";
        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
            return "DEACTIVATE_DATA_CALL";
        case RIL_REQUEST_QUERY_FACILITY_LOCK:
            return "QUERY_FACILITY_LOCK";
        case RIL_REQUEST_SET_FACILITY_LOCK:
            return "SET_FACILITY_LOCK";
        case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
            return "CHANGE_BARRING_PASSWORD";
        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
            return "QUERY_NETWORK_SELECTION_MODE";
        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
            return "SET_NETWORK_SELECTION_AUTOMATIC";
        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
            return "SET_NETWORK_SELECTION_MANUAL";
        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
            return "QUERY_AVAILABLE_NETWORKS ";
        case RIL_REQUEST_DTMF_START:
            return "DTMF_START";
        case RIL_REQUEST_DTMF_STOP:
            return "DTMF_STOP";
        case RIL_REQUEST_BASEBAND_VERSION:
            return "BASEBAND_VERSION";
        case RIL_REQUEST_SEPARATE_CONNECTION:
            return "SEPARATE_CONNECTION";
        case RIL_REQUEST_SET_MUTE:
            return "SET_MUTE";
        case RIL_REQUEST_GET_MUTE:
            return "GET_MUTE";
        case RIL_REQUEST_QUERY_CLIP:
            return "QUERY_CLIP";
        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
            return "LAST_DATA_CALL_FAIL_CAUSE";
        case RIL_REQUEST_DATA_CALL_LIST:
            return "DATA_CALL_LIST";
        case RIL_REQUEST_RESET_RADIO:
            return "RESET_RADIO";
        case RIL_REQUEST_OEM_HOOK_RAW:
            return "OEM_HOOK_RAW";
        case RIL_REQUEST_OEM_HOOK_STRINGS:
            return "OEM_HOOK_STRINGS";
        case RIL_REQUEST_SCREEN_STATE:
            return "SCREEN_STATE";
        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
            return "SET_SUPP_SVC_NOTIFICATION";
        case RIL_REQUEST_WRITE_SMS_TO_SIM:
            return "WRITE_SMS_TO_SIM";
        case RIL_REQUEST_DELETE_SMS_ON_SIM:
            return "DELETE_SMS_ON_SIM";
        case RIL_REQUEST_SET_BAND_MODE:
            return "SET_BAND_MODE";
        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
            return "QUERY_AVAILABLE_BAND_MODE";
        case RIL_REQUEST_STK_GET_PROFILE:
            return "REQUEST_STK_GET_PROFILE";
        case RIL_REQUEST_STK_SET_PROFILE:
            return "REQUEST_STK_SET_PROFILE";
        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
            return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
            return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
            return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
            return "REQUEST_EXPLICIT_CALL_TRANSFER";
        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
            return "REQUEST_GET_NEIGHBORING_CELL_IDS";
        case RIL_REQUEST_SET_LOCATION_UPDATES:
            return "REQUEST_SET_LOCATION_UPDATES";
        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
        case RIL_REQUEST_SET_TTY_MODE:
            return "RIL_REQUEST_SET_TTY_MODE";
        case RIL_REQUEST_QUERY_TTY_MODE:
            return "RIL_REQUEST_QUERY_TTY_MODE";
        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_FLASH:
            return "RIL_REQUEST_CDMA_FLASH";
        case RIL_REQUEST_CDMA_BURST_DTMF:
            return "RIL_REQUEST_CDMA_BURST_DTMF";
        case RIL_REQUEST_CDMA_SEND_SMS:
            return "RIL_REQUEST_CDMA_SEND_SMS";
        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
            return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
            return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
        case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_SUBSCRIPTION:
            return "RIL_REQUEST_CDMA_SUBSCRIPTION";
        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
            return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
            return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
        case RIL_REQUEST_DEVICE_IDENTITY:
            return "RIL_REQUEST_DEVICE_IDENTITY";
        case RIL_REQUEST_GET_SMSC_ADDRESS:
            return "RIL_REQUEST_GET_SMSC_ADDRESS";
        case RIL_REQUEST_SET_SMSC_ADDRESS:
            return "RIL_REQUEST_SET_SMSC_ADDRESS";
        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
            return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
            return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
            return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_ISIM_AUTHENTICATION:
            return "RIL_REQUEST_ISIM_AUTHENTICATION";
        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
            return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
            return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
        case RIL_REQUEST_VOICE_RADIO_TECH:
            return "RIL_REQUEST_VOICE_RADIO_TECH";
        case RIL_REQUEST_GET_CELL_INFO_LIST:
            return "RIL_REQUEST_GET_CELL_INFO_LIST";
        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
            return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
            return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
        case RIL_REQUEST_SET_DATA_PROFILE:
            return "RIL_REQUEST_SET_DATA_PROFILE";
        case RIL_REQUEST_IMS_REGISTRATION_STATE:
            return "RIL_REQUEST_IMS_REGISTRATION_STATE";
        case RIL_REQUEST_IMS_SEND_SMS:
            return "RIL_REQUEST_IMS_SEND_SMS";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
            return "RIL_REQUEST_SIM_OPEN_CHANNEL";
        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
            return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
        case RIL_REQUEST_NV_READ_ITEM:
            return "RIL_REQUEST_NV_READ_ITEM";
        case RIL_REQUEST_NV_WRITE_ITEM:
            return "RIL_REQUEST_NV_WRITE_ITEM";
        case RIL_REQUEST_NV_WRITE_CDMA_PRL:
            return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
        case RIL_REQUEST_NV_RESET_CONFIG:
            return "RIL_REQUEST_NV_RESET_CONFIG";
        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
            return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
        case RIL_REQUEST_ALLOW_DATA:
            return "RIL_REQUEST_ALLOW_DATA";
        case RIL_REQUEST_GET_HARDWARE_CONFIG:
            return "GET_HARDWARE_CONFIG";
        case RIL_REQUEST_SIM_AUTHENTICATION:
            return "RIL_REQUEST_SIM_AUTHENTICATION";
        case RIL_REQUEST_SHUTDOWN:
            return "RIL_REQUEST_SHUTDOWN";
        case RIL_REQUEST_SET_RADIO_CAPABILITY:
            return "RIL_REQUEST_SET_RADIO_CAPABILITY";
        case RIL_REQUEST_GET_RADIO_CAPABILITY:
            return "RIL_REQUEST_GET_RADIO_CAPABILITY";
        case RIL_REQUEST_START_LCE:
            return "RIL_REQUEST_START_LCE";
        case RIL_REQUEST_STOP_LCE:
            return "RIL_REQUEST_STOP_LCE";
        case RIL_REQUEST_PULL_LCEDATA:
            return "RIL_REQUEST_PULL_LCEDATA";
        case RIL_REQUEST_GET_ACTIVITY_INFO:
            return "RIL_REQUEST_GET_ACTIVITY_INFO";
        case RIL_REQUEST_SET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_SET_ALLOWED_CARRIERS";
        case RIL_REQUEST_GET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_GET_ALLOWED_CARRIERS";
        case RIL_RESPONSE_ACKNOWLEDGEMENT:
            return "RIL_RESPONSE_ACKNOWLEDGEMENT";
        default:
            return "<unknown request>";
    }
}
#end_block

#method_before
static String responseToString(int request) {
    /*
 cat libs/telephony/ril_unsol_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
*/
    switch(request) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            return "UNSOL_RESPONSE_NEW_SMS";
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
        case RIL_UNSOL_ON_USSD:
            return "UNSOL_ON_USSD";
        case RIL_UNSOL_ON_USSD_REQUEST:
            return "UNSOL_ON_USSD_REQUEST";
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            return "UNSOL_NITZ_TIME_RECEIVED";
        case RIL_UNSOL_SIGNAL_STRENGTH:
            return "UNSOL_SIGNAL_STRENGTH";
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            return "UNSOL_DATA_CALL_LIST_CHANGED";
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            return "UNSOL_SUPP_SVC_NOTIFICATION";
        case RIL_UNSOL_STK_SESSION_END:
            return "UNSOL_STK_SESSION_END";
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            return "UNSOL_STK_PROACTIVE_COMMAND";
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            return "UNSOL_STK_EVENT_NOTIFY";
        case RIL_UNSOL_STK_CALL_SETUP:
            return "UNSOL_STK_CALL_SETUP";
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            return "UNSOL_SIM_SMS_STORAGE_FULL";
        case RIL_UNSOL_SIM_REFRESH:
            return "UNSOL_SIM_REFRESH";
        case RIL_UNSOL_CALL_RING:
            return "UNSOL_CALL_RING";
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            return "UNSOL_RESPONSE_CDMA_NEW_SMS";
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            return "UNSOL_RESTRICTED_STATE_CHANGED";
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
        case RIL_UNSOL_CDMA_CALL_WAITING:
            return "UNSOL_CDMA_CALL_WAITING";
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            return "UNSOL_CDMA_OTA_PROVISION_STATUS";
        case RIL_UNSOL_CDMA_INFO_REC:
            return "UNSOL_CDMA_INFO_REC";
        case RIL_UNSOL_OEM_HOOK_RAW:
            return "UNSOL_OEM_HOOK_RAW";
        case RIL_UNSOL_RINGBACK_TONE:
            return "UNSOL_RINGBACK_TONE";
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            return "UNSOL_RESEND_INCALL_MUTE";
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            return "UNSOL_CDMA_PRL_CHANGED";
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_UNSOL_RIL_CONNECTED:
            return "UNSOL_RIL_CONNECTED";
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            return "UNSOL_VOICE_RADIO_TECH_CHANGED";
        case RIL_UNSOL_CELL_INFO_LIST:
            return "UNSOL_CELL_INFO_LIST";
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            return "UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED";
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            return "RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            return "UNSOL_SRVCC_STATE_NOTIFY";
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
        case RIL_UNSOL_RADIO_CAPABILITY:
            return "RIL_UNSOL_RADIO_CAPABILITY";
        case RIL_UNSOL_ON_SS:
            return "UNSOL_ON_SS";
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            return "UNSOL_STK_CC_ALPHA_NOTIFY";
        case RIL_UNSOL_LCEDATA_RECV:
            return "UNSOL_LCE_INFO_RECV";
        default:
            return "<unknown response>";
    }
}
#method_after
static String responseToString(int request) {
    /*
 cat libs/telephony/ril_unsol_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
*/
    switch(request) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            return "UNSOL_RESPONSE_NEW_SMS";
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
        case RIL_UNSOL_ON_USSD:
            return "UNSOL_ON_USSD";
        case RIL_UNSOL_ON_USSD_REQUEST:
            return "UNSOL_ON_USSD_REQUEST";
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            return "UNSOL_NITZ_TIME_RECEIVED";
        case RIL_UNSOL_SIGNAL_STRENGTH:
            return "UNSOL_SIGNAL_STRENGTH";
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            return "UNSOL_DATA_CALL_LIST_CHANGED";
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            return "UNSOL_SUPP_SVC_NOTIFICATION";
        case RIL_UNSOL_STK_SESSION_END:
            return "UNSOL_STK_SESSION_END";
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            return "UNSOL_STK_PROACTIVE_COMMAND";
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            return "UNSOL_STK_EVENT_NOTIFY";
        case RIL_UNSOL_STK_CALL_SETUP:
            return "UNSOL_STK_CALL_SETUP";
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            return "UNSOL_SIM_SMS_STORAGE_FULL";
        case RIL_UNSOL_SIM_REFRESH:
            return "UNSOL_SIM_REFRESH";
        case RIL_UNSOL_CALL_RING:
            return "UNSOL_CALL_RING";
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            return "UNSOL_RESPONSE_CDMA_NEW_SMS";
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            return "UNSOL_RESTRICTED_STATE_CHANGED";
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
        case RIL_UNSOL_CDMA_CALL_WAITING:
            return "UNSOL_CDMA_CALL_WAITING";
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            return "UNSOL_CDMA_OTA_PROVISION_STATUS";
        case RIL_UNSOL_CDMA_INFO_REC:
            return "UNSOL_CDMA_INFO_REC";
        case RIL_UNSOL_OEM_HOOK_RAW:
            return "UNSOL_OEM_HOOK_RAW";
        case RIL_UNSOL_RINGBACK_TONE:
            return "UNSOL_RINGBACK_TONE";
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            return "UNSOL_RESEND_INCALL_MUTE";
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            return "UNSOL_CDMA_PRL_CHANGED";
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_UNSOL_RIL_CONNECTED:
            return "UNSOL_RIL_CONNECTED";
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            return "UNSOL_VOICE_RADIO_TECH_CHANGED";
        case RIL_UNSOL_CELL_INFO_LIST:
            return "UNSOL_CELL_INFO_LIST";
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            return "UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED";
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            return "RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            return "UNSOL_SRVCC_STATE_NOTIFY";
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
        case RIL_UNSOL_RADIO_CAPABILITY:
            return "RIL_UNSOL_RADIO_CAPABILITY";
        case RIL_UNSOL_ON_SS:
            return "UNSOL_ON_SS";
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            return "UNSOL_STK_CC_ALPHA_NOTIFY";
        case RIL_UNSOL_LCEDATA_RECV:
            return "UNSOL_LCE_INFO_RECV";
        case RIL_UNSOL_PCO_DATA:
            return "UNSOL_PCO_DATA";
        default:
            return "<unknown response>";
    }
}
#end_block

#method_before
private void riljLog(String msg) {
    Rlog.d(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#method_after
void riljLog(String msg) {
    Rlog.d(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#end_block

#method_before
private void riljLogv(String msg) {
    Rlog.v(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#method_after
void riljLogv(String msg) {
    Rlog.v(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#end_block

#method_before
private void unsljLog(int response) {
    riljLog("[UNSL]< " + responseToString(response));
}
#method_after
void unsljLog(int response) {
    riljLog("[UNSL]< " + responseToString(response));
}
#end_block

#method_before
private void unsljLogMore(int response, String more) {
    riljLog("[UNSL]< " + responseToString(response) + " " + more);
}
#method_after
void unsljLogMore(int response, String more) {
    riljLog("[UNSL]< " + responseToString(response) + " " + more);
}
#end_block

#method_before
private void unsljLogRet(int response, Object ret) {
    riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#method_after
void unsljLogRet(int response, Object ret) {
    riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#end_block

#method_before
private void unsljLogvRet(int response, Object ret) {
    riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#method_after
void unsljLogvRet(int response, Object ret) {
    riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#end_block

#method_before
private NetworkCapabilities networkCapabilitiesForFeature(int networkType, String feature) {
    if (networkType == TYPE_MOBILE) {
        int cap = -1;
        if ("enableMMS".equals(feature)) {
            cap = NetworkCapabilities.NET_CAPABILITY_MMS;
        } else if ("enableSUPL".equals(feature)) {
            cap = NetworkCapabilities.NET_CAPABILITY_SUPL;
        } else if ("enableDUN".equals(feature) || "enableDUNAlways".equals(feature)) {
            cap = NetworkCapabilities.NET_CAPABILITY_DUN;
        } else if ("enableHIPRI".equals(feature)) {
            cap = NetworkCapabilities.NET_CAPABILITY_INTERNET;
        } else if ("enableFOTA".equals(feature)) {
            cap = NetworkCapabilities.NET_CAPABILITY_FOTA;
        } else if ("enableIMS".equals(feature)) {
            cap = NetworkCapabilities.NET_CAPABILITY_IMS;
        } else if ("enableCBS".equals(feature)) {
            cap = NetworkCapabilities.NET_CAPABILITY_CBS;
        } else {
            return null;
        }
        NetworkCapabilities netCap = new NetworkCapabilities();
        netCap.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR).addCapability(cap);
        netCap.maybeMarkCapabilitiesRestricted();
        return netCap;
    } else if (networkType == TYPE_WIFI) {
        if ("p2p".equals(feature)) {
            NetworkCapabilities netCap = new NetworkCapabilities();
            netCap.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
            netCap.addCapability(NetworkCapabilities.NET_CAPABILITY_WIFI_P2P);
            netCap.maybeMarkCapabilitiesRestricted();
            return netCap;
        }
    }
    return null;
}
#method_after
private NetworkCapabilities networkCapabilitiesForFeature(int networkType, String feature) {
    if (networkType == TYPE_MOBILE) {
        switch(feature) {
            case "enableCBS":
                return networkCapabilitiesForType(TYPE_MOBILE_CBS);
            case "enableDUN":
            case "enableDUNAlways":
                return networkCapabilitiesForType(TYPE_MOBILE_DUN);
            case "enableFOTA":
                return networkCapabilitiesForType(TYPE_MOBILE_FOTA);
            case "enableHIPRI":
                return networkCapabilitiesForType(TYPE_MOBILE_HIPRI);
            case "enableIMS":
                return networkCapabilitiesForType(TYPE_MOBILE_IMS);
            case "enableMMS":
                return networkCapabilitiesForType(TYPE_MOBILE_MMS);
            case "enableSUPL":
                return networkCapabilitiesForType(TYPE_MOBILE_SUPL);
            default:
                return null;
        }
    } else if (networkType == TYPE_WIFI && "p2p".equals(feature)) {
        return networkCapabilitiesForType(TYPE_WIFI_P2P);
    }
    return null;
}
#end_block

#method_before
public static NetworkCapabilities networkCapabilitiesForType(int type) {
    final NetworkCapabilities nc = new NetworkCapabilities();
    // Map from type to transports.
    switch(type) {
        case TYPE_MOBILE:
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
            nc.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
            break;
        case TYPE_WIFI:
        case TYPE_WIFI_P2P:
            nc.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
            break;
        case TYPE_BLUETOOTH:
            nc.addTransportType(NetworkCapabilities.TRANSPORT_BLUETOOTH);
            break;
        case TYPE_ETHERNET:
            nc.addTransportType(NetworkCapabilities.TRANSPORT_ETHERNET);
            break;
        default:
            return null;
    }
    // Map from type to capabilities.
    switch(type) {
        case TYPE_MOBILE_DUN:
            nc.addCapability(NetworkCapabilities.NET_CAPABILITY_DUN);
            nc.removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED);
            break;
        case TYPE_WIFI_P2P:
            nc.addCapability(NetworkCapabilities.NET_CAPABILITY_WIFI_P2P);
            break;
        default:
            nc.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
    }
    return nc;
}
#method_after
public static NetworkCapabilities networkCapabilitiesForType(int type) {
    final NetworkCapabilities nc = new NetworkCapabilities();
    // Map from type to transports.
    final int NOT_FOUND = -1;
    final int transport = sLegacyTypeToTransport.get(type, NOT_FOUND);
    if (transport == NOT_FOUND) {
        throw new IllegalArgumentException("unknown legacy type: " + type);
    }
    nc.addTransportType(transport);
    // Map from type to capabilities.
    nc.addCapability(sLegacyTypeToCapability.get(type, NetworkCapabilities.NET_CAPABILITY_INTERNET));
    nc.maybeMarkCapabilitiesRestricted();
    return nc;
}
#end_block

#method_before
public void start() {
    stop();
    mDefaultNetworkCallback = new UpstreamNetworkCallback();
    cm().registerDefaultNetworkCallback(mDefaultNetworkCallback);
    final NetworkRequest dunTetheringRequest = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR).removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED).addCapability(NetworkCapabilities.NET_CAPABILITY_DUN).build();
    mDunTetheringCallback = new UpstreamNetworkCallback();
    cm().registerNetworkCallback(dunTetheringRequest, mDunTetheringCallback);
}
#method_after
public void start() {
    stop();
    final NetworkRequest listenAllRequest = new NetworkRequest.Builder().clearCapabilities().build();
    mListenAllCallback = new UpstreamNetworkCallback(CALLBACK_LISTEN_ALL);
    cm().registerNetworkCallback(listenAllRequest, mListenAllCallback);
    mDefaultNetworkCallback = new UpstreamNetworkCallback(CALLBACK_TRACK_DEFAULT);
    cm().registerDefaultNetworkCallback(mDefaultNetworkCallback);
}
#end_block

#method_before
public void stop() {
    releaseMobileNetworkRequest();
    releaseCallback(mDefaultNetworkCallback);
    mDefaultNetworkCallback = null;
    releaseCallback(mDunTetheringCallback);
    mDunTetheringCallback = null;
    mNetworkMap.clear();
}
#method_after
public void stop() {
    releaseMobileNetworkRequest();
    releaseCallback(mDefaultNetworkCallback);
    mDefaultNetworkCallback = null;
    releaseCallback(mListenAllCallback);
    mListenAllCallback = null;
    mNetworkMap.clear();
}
#end_block

#method_before
public void registerMobileNetworkRequest() {
    if (mMobileNetworkCallback != null) {
        Log.e(TAG, "registerMobileNetworkRequest() already registered");
        return;
    }
    // The following use of the legacy type system cannot be removed until
    // after upstream selection no longer finds networks by legacy type.
    // See also b/34364553.
    final int legacyType = mDunRequired ? TYPE_MOBILE_DUN : TYPE_MOBILE_HIPRI;
    final NetworkRequest mobileUpstreamRequest = new NetworkRequest.Builder().setCapabilities(ConnectivityManager.networkCapabilitiesForType(legacyType)).build();
    // The existing default network and DUN callbacks will be notified.
    // Therefore, to avoid duplicate notifications, we only register a no-op.
    mMobileNetworkCallback = new NetworkCallback();
    // TODO: Change the timeout from 0 (no onUnavailable callback) to some
    // moderate callback timeout. This might be useful for updating some UI.
    // Additionally, we log a message to aid in any subsequent debugging.
    Log.d(TAG, "requesting mobile upstream network: " + mobileUpstreamRequest);
    cm().requestNetwork(mobileUpstreamRequest, mMobileNetworkCallback, 0, legacyType);
}
#method_after
public void registerMobileNetworkRequest() {
    if (mMobileNetworkCallback != null) {
        Log.e(TAG, "registerMobileNetworkRequest() already registered");
        return;
    }
    // The following use of the legacy type system cannot be removed until
    // after upstream selection no longer finds networks by legacy type.
    // See also http://b/34364553 .
    final int legacyType = mDunRequired ? TYPE_MOBILE_DUN : TYPE_MOBILE_HIPRI;
    final NetworkRequest mobileUpstreamRequest = new NetworkRequest.Builder().setCapabilities(ConnectivityManager.networkCapabilitiesForType(legacyType)).build();
    // The existing default network and DUN callbacks will be notified.
    // Therefore, to avoid duplicate notifications, we only register a no-op.
    mMobileNetworkCallback = new UpstreamNetworkCallback(CALLBACK_MOBILE_REQUEST);
    // TODO: Change the timeout from 0 (no onUnavailable callback) to some
    // moderate callback timeout. This might be useful for updating some UI.
    // Additionally, we log a message to aid in any subsequent debugging.
    Log.d(TAG, "requesting mobile upstream network: " + mobileUpstreamRequest);
    cm().requestNetwork(mobileUpstreamRequest, mMobileNetworkCallback, 0, legacyType);
}
#end_block

#method_before
private void handleAvailable(Network network) {
    if (VDBG) {
        Log.d(TAG, "EVENT_ON_AVAILABLE for " + network);
    }
    if (!mNetworkMap.containsKey(network)) {
        mNetworkMap.put(network, new NetworkState(null, null, null, network, null, null));
    }
    final ConnectivityManager cm = cm();
    if (mDefaultNetworkCallback != null) {
        cm.requestNetworkCapabilities(mDefaultNetworkCallback);
        cm.requestLinkProperties(mDefaultNetworkCallback);
    }
    // Requesting updates for mDunTetheringCallback is not
    // necessary. Because it's a listen, it will already have
    // heard all NetworkCapabilities and LinkProperties updates
    // since UpstreamNetworkMonitor was started. Because we
    // start UpstreamNetworkMonitor before chooseUpstreamType()
    // is ever invoked (it can register a DUN request) this is
    // mostly safe. However, if a DUN network is already up for
    // some reason (unlikely, because DUN is restricted and,
    // unless the DUN network is shared with another APN, only
    // the system can request it and this is the only part of
    // the system that requests it) we won't know its
    // LinkProperties or NetworkCapabilities.
    notifyTarget(EVENT_ON_AVAILABLE, network);
}
#method_after
private void handleAvailable(int callbackType, Network network) {
    if (VDBG)
        Log.d(TAG, "EVENT_ON_AVAILABLE for " + network);
    if (!mNetworkMap.containsKey(network)) {
        mNetworkMap.put(network, new NetworkState(null, null, null, network, null, null));
    }
    // not have been notified of any information that had not changed.
    switch(callbackType) {
        case CALLBACK_LISTEN_ALL:
            break;
        case CALLBACK_TRACK_DEFAULT:
            cm().requestNetworkCapabilities(mDefaultNetworkCallback);
            cm().requestLinkProperties(mDefaultNetworkCallback);
            mCurrentDefault = network;
            break;
        case CALLBACK_MOBILE_REQUEST:
            cm().requestNetworkCapabilities(mMobileNetworkCallback);
            cm().requestLinkProperties(mMobileNetworkCallback);
            break;
    }
    // Requesting updates for mListenAllCallback is not currently possible
    // because it's a "listen". Two possible solutions to getting updates
    // about networks without waiting for a change (which might never come)
    // are:
    // 
    // [1] extend request{NetworkCapabilities,LinkProperties}() to
    // take a Network argument and have ConnectivityService do
    // what's required (if the network satisfies the request)
    // 
    // [2] explicitly file a NetworkRequest for each connectivity type
    // listed as a preferred upstream and wait for these callbacks
    // to be notified (requires tracking many more callbacks).
    // 
    // Until this is addressed, networks that exist prior to the "listen"
    // registration and which do not subsequently change will not cause
    // us to learn their NetworkCapabilities nor their LinkProperties.
    // TODO: If sufficient information is available to select a more
    // preferable upstream, do so now and notify the target.
    notifyTarget(EVENT_ON_AVAILABLE, network);
}
#end_block

#method_before
private void handleNetCap(Network network, NetworkCapabilities newNc) {
    if (!mNetworkMap.containsKey(network)) {
        // or for which we have already received onLost().
        return;
    }
    if (VDBG) {
        Log.d(TAG, String.format("EVENT_ON_CAPABILITIES for %s: %s", network, newNc));
    }
    final NetworkState prev = mNetworkMap.get(network);
    mNetworkMap.put(network, new NetworkState(null, prev.linkProperties, newNc, network, null, null));
    notifyTarget(EVENT_ON_CAPABILITIES, network);
}
#method_after
private void handleNetCap(Network network, NetworkCapabilities newNc) {
    final NetworkState prev = mNetworkMap.get(network);
    if (prev == null || newNc.equals(prev.networkCapabilities)) {
        // notifications (e.g. matching more than one of our callbacks).
        return;
    }
    if (VDBG) {
        Log.d(TAG, String.format("EVENT_ON_CAPABILITIES for %s: %s", network, newNc));
    }
    mNetworkMap.put(network, new NetworkState(null, prev.linkProperties, newNc, network, null, null));
    // TODO: If sufficient information is available to select a more
    // preferable upstream, do so now and notify the target.
    notifyTarget(EVENT_ON_CAPABILITIES, network);
}
#end_block

#method_before
private void handleLinkProp(Network network, LinkProperties newLp) {
    if (!mNetworkMap.containsKey(network)) {
        // or for which we have already received onLost().
        return;
    }
    if (VDBG) {
        Log.d(TAG, String.format("EVENT_ON_LINKPROPERTIES for %s: %s", network, newLp));
    }
    final NetworkState prev = mNetworkMap.get(network);
    mNetworkMap.put(network, new NetworkState(null, newLp, prev.networkCapabilities, network, null, null));
    notifyTarget(EVENT_ON_LINKPROPERTIES, network);
}
#method_after
private void handleLinkProp(Network network, LinkProperties newLp) {
    final NetworkState prev = mNetworkMap.get(network);
    if (prev == null || newLp.equals(prev.linkProperties)) {
        // notifications (e.g. matching more than one of our callbacks).
        return;
    }
    if (VDBG) {
        Log.d(TAG, String.format("EVENT_ON_LINKPROPERTIES for %s: %s", network, newLp));
    }
    mNetworkMap.put(network, new NetworkState(null, newLp, prev.networkCapabilities, network, null, null));
    // TODO: If sufficient information is available to select a more
    // preferable upstream, do so now and notify the target.
    notifyTarget(EVENT_ON_LINKPROPERTIES, network);
}
#end_block

#method_before
private void handleLost(Network network) {
    if (!mNetworkMap.containsKey(network)) {
        // or for which we have already received onLost().
        return;
    }
    if (VDBG) {
        Log.d(TAG, "EVENT_ON_LOST for " + network);
    }
    notifyTarget(EVENT_ON_LOST, mNetworkMap.remove(network));
}
#method_after
private void handleLost(int callbackType, Network network) {
    if (callbackType == CALLBACK_TRACK_DEFAULT) {
        mCurrentDefault = null;
        // clearing all state.
        return;
    }
    if (!mNetworkMap.containsKey(network)) {
        // an onLost() notification.
        return;
    }
    if (VDBG)
        Log.d(TAG, "EVENT_ON_LOST for " + network);
    // TODO: If sufficient information is available to select a more
    // preferable upstream, do so now and notify the target.  Likewise,
    // if the current upstream network is gone, notify the target of the
    // fact that we now have no upstream at all.
    notifyTarget(EVENT_ON_LOST, mNetworkMap.remove(network));
}
#end_block

#method_before
@Override
public void onAvailable(Network network) {
    mTarget.getHandler().post(() -> handleAvailable(network));
}
#method_after
@Override
public void onAvailable(Network network) {
    mTarget.getHandler().post(() -> handleAvailable(mCallbackType, network));
}
#end_block

#method_before
@Override
public void onLost(Network network) {
    mTarget.getHandler().post(() -> handleLost(network));
}
#method_after
@Override
public void onLost(Network network) {
    mTarget.getHandler().post(() -> handleLost(mCallbackType, network));
}
#end_block

#method_before
public void checkAndStartWifi() {
    /* Check if wi-fi needs to be enabled */
    boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
    Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled"));
    registerForScanModeChange();
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (mSettingsStore.handleAirplaneModeToggled()) {
                mWifiController.sendMessage(CMD_AIRPLANE_TOGGLED);
            }
            if (mSettingsStore.isAirplaneModeOn()) {
                Log.d(TAG, "resetting country code because Airplane mode is ON");
                mCountryCode.airplaneModeEnabled();
            }
        }
    }, new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
            if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was removed");
                mWifiStateMachine.resetSimAuthNetworks(false);
                Log.d(TAG, "resetting country code because SIM is removed");
                mCountryCode.simCardRemoved();
            } else if (IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was loaded");
                mWifiStateMachine.resetSimAuthNetworks(true);
            }
        }
    }, new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));
    // Adding optimizations of only receiving broadcasts when wifi is enabled
    // can result in race conditions when apps toggle wifi in the background
    // without active user involvement. Always receive broadcasts.
    registerForBroadcasts();
    registerForPackageOrUserRemoval();
    mInIdleMode = mPowerManager.isDeviceIdleMode();
    mWifiController.start();
    mWifiStateMachine.initialize();
    // state here
    if (wifiEnabled) {
        try {
            setWifiEnabled(mContext.getPackageName(), wifiEnabled);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
    }
}
#method_after
public void checkAndStartWifi() {
    /* Check if wi-fi needs to be enabled */
    boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
    Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled"));
    registerForScanModeChange();
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (mSettingsStore.handleAirplaneModeToggled()) {
                mWifiController.sendMessage(CMD_AIRPLANE_TOGGLED);
            }
            if (mSettingsStore.isAirplaneModeOn()) {
                Log.d(TAG, "resetting country code because Airplane mode is ON");
                mCountryCode.airplaneModeEnabled();
            }
        }
    }, new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
            if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was removed");
                mWifiStateMachine.resetSimAuthNetworks(false);
                Log.d(TAG, "resetting country code because SIM is removed");
                mCountryCode.simCardRemoved();
            } else if (IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was loaded");
                mWifiStateMachine.resetSimAuthNetworks(true);
            }
        }
    }, new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));
    // Adding optimizations of only receiving broadcasts when wifi is enabled
    // can result in race conditions when apps toggle wifi in the background
    // without active user involvement. Always receive broadcasts.
    registerForBroadcasts();
    registerForPackageOrUserRemoval();
    mInIdleMode = mPowerManager.isDeviceIdleMode();
    if (!mWifiStateMachine.syncInitialize(mWifiStateMachineChannel)) {
        Log.wtf(TAG, "Failed to initialize WifiStateMachine");
    }
    mWifiController.start();
    // state here
    if (wifiEnabled) {
        try {
            setWifiEnabled(mContext.getPackageName(), wifiEnabled);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Log.d(TAG, "Setting up ...");
    // Ensure looper exists
    mLooper = new TestLooper();
    MockitoAnnotations.initMocks(this);
    /**
     * uncomment this to enable logs from WifiStateMachines
     */
    // enableDebugLogs();
    mWifiMonitor = new MockWifiMonitor();
    when(mWifiInjector.getWifiMetrics()).thenReturn(mWifiMetrics);
    when(mWifiInjector.getClock()).thenReturn(mock(Clock.class));
    when(mWifiInjector.getWifiLastResortWatchdog()).thenReturn(mWifiLastResortWatchdog);
    when(mWifiInjector.getPropertyService()).thenReturn(mPropertyService);
    when(mWifiInjector.getBuildProperties()).thenReturn(mBuildProperties);
    when(mWifiInjector.getKeyStore()).thenReturn(mock(KeyStore.class));
    when(mWifiInjector.getWifiBackupRestore()).thenReturn(mock(WifiBackupRestore.class));
    when(mWifiInjector.makeWifiDiagnostics(anyObject())).thenReturn(mock(BaseWifiDiagnostics.class));
    when(mWifiInjector.makeWificond()).thenReturn(mWificond);
    when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
    when(mWifiInjector.getWifiSupplicantControl()).thenReturn(mWifiSupplicantControl);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    when(mWifiInjector.getWifiNetworkSelector()).thenReturn(mock(WifiNetworkSelector.class));
    when(mWifiInjector.makeWifiConnectivityManager(any(WifiInfo.class), anyBoolean())).thenReturn(mWifiConnectivityManager);
    when(mWifiNative.getInterfaceName()).thenReturn("mockWlan");
    when(mWifiSupplicantControl.getFrameworkNetworkId(anyInt())).thenReturn(0);
    FrameworkFacade factory = getFrameworkFacade();
    Context context = getContext();
    Resources resources = getMockResources();
    when(context.getResources()).thenReturn(resources);
    when(factory.getIntegerSetting(context, Settings.Global.WIFI_FREQUENCY_BAND, WifiManager.WIFI_FREQUENCY_BAND_AUTO)).thenReturn(WifiManager.WIFI_FREQUENCY_BAND_AUTO);
    when(factory.makeApConfigStore(eq(context), eq(mBackupManagerProxy))).thenReturn(mApConfigStore);
    when(factory.makeSupplicantStateTracker(any(Context.class), any(WifiConfigManager.class), any(Handler.class))).thenReturn(mSupplicantStateTracker);
    when(mUserManager.getProfileParent(11)).thenReturn(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0));
    when(mUserManager.getProfiles(UserHandle.USER_SYSTEM)).thenReturn(Arrays.asList(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0), new UserInfo(11, "managed profile", 0)));
    when(mWificond.createClientInterface()).thenReturn(mClientInterface);
    when(mClientInterface.asBinder()).thenReturn(mClientInterfaceBinder);
    when(mClientInterface.enableSupplicant()).thenReturn(true);
    when(mClientInterface.disableSupplicant()).thenReturn(true);
    mWsm = new WifiStateMachine(context, factory, mLooper.getLooper(), mUserManager, mWifiInjector, mBackupManagerProxy, mCountryCode, mWifiNative);
    mWsmThread = getWsmHandlerThread(mWsm);
    final AsyncChannel channel = new AsyncChannel();
    Handler handler = new Handler(mLooper.getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        mWsmAsyncChannel = channel;
                    } else {
                        Log.d(TAG, "Failed to connect Command channel " + this);
                    }
                    break;
                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
                    Log.d(TAG, "Command channel disconnected" + this);
                    break;
            }
        }
    };
    channel.connect(context, handler, mWsm.getMessenger());
    mLooper.dispatchAll();
    /* Now channel is supposed to be connected */
    mBinderToken = Binder.clearCallingIdentity();
}
#method_after
@Before
public void setUp() throws Exception {
    Log.d(TAG, "Setting up ...");
    // Ensure looper exists
    mLooper = new TestLooper();
    MockitoAnnotations.initMocks(this);
    /**
     * uncomment this to enable logs from WifiStateMachines
     */
    // enableDebugLogs();
    mWifiMonitor = new MockWifiMonitor();
    when(mWifiInjector.getWifiMetrics()).thenReturn(mWifiMetrics);
    when(mWifiInjector.getClock()).thenReturn(mock(Clock.class));
    when(mWifiInjector.getWifiLastResortWatchdog()).thenReturn(mWifiLastResortWatchdog);
    when(mWifiInjector.getPropertyService()).thenReturn(mPropertyService);
    when(mWifiInjector.getBuildProperties()).thenReturn(mBuildProperties);
    when(mWifiInjector.getKeyStore()).thenReturn(mock(KeyStore.class));
    when(mWifiInjector.getWifiBackupRestore()).thenReturn(mock(WifiBackupRestore.class));
    when(mWifiInjector.makeWifiDiagnostics(anyObject())).thenReturn(mock(BaseWifiDiagnostics.class));
    when(mWifiInjector.makeWificond()).thenReturn(mWificond);
    when(mWifiInjector.getWifiConfigManager()).thenReturn(mWifiConfigManager);
    when(mWifiInjector.getWifiSupplicantControl()).thenReturn(mWifiSupplicantControl);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    when(mWifiInjector.getWifiNetworkSelector()).thenReturn(mock(WifiNetworkSelector.class));
    when(mWifiInjector.makeWifiConnectivityManager(any(WifiInfo.class), anyBoolean())).thenReturn(mWifiConnectivityManager);
    when(mWifiInjector.makeSoftApManager(any(INetworkManagementService.class), any(SoftApManager.Listener.class), any(IApInterface.class), any(WifiConfiguration.class))).thenReturn(mSoftApManager);
    when(mWifiNative.getInterfaceName()).thenReturn("mockWlan");
    when(mWifiSupplicantControl.getFrameworkNetworkId(anyInt())).thenReturn(0);
    FrameworkFacade factory = getFrameworkFacade();
    Context context = getContext();
    Resources resources = getMockResources();
    when(context.getResources()).thenReturn(resources);
    when(factory.getIntegerSetting(context, Settings.Global.WIFI_FREQUENCY_BAND, WifiManager.WIFI_FREQUENCY_BAND_AUTO)).thenReturn(WifiManager.WIFI_FREQUENCY_BAND_AUTO);
    when(factory.makeApConfigStore(eq(context), eq(mBackupManagerProxy))).thenReturn(mApConfigStore);
    when(factory.makeSupplicantStateTracker(any(Context.class), any(WifiConfigManager.class), any(Handler.class))).thenReturn(mSupplicantStateTracker);
    when(mUserManager.getProfileParent(11)).thenReturn(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0));
    when(mUserManager.getProfiles(UserHandle.USER_SYSTEM)).thenReturn(Arrays.asList(new UserInfo(UserHandle.USER_SYSTEM, "owner", 0), new UserInfo(11, "managed profile", 0)));
    when(mWificond.createApInterface()).thenReturn(mApInterface);
    when(mApInterface.asBinder()).thenReturn(mApInterfaceBinder);
    when(mWificond.createClientInterface()).thenReturn(mClientInterface);
    when(mClientInterface.asBinder()).thenReturn(mClientInterfaceBinder);
    when(mClientInterface.enableSupplicant()).thenReturn(true);
    when(mClientInterface.disableSupplicant()).thenReturn(true);
    mWsm = new WifiStateMachine(context, factory, mLooper.getLooper(), mUserManager, mWifiInjector, mBackupManagerProxy, mCountryCode, mWifiNative);
    mWsmThread = getWsmHandlerThread(mWsm);
    final AsyncChannel channel = new AsyncChannel();
    Handler handler = new Handler(mLooper.getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            switch(msg.what) {
                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        mWsmAsyncChannel = channel;
                    } else {
                        Log.d(TAG, "Failed to connect Command channel " + this);
                    }
                    break;
                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
                    Log.d(TAG, "Command channel disconnected" + this);
                    break;
            }
        }
    };
    channel.connect(context, handler, mWsm.getMessenger());
    mLooper.dispatchAll();
    /* Now channel is supposed to be connected */
    mBinderToken = Binder.clearCallingIdentity();
}
#end_block

#method_before
private void addNetworkAndVerifySuccess(boolean isHidden) throws Exception {
    loadComponents();
    WifiConfiguration config = new WifiConfiguration();
    config.SSID = sSSID;
    config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
    config.hiddenSSID = isHidden;
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(0));
    when(mWifiConfigManager.getSavedNetworks()).thenReturn(Arrays.asList(config));
    when(mWifiConfigManager.getConfiguredNetwork(0)).thenReturn(config);
    mLooper.startAutoDispatch();
    mWsm.syncAddOrUpdateNetwork(mWsmAsyncChannel, config);
    mLooper.stopAutoDispatch();
    verify(mWifiConfigManager).addOrUpdateNetwork(eq(config), anyInt());
    mLooper.startAutoDispatch();
    List<WifiConfiguration> configs = mWsm.syncGetConfiguredNetworks(-1, mWsmAsyncChannel);
    mLooper.stopAutoDispatch();
    assertEquals(1, configs.size());
    WifiConfiguration config2 = configs.get(0);
    assertEquals("\"GoogleGuest\"", config2.SSID);
    assertTrue(config2.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE));
}
#method_after
private void addNetworkAndVerifySuccess(boolean isHidden) throws Exception {
    loadComponentsInStaMode();
    WifiConfiguration config = new WifiConfiguration();
    config.SSID = sSSID;
    config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
    config.hiddenSSID = isHidden;
    when(mWifiConfigManager.addOrUpdateNetwork(any(WifiConfiguration.class), anyInt())).thenReturn(new NetworkUpdateResult(0));
    when(mWifiConfigManager.getSavedNetworks()).thenReturn(Arrays.asList(config));
    when(mWifiConfigManager.getConfiguredNetwork(0)).thenReturn(config);
    mLooper.startAutoDispatch();
    mWsm.syncAddOrUpdateNetwork(mWsmAsyncChannel, config);
    mLooper.stopAutoDispatch();
    verify(mWifiConfigManager).addOrUpdateNetwork(eq(config), anyInt());
    mLooper.startAutoDispatch();
    List<WifiConfiguration> configs = mWsm.syncGetConfiguredNetworks(-1, mWsmAsyncChannel);
    mLooper.stopAutoDispatch();
    assertEquals(1, configs.size());
    WifiConfiguration config2 = configs.get(0);
    assertEquals("\"GoogleGuest\"", config2.SSID);
    assertTrue(config2.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE));
}
#end_block

#method_before
public boolean initializeVendorHal() {
    return mWifiVendorHal.initialize();
}
#method_after
public boolean initializeVendorHal() {
    if (!HIDL_ENABLE) {
        return true;
    }
    return mWifiVendorHal.initialize();
}
#end_block

#method_before
public boolean initializeSupplicantHal() {
    return mWifiSupplicantHal.initialize();
}
#method_after
public boolean initializeSupplicantHal() {
    if (!HIDL_ENABLE) {
        return true;
    }
    return mWifiSupplicantHal.initialize();
}
#end_block

#method_before
private SupplicantState handleSupplicantStateChange(Message message) {
    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
    SupplicantState state = stateChangeResult.state;
    // Supplicant state change
    // [31-13] Reserved for future use
    // [8 - 0] Supplicant state (as defined in SupplicantState.java)
    // 50023 supplicant_state_changed (custom|1|5)
    mWifiInfo.setSupplicantState(state);
    // We should pretend we are still connected when linkDebouncing is on.
    if ((stateChangeResult.wifiSsid == null || stateChangeResult.wifiSsid.toString().isEmpty()) && isLinkDebouncing()) {
        return state;
    }
    // Network id is only valid when we start connecting
    if (SupplicantState.isConnecting(state)) {
        mWifiInfo.setNetworkId(lookupFrameworkNetworkId(stateChangeResult.networkId));
    } else {
        mWifiInfo.setNetworkId(WifiConfiguration.INVALID_NETWORK_ID);
    }
    mWifiInfo.setBSSID(stateChangeResult.BSSID);
    mWifiInfo.setSSID(stateChangeResult.wifiSsid);
    WifiConfiguration config = getCurrentWifiConfiguration();
    if (config != null) {
        mWifiInfo.setEphemeral(config.ephemeral);
        if (!mWifiInfo.getMeteredHint()) {
            // don't override the value if already set.
            mWifiInfo.setMeteredHint(config.meteredHint);
        }
    }
    mSupplicantStateTracker.sendMessage(Message.obtain(message));
    return state;
}
#method_after
private SupplicantState handleSupplicantStateChange(Message message) {
    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
    SupplicantState state = stateChangeResult.state;
    // Supplicant state change
    // [31-13] Reserved for future use
    // [8 - 0] Supplicant state (as defined in SupplicantState.java)
    // 50023 supplicant_state_changed (custom|1|5)
    mWifiInfo.setSupplicantState(state);
    // We should pretend we are still connected when linkDebouncing is on.
    if ((stateChangeResult.wifiSsid == null || stateChangeResult.wifiSsid.toString().isEmpty()) && isLinkDebouncing()) {
        return state;
    }
    // Network id is only valid when we start connecting
    if (SupplicantState.isConnecting(state)) {
        mWifiInfo.setNetworkId(lookupFrameworkNetworkId(stateChangeResult.networkId));
    } else {
        mWifiInfo.setNetworkId(WifiConfiguration.INVALID_NETWORK_ID);
    }
    mWifiInfo.setBSSID(stateChangeResult.BSSID);
    mWifiInfo.setSSID(stateChangeResult.wifiSsid);
    WifiConfiguration config = getCurrentWifiConfiguration();
    if (config != null) {
        // Set meteredHint to true if the access network type of the connecting/connected AP
        // is a chargeable public network.
        ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(config.networkId);
        if (scanDetailCache != null) {
            ScanDetail scanDetail = scanDetailCache.getScanDetail(stateChangeResult.BSSID);
            if (scanDetail != null) {
                NetworkDetail networkDetail = scanDetail.getNetworkDetail();
                if (networkDetail != null && networkDetail.getAnt() == NetworkDetail.Ant.ChargeablePublic) {
                    mWifiInfo.setMeteredHint(true);
                }
            }
        }
        mWifiInfo.setEphemeral(config.ephemeral);
        if (!mWifiInfo.getMeteredHint()) {
            // don't override the value if already set.
            mWifiInfo.setMeteredHint(config.meteredHint);
        }
    }
    mSupplicantStateTracker.sendMessage(Message.obtain(message));
    return state;
}
#end_block

#method_before
private IApInterface setupDriverForSoftAp() {
    if (mWificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IApInterface apInterface = null;
    try {
        apInterface = mWificond.createApInterface();
    } catch (RemoteException e1) {
    }
    if (apInterface == null) {
        Log.e(TAG, "Could not get IApInterface instance from wificond");
        return null;
    } else {
        Binder.allowBlocking(apInterface.asBinder());
    }
    if (!mWifiNative.startHal(false)) {
        // starting HAL is optional
        Log.e(TAG, "Failed to start HAL for AP mode");
    }
    return apInterface;
}
#method_after
private IApInterface setupDriverForSoftAp() {
    if (mWificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IApInterface apInterface = null;
    try {
        apInterface = mWificond.createApInterface();
    } catch (RemoteException e1) {
    }
    if (apInterface == null) {
        Log.e(TAG, "Could not get IApInterface instance from wificond");
        return null;
    } else {
        Binder.allowBlocking(apInterface.asBinder());
    }
    if (!mWifiNative.startHal(false)) {
        // TODO(b/34859006): Handle failures.
        Log.e(TAG, "Failed to start HAL for AP mode");
    }
    return apInterface;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            mWifiNative.initializeVendorHal();
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                        // set the operational mode and started to set up for connect mode.
                        if (mOperationalMode == CONNECT_MODE) {
                            // This message will only be handled if we are in Connect mode.
                            // If we are not in connect mode yet, this will be dropped and the
                            // ConnectMode.enter method will call to enable p2p.
                            sendMessage(CMD_ENABLE_P2P);
                        }
                    } else {
                        // TODO: We should probably do some cleanup or attempt a retry
                        // b/34283611
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay (b/34283611)
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_INITIALIZE:
            boolean ok = mWifiNative.initializeVendorHal();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_ENABLE_P2P:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            mClientInterface = setupDriverForClientMode(mWificond);
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.startHal(true)) {
                // starting HAL is optional
                Log.e(TAG, "Failed to start HAL for client mode");
            }
            try {
                if (!mClientInterface.enableSupplicant()) {
                    loge("Failed to start supplicant!");
                    setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                    cleanup();
                    break;
                }
            } catch (RemoteException e) {
                cleanup();
                break;
            }
            /**
             *                    if (!mWifiNative.initializeSupplicantHal()) {
             *                        Log.e(TAG, "Failed to start supplicant Hal");
             *                    }
             */
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            mClientInterface = setupDriverForClientMode(mWificond);
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.startHal(true)) {
                // TODO(b/34859006): Handle failures.
                Log.e(TAG, "Failed to start HAL for client mode");
            }
            try {
                if (!mClientInterface.enableSupplicant()) {
                    loge("Failed to start supplicant!");
                    setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                    cleanup();
                    break;
                }
            } catch (RemoteException e) {
                cleanup();
                break;
            }
            if (!mWifiNative.initializeSupplicantHal()) {
                Log.e(TAG, "Failed to start supplicant Hal");
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mAwareSupported) {
        if (mWifiAwareManager == null) {
            mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
        }
        if (mWifiAwareManager == null) {
            Log.e(TAG, "Can't get WifiAwareManager to enable usage!");
        } else {
            if (mOperationalMode == CONNECT_MODE) {
                mWifiAwareManager.enableUsage();
            } else {
            /*
                     * Aware state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
            }
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
@Override
public void exit() {
    mWifiDiagnostics.stopLogging();
    mIsRunning = false;
    updateBatteryWorkSource(null);
    mScanResults = new ArrayList<>();
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    mBufferedScanMsg.clear();
    if (mAwareSupported) {
        if (mWifiAwareManager == null) {
            mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
        }
        if (mWifiAwareManager == null) {
            Log.e(TAG, "Can't get WifiAwareManager (to disable usage)!");
        } else {
            mWifiAwareManager.disableUsage();
        }
    }
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    mCountryCode.setReadyForChange(false);
}
#method_after
@Override
public void exit() {
    mWifiDiagnostics.stopLogging();
    mIsRunning = false;
    updateBatteryWorkSource(null);
    mScanResults = new ArrayList<>();
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    mBufferedScanMsg.clear();
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    mCountryCode.setReadyForChange(false);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            reportConnectionAttemptStart(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_ENABLE_P2P:
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
public void grantDefaultPermissionsToEnabledImsServicesLPr(String[] packageNames, int userId) {
    Log.i(TAG, "Granting permissions to enabled ImsServices for user:" + userId);
    if (packageNames == null) {
        return;
    }
    for (String packageName : packageNames) {
        PackageParser.Package ImsServicePackage = getSystemPackageLPr(packageName);
        if (ImsServicePackage != null && doesPackageSupportRuntimePermissions(ImsServicePackage)) {
            grantRuntimePermissionsLPw(ImsServicePackage, PHONE_PERMISSIONS, userId);
            grantRuntimePermissionsLPw(ImsServicePackage, MICROPHONE_PERMISSIONS, userId);
            grantRuntimePermissionsLPw(ImsServicePackage, LOCATION_PERMISSIONS, userId);
            grantRuntimePermissionsLPw(ImsServicePackage, CAMERA_PERMISSIONS, userId);
        }
    }
}
#method_after
public void grantDefaultPermissionsToEnabledImsServicesLPr(String[] packageNames, int userId) {
    Log.i(TAG, "Granting permissions to enabled ImsServices for user:" + userId);
    if (packageNames == null) {
        return;
    }
    for (String packageName : packageNames) {
        PackageParser.Package imsServicePackage = getSystemPackageLPr(packageName);
        if (imsServicePackage != null && doesPackageSupportRuntimePermissions(imsServicePackage)) {
            grantRuntimePermissionsLPw(imsServicePackage, PHONE_PERMISSIONS, userId);
            grantRuntimePermissionsLPw(imsServicePackage, MICROPHONE_PERMISSIONS, userId);
            grantRuntimePermissionsLPw(imsServicePackage, LOCATION_PERMISSIONS, userId);
            grantRuntimePermissionsLPw(imsServicePackage, CAMERA_PERMISSIONS, userId);
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (mHomeSp != null ? mHomeSp.hashCode() : 0);
    result = 31 * result + (mCredential != null ? mCredential.hashCode() : 0);
    result = 31 * result + (mPolicy != null ? mPolicy.hashCode() : 0);
    result = 31 * result + (mSubscriptionUpdate != null ? mSubscriptionUpdate.hashCode() : 0);
    result = 31 * result + (mTrustRootCertList != null ? mTrustRootCertList.hashCode() : 0);
    result = 31 * result + mUpdateIdentifier;
    result = 31 * result + mCredentialPriority;
    result = 31 * result + (mSubscriptionType != null ? mSubscriptionType.hashCode() : 0);
    result = (int) (31 * result + mSubscriptionCreationTimeInMs);
    result = (int) (31 * result + mSubscriptionExpirationTimeInMs);
    result = (int) (31 * result + mUsageLimitUsageTimePeriodInMinutes);
    result = (int) (31 * result + mUsageLimitStartTimeInMs);
    result = (int) (31 * result + mUsageLimitDataLimit);
    result = (int) (31 * result + mUsageLimitTimeLimitInMinutes);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mHomeSp, mCredential, mPolicy, mSubscriptionUpdate, mTrustRootCertList, mUpdateIdentifier, mCredentialPriority, mSubscriptionCreationTimeInMs, mSubscriptionExpirationTimeInMs, mUsageLimitUsageTimePeriodInMinutes, mUsageLimitStartTimeInMs, mUsageLimitDataLimit, mUsageLimitTimeLimitInMinutes);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (mTag != null ? mTag.hashCode() : 0);
    result = 31 * result + (mText != null ? mText.hashCode() : 0);
    if (mChildren != null) {
        for (XMLNode child : mChildren) {
            result = 31 * result + child.hashCode();
        }
    }
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mTag, mText, mChildren);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (mMachineManaged ? 1 : 0);
    result = 31 * result + (mAbleToShare ? 1 : 0);
    result = 31 * result + mEapType;
    result = 31 * result + (mUsername != null ? mUsername.hashCode() : 0);
    result = 31 * result + (mPassword != null ? mPassword.hashCode() : 0);
    result = 31 * result + (mSoftTokenApp != null ? mSoftTokenApp.hashCode() : 0);
    result = 31 * result + (mNonEapInnerMethod != null ? mNonEapInnerMethod.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mUsername, mPassword, mMachineManaged, mSoftTokenApp, mAbleToShare, mEapType, mNonEapInnerMethod);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (mCertType != null ? mCertType.hashCode() : 0);
    result = 31 * result + Arrays.hashCode(mCertSha256Fingerprint);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mCertType, mCertSha256Fingerprint);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (mImsi != null ? mImsi.hashCode() : 0);
    result = 31 * result + mEapType;
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mImsi, mEapType);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = (int) (31 * result + mCreationTimeInMs);
    result = (int) (31 * result + mExpirationTimeInMs);
    result = 31 * result + (mCheckAAAServerCertStatus ? 1 : 0);
    result = 31 * result + (mRealm != null ? mRealm.hashCode() : 0);
    result = 31 * result + (mUserCredential != null ? mUserCredential.hashCode() : 0);
    result = 31 * result + (mCertCredential != null ? mCertCredential.hashCode() : 0);
    result = 31 * result + (mSimCredential != null ? mSimCredential.hashCode() : 0);
    result = 31 * result + getX509CertificateHashCode(mCaCertificate);
    if (mClientCertificateChain != null) {
        for (X509Certificate cert : mClientCertificateChain) {
            result = 31 * result + getX509CertificateHashCode(cert);
        }
    }
    if (mClientPrivateKey != null) {
        result = 31 * result + mClientPrivateKey.getAlgorithm().hashCode();
        result = 31 * result + Arrays.hashCode(mClientPrivateKey.getEncoded());
    }
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mRealm, mCreationTimeInMs, mExpirationTimeInMs, mCheckAAAServerCertStatus, mUserCredential, mCertCredential, mSimCredential, mCaCertificate, mClientCertificateChain, mClientPrivateKey);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (mFqdnExactMatch ? 1 : 0);
    result = 31 * result + mPriority;
    result = 31 * result + (mFqdn != null ? mFqdn.hashCode() : 0);
    result = 31 * result + (mCountries != null ? mCountries.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mFqdn, mFqdnExactMatch, mPriority, mCountries);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = (int) (31 * result + mMinHomeDownlinkBandwidth);
    result = (int) (31 * result + mMinHomeUplinkBandwidth);
    result = (int) (31 * result + mMinRoamingDownlinkBandwidth);
    result = (int) (31 * result + mMinRoamingUplinkBandwidth);
    result = 31 * result + mMaximumBssLoadValue;
    result = 31 * result + Arrays.hashCode(mExcludedSsidList);
    result = 31 * result + (mRequiredProtoPortMap != null ? mRequiredProtoPortMap.hashCode() : 0);
    result = 31 * result + (mPreferredRoamingPartnerList != null ? mPreferredRoamingPartnerList.hashCode() : 0);
    result = 31 * result + (mPolicyUpdate != null ? mPolicyUpdate.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mMinHomeDownlinkBandwidth, mMinHomeUplinkBandwidth, mMinRoamingDownlinkBandwidth, mMinRoamingUplinkBandwidth, mExcludedSsidList, mRequiredProtoPortMap, mMaximumBssLoadValue, mPreferredRoamingPartnerList, mPolicyUpdate);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (mFqdn != null ? mFqdn.hashCode() : 0);
    result = 31 * result + (mFriendlyName != null ? mFriendlyName.hashCode() : 0);
    result = 31 * result + (mIconUrl != null ? mIconUrl.hashCode() : 0);
    result = 31 * result + (mHomeNetworkIds != null ? mHomeNetworkIds.hashCode() : 0);
    result = 31 * result + Arrays.hashCode(mMatchAllOIs);
    result = 31 * result + Arrays.hashCode(mMatchAnyOIs);
    result = 31 * result + Arrays.hashCode(mOtherHomePartners);
    result = 31 * result + Arrays.hashCode(mRoamingConsortiumOIs);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mFqdn, mFriendlyName, mIconUrl, mHomeNetworkIds, mMatchAllOIs, mMatchAnyOIs, mOtherHomePartners, mRoamingConsortiumOIs);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = (int) (31 * result + mUpdateIntervalInMinutes);
    result = 31 * result + (mUpdateMethod != null ? mUpdateMethod.hashCode() : 0);
    result = 31 * result + (mRestriction != null ? mRestriction.hashCode() : 0);
    result = 31 * result + (mServerUri != null ? mServerUri.hashCode() : 0);
    result = 31 * result + (mUsername != null ? mUsername.hashCode() : 0);
    result = 31 * result + (mBase64EncodedPassword != null ? mBase64EncodedPassword.hashCode() : 0);
    result = 31 * result + (mTrustRootCertUrl != null ? mTrustRootCertUrl.hashCode() : 0);
    result = 31 * result + Arrays.hashCode(mTrustRootCertSha256Fingerprint);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mUpdateIntervalInMinutes, mUpdateMethod, mRestriction, mServerUri, mUsername, mBase64EncodedPassword, mTrustRootCertUrl, mTrustRootCertSha256Fingerprint);
}
#end_block

#method_before
@Override
protected final void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(permission.DUMP, TAG);
    String header = String.format("WifiNetworkScoreCache (%s/%d)", mContext.getPackageName(), mCreatorUid);
    writer.println(header);
    writer.println("  All score curves:");
    for (Map.Entry<String, ScoredNetwork> entry : mNetworkCache.entrySet()) {
        ScoredNetwork scoredNetwork = entry.getValue();
        writer.println("    " + entry.getKey() + ": " + scoredNetwork.rssiCurve + ", meteredHint=" + scoredNetwork.meteredHint);
    }
    writer.println("  Current network scores:");
    WifiManager wifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
    for (ScanResult scanResult : wifiManager.getScanResults()) {
        writer.println("    " + buildNetworkKey(scanResult) + ": " + getNetworkScore(scanResult));
    }
}
#method_after
@Override
protected final void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(permission.DUMP, TAG);
    String header = String.format("WifiNetworkScoreCache (%s/%d)", mContext.getPackageName(), Process.myUid());
    writer.println(header);
    writer.println("  All score curves:");
    for (Map.Entry<String, ScoredNetwork> entry : mNetworkCache.entrySet()) {
        ScoredNetwork scoredNetwork = entry.getValue();
        writer.println("    " + entry.getKey() + ": " + scoredNetwork.rssiCurve + ", meteredHint=" + scoredNetwork.meteredHint);
    }
    writer.println("  Current network scores:");
    WifiManager wifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
    for (ScanResult scanResult : wifiManager.getScanResults()) {
        writer.println("    " + buildNetworkKey(scanResult) + ": " + getNetworkScore(scanResult));
    }
}
#end_block

#method_before
// Android changed: Removed retrieveFirstDayOfWeek and retrieveMinimalDaysInFirstWeek.
// use libcore.icu.LocaleData or android.icu.util.Calendar.WeekData instead
public static String retrieveFieldValueName(String id, int field, int value, int style, Locale locale) {
    // Android changed: delegate to ICU.
    String[] names = getNames(id, field, style, locale);
    if (field == Calendar.ERA) {
        switch(normalizeCalendarType(id)) {
            // These calendars have only one era, but represented it by the value 1.
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                value -= 1;
                break;
            case JAPANESE_CALENDAR:
                // CLDR contains full data for historical eras, java.time only supports the 4
                // modern eras.
                value += 231;
        }
    }
    return names[value];
}
#method_after
// Android-changed: Removed retrieveFirstDayOfWeek and retrieveMinimalDaysInFirstWeek.
// use libcore.icu.LocaleData or android.icu.util.Calendar.WeekData instead
public static String retrieveFieldValueName(String id, int field, int value, int style, Locale locale) {
    // Android-changed: delegate to ICU.
    if (field == Calendar.ERA) {
        // For era the field value does not always equal the index into the names array.
        switch(normalizeCalendarType(id)) {
            // These calendars have only one era, but represented it by the value 1.
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                value -= 1;
                break;
            case JAPANESE_CALENDAR:
                // CLDR contains full data for historical eras, java.time only supports the 4
                // modern eras and numbers the modern eras starting with 1 (MEIJI). There are
                // 232 historical eras in CLDR/ICU so to get the real offset, we add 231.
                value += 231;
                break;
            default:
                // Other eras use 0-based values (e.g. 0=BCE, 1=CE for gregorian).
                break;
        }
    }
    if (value < 0) {
        return null;
    }
    String[] names = getNames(id, field, style, locale);
    if (value >= names.length) {
        return null;
    }
    return names[value];
}
#end_block

#method_before
public static String retrieveJavaTimeFieldValueName(String id, int field, int value, int style, Locale locale) {
    // Android changed: don't distinguish between retrieve* and retrieveJavaTime* methods.
    return retrieveFieldValueName(id, field, value, style, locale);
}
#method_after
public static String retrieveJavaTimeFieldValueName(String id, int field, int value, int style, Locale locale) {
    // Android-changed: don't distinguish between retrieve* and retrieveJavaTime* methods.
    return retrieveFieldValueName(id, field, value, style, locale);
}
#end_block

#method_before
public static Map<String, Integer> retrieveFieldValueNames(String id, int field, int style, Locale locale) {
    // TODO: support ALL_STYLES
    // Android changed: delegate to ICU.
    String[] names = getNames(id, field, style, locale);
    Map<String, Integer> result = new LinkedHashMap<>();
    int skipped = 0;
    int offset = 0;
    if (field == Calendar.ERA) {
        switch(normalizeCalendarType(id)) {
            // These calendars have only one era, but represented it by the value 1.
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                offset = 1;
                break;
            case JAPANESE_CALENDAR:
                // CLDR contains full data for historical eras, java.time only supports the 4
                // modern eras.
                skipped = 232;
                offset = -231;
        }
    }
    for (int i = skipped; i < names.length; i++) {
        if (names[i].isEmpty()) {
            continue;
        }
        result.put(names[i], i + offset);
    }
    return result;
}
#method_after
public static Map<String, Integer> retrieveFieldValueNames(String id, int field, int style, Locale locale) {
    // TODO: support ALL_STYLES
    // Android-changed: delegate to ICU.
    String[] names = getNames(id, field, style, locale);
    Map<String, Integer> result = new LinkedHashMap<>();
    int skipped = 0;
    int offset = 0;
    if (field == Calendar.ERA) {
        // See retrieveFieldValueName() for explanation of this code and the values used.
        switch(normalizeCalendarType(id)) {
            case BUDDHIST_CALENDAR:
            case ISLAMIC_CALENDAR:
                offset = 1;
                break;
            case JAPANESE_CALENDAR:
                skipped = 232;
                offset = -231;
                break;
            default:
                break;
        }
    }
    for (int i = skipped; i < names.length; i++) {
        if (names[i].isEmpty()) {
            continue;
        }
        result.put(names[i], i + offset);
    }
    return result;
}
#end_block

#method_before
public static Map<String, Integer> retrieveJavaTimeFieldValueNames(String id, int field, int style, Locale locale) {
    // Android changed: don't distinguish between retrieve* and retrieveJavaTime* methods.
    return retrieveFieldValueNames(id, field, style, locale);
}
#method_after
public static Map<String, Integer> retrieveJavaTimeFieldValueNames(String id, int field, int style, Locale locale) {
    // Android-changed: don't distinguish between retrieve* and retrieveJavaTime* methods.
    return retrieveFieldValueNames(id, field, style, locale);
}
#end_block

#method_before
private static DateFormatSymbols getDateFormatSymbols(String id, Locale locale) {
    String calendarType = normalizeCalendarType(id);
    return new DateFormatSymbols(calendarType, ULocale.forLocale(locale));
}
#method_after
private static DateFormatSymbols getDateFormatSymbols(String id, Locale locale) {
    String calendarType = normalizeCalendarType(id);
    return new DateFormatSymbols(ULocale.forLocale(locale), calendarType);
}
#end_block

#method_before
@DataProvider(name = "localePatterns")
Object[][] localizedDateTimePatterns() {
    // Android changed: Adapt for changes since old CLDR version this tests were written for.
    return new Object[][] { { FormatStyle.FULL, FormatStyle.FULL, IsoChronology.INSTANCE, Locale.US, "EEEE, MMMM d, y 'at' h:mm:ss a zzzz" }, { FormatStyle.LONG, FormatStyle.LONG, IsoChronology.INSTANCE, Locale.US, "MMMM d, y 'at' h:mm:ss a z" }, { FormatStyle.MEDIUM, FormatStyle.MEDIUM, IsoChronology.INSTANCE, Locale.US, "MMM d, y, h:mm:ss a" }, { FormatStyle.SHORT, FormatStyle.SHORT, IsoChronology.INSTANCE, Locale.US, "M/d/yy, h:mm a" }, { FormatStyle.FULL, null, IsoChronology.INSTANCE, Locale.US, "EEEE, MMMM d, y" }, { FormatStyle.LONG, null, IsoChronology.INSTANCE, Locale.US, "MMMM d, y" }, { FormatStyle.MEDIUM, null, IsoChronology.INSTANCE, Locale.US, "MMM d, y" }, { FormatStyle.SHORT, null, IsoChronology.INSTANCE, Locale.US, "M/d/yy" }, { null, FormatStyle.FULL, IsoChronology.INSTANCE, Locale.US, "h:mm:ss a zzzz" }, { null, FormatStyle.LONG, IsoChronology.INSTANCE, Locale.US, "h:mm:ss a z" }, { null, FormatStyle.MEDIUM, IsoChronology.INSTANCE, Locale.US, "h:mm:ss a" }, { null, FormatStyle.SHORT, IsoChronology.INSTANCE, Locale.US, "h:mm a" }, // French Locale and ISO Chronology
    { FormatStyle.FULL, FormatStyle.FULL, IsoChronology.INSTANCE, Locale.FRENCH, "EEEE d MMMM y 'à' HH:mm:ss zzzz" }, { FormatStyle.LONG, FormatStyle.LONG, IsoChronology.INSTANCE, Locale.FRENCH, "d MMMM y 'à' HH:mm:ss z" }, { FormatStyle.MEDIUM, FormatStyle.MEDIUM, IsoChronology.INSTANCE, Locale.FRENCH, "d MMM y 'à' HH:mm:ss" }, { FormatStyle.SHORT, FormatStyle.SHORT, IsoChronology.INSTANCE, Locale.FRENCH, "dd/MM/y HH:mm" }, { FormatStyle.FULL, null, IsoChronology.INSTANCE, Locale.FRENCH, "EEEE d MMMM y" }, { FormatStyle.LONG, null, IsoChronology.INSTANCE, Locale.FRENCH, "d MMMM y" }, { FormatStyle.MEDIUM, null, IsoChronology.INSTANCE, Locale.FRENCH, "d MMM y" }, { FormatStyle.SHORT, null, IsoChronology.INSTANCE, Locale.FRENCH, "dd/MM/y" }, { null, FormatStyle.FULL, IsoChronology.INSTANCE, Locale.FRENCH, "HH:mm:ss zzzz" }, { null, FormatStyle.LONG, IsoChronology.INSTANCE, Locale.FRENCH, "HH:mm:ss z" }, { null, FormatStyle.MEDIUM, IsoChronology.INSTANCE, Locale.FRENCH, "HH:mm:ss" }, { null, FormatStyle.SHORT, IsoChronology.INSTANCE, Locale.FRENCH, "HH:mm" }, // Japanese Locale and JapaneseChronology
    { FormatStyle.FULL, FormatStyle.FULL, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5EEEE H\u6642mm\u5206ss\u79d2 zzzz" }, { FormatStyle.LONG, FormatStyle.LONG, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5 H:mm:ss z" }, { FormatStyle.MEDIUM, FormatStyle.MEDIUM, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5 H:mm:ss" }, { FormatStyle.SHORT, FormatStyle.SHORT, JapaneseChronology.INSTANCE, Locale.JAPANESE, "GGGGGy/M/d H:mm" }, { FormatStyle.FULL, null, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5EEEE" }, { FormatStyle.LONG, null, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5" }, { FormatStyle.MEDIUM, null, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5" }, { FormatStyle.SHORT, null, JapaneseChronology.INSTANCE, Locale.JAPANESE, "GGGGGy/M/d" }, { null, FormatStyle.FULL, JapaneseChronology.INSTANCE, Locale.JAPANESE, "H\u6642mm\u5206ss\u79d2 zzzz" }, { null, FormatStyle.LONG, JapaneseChronology.INSTANCE, Locale.JAPANESE, "H:mm:ss z" }, { null, FormatStyle.MEDIUM, JapaneseChronology.INSTANCE, Locale.JAPANESE, "H:mm:ss" }, { null, FormatStyle.SHORT, JapaneseChronology.INSTANCE, Locale.JAPANESE, "H:mm" }, // Chinese Local and Chronology
    { FormatStyle.FULL, FormatStyle.FULL, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5EEEE zzzz ah:mm:ss" }, { FormatStyle.LONG, FormatStyle.LONG, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5 z ah:mm:ss" }, { FormatStyle.MEDIUM, FormatStyle.MEDIUM, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5 ah:mm:ss" }, { FormatStyle.SHORT, FormatStyle.SHORT, MinguoChronology.INSTANCE, Locale.CHINESE, "Gyy/M/d ah:mm" }, { FormatStyle.FULL, null, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5EEEE" }, { FormatStyle.LONG, null, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5" }, { FormatStyle.MEDIUM, null, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5" }, { FormatStyle.SHORT, null, MinguoChronology.INSTANCE, Locale.CHINESE, "Gyy/M/d" }, { null, FormatStyle.FULL, MinguoChronology.INSTANCE, Locale.CHINESE, "zzzz ah:mm:ss" }, { null, FormatStyle.LONG, MinguoChronology.INSTANCE, Locale.CHINESE, "z ah:mm:ss" }, { null, FormatStyle.MEDIUM, MinguoChronology.INSTANCE, Locale.CHINESE, "ah:mm:ss" }, { null, FormatStyle.SHORT, MinguoChronology.INSTANCE, Locale.CHINESE, "ah:mm" } };
}
#method_after
@DataProvider(name = "localePatterns")
Object[][] localizedDateTimePatterns() {
    // Android-changed: Adapt for changes since old CLDR version this tests were written for.
    return new Object[][] { { FormatStyle.FULL, FormatStyle.FULL, IsoChronology.INSTANCE, Locale.US, "EEEE, MMMM d, y 'at' h:mm:ss a zzzz" }, { FormatStyle.LONG, FormatStyle.LONG, IsoChronology.INSTANCE, Locale.US, "MMMM d, y 'at' h:mm:ss a z" }, { FormatStyle.MEDIUM, FormatStyle.MEDIUM, IsoChronology.INSTANCE, Locale.US, "MMM d, y, h:mm:ss a" }, { FormatStyle.SHORT, FormatStyle.SHORT, IsoChronology.INSTANCE, Locale.US, "M/d/yy, h:mm a" }, { FormatStyle.FULL, null, IsoChronology.INSTANCE, Locale.US, "EEEE, MMMM d, y" }, { FormatStyle.LONG, null, IsoChronology.INSTANCE, Locale.US, "MMMM d, y" }, { FormatStyle.MEDIUM, null, IsoChronology.INSTANCE, Locale.US, "MMM d, y" }, { FormatStyle.SHORT, null, IsoChronology.INSTANCE, Locale.US, "M/d/yy" }, { null, FormatStyle.FULL, IsoChronology.INSTANCE, Locale.US, "h:mm:ss a zzzz" }, { null, FormatStyle.LONG, IsoChronology.INSTANCE, Locale.US, "h:mm:ss a z" }, { null, FormatStyle.MEDIUM, IsoChronology.INSTANCE, Locale.US, "h:mm:ss a" }, { null, FormatStyle.SHORT, IsoChronology.INSTANCE, Locale.US, "h:mm a" }, // French Locale and ISO Chronology
    { FormatStyle.FULL, FormatStyle.FULL, IsoChronology.INSTANCE, Locale.FRENCH, "EEEE d MMMM y 'à' HH:mm:ss zzzz" }, { FormatStyle.LONG, FormatStyle.LONG, IsoChronology.INSTANCE, Locale.FRENCH, "d MMMM y 'à' HH:mm:ss z" }, { FormatStyle.MEDIUM, FormatStyle.MEDIUM, IsoChronology.INSTANCE, Locale.FRENCH, "d MMM y 'à' HH:mm:ss" }, { FormatStyle.SHORT, FormatStyle.SHORT, IsoChronology.INSTANCE, Locale.FRENCH, "dd/MM/y HH:mm" }, { FormatStyle.FULL, null, IsoChronology.INSTANCE, Locale.FRENCH, "EEEE d MMMM y" }, { FormatStyle.LONG, null, IsoChronology.INSTANCE, Locale.FRENCH, "d MMMM y" }, { FormatStyle.MEDIUM, null, IsoChronology.INSTANCE, Locale.FRENCH, "d MMM y" }, { FormatStyle.SHORT, null, IsoChronology.INSTANCE, Locale.FRENCH, "dd/MM/y" }, { null, FormatStyle.FULL, IsoChronology.INSTANCE, Locale.FRENCH, "HH:mm:ss zzzz" }, { null, FormatStyle.LONG, IsoChronology.INSTANCE, Locale.FRENCH, "HH:mm:ss z" }, { null, FormatStyle.MEDIUM, IsoChronology.INSTANCE, Locale.FRENCH, "HH:mm:ss" }, { null, FormatStyle.SHORT, IsoChronology.INSTANCE, Locale.FRENCH, "HH:mm" }, // Japanese Locale and JapaneseChronology
    { FormatStyle.FULL, FormatStyle.FULL, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5EEEE H\u6642mm\u5206ss\u79d2 zzzz" }, { FormatStyle.LONG, FormatStyle.LONG, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5 H:mm:ss z" }, { FormatStyle.MEDIUM, FormatStyle.MEDIUM, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5 H:mm:ss" }, { FormatStyle.SHORT, FormatStyle.SHORT, JapaneseChronology.INSTANCE, Locale.JAPANESE, "GGGGGy/M/d H:mm" }, { FormatStyle.FULL, null, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5EEEE" }, { FormatStyle.LONG, null, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5" }, { FormatStyle.MEDIUM, null, JapaneseChronology.INSTANCE, Locale.JAPANESE, "Gy\u5e74M\u6708d\u65e5" }, { FormatStyle.SHORT, null, JapaneseChronology.INSTANCE, Locale.JAPANESE, "GGGGGy/M/d" }, { null, FormatStyle.FULL, JapaneseChronology.INSTANCE, Locale.JAPANESE, "H\u6642mm\u5206ss\u79d2 zzzz" }, { null, FormatStyle.LONG, JapaneseChronology.INSTANCE, Locale.JAPANESE, "H:mm:ss z" }, { null, FormatStyle.MEDIUM, JapaneseChronology.INSTANCE, Locale.JAPANESE, "H:mm:ss" }, { null, FormatStyle.SHORT, JapaneseChronology.INSTANCE, Locale.JAPANESE, "H:mm" }, // Chinese Local and Chronology
    { FormatStyle.FULL, FormatStyle.FULL, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5EEEE zzzz ah:mm:ss" }, { FormatStyle.LONG, FormatStyle.LONG, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5 z ah:mm:ss" }, { FormatStyle.MEDIUM, FormatStyle.MEDIUM, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5 ah:mm:ss" }, { FormatStyle.SHORT, FormatStyle.SHORT, MinguoChronology.INSTANCE, Locale.CHINESE, "Gyy/M/d ah:mm" }, { FormatStyle.FULL, null, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5EEEE" }, { FormatStyle.LONG, null, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5" }, { FormatStyle.MEDIUM, null, MinguoChronology.INSTANCE, Locale.CHINESE, "Gy\u5e74M\u6708d\u65e5" }, { FormatStyle.SHORT, null, MinguoChronology.INSTANCE, Locale.CHINESE, "Gyy/M/d" }, { null, FormatStyle.FULL, MinguoChronology.INSTANCE, Locale.CHINESE, "zzzz ah:mm:ss" }, { null, FormatStyle.LONG, MinguoChronology.INSTANCE, Locale.CHINESE, "z ah:mm:ss" }, { null, FormatStyle.MEDIUM, MinguoChronology.INSTANCE, Locale.CHINESE, "ah:mm:ss" }, { null, FormatStyle.SHORT, MinguoChronology.INSTANCE, Locale.CHINESE, "ah:mm" } };
}
#end_block

#method_before
@DataProvider(name = "print_standalone")
Object[][] provider_StandaloneNames() {
    return new Object[][] { // Android changed: CLDR uses lower case for russian month names.
    { RUSSIAN, MONTH_OF_YEAR, TextStyle.FULL_STANDALONE, "\u044f\u043d\u0432\u0430\u0440\u044c" }, { RUSSIAN, MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE, "\u044f\u043d\u0432." }, { FINNISH, DAY_OF_WEEK, TextStyle.FULL_STANDALONE, "tiistai" }, { FINNISH, DAY_OF_WEEK, TextStyle.SHORT_STANDALONE, "ti" } };
}
#method_after
@DataProvider(name = "print_standalone")
Object[][] provider_StandaloneNames() {
    return new Object[][] { // Android-changed: CLDR uses lower case for russian month names.
    { RUSSIAN, MONTH_OF_YEAR, TextStyle.FULL_STANDALONE, "\u044f\u043d\u0432\u0430\u0440\u044c" }, { RUSSIAN, MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE, "\u044f\u043d\u0432." }, { FINNISH, DAY_OF_WEEK, TextStyle.FULL_STANDALONE, "tiistai" }, { FINNISH, DAY_OF_WEEK, TextStyle.SHORT_STANDALONE, "ti" } };
}
#end_block

#method_before
@Test
public void test_IsoFields_week_based_year() {
    Locale locale = Locale.US;
    String name = IsoFields.WEEK_OF_WEEK_BASED_YEAR.getDisplayName(locale);
    // Android changed: week is lower-case in CLDR.
    assertEquals(name, "week");
}
#method_after
@Test
public void test_IsoFields_week_based_year() {
    Locale locale = Locale.US;
    String name = IsoFields.WEEK_OF_WEEK_BASED_YEAR.getDisplayName(locale);
    // Android-changed: week is lower-case in CLDR.
    assertEquals(name, "week");
}
#end_block

#method_before
@Test
public void test_WeekFields_week_based_year() {
    Locale locale = Locale.US;
    TemporalField weekOfYearField = WeekFields.SUNDAY_START.weekOfYear();
    String name = weekOfYearField.getDisplayName(locale);
    // Android changed: week is lower-case in CLDR.
    assertEquals(name, "week");
}
#method_after
@Test
public void test_WeekFields_week_based_year() {
    Locale locale = Locale.US;
    TemporalField weekOfYearField = WeekFields.SUNDAY_START.weekOfYear();
    String name = weekOfYearField.getDisplayName(locale);
    // Android-changed: week is lower-case in CLDR.
    assertEquals(name, "week");
}
#end_block

#method_before
@DataProvider(name = "parseStandaloneText")
Object[][] providerStandaloneText() {
    // Locale, TemporalField, TextStyle, expected value, input text
    return new Object[][] { // Android changed: CLDR provides russian days/months in lower-case and with a fullstop.
    { RUSSIAN, MONTH_OF_YEAR, TextStyle.FULL_STANDALONE, 1, "\u044f\u043d\u0432\u0430\u0440\u044c" }, { RUSSIAN, MONTH_OF_YEAR, TextStyle.FULL_STANDALONE, 12, "\u0434\u0435\u043a\u0430\u0431\u0440\u044c" }, { RUSSIAN, MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE, 1, "\u044f\u043d\u0432." }, { RUSSIAN, MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE, 12, "\u0434\u0435\u043a." }, { FINNISH, DAY_OF_WEEK, TextStyle.FULL_STANDALONE, 2, "tiistai" }, { FINNISH, DAY_OF_WEEK, TextStyle.SHORT_STANDALONE, 2, "ti" } };
}
#method_after
@DataProvider(name = "parseStandaloneText")
Object[][] providerStandaloneText() {
    // Locale, TemporalField, TextStyle, expected value, input text
    return new Object[][] { // Android-changed: CLDR provides russian days/months in lower-case and with a fullstop.
    { RUSSIAN, MONTH_OF_YEAR, TextStyle.FULL_STANDALONE, 1, "\u044f\u043d\u0432\u0430\u0440\u044c" }, { RUSSIAN, MONTH_OF_YEAR, TextStyle.FULL_STANDALONE, 12, "\u0434\u0435\u043a\u0430\u0431\u0440\u044c" }, { RUSSIAN, MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE, 1, "\u044f\u043d\u0432." }, { RUSSIAN, MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE, 12, "\u0434\u0435\u043a." }, { FINNISH, DAY_OF_WEEK, TextStyle.FULL_STANDALONE, 2, "tiistai" }, { FINNISH, DAY_OF_WEEK, TextStyle.SHORT_STANDALONE, 2, "ti" } };
}
#end_block

#method_before
@DataProvider(name = "chrono_names")
Object[][] chronoNamesData() {
    return new Object[][] { // Android changed: CLDR data has changed.
    { ISO8601, Locale.ENGLISH, "ISO-8601 Calendar" }, { BUDDHIST, Locale.ENGLISH, "Buddhist Calendar" }, { HIJRAH, Locale.ENGLISH, "Islamic Calendar (Umm al-Qura)" }, { JAPANESE, Locale.ENGLISH, "Japanese Calendar" }, { MINGUO, Locale.ENGLISH, "Minguo Calendar" }, { ISO8601, Locale.JAPANESE, "ISO-8601" }, { JAPANESE, Locale.JAPANESE, "\u548c\u66a6" }, { BUDDHIST, Locale.JAPANESE, "\u4ecf\u66a6" }, { ISO8601, thTH, "\u0e1b\u0e0f\u0e34\u0e17\u0e34\u0e19 ISO-8601" }, { JAPANESE, thTH, "\u0e1b\u0e0f\u0e34\u0e17\u0e34\u0e19\u0e0d\u0e35\u0e48\u0e1b\u0e38\u0e48\u0e19" }, { BUDDHIST, thTH, "\u0e1b\u0e0f\u0e34\u0e17\u0e34\u0e19\u0e1e\u0e38\u0e17\u0e18" }, { HIJRAH, ARABIC, "\u0627\u0644\u062a\u0642\u0648\u064a\u0645 " + "\u0627\u0644\u0625\u0633\u0644\u0627\u0645\u064a " + // JDK-8015986
    "(\u0623\u0645 \u0627\u0644\u0642\u0631\u0649)" } };
}
#method_after
@DataProvider(name = "chrono_names")
Object[][] chronoNamesData() {
    return new Object[][] { // Android-changed: CLDR data has changed.
    { ISO8601, Locale.ENGLISH, "ISO-8601 Calendar" }, { BUDDHIST, Locale.ENGLISH, "Buddhist Calendar" }, { HIJRAH, Locale.ENGLISH, "Islamic Calendar (Umm al-Qura)" }, { JAPANESE, Locale.ENGLISH, "Japanese Calendar" }, { MINGUO, Locale.ENGLISH, "Minguo Calendar" }, { ISO8601, Locale.JAPANESE, "ISO-8601" }, { JAPANESE, Locale.JAPANESE, "\u548c\u66a6" }, { BUDDHIST, Locale.JAPANESE, "\u4ecf\u66a6" }, { ISO8601, thTH, "\u0e1b\u0e0f\u0e34\u0e17\u0e34\u0e19 ISO-8601" }, { JAPANESE, thTH, "\u0e1b\u0e0f\u0e34\u0e17\u0e34\u0e19\u0e0d\u0e35\u0e48\u0e1b\u0e38\u0e48\u0e19" }, { BUDDHIST, thTH, "\u0e1b\u0e0f\u0e34\u0e17\u0e34\u0e19\u0e1e\u0e38\u0e17\u0e18" }, { HIJRAH, ARABIC, "\u0627\u0644\u062a\u0642\u0648\u064a\u0645 " + "\u0627\u0644\u0625\u0633\u0644\u0627\u0645\u064a " + // JDK-8015986
    "(\u0623\u0645 \u0627\u0644\u0642\u0631\u0649)" } };
}
#end_block

#method_before
@DataProvider(name = "formatStyle")
Object[][] data_formatStyle() {
    return new Object[][] { // Android changed: date/time patterns changed in new CLDR; adapt to UK locale.
    { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), ZONEID_PARIS), FormatStyle.FULL, "Tuesday, 2 October 2001 at 01:02:03 Central European Summer Time Europe/Paris" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), ZONEID_PARIS), FormatStyle.LONG, "2 October 2001 at 01:02:03 CEST Europe/Paris" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), ZONEID_PARIS), FormatStyle.MEDIUM, "2 Oct 2001, 01:02:03 Europe/Paris" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), ZONEID_PARIS), FormatStyle.SHORT, "02/10/2001, 01:02 Europe/Paris" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), OFFSET_PTWO), FormatStyle.FULL, "Tuesday, 2 October 2001 at 01:02:03 +02:00 +02:00" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), OFFSET_PTWO), FormatStyle.LONG, "2 October 2001 at 01:02:03 +02:00 +02:00" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), OFFSET_PTWO), FormatStyle.MEDIUM, "2 Oct 2001, 01:02:03 +02:00" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), OFFSET_PTWO), FormatStyle.SHORT, "02/10/2001, 01:02 +02:00" } };
}
#method_after
@DataProvider(name = "formatStyle")
Object[][] data_formatStyle() {
    return new Object[][] { // Android-changed: date/time patterns changed in new CLDR; adapt to UK locale.
    { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), ZONEID_PARIS), FormatStyle.FULL, "Tuesday, 2 October 2001 at 01:02:03 Central European Summer Time Europe/Paris" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), ZONEID_PARIS), FormatStyle.LONG, "2 October 2001 at 01:02:03 CEST Europe/Paris" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), ZONEID_PARIS), FormatStyle.MEDIUM, "2 Oct 2001, 01:02:03 Europe/Paris" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), ZONEID_PARIS), FormatStyle.SHORT, "02/10/2001, 01:02 Europe/Paris" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), OFFSET_PTWO), FormatStyle.FULL, "Tuesday, 2 October 2001 at 01:02:03 +02:00 +02:00" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), OFFSET_PTWO), FormatStyle.LONG, "2 October 2001 at 01:02:03 +02:00 +02:00" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), OFFSET_PTWO), FormatStyle.MEDIUM, "2 Oct 2001, 01:02:03 +02:00" }, { ZonedDateTime.of(LocalDateTime.of(2001, 10, 2, 1, 2, 3), OFFSET_PTWO), FormatStyle.SHORT, "02/10/2001, 01:02 +02:00" } };
}
#end_block

#method_before
@Test(dataProvider = "formatStyle")
public void test_formatStyle(Temporal temporal, FormatStyle style, String formattedStr) {
    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
    DateTimeFormatter formatter = builder.appendLocalized(style, style).appendLiteral(" ").appendZoneOrOffsetId().toFormatter();
    // Android changed: Use a locale that actually uses "CEST" as short form of Europe/Paris.
    formatter = formatter.withLocale(Locale.UK);
    assertEquals(formatter.format(temporal), formattedStr);
}
#method_after
@Test(dataProvider = "formatStyle")
public void test_formatStyle(Temporal temporal, FormatStyle style, String formattedStr) {
    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
    DateTimeFormatter formatter = builder.appendLocalized(style, style).appendLiteral(" ").appendZoneOrOffsetId().toFormatter();
    // Android-changed: Use a locale that actually uses "CEST" as short form of Europe/Paris.
    formatter = formatter.withLocale(Locale.UK);
    assertEquals(formatter.format(temporal), formattedStr);
}
#end_block

#method_before
@DataProvider(name = "Text")
Object[][] data_text() {
    return new Object[][] { { DAY_OF_WEEK, 1, TextStyle.SHORT, enUS, "Mon" }, { DAY_OF_WEEK, 2, TextStyle.SHORT, enUS, "Tue" }, { DAY_OF_WEEK, 3, TextStyle.SHORT, enUS, "Wed" }, { DAY_OF_WEEK, 4, TextStyle.SHORT, enUS, "Thu" }, { DAY_OF_WEEK, 5, TextStyle.SHORT, enUS, "Fri" }, { DAY_OF_WEEK, 6, TextStyle.SHORT, enUS, "Sat" }, { DAY_OF_WEEK, 7, TextStyle.SHORT, enUS, "Sun" }, // Android changed: upstream tests expect upper case names for pt_BR, but CLDR has lower
    { DAY_OF_WEEK, 1, TextStyle.SHORT, ptBR, "seg" }, { DAY_OF_WEEK, 2, TextStyle.SHORT, ptBR, "ter" }, { DAY_OF_WEEK, 3, TextStyle.SHORT, ptBR, "qua" }, { DAY_OF_WEEK, 4, TextStyle.SHORT, ptBR, "qui" }, { DAY_OF_WEEK, 5, TextStyle.SHORT, ptBR, "sex" }, { DAY_OF_WEEK, 6, TextStyle.SHORT, ptBR, "s\u00E1b" }, { DAY_OF_WEEK, 7, TextStyle.SHORT, ptBR, "dom" }, { DAY_OF_WEEK, 1, TextStyle.FULL, enUS, "Monday" }, { DAY_OF_WEEK, 2, TextStyle.FULL, enUS, "Tuesday" }, { DAY_OF_WEEK, 3, TextStyle.FULL, enUS, "Wednesday" }, { DAY_OF_WEEK, 4, TextStyle.FULL, enUS, "Thursday" }, { DAY_OF_WEEK, 5, TextStyle.FULL, enUS, "Friday" }, { DAY_OF_WEEK, 6, TextStyle.FULL, enUS, "Saturday" }, { DAY_OF_WEEK, 7, TextStyle.FULL, enUS, "Sunday" }, // Android changed: upstream tests expect upper case names for pt_BR, but CLDR has lower
    { DAY_OF_WEEK, 1, TextStyle.FULL, ptBR, "segunda-feira" }, { DAY_OF_WEEK, 2, TextStyle.FULL, ptBR, "ter\u00E7a-feira" }, { DAY_OF_WEEK, 3, TextStyle.FULL, ptBR, "quarta-feira" }, { DAY_OF_WEEK, 4, TextStyle.FULL, ptBR, "quinta-feira" }, { DAY_OF_WEEK, 5, TextStyle.FULL, ptBR, "sexta-feira" }, { DAY_OF_WEEK, 6, TextStyle.FULL, ptBR, "s\u00E1bado" }, { DAY_OF_WEEK, 7, TextStyle.FULL, ptBR, "domingo" }, { MONTH_OF_YEAR, 1, TextStyle.SHORT, enUS, "Jan" }, { MONTH_OF_YEAR, 2, TextStyle.SHORT, enUS, "Feb" }, { MONTH_OF_YEAR, 3, TextStyle.SHORT, enUS, "Mar" }, { MONTH_OF_YEAR, 4, TextStyle.SHORT, enUS, "Apr" }, { MONTH_OF_YEAR, 5, TextStyle.SHORT, enUS, "May" }, { MONTH_OF_YEAR, 6, TextStyle.SHORT, enUS, "Jun" }, { MONTH_OF_YEAR, 7, TextStyle.SHORT, enUS, "Jul" }, { MONTH_OF_YEAR, 8, TextStyle.SHORT, enUS, "Aug" }, { MONTH_OF_YEAR, 9, TextStyle.SHORT, enUS, "Sep" }, { MONTH_OF_YEAR, 10, TextStyle.SHORT, enUS, "Oct" }, { MONTH_OF_YEAR, 11, TextStyle.SHORT, enUS, "Nov" }, { MONTH_OF_YEAR, 12, TextStyle.SHORT, enUS, "Dec" }, { MONTH_OF_YEAR, 1, TextStyle.SHORT, ptBR, "jan" }, { MONTH_OF_YEAR, 2, TextStyle.SHORT, ptBR, "fev" }, { MONTH_OF_YEAR, 3, TextStyle.SHORT, ptBR, "mar" }, { MONTH_OF_YEAR, 4, TextStyle.SHORT, ptBR, "abr" }, { MONTH_OF_YEAR, 5, TextStyle.SHORT, ptBR, "mai" }, { MONTH_OF_YEAR, 6, TextStyle.SHORT, ptBR, "jun" }, { MONTH_OF_YEAR, 7, TextStyle.SHORT, ptBR, "jul" }, { MONTH_OF_YEAR, 8, TextStyle.SHORT, ptBR, "ago" }, { MONTH_OF_YEAR, 9, TextStyle.SHORT, ptBR, "set" }, { MONTH_OF_YEAR, 10, TextStyle.SHORT, ptBR, "out" }, { MONTH_OF_YEAR, 11, TextStyle.SHORT, ptBR, "nov" }, { MONTH_OF_YEAR, 12, TextStyle.SHORT, ptBR, "dez" }, { MONTH_OF_YEAR, 1, TextStyle.FULL, enUS, "January" }, { MONTH_OF_YEAR, 2, TextStyle.FULL, enUS, "February" }, { MONTH_OF_YEAR, 3, TextStyle.FULL, enUS, "March" }, { MONTH_OF_YEAR, 4, TextStyle.FULL, enUS, "April" }, { MONTH_OF_YEAR, 5, TextStyle.FULL, enUS, "May" }, { MONTH_OF_YEAR, 6, TextStyle.FULL, enUS, "June" }, { MONTH_OF_YEAR, 7, TextStyle.FULL, enUS, "July" }, { MONTH_OF_YEAR, 8, TextStyle.FULL, enUS, "August" }, { MONTH_OF_YEAR, 9, TextStyle.FULL, enUS, "September" }, { MONTH_OF_YEAR, 10, TextStyle.FULL, enUS, "October" }, { MONTH_OF_YEAR, 11, TextStyle.FULL, enUS, "November" }, { MONTH_OF_YEAR, 12, TextStyle.FULL, enUS, "December" }, // Android changed: upstream tests expect upper case names for pt_BR, but CLDR has lower
    { MONTH_OF_YEAR, 1, TextStyle.FULL, ptBR, "janeiro" }, { MONTH_OF_YEAR, 2, TextStyle.FULL, ptBR, "fevereiro" }, { MONTH_OF_YEAR, 3, TextStyle.FULL, ptBR, "mar\u00E7o" }, { MONTH_OF_YEAR, 4, TextStyle.FULL, ptBR, "abril" }, { MONTH_OF_YEAR, 5, TextStyle.FULL, ptBR, "maio" }, { MONTH_OF_YEAR, 6, TextStyle.FULL, ptBR, "junho" }, { MONTH_OF_YEAR, 7, TextStyle.FULL, ptBR, "julho" }, { MONTH_OF_YEAR, 8, TextStyle.FULL, ptBR, "agosto" }, { MONTH_OF_YEAR, 9, TextStyle.FULL, ptBR, "setembro" }, { MONTH_OF_YEAR, 10, TextStyle.FULL, ptBR, "outubro" }, { MONTH_OF_YEAR, 11, TextStyle.FULL, ptBR, "novembro" }, { MONTH_OF_YEAR, 12, TextStyle.FULL, ptBR, "dezembro" }, { AMPM_OF_DAY, 0, TextStyle.SHORT, enUS, "AM" }, { AMPM_OF_DAY, 1, TextStyle.SHORT, enUS, "PM" } };
}
#method_after
@DataProvider(name = "Text")
Object[][] data_text() {
    return new Object[][] { { DAY_OF_WEEK, 1, TextStyle.SHORT, enUS, "Mon" }, { DAY_OF_WEEK, 2, TextStyle.SHORT, enUS, "Tue" }, { DAY_OF_WEEK, 3, TextStyle.SHORT, enUS, "Wed" }, { DAY_OF_WEEK, 4, TextStyle.SHORT, enUS, "Thu" }, { DAY_OF_WEEK, 5, TextStyle.SHORT, enUS, "Fri" }, { DAY_OF_WEEK, 6, TextStyle.SHORT, enUS, "Sat" }, { DAY_OF_WEEK, 7, TextStyle.SHORT, enUS, "Sun" }, // Android-changed: upstream tests expect title case names for pt_BR, but CLDR has lower
    { DAY_OF_WEEK, 1, TextStyle.SHORT, ptBR, "seg" }, { DAY_OF_WEEK, 2, TextStyle.SHORT, ptBR, "ter" }, { DAY_OF_WEEK, 3, TextStyle.SHORT, ptBR, "qua" }, { DAY_OF_WEEK, 4, TextStyle.SHORT, ptBR, "qui" }, { DAY_OF_WEEK, 5, TextStyle.SHORT, ptBR, "sex" }, { DAY_OF_WEEK, 6, TextStyle.SHORT, ptBR, "s\u00E1b" }, { DAY_OF_WEEK, 7, TextStyle.SHORT, ptBR, "dom" }, { DAY_OF_WEEK, 1, TextStyle.FULL, enUS, "Monday" }, { DAY_OF_WEEK, 2, TextStyle.FULL, enUS, "Tuesday" }, { DAY_OF_WEEK, 3, TextStyle.FULL, enUS, "Wednesday" }, { DAY_OF_WEEK, 4, TextStyle.FULL, enUS, "Thursday" }, { DAY_OF_WEEK, 5, TextStyle.FULL, enUS, "Friday" }, { DAY_OF_WEEK, 6, TextStyle.FULL, enUS, "Saturday" }, { DAY_OF_WEEK, 7, TextStyle.FULL, enUS, "Sunday" }, // Android-changed: upstream tests expect title case names for pt_BR, but CLDR has lower
    { DAY_OF_WEEK, 1, TextStyle.FULL, ptBR, "segunda-feira" }, { DAY_OF_WEEK, 2, TextStyle.FULL, ptBR, "ter\u00E7a-feira" }, { DAY_OF_WEEK, 3, TextStyle.FULL, ptBR, "quarta-feira" }, { DAY_OF_WEEK, 4, TextStyle.FULL, ptBR, "quinta-feira" }, { DAY_OF_WEEK, 5, TextStyle.FULL, ptBR, "sexta-feira" }, { DAY_OF_WEEK, 6, TextStyle.FULL, ptBR, "s\u00E1bado" }, { DAY_OF_WEEK, 7, TextStyle.FULL, ptBR, "domingo" }, { MONTH_OF_YEAR, 1, TextStyle.SHORT, enUS, "Jan" }, { MONTH_OF_YEAR, 2, TextStyle.SHORT, enUS, "Feb" }, { MONTH_OF_YEAR, 3, TextStyle.SHORT, enUS, "Mar" }, { MONTH_OF_YEAR, 4, TextStyle.SHORT, enUS, "Apr" }, { MONTH_OF_YEAR, 5, TextStyle.SHORT, enUS, "May" }, { MONTH_OF_YEAR, 6, TextStyle.SHORT, enUS, "Jun" }, { MONTH_OF_YEAR, 7, TextStyle.SHORT, enUS, "Jul" }, { MONTH_OF_YEAR, 8, TextStyle.SHORT, enUS, "Aug" }, { MONTH_OF_YEAR, 9, TextStyle.SHORT, enUS, "Sep" }, { MONTH_OF_YEAR, 10, TextStyle.SHORT, enUS, "Oct" }, { MONTH_OF_YEAR, 11, TextStyle.SHORT, enUS, "Nov" }, { MONTH_OF_YEAR, 12, TextStyle.SHORT, enUS, "Dec" }, { MONTH_OF_YEAR, 1, TextStyle.SHORT, ptBR, "jan" }, { MONTH_OF_YEAR, 2, TextStyle.SHORT, ptBR, "fev" }, { MONTH_OF_YEAR, 3, TextStyle.SHORT, ptBR, "mar" }, { MONTH_OF_YEAR, 4, TextStyle.SHORT, ptBR, "abr" }, { MONTH_OF_YEAR, 5, TextStyle.SHORT, ptBR, "mai" }, { MONTH_OF_YEAR, 6, TextStyle.SHORT, ptBR, "jun" }, { MONTH_OF_YEAR, 7, TextStyle.SHORT, ptBR, "jul" }, { MONTH_OF_YEAR, 8, TextStyle.SHORT, ptBR, "ago" }, { MONTH_OF_YEAR, 9, TextStyle.SHORT, ptBR, "set" }, { MONTH_OF_YEAR, 10, TextStyle.SHORT, ptBR, "out" }, { MONTH_OF_YEAR, 11, TextStyle.SHORT, ptBR, "nov" }, { MONTH_OF_YEAR, 12, TextStyle.SHORT, ptBR, "dez" }, { MONTH_OF_YEAR, 1, TextStyle.FULL, enUS, "January" }, { MONTH_OF_YEAR, 2, TextStyle.FULL, enUS, "February" }, { MONTH_OF_YEAR, 3, TextStyle.FULL, enUS, "March" }, { MONTH_OF_YEAR, 4, TextStyle.FULL, enUS, "April" }, { MONTH_OF_YEAR, 5, TextStyle.FULL, enUS, "May" }, { MONTH_OF_YEAR, 6, TextStyle.FULL, enUS, "June" }, { MONTH_OF_YEAR, 7, TextStyle.FULL, enUS, "July" }, { MONTH_OF_YEAR, 8, TextStyle.FULL, enUS, "August" }, { MONTH_OF_YEAR, 9, TextStyle.FULL, enUS, "September" }, { MONTH_OF_YEAR, 10, TextStyle.FULL, enUS, "October" }, { MONTH_OF_YEAR, 11, TextStyle.FULL, enUS, "November" }, { MONTH_OF_YEAR, 12, TextStyle.FULL, enUS, "December" }, // Android-changed: upstream tests expect title case names for pt_BR, but CLDR has lower
    { MONTH_OF_YEAR, 1, TextStyle.FULL, ptBR, "janeiro" }, { MONTH_OF_YEAR, 2, TextStyle.FULL, ptBR, "fevereiro" }, { MONTH_OF_YEAR, 3, TextStyle.FULL, ptBR, "mar\u00E7o" }, { MONTH_OF_YEAR, 4, TextStyle.FULL, ptBR, "abril" }, { MONTH_OF_YEAR, 5, TextStyle.FULL, ptBR, "maio" }, { MONTH_OF_YEAR, 6, TextStyle.FULL, ptBR, "junho" }, { MONTH_OF_YEAR, 7, TextStyle.FULL, ptBR, "julho" }, { MONTH_OF_YEAR, 8, TextStyle.FULL, ptBR, "agosto" }, { MONTH_OF_YEAR, 9, TextStyle.FULL, ptBR, "setembro" }, { MONTH_OF_YEAR, 10, TextStyle.FULL, ptBR, "outubro" }, { MONTH_OF_YEAR, 11, TextStyle.FULL, ptBR, "novembro" }, { MONTH_OF_YEAR, 12, TextStyle.FULL, ptBR, "dezembro" }, { AMPM_OF_DAY, 0, TextStyle.SHORT, enUS, "AM" }, { AMPM_OF_DAY, 1, TextStyle.SHORT, enUS, "PM" } };
}
#end_block

#method_before
private boolean installKeys(WifiEnterpriseConfig existingConfig, WifiEnterpriseConfig config, String name) {
    boolean ret = true;
    String privKeyName = Credentials.USER_PRIVATE_KEY + name;
    String userCertName = Credentials.USER_CERTIFICATE + name;
    if (config.getClientCertificate() != null) {
        byte[] privKeyData = config.getClientPrivateKey().getEncoded();
        if (mVerboseLoggingEnabled) {
            if (isHardwareBackedKey(config.getClientPrivateKey())) {
                Log.d(TAG, "importing keys " + name + " in hardware backed store");
            } else {
                Log.d(TAG, "importing keys " + name + " in software backed store");
            }
        }
        ret = mKeyStore.importKey(privKeyName, privKeyData, Process.WIFI_UID, KeyStore.FLAG_NONE);
        if (!ret) {
            return ret;
        }
        ret = putCertInKeyStore(userCertName, config.getClientCertificate());
        if (!ret) {
            // Remove private key installed
            mKeyStore.delete(privKeyName, Process.WIFI_UID);
            return ret;
        }
        Certificate[] clientChain = config.getClientCertificateChain();
        if (clientChain != null && clientChain.length != 0) {
            ret = putClientChainInKeyStore(userCertName, clientChain);
            if (!ret) {
                // Remove partially installed user certificate chain
                mKeyStore.delete(userCertName, Process.WIFI_UID);
                // Remove private key installed
                mKeyStore.delete(privKeyName, Process.WIFI_UID);
                return ret;
            }
        }
    }
    X509Certificate[] caCertificates = config.getCaCertificates();
    Set<String> oldCaCertificatesToRemove = new ArraySet<>();
    if (existingConfig != null && existingConfig.getCaCertificateAliases() != null) {
        oldCaCertificatesToRemove.addAll(Arrays.asList(existingConfig.getCaCertificateAliases()));
    }
    List<String> caCertificateAliases = null;
    if (caCertificates != null) {
        caCertificateAliases = new ArrayList<>();
        for (int i = 0; i < caCertificates.length; i++) {
            String alias = caCertificates.length == 1 ? name : String.format("%s_%d", name, i);
            oldCaCertificatesToRemove.remove(alias);
            ret = putCertInKeyStore(Credentials.CA_CERTIFICATE + alias, caCertificates[i]);
            if (!ret) {
                // Remove client key+cert
                if (config.getClientCertificate() != null) {
                    mKeyStore.delete(privKeyName, Process.WIFI_UID);
                    mKeyStore.delete(userCertName, Process.WIFI_UID);
                }
                // Remove added CA certs.
                for (String addedAlias : caCertificateAliases) {
                    mKeyStore.delete(Credentials.CA_CERTIFICATE + addedAlias, Process.WIFI_UID);
                }
                return ret;
            } else {
                caCertificateAliases.add(alias);
            }
        }
    }
    // Remove old CA certs.
    for (String oldAlias : oldCaCertificatesToRemove) {
        mKeyStore.delete(Credentials.CA_CERTIFICATE + oldAlias, Process.WIFI_UID);
    }
    // Set alias names
    if (config.getClientCertificate() != null) {
        config.setClientCertificateAlias(name);
        config.resetClientKeyEntry();
    }
    if (caCertificates != null) {
        config.setCaCertificateAliases(caCertificateAliases.toArray(new String[caCertificateAliases.size()]));
        config.resetCaCertificate();
    }
    return ret;
}
#method_after
private boolean installKeys(WifiEnterpriseConfig existingConfig, WifiEnterpriseConfig config, String name) {
    boolean ret = true;
    String privKeyName = Credentials.USER_PRIVATE_KEY + name;
    String userCertName = Credentials.USER_CERTIFICATE + name;
    Certificate[] clientCertificateChain = config.getClientCertificateChain();
    if (clientCertificateChain != null && clientCertificateChain.length != 0) {
        byte[] privKeyData = config.getClientPrivateKey().getEncoded();
        if (mVerboseLoggingEnabled) {
            if (isHardwareBackedKey(config.getClientPrivateKey())) {
                Log.d(TAG, "importing keys " + name + " in hardware backed store");
            } else {
                Log.d(TAG, "importing keys " + name + " in software backed store");
            }
        }
        ret = mKeyStore.importKey(privKeyName, privKeyData, Process.WIFI_UID, KeyStore.FLAG_NONE);
        if (!ret) {
            return ret;
        }
        ret = putCertsInKeyStore(userCertName, clientCertificateChain);
        if (!ret) {
            // Remove private key installed
            mKeyStore.delete(privKeyName, Process.WIFI_UID);
            return ret;
        }
    }
    X509Certificate[] caCertificates = config.getCaCertificates();
    Set<String> oldCaCertificatesToRemove = new ArraySet<>();
    if (existingConfig != null && existingConfig.getCaCertificateAliases() != null) {
        oldCaCertificatesToRemove.addAll(Arrays.asList(existingConfig.getCaCertificateAliases()));
    }
    List<String> caCertificateAliases = null;
    if (caCertificates != null) {
        caCertificateAliases = new ArrayList<>();
        for (int i = 0; i < caCertificates.length; i++) {
            String alias = caCertificates.length == 1 ? name : String.format("%s_%d", name, i);
            oldCaCertificatesToRemove.remove(alias);
            ret = putCertInKeyStore(Credentials.CA_CERTIFICATE + alias, caCertificates[i]);
            if (!ret) {
                // Remove client key+cert
                if (config.getClientCertificate() != null) {
                    mKeyStore.delete(privKeyName, Process.WIFI_UID);
                    mKeyStore.delete(userCertName, Process.WIFI_UID);
                }
                // Remove added CA certs.
                for (String addedAlias : caCertificateAliases) {
                    mKeyStore.delete(Credentials.CA_CERTIFICATE + addedAlias, Process.WIFI_UID);
                }
                return ret;
            } else {
                caCertificateAliases.add(alias);
            }
        }
    }
    // Remove old CA certs.
    for (String oldAlias : oldCaCertificatesToRemove) {
        mKeyStore.delete(Credentials.CA_CERTIFICATE + oldAlias, Process.WIFI_UID);
    }
    // Set alias names
    if (config.getClientCertificate() != null) {
        config.setClientCertificateAlias(name);
        config.resetClientKeyEntry();
    }
    if (caCertificates != null) {
        config.setCaCertificateAliases(caCertificateAliases.toArray(new String[caCertificateAliases.size()]));
        config.resetCaCertificate();
    }
    return ret;
}
#end_block

#method_before
public boolean putCertInKeyStore(String name, Certificate cert) {
    return putClientChainInKeyStore(name, new Certificate[] { cert });
}
#method_after
public boolean putCertInKeyStore(String name, Certificate cert) {
    return putCertsInKeyStore(name, new Certificate[] { cert });
}
#end_block

#method_before
public boolean startVendorHal() {
    kilroy();
    throw new UnsupportedOperationException();
}
#method_after
public boolean startVendorHal(boolean isStaMode) {
    if (!mHalDeviceManager.start()) {
        Log.e(TAG, "Failed to start the vendor HAL");
        return false;
    }
    if (isStaMode) {
        mIWifiStaIface = mHalDeviceManager.createStaIface(null, null);
        if (mIWifiStaIface == null) {
            Log.e(TAG, "Failed to create STA Iface");
            return false;
        }
    } else {
        mIWifiApIface = mHalDeviceManager.createApIface(null, null);
        if (mIWifiApIface == null) {
            Log.e(TAG, "Failed to create AP Iface");
            return false;
        }
    }
    IWifiIface iface = (IWifiIface) (mIWifiStaIface != null ? mIWifiStaIface : mIWifiApIface);
    mIWifiChip = mHalDeviceManager.getChip(iface);
    if (mIWifiStaIface == null) {
        Log.e(TAG, "Failed to get the chip created for the Iface");
        return false;
    }
    return true;
}
#end_block

#method_before
public void stopVendorHal() {
    kilroy();
    // TODO(mplass): Actually stop b/33383725
    mIWifi = null;
    mIWifiChip = null;
    mDriverDescription = null;
    mFirmwareDescription = null;
    throw new UnsupportedOperationException();
}
#method_after
public void stopVendorHal() {
    mHalDeviceManager.stop();
}
#end_block

#method_before
public boolean isHalStarted() {
    return mIWifiStaIface != null;
}
#method_after
public boolean isHalStarted() {
    return (mIWifiStaIface != null || mIWifiApIface != null);
}
#end_block

#method_before
/**
 * Explicitly sets the WifiSupplicantHal instance
 * TODO(b/34722734): move this into the constructor of WifiNative when I clean up the awful
 * double singleton pattern
 */
void setWifiSupplicantHal(WifiSupplicantHal wifiSupplicantHal) {
    mWifiSupplicantHal = wifiSupplicantHal;
}
#method_after
public void setWifiSupplicantHal(WifiSupplicantHal wifiSupplicantHal) {
    mWifiSupplicantHal = wifiSupplicantHal;
}
#end_block

#method_before
/**
 * Explicitly sets the WifiVendorHal instance
 * TODO(b/34722734): move this into the constructor of WifiNative when I clean up the awful
 * double singleton pattern
 */
void setWifiVendorHal(WifiVendorHal wifiVendorHal) {
    mWifiVendorHal = wifiVendorHal;
}
#method_after
public void setWifiVendorHal(WifiVendorHal wifiVendorHal) {
    mWifiVendorHal = wifiVendorHal;
}
#end_block

#method_before
public boolean initializeSupplicantHal() {
    /* Deactivated until HAL integration is ready
           mWifiSupplicantHal.initialize();
           */
    return true;
}
#method_after
public boolean initializeSupplicantHal() {
    return mWifiSupplicantHal.initialize();
}
#end_block

#method_before
public boolean initialize() {
    Log.i(TAG, "Registering SupplicantHidl service ready callback.");
    synchronized (mLock) {
        mHidlSupplicant = null;
        mHidlSupplicantStaIface = null;
        mHidlSupplicantP2pIface = null;
        try {
            final IServiceManager serviceManager = IServiceManager.getService("manager");
            if (serviceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!serviceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                    if (!getSupplicantService() || !getSupplicantStaIface() || !getSupplicantP2pIface()) {
                        Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                        supplicantServiceDiedHandler();
                    }
                    Log.i(TAG, "Completed initialization of ISupplicant service and Ifaces!");
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!serviceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
        }
        return true;
    }
}
#method_after
public boolean initialize() {
    Log.i(TAG, "Registering SupplicantHidl service ready callback.");
    synchronized (mLock) {
        mHidlSupplicant = null;
        mHidlSupplicantStaIface = null;
        mHidlSupplicantP2pIface = null;
        try {
            final IServiceManager serviceManager = IServiceManager.getService("manager");
            if (serviceManager == null) {
                Log.e(TAG, "Failed to get HIDL Service Manager");
                return false;
            }
            if (!serviceManager.linkToDeath(cookie -> {
                Log.wtf(TAG, "IServiceManager died: cookie=" + cookie);
                synchronized (mLock) {
                    supplicantServiceDiedHandler();
                }
            }, 0)) {
                Log.wtf(TAG, "Error on linkToDeath on IServiceManager");
                supplicantServiceDiedHandler();
                return false;
            }
            IServiceNotification serviceNotificationCb = new IServiceNotification.Stub() {

                public void onRegistration(String fqName, String name, boolean preexisting) {
                    Log.i(TAG, "IServiceNotification.onRegistration for: " + fqName + ", " + name + " preexisting=" + preexisting);
                    if (!getSupplicantService() || !getSupplicantStaIface() || !getSupplicantP2pIface()) {
                        Log.e(TAG, "initalizing ISupplicantIfaces failed.");
                        supplicantServiceDiedHandler();
                    }
                    Log.i(TAG, "Completed initialization of ISupplicant service and Ifaces!");
                }
            };
            /* TODO(b/33639391) : Use the new ISupplicant.registerForNotifications() once it
                   exists */
            if (!serviceManager.registerForNotifications(ISupplicant.kInterfaceName, "", serviceNotificationCb)) {
                Log.e(TAG, "Failed to register for notifications to " + ISupplicant.kInterfaceName);
                return false;
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Exception while trying to register a listener for ISupplicant service: " + e);
        }
        mHalDeviceManager.initialize();
        mHalDeviceManager.registerStatusListener(mHalDeviceManagerStatusCallbacks, mWifiStateMachineHandlerThread.getLooper());
        return true;
    }
}
#end_block

#method_before
private void supplicantServiceDiedHandler() {
    synchronized (mLock) {
        mHidlSupplicant = null;
        mHidlSupplicantStaIface = null;
        mHidlSupplicantP2pIface = null;
    }
}
#method_after
private void supplicantServiceDiedHandler() {
    resetHandles();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    super.setUp("GsmInboundSmsHandlerTest");
    doReturn(true).when(mTelephonyManager).getSmsReceiveCapableForPhone(anyInt(), anyBoolean());
    doReturn(true).when(mSmsStorageMonitor).isStorageAvailable();
    UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    doReturn(true).when(userManager).isUserUnlocked();
    try {
        doReturn(new int[] { UserHandle.USER_SYSTEM }).when(mIActivityManager).getRunningUserIds();
    } catch (RemoteException re) {
        fail("Unexpected RemoteException: " + re.getStackTrace());
    }
    mSmsMessage.mWrappedSmsMessage = mGsmSmsMessage;
    mInboundSmsTrackerCV.put("destination_port", 1 << 16);
    mInboundSmsTrackerCV.put("pdu", HexDump.toHexString(mSmsPdu));
    mInboundSmsTrackerCV.put("address", "1234567890");
    mInboundSmsTrackerCV.put("reference_number", 1);
    mInboundSmsTrackerCV.put("sequence", 1);
    mInboundSmsTrackerCV.put("count", 1);
    mInboundSmsTrackerCV.put("date", System.currentTimeMillis());
    mInboundSmsTrackerCV.put("message_body", mMessageBody);
    doReturn(1).when(mInboundSmsTracker).getMessageCount();
    doReturn(1).when(mInboundSmsTracker).getReferenceNumber();
    doReturn("1234567890").when(mInboundSmsTracker).getAddress();
    doReturn(1).when(mInboundSmsTracker).getSequenceNumber();
    doReturn(1).when(mInboundSmsTracker).getIndexOffset();
    doReturn(-1).when(mInboundSmsTracker).getDestPort();
    doReturn(mMessageBody).when(mInboundSmsTracker).getMessageBody();
    doReturn(mSmsPdu).when(mInboundSmsTracker).getPdu();
    doReturn(mInboundSmsTrackerCV.get("date")).when(mInboundSmsTracker).getTimestamp();
    doReturn(mInboundSmsTrackerCV).when(mInboundSmsTracker).getContentValues();
    mContentProvider = new FakeSmsContentProvider();
    ((MockContentResolver) mContext.getContentResolver()).addProvider(Telephony.Sms.CONTENT_URI.getAuthority(), mContentProvider);
    mGsmInboundSmsHandlerTestHandler = new GsmInboundSmsHandlerTestHandler(TAG);
    mGsmInboundSmsHandlerTestHandler.start();
    waitUntilReady();
}
#method_after
@Before
public void setUp() throws Exception {
    super.setUp("GsmInboundSmsHandlerTest");
    doReturn(true).when(mTelephonyManager).getSmsReceiveCapableForPhone(anyInt(), anyBoolean());
    doReturn(true).when(mSmsStorageMonitor).isStorageAvailable();
    UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    doReturn(true).when(userManager).isUserUnlocked();
    try {
        doReturn(new int[] { UserHandle.USER_SYSTEM }).when(mIActivityManager).getRunningUserIds();
    } catch (RemoteException re) {
        fail("Unexpected RemoteException: " + re.getStackTrace());
    }
    mSmsMessage.mWrappedSmsMessage = mGsmSmsMessage;
    mInboundSmsTrackerCV.put("destination_port", 1 << 16);
    mInboundSmsTrackerCV.put("pdu", HexDump.toHexString(mSmsPdu));
    mInboundSmsTrackerCV.put("address", "1234567890");
    mInboundSmsTrackerCV.put("reference_number", 1);
    mInboundSmsTrackerCV.put("sequence", 1);
    mInboundSmsTrackerCV.put("count", 1);
    mInboundSmsTrackerCV.put("date", System.currentTimeMillis());
    mInboundSmsTrackerCV.put("message_body", mMessageBody);
    mInboundSmsTrackerCV.put("display_originating_addr", "1234567890");
    doReturn(1).when(mInboundSmsTracker).getMessageCount();
    doReturn(1).when(mInboundSmsTracker).getReferenceNumber();
    doReturn("1234567890").when(mInboundSmsTracker).getAddress();
    doReturn(1).when(mInboundSmsTracker).getSequenceNumber();
    doReturn(1).when(mInboundSmsTracker).getIndexOffset();
    doReturn(-1).when(mInboundSmsTracker).getDestPort();
    doReturn(mMessageBody).when(mInboundSmsTracker).getMessageBody();
    doReturn(mSmsPdu).when(mInboundSmsTracker).getPdu();
    doReturn(mInboundSmsTrackerCV.get("date")).when(mInboundSmsTracker).getTimestamp();
    doReturn(mInboundSmsTrackerCV).when(mInboundSmsTracker).getContentValues();
    mContentProvider = new FakeSmsContentProvider();
    ((MockContentResolver) mContext.getContentResolver()).addProvider(Telephony.Sms.CONTENT_URI.getAuthority(), mContentProvider);
    mGsmInboundSmsHandlerTestHandler = new GsmInboundSmsHandlerTestHandler(TAG);
    mGsmInboundSmsHandlerTestHandler.start();
    waitUntilReady();
}
#end_block

#method_before
@Test
@MediumTest
public void testNewSmsFromBlockedNumber_noBroadcastsSent() {
    String blockedNumber = "123456789";
    doReturn(blockedNumber).when(mInboundSmsTracker).getAddress();
    mFakeBlockedNumberContentProvider.mBlockedNumbers.add(blockedNumber);
    transitionFromStartupToIdle();
    mGsmInboundSmsHandler.sendMessage(InboundSmsHandler.EVENT_NEW_SMS, new AsyncResult(null, mSmsMessage, null));
    waitForMs(100);
    verify(mContext, never()).sendBroadcast(any(Intent.class));
    assertEquals("IdleState", getCurrentState().getName());
}
#method_after
@Test
@MediumTest
public void testNewSmsFromBlockedNumber_noBroadcastsSent() {
    String blockedNumber = "1234567890";
    doReturn(blockedNumber).when(mInboundSmsTracker).getDisplayAddress();
    mFakeBlockedNumberContentProvider.mBlockedNumbers.add(blockedNumber);
    transitionFromStartupToIdle();
    mGsmInboundSmsHandler.sendMessage(InboundSmsHandler.EVENT_NEW_SMS, new AsyncResult(null, mSmsMessage, null));
    waitForMs(100);
    verify(mContext, never()).sendBroadcast(any(Intent.class));
    assertEquals("IdleState", getCurrentState().getName());
}
#end_block

#method_before
private void prepareMultiPartSms() {
    // Part 1
    mInboundSmsTrackerCVPart1 = new ContentValues();
    mInboundSmsTrackerCVPart1.put("destination_port", 1 << 16);
    mInboundSmsTrackerCVPart1.put("pdu", HexDump.toHexString(mSmsPdu));
    mInboundSmsTrackerCVPart1.put("address", "1234567890");
    mInboundSmsTrackerCVPart1.put("reference_number", 1);
    mInboundSmsTrackerCVPart1.put("sequence", 1);
    mInboundSmsTrackerCVPart1.put("count", 2);
    mInboundSmsTrackerCVPart1.put("date", System.currentTimeMillis());
    mInboundSmsTrackerCVPart1.put("message_body", mMessageBodyPart1);
    doReturn(2).when(mInboundSmsTrackerPart1).getMessageCount();
    doReturn(1).when(mInboundSmsTrackerPart1).getReferenceNumber();
    doReturn("1234567890").when(mInboundSmsTrackerPart1).getAddress();
    doReturn(1).when(mInboundSmsTrackerPart1).getSequenceNumber();
    doReturn(1).when(mInboundSmsTrackerPart1).getIndexOffset();
    doReturn(-1).when(mInboundSmsTrackerPart1).getDestPort();
    doReturn(mMessageBodyPart1).when(mInboundSmsTrackerPart1).getMessageBody();
    doReturn(mSmsPdu).when(mInboundSmsTrackerPart1).getPdu();
    doReturn(mInboundSmsTrackerCVPart1.get("date")).when(mInboundSmsTrackerPart1).getTimestamp();
    doReturn(mInboundSmsTrackerCVPart1).when(mInboundSmsTrackerPart1).getContentValues();
    // Part 2
    mInboundSmsTrackerCVPart2 = new ContentValues();
    mInboundSmsTrackerCVPart2.put("destination_port", 1 << 16);
    mInboundSmsTrackerCVPart2.put("pdu", HexDump.toHexString(mSmsPdu));
    mInboundSmsTrackerCVPart2.put("address", "1234567890");
    mInboundSmsTrackerCVPart2.put("reference_number", 1);
    mInboundSmsTrackerCVPart2.put("sequence", 2);
    mInboundSmsTrackerCVPart2.put("count", 2);
    mInboundSmsTrackerCVPart2.put("date", System.currentTimeMillis());
    mInboundSmsTrackerCVPart2.put("message_body", mMessageBodyPart2);
    doReturn(2).when(mInboundSmsTrackerPart2).getMessageCount();
    doReturn(1).when(mInboundSmsTrackerPart2).getReferenceNumber();
    doReturn("1234567890").when(mInboundSmsTrackerPart2).getAddress();
    doReturn(2).when(mInboundSmsTrackerPart2).getSequenceNumber();
    doReturn(1).when(mInboundSmsTrackerPart2).getIndexOffset();
    doReturn(-1).when(mInboundSmsTrackerPart2).getDestPort();
    doReturn(mMessageBodyPart2).when(mInboundSmsTrackerPart2).getMessageBody();
    doReturn(mSmsPdu).when(mInboundSmsTrackerPart2).getPdu();
    doReturn(mInboundSmsTrackerCVPart2.get("date")).when(mInboundSmsTrackerPart2).getTimestamp();
    doReturn(mInboundSmsTrackerCVPart2).when(mInboundSmsTrackerPart2).getContentValues();
}
#method_after
private void prepareMultiPartSms() {
    // Part 1
    mInboundSmsTrackerCVPart1 = new ContentValues();
    mInboundSmsTrackerCVPart1.put("destination_port", 1 << 16);
    mInboundSmsTrackerCVPart1.put("pdu", HexDump.toHexString(mSmsPdu));
    mInboundSmsTrackerCVPart1.put("address", "1234567890");
    mInboundSmsTrackerCVPart1.put("reference_number", 1);
    mInboundSmsTrackerCVPart1.put("sequence", 1);
    mInboundSmsTrackerCVPart1.put("count", 2);
    mInboundSmsTrackerCVPart1.put("date", System.currentTimeMillis());
    mInboundSmsTrackerCVPart1.put("message_body", mMessageBodyPart1);
    mInboundSmsTrackerCVPart1.put("display_originating_addr", "1234567890");
    doReturn(2).when(mInboundSmsTrackerPart1).getMessageCount();
    doReturn(1).when(mInboundSmsTrackerPart1).getReferenceNumber();
    doReturn("1234567890").when(mInboundSmsTrackerPart1).getAddress();
    doReturn(1).when(mInboundSmsTrackerPart1).getSequenceNumber();
    doReturn(1).when(mInboundSmsTrackerPart1).getIndexOffset();
    doReturn(-1).when(mInboundSmsTrackerPart1).getDestPort();
    doReturn(mMessageBodyPart1).when(mInboundSmsTrackerPart1).getMessageBody();
    doReturn(mSmsPdu).when(mInboundSmsTrackerPart1).getPdu();
    doReturn(mInboundSmsTrackerCVPart1.get("date")).when(mInboundSmsTrackerPart1).getTimestamp();
    doReturn(mInboundSmsTrackerCVPart1).when(mInboundSmsTrackerPart1).getContentValues();
    // Part 2
    mInboundSmsTrackerCVPart2 = new ContentValues();
    mInboundSmsTrackerCVPart2.put("destination_port", 1 << 16);
    mInboundSmsTrackerCVPart2.put("pdu", HexDump.toHexString(mSmsPdu));
    mInboundSmsTrackerCVPart2.put("address", "1234567890");
    mInboundSmsTrackerCVPart2.put("reference_number", 1);
    mInboundSmsTrackerCVPart2.put("sequence", 2);
    mInboundSmsTrackerCVPart2.put("count", 2);
    mInboundSmsTrackerCVPart2.put("date", System.currentTimeMillis());
    mInboundSmsTrackerCVPart2.put("message_body", mMessageBodyPart2);
    mInboundSmsTrackerCVPart2.put("display_originating_addr", "1234567890");
    doReturn(2).when(mInboundSmsTrackerPart2).getMessageCount();
    doReturn(1).when(mInboundSmsTrackerPart2).getReferenceNumber();
    doReturn("1234567890").when(mInboundSmsTrackerPart2).getAddress();
    doReturn(2).when(mInboundSmsTrackerPart2).getSequenceNumber();
    doReturn(1).when(mInboundSmsTrackerPart2).getIndexOffset();
    doReturn(-1).when(mInboundSmsTrackerPart2).getDestPort();
    doReturn(mMessageBodyPart2).when(mInboundSmsTrackerPart2).getMessageBody();
    doReturn(mSmsPdu).when(mInboundSmsTrackerPart2).getPdu();
    doReturn(mInboundSmsTrackerCVPart2.get("date")).when(mInboundSmsTrackerPart2).getTimestamp();
    doReturn(mInboundSmsTrackerCVPart2).when(mInboundSmsTrackerPart2).getContentValues();
}
#end_block

#method_before
private boolean processMessagePart(InboundSmsTracker tracker) {
    int messageCount = tracker.getMessageCount();
    byte[][] pdus;
    int destPort = tracker.getDestPort();
    boolean block = false;
    if (messageCount == 1) {
        // single-part message
        pdus = new byte[][] { tracker.getPdu() };
    } else {
        // multi-part message
        Cursor cursor = null;
        try {
            // used by several query selection arguments
            String address = tracker.getAddress();
            String refNumber = Integer.toString(tracker.getReferenceNumber());
            String count = Integer.toString(tracker.getMessageCount());
            // query for all segments and broadcast message if we have all the parts
            String[] whereArgs = { address, refNumber, count };
            cursor = mResolver.query(sRawUri, PDU_SEQUENCE_PORT_PROJECTION, SELECT_BY_REFERENCE, whereArgs, null);
            int cursorCount = cursor.getCount();
            if (cursorCount < messageCount) {
                // get a row count of 0 and return.
                return false;
            }
            // All the parts are in place, deal with them
            pdus = new byte[messageCount][];
            while (cursor.moveToNext()) {
                // subtract offset to convert sequence to 0-based array index
                int index = cursor.getInt(PUD_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(SEQUENCE_COLUMN)) - tracker.getIndexOffset();
                pdus[index] = HexDump.hexStringToByteArray(cursor.getString(PUD_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(PDU_COLUMN)));
                // It's not a bad idea to prefer the port from the first segment in other cases.
                if (index == 0 && !cursor.isNull(PUD_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(DESTINATION_PORT_COLUMN))) {
                    int port = cursor.getInt(PUD_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(DESTINATION_PORT_COLUMN));
                    // strip format flags and convert to real port number, or -1
                    port = InboundSmsTracker.getRealDestPort(port);
                    if (port != -1) {
                        destPort = port;
                    }
                }
                // check if display address should be blocked or not
                if (!block) {
                    // Depending on the nature of the gateway, the display origination address
                    // is either derived from the content of the SMS TP-OA field, or the TP-OA
                    // field contains a generic gateway address and the from address is added
                    // at the beginning in the message body. In that case only the first SMS
                    // (part of Multi-SMS) comes with the display origination address which
                    // could used for block checking purpose.
                    block = BlockChecker.isBlocked(mContext, cursor.getString(PUD_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(DISPLAY_ADDRESS_COLUMN)));
                }
            }
        } catch (SQLException e) {
            loge("Can't access multipart SMS database", e);
            return false;
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
    // Do not process null pdu(s). Check for that and return false in that case.
    List<byte[]> pduList = Arrays.asList(pdus);
    if (pduList.size() == 0 || pduList.contains(null)) {
        loge("processMessagePart: returning false due to " + (pduList.size() == 0 ? "pduList.size() == 0" : "pduList.contains(null)"));
        return false;
    }
    SmsBroadcastReceiver resultReceiver = new SmsBroadcastReceiver(tracker);
    if (!mUserManager.isUserUnlocked()) {
        return processMessagePartWithUserLocked(tracker, pdus, destPort, resultReceiver);
    }
    if (destPort == SmsHeader.PORT_WAP_PUSH) {
        // Build up the data stream
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        for (byte[] pdu : pdus) {
            // 3GPP needs to extract the User Data from the PDU; 3GPP2 has already done this
            if (!tracker.is3gpp2()) {
                SmsMessage msg = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
                if (msg != null) {
                    pdu = msg.getUserData();
                } else {
                    loge("processMessagePart: SmsMessage.createFromPdu returned null");
                    return false;
                }
            }
            output.write(pdu, 0, pdu.length);
        }
        int result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver, this);
        if (DBG)
            log("dispatchWapPdu() returned " + result);
        // result is Activity.RESULT_OK if an ordered broadcast was sent
        if (result == Activity.RESULT_OK) {
            return true;
        } else {
            deleteFromRawTable(tracker.getDeleteWhere(), tracker.getDeleteWhereArgs(), MARK_DELETED);
            return false;
        }
    }
    if (block) {
        deleteFromRawTable(tracker.getDeleteWhere(), tracker.getDeleteWhereArgs(), DELETE_PERMANENTLY);
        return false;
    }
    boolean filterInvoked = filterSms(pdus, destPort, tracker, resultReceiver, true);
    if (!filterInvoked) {
        dispatchSmsDeliveryIntent(pdus, tracker.getFormat(), destPort, resultReceiver);
    }
    return true;
}
#method_after
private boolean processMessagePart(InboundSmsTracker tracker) {
    int messageCount = tracker.getMessageCount();
    byte[][] pdus;
    int destPort = tracker.getDestPort();
    boolean block = false;
    if (messageCount == 1) {
        // single-part message
        pdus = new byte[][] { tracker.getPdu() };
        block = BlockChecker.isBlocked(mContext, tracker.getDisplayAddress());
    } else {
        // multi-part message
        Cursor cursor = null;
        try {
            // used by several query selection arguments
            String address = tracker.getAddress();
            String refNumber = Integer.toString(tracker.getReferenceNumber());
            String count = Integer.toString(tracker.getMessageCount());
            // query for all segments and broadcast message if we have all the parts
            String[] whereArgs = { address, refNumber, count };
            cursor = mResolver.query(sRawUri, PDU_SEQUENCE_PORT_PROJECTION, SELECT_BY_REFERENCE, whereArgs, null);
            int cursorCount = cursor.getCount();
            if (cursorCount < messageCount) {
                // get a row count of 0 and return.
                return false;
            }
            // All the parts are in place, deal with them
            pdus = new byte[messageCount][];
            while (cursor.moveToNext()) {
                // subtract offset to convert sequence to 0-based array index
                int index = cursor.getInt(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(SEQUENCE_COLUMN)) - tracker.getIndexOffset();
                pdus[index] = HexDump.hexStringToByteArray(cursor.getString(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(PDU_COLUMN)));
                // It's not a bad idea to prefer the port from the first segment in other cases.
                if (index == 0 && !cursor.isNull(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(DESTINATION_PORT_COLUMN))) {
                    int port = cursor.getInt(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(DESTINATION_PORT_COLUMN));
                    // strip format flags and convert to real port number, or -1
                    port = InboundSmsTracker.getRealDestPort(port);
                    if (port != -1) {
                        destPort = port;
                    }
                }
                // check if display address should be blocked or not
                if (!block) {
                    // Depending on the nature of the gateway, the display origination address
                    // is either derived from the content of the SMS TP-OA field, or the TP-OA
                    // field contains a generic gateway address and the from address is added
                    // at the beginning in the message body. In that case only the first SMS
                    // (part of Multi-SMS) comes with the display originating address which
                    // could be used for block checking purpose.
                    block = BlockChecker.isBlocked(mContext, cursor.getString(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING.get(DISPLAY_ADDRESS_COLUMN)));
                }
            }
        } catch (SQLException e) {
            loge("Can't access multipart SMS database", e);
            return false;
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }
    // Do not process null pdu(s). Check for that and return false in that case.
    List<byte[]> pduList = Arrays.asList(pdus);
    if (pduList.size() == 0 || pduList.contains(null)) {
        loge("processMessagePart: returning false due to " + (pduList.size() == 0 ? "pduList.size() == 0" : "pduList.contains(null)"));
        return false;
    }
    SmsBroadcastReceiver resultReceiver = new SmsBroadcastReceiver(tracker);
    if (!mUserManager.isUserUnlocked()) {
        return processMessagePartWithUserLocked(tracker, pdus, destPort, resultReceiver);
    }
    if (destPort == SmsHeader.PORT_WAP_PUSH) {
        // Build up the data stream
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        for (byte[] pdu : pdus) {
            // 3GPP needs to extract the User Data from the PDU; 3GPP2 has already done this
            if (!tracker.is3gpp2()) {
                SmsMessage msg = SmsMessage.createFromPdu(pdu, SmsConstants.FORMAT_3GPP);
                if (msg != null) {
                    pdu = msg.getUserData();
                } else {
                    loge("processMessagePart: SmsMessage.createFromPdu returned null");
                    return false;
                }
            }
            output.write(pdu, 0, pdu.length);
        }
        int result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver, this);
        if (DBG)
            log("dispatchWapPdu() returned " + result);
        // result is Activity.RESULT_OK if an ordered broadcast was sent
        if (result == Activity.RESULT_OK) {
            return true;
        } else {
            deleteFromRawTable(tracker.getDeleteWhere(), tracker.getDeleteWhereArgs(), MARK_DELETED);
            return false;
        }
    }
    if (block) {
        deleteFromRawTable(tracker.getDeleteWhere(), tracker.getDeleteWhereArgs(), DELETE_PERMANENTLY);
        return false;
    }
    boolean filterInvoked = filterSms(pdus, destPort, tracker, resultReceiver, true);
    if (!filterInvoked) {
        dispatchSmsDeliveryIntent(pdus, tracker.getFormat(), destPort, resultReceiver);
    }
    return true;
}
#end_block

#method_before
public static MatrixCursor createFakeCursor() {
    MatrixCursor mc = new MatrixCursor(new String[] { "pdu", "seq", "dest", "date", "ref", "cnt", "addr", "id", "msg_body" });
    mc.addRow(new Object[] { HexDump.toHexString(FAKE_PDU), FAKE_SEQUENCE_NUMBER, FAKE_DEST_PORT, FAKE_TIMESTAMP, FAKE_REFERENCE_NUMBER, FAKE_MESSAGE_COUNT, FAKE_ADDRESS, 1, FAKE_MESSAGE_BODY });
    mc.addRow(new Object[] { HexDump.toHexString(FAKE_PDU), FAKE_SEQUENCE_NUMBER, FAKE_DEST_PORT, FAKE_TIMESTAMP, FAKE_REFERENCE_NUMBER, FAKE_MESSAGE_COUNT, FAKE_ADDRESS, 2, FAKE_MESSAGE_BODY });
    mc.moveToFirst();
    return mc;
}
#method_after
public static MatrixCursor createFakeCursor() {
    MatrixCursor mc = new MatrixCursor(new String[] { "pdu", "seq", "dest", "date", "ref", "cnt", "addr", "id", "msg_body", "display_originating_addr" });
    mc.addRow(new Object[] { HexDump.toHexString(FAKE_PDU), FAKE_SEQUENCE_NUMBER, FAKE_DEST_PORT, FAKE_TIMESTAMP, FAKE_REFERENCE_NUMBER, FAKE_MESSAGE_COUNT, FAKE_ADDRESS, 1, FAKE_MESSAGE_BODY, FAKE_DISPLAY_ADDRESS });
    mc.addRow(new Object[] { HexDump.toHexString(FAKE_PDU), FAKE_SEQUENCE_NUMBER, FAKE_DEST_PORT, FAKE_TIMESTAMP, FAKE_REFERENCE_NUMBER, FAKE_MESSAGE_COUNT, FAKE_ADDRESS, 2, FAKE_MESSAGE_BODY, FAKE_DISPLAY_ADDRESS });
    mc.moveToFirst();
    return mc;
}
#end_block

#method_before
@Test
@SmallTest
public void testInitialization() {
    assertTrue(Arrays.equals(FAKE_PDU, mInboundSmsTracker.getPdu()));
    assertEquals(FAKE_TIMESTAMP, mInboundSmsTracker.getTimestamp());
    assertEquals(FAKE_DEST_PORT, mInboundSmsTracker.getDestPort());
    assertFalse(mInboundSmsTracker.is3gpp2());
    assertEquals(FAKE_ADDRESS, mInboundSmsTracker.getAddress());
    assertEquals(FAKE_REFERENCE_NUMBER, mInboundSmsTracker.getReferenceNumber());
    assertEquals(FAKE_SEQUENCE_NUMBER, mInboundSmsTracker.getSequenceNumber());
    assertEquals(FAKE_MESSAGE_COUNT, mInboundSmsTracker.getMessageCount());
    assertEquals(1, mInboundSmsTracker.getIndexOffset());
    assertEquals(SmsConstants.FORMAT_3GPP, mInboundSmsTracker.getFormat());
    assertEquals(FAKE_MESSAGE_BODY, mInboundSmsTracker.getMessageBody());
    String[] args = new String[] { "123" };
    mInboundSmsTracker.setDeleteWhere(InboundSmsHandler.SELECT_BY_ID, args);
    assertEquals(InboundSmsHandler.SELECT_BY_ID, mInboundSmsTracker.getDeleteWhere());
    assertTrue(Arrays.equals(args, mInboundSmsTracker.getDeleteWhereArgs()));
}
#method_after
@Test
@SmallTest
public void testInitialization() {
    assertTrue(Arrays.equals(FAKE_PDU, mInboundSmsTracker.getPdu()));
    assertEquals(FAKE_TIMESTAMP, mInboundSmsTracker.getTimestamp());
    assertEquals(FAKE_DEST_PORT, mInboundSmsTracker.getDestPort());
    assertFalse(mInboundSmsTracker.is3gpp2());
    assertEquals(FAKE_ADDRESS, mInboundSmsTracker.getAddress());
    assertEquals(FAKE_REFERENCE_NUMBER, mInboundSmsTracker.getReferenceNumber());
    assertEquals(FAKE_SEQUENCE_NUMBER, mInboundSmsTracker.getSequenceNumber());
    assertEquals(FAKE_MESSAGE_COUNT, mInboundSmsTracker.getMessageCount());
    assertEquals(1, mInboundSmsTracker.getIndexOffset());
    assertEquals(SmsConstants.FORMAT_3GPP, mInboundSmsTracker.getFormat());
    assertEquals(FAKE_MESSAGE_BODY, mInboundSmsTracker.getMessageBody());
    assertEquals(FAKE_DISPLAY_ADDRESS, mInboundSmsTracker.getDisplayAddress());
    String[] args = new String[] { "123" };
    mInboundSmsTracker.setDeleteWhere(InboundSmsHandler.SELECT_BY_ID, args);
    assertEquals(InboundSmsHandler.SELECT_BY_ID, mInboundSmsTracker.getDeleteWhere());
    assertTrue(Arrays.equals(args, mInboundSmsTracker.getDeleteWhereArgs()));
}
#end_block

#method_before
@Override
public MethodType getMethodType() {
    // The "nominal" type of a cracked method handle is the same as the type
    // of the handle itself, except in the cases enumerated below :
    MethodType handleType = handle.type();
    boolean omitLeadingParam = false;
    // the object returned.
    if (member instanceof Constructor) {
        handleType = handleType.changeReturnType(void.class);
        omitLeadingParam = true;
    }
    // leading reference parameter to |this|.
    switch(handle.getHandleKind()) {
        case IGET:
        case IPUT:
        case INVOKE_INTERFACE:
        case INVOKE_DIRECT:
        case INVOKE_VIRTUAL:
        case INVOKE_SUPER:
            omitLeadingParam = true;
    }
    return omitLeadingParam ? handleType.dropParameterTypes(0, 1) : handleType;
}
#method_after
@Override
public MethodType getMethodType() {
    // The "nominal" type of a cracked method handle is the same as the type
    // of the handle itself, except in the cases enumerated below.
    MethodType handleType = handle.type();
    boolean omitLeadingParam = false;
    // nominally the type of the object being constructed.
    if (member instanceof Constructor) {
        handleType = handleType.changeReturnType(void.class);
        omitLeadingParam = true;
    }
    // leading reference parameter to |this|.
    switch(handle.getHandleKind()) {
        case IGET:
        case IPUT:
        case INVOKE_INTERFACE:
        case INVOKE_DIRECT:
        case INVOKE_VIRTUAL:
        case INVOKE_SUPER:
            omitLeadingParam = true;
    }
    return omitLeadingParam ? handleType.dropParameterTypes(0, 1) : handleType;
}
#end_block

#method_before
@SmallTest
public void testSatisfiedNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, 150);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, 150);
    // pass timeout and validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testSatisfiedNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    final int timeoutMs = 150;
    mCm.requestNetwork(nr, networkCallback, timeoutMs);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, timeoutMs);
    // pass timeout and validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#end_block

#method_before
@SmallTest
public void testSatisfiedThenLostNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, 100);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, 150);
    sleepFor(20);
    mWiFiNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // pass timeout and validate that UNAVAILABLE is not called
    sleepFor(100);
    networkCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testSatisfiedThenLostNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    final int requestTimeoutMs = 100;
    mCm.requestNetwork(nr, networkCallback, requestTimeoutMs);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    final int assertTimeoutMs = 150;
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, assertTimeoutMs);
    sleepFor(20);
    mWiFiNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // pass timeout and validate that UNAVAILABLE is not called
    sleepFor(100);
    networkCallback.assertNoCallback();
}
#end_block

#method_before
@SmallTest
public void testTimedoutNetworkRequest() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, 10);
    // pass timeout and validate that UNAVAILABLE is called
    networkCallback.expectCallback(CallbackState.UNAVAILABLE, null);
    // create a network satisfying request - validate that request not triggered
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testTimedoutNetworkRequest() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    final int timeoutMs = 10;
    mCm.requestNetwork(nr, networkCallback, timeoutMs);
    // pass timeout and validate that UNAVAILABLE is called
    networkCallback.expectCallback(CallbackState.UNAVAILABLE, null);
    // create a network satisfying request - validate that request not triggered
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.assertNoCallback();
}
#end_block

#method_before
@SmallTest
public void testTimedoutAfterUnregisteredNetworkRequest() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, 10);
    // remove request
    mCm.unregisterNetworkCallback(networkCallback);
    // pass timeout and validate that no callbacks
    // Note: doesn't validate that nothing called from CS since even if called the CM already
    // unregisters the callback and won't pass it through!
    sleepFor(15);
    networkCallback.assertNoCallback();
    // create a network satisfying request - validate that request not triggered
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testTimedoutAfterUnregisteredNetworkRequest() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    final int timeoutMs = 10;
    mCm.requestNetwork(nr, networkCallback, timeoutMs);
    // remove request
    mCm.unregisterNetworkCallback(networkCallback);
    // pass timeout and validate that no callbacks
    // Note: doesn't validate that nothing called from CS since even if called the CM already
    // unregisters the callback and won't pass it through!
    sleepFor(15);
    networkCallback.assertNoCallback();
    // create a network satisfying request - validate that request not triggered
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.assertNoCallback();
}
#end_block

#method_before
private void handleMobileDataAlwaysOn() {
    final boolean enable = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.MOBILE_DATA_ALWAYS_ON, 0) == 1);
    final boolean isEnabled = (mNetworkRequests.get(mDefaultMobileDataRequest) != null);
    if (enable == isEnabled) {
        // Nothing to do.
        return;
    }
    if (enable) {
        handleRegisterNetworkRequest(new NetworkRequestInfo(null, mDefaultMobileDataRequest, new Binder()));
    } else {
        handleReleaseNetworkRequest(mDefaultMobileDataRequest, Process.SYSTEM_UID);
    }
}
#method_after
private void handleMobileDataAlwaysOn() {
    final boolean enable = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.MOBILE_DATA_ALWAYS_ON, 1) == 1);
    final boolean isEnabled = (mNetworkRequests.get(mDefaultMobileDataRequest) != null);
    if (enable == isEnabled) {
        // Nothing to do.
        return;
    }
    if (enable) {
        handleRegisterNetworkRequest(new NetworkRequestInfo(null, mDefaultMobileDataRequest, new Binder()));
    } else {
        handleReleaseNetworkRequest(mDefaultMobileDataRequest, Process.SYSTEM_UID);
    }
}
#end_block

#method_before
// if ro.tether.denied = true we default to no tethering
// gservices could set the secure setting to 1 though to enable it on a build where it
@Override
public boolean isTetheringSupported() {
    enforceTetherAccessPermission();
    int defaultVal = (SystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1);
    boolean tetherEnabledInSettings = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TETHER_SUPPORTED, defaultVal) != 0) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING);
    return tetherEnabledInSettings && mUserManager.isAdminUser() && ((mTethering.getTetherableUsbRegexs().length != 0 || mTethering.getTetherableWifiRegexs().length != 0 || mTethering.getTetherableBluetoothRegexs().length != 0) && mTethering.getUpstreamIfaceTypes().length != 0);
}
#method_after
// if ro.tether.denied = true we default to no tethering
// gservices could set the secure setting to 1 though to enable it on a build where it
@Override
public boolean isTetheringSupported() {
    enforceTetherAccessPermission();
    int defaultVal = (SystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1);
    boolean tetherEnabledInSettings = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TETHER_SUPPORTED, defaultVal) != 0) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING);
    return tetherEnabledInSettings && mUserManager.isAdminUser() && mTethering.hasTetherableConfiguration();
}
#end_block

#method_before
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final int userId = UserHandle.getCallingUserId();
    // Turn airplane mode off
    setAirplaneMode(false);
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Untether
        for (String tether : getTetheredIfaces()) {
            untether(tether);
        }
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN)) {
        // Remove always-on package
        synchronized (mVpns) {
            final String alwaysOnPackage = getAlwaysOnVpnPackage(userId);
            if (alwaysOnPackage != null) {
                setAlwaysOnVpnPackage(userId, null, false);
                setVpnPackageAuthorization(alwaysOnPackage, userId, false);
            }
        }
        // Turn VPN off
        VpnConfig vpnConfig = getVpnConfig(userId);
        if (vpnConfig != null) {
            if (vpnConfig.legacy) {
                prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN, userId);
            } else {
                // Prevent this app (packagename = vpnConfig.user) from initiating VPN connections
                // in the future without user intervention.
                setVpnPackageAuthorization(vpnConfig.user, userId, false);
                prepareVpn(null, VpnConfig.LEGACY_VPN, userId);
            }
        }
    }
    Settings.Global.putString(mContext.getContentResolver(), Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
}
#method_after
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final int userId = UserHandle.getCallingUserId();
    // Turn airplane mode off
    setAirplaneMode(false);
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Untether
        for (String tether : getTetheredIfaces()) {
            untether(tether);
        }
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN)) {
        // Remove always-on package
        synchronized (mVpns) {
            final String alwaysOnPackage = getAlwaysOnVpnPackage(userId);
            if (alwaysOnPackage != null) {
                setAlwaysOnVpnPackage(userId, null, false);
                setVpnPackageAuthorization(alwaysOnPackage, userId, false);
            }
        }
        // Turn Always-on VPN off
        if (mLockdownEnabled && userId == UserHandle.USER_SYSTEM) {
            final long ident = Binder.clearCallingIdentity();
            try {
                mKeyStore.delete(Credentials.LOCKDOWN_VPN);
                mLockdownEnabled = false;
                setLockdownTracker(null);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
        // Turn VPN off
        VpnConfig vpnConfig = getVpnConfig(userId);
        if (vpnConfig != null) {
            if (vpnConfig.legacy) {
                prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN, userId);
            } else {
                // Prevent this app (packagename = vpnConfig.user) from initiating VPN connections
                // in the future without user intervention.
                setVpnPackageAuthorization(vpnConfig.user, userId, false);
                prepareVpn(null, VpnConfig.LEGACY_VPN, userId);
            }
        }
    }
    Settings.Global.putString(mContext.getContentResolver(), Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
}
#end_block

#method_before
@SmallTest
public void testMultipleLingering() {
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addCapability(NET_CAPABILITY_NOT_METERED).build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mEthernetNetworkAgent = new MockNetworkAgent(TRANSPORT_ETHERNET);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mWiFiNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mEthernetNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.connect(true);
    // We get AVAILABLE on wifi when wifi connects and satisfies our unmetered request.
    // We then get LOSING when wifi validates and cell is outscored.
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mEthernetNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mEthernetNetworkAgent);
    assertEquals(mEthernetNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    for (int i = 0; i < 4; i++) {
        MockNetworkAgent oldNetwork, newNetwork;
        if (i % 2 == 0) {
            mWiFiNetworkAgent.adjustScore(-15);
            oldNetwork = mWiFiNetworkAgent;
            newNetwork = mCellNetworkAgent;
        } else {
            mWiFiNetworkAgent.adjustScore(15);
            oldNetwork = mCellNetworkAgent;
            newNetwork = mWiFiNetworkAgent;
        }
        callback.expectCallback(CallbackState.LOSING, oldNetwork);
        // TODO: should we send an AVAILABLE callback to newNetwork, to indicate that it is no
        // longer lingering?
        defaultCallback.expectCallback(CallbackState.AVAILABLE, newNetwork);
        assertEquals(newNetwork.getNetwork(), mCm.getActiveNetwork());
    }
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Verify that if a network no longer satisfies a request, we send LOST and not LOSING, even
    // if the network is still up.
    mWiFiNetworkAgent.removeCapability(NET_CAPABILITY_NOT_METERED);
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Wifi no longer satisfies our listen, which is for an unmetered network.
    // But because its score is 55, it's still up (and the default network).
    defaultCallback.assertNoCallback();
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Disconnect our test networks.
    mWiFiNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mService.waitForIdle();
    // Check that a network is only lingered or torn down if it would not satisfy a request even
    // if it validated.
    request = new NetworkRequest.Builder().clearCapabilities().build();
    callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Score: 10
    mCellNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 20.
    // Cell stays up because it would satisfy the default request if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Score: 20
    mWiFiNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 70.
    // Cell is lingered because it would not satisfy any request, even if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.adjustScore(50);
    // Score: 70
    mWiFiNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Tear down wifi.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi, then validate it. Previous versions would immediately tear down cell, but
    // it's arguably correct to linger it, since it was the default network before it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // If a network is lingering, and we add and remove a request from it, resume lingering.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // TODO: should this cause an AVAILABLE callback, to indicate that the network is no longer
    // lingering?
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Similar to the above: lingering can start even after the lingered request is removed.
    // Disconnect wifi and switch to cell.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    // Cell is now the default network. Pin it with a cell-specific request.
    // Can't reuse NetworkCallbacks. http://b/20701525
    noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // Now connect wifi, and expect it to become the default network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    // The default request is lingering on cell, but nothing happens to cell, and we send no
    // callbacks for it, because it's kept up by cellRequest.
    callback.assertNoCallback();
    // Now unregister cellRequest and expect cell to start lingering.
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    final int lingerTimeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent, lingerTimeoutMs);
    // Clean up.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#method_after
@SmallTest
public void testMultipleLingering() {
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addCapability(NET_CAPABILITY_NOT_METERED).build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    TestNetworkCallback defaultCallback = new TestNetworkCallback();
    mCm.registerDefaultNetworkCallback(defaultCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mEthernetNetworkAgent = new MockNetworkAgent(TRANSPORT_ETHERNET);
    mCellNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mWiFiNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mEthernetNetworkAgent.addCapability(NET_CAPABILITY_NOT_METERED);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.connect(true);
    // We get AVAILABLE on wifi when wifi connects and satisfies our unmetered request.
    // We then get LOSING when wifi validates and cell is outscored.
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mEthernetNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mEthernetNetworkAgent);
    assertEquals(mEthernetNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mEthernetNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mEthernetNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    for (int i = 0; i < 4; i++) {
        MockNetworkAgent oldNetwork, newNetwork;
        if (i % 2 == 0) {
            mWiFiNetworkAgent.adjustScore(-15);
            oldNetwork = mWiFiNetworkAgent;
            newNetwork = mCellNetworkAgent;
        } else {
            mWiFiNetworkAgent.adjustScore(15);
            oldNetwork = mCellNetworkAgent;
            newNetwork = mWiFiNetworkAgent;
        }
        callback.expectCallback(CallbackState.LOSING, oldNetwork);
        // TODO: should we send an AVAILABLE callback to newNetwork, to indicate that it is no
        // longer lingering?
        defaultCallback.expectCallback(CallbackState.AVAILABLE, newNetwork);
        assertEquals(newNetwork.getNetwork(), mCm.getActiveNetwork());
    }
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Verify that if a network no longer satisfies a request, we send LOST and not LOSING, even
    // if the network is still up.
    mWiFiNetworkAgent.removeCapability(NET_CAPABILITY_NOT_METERED);
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // Wifi no longer satisfies our listen, which is for an unmetered network.
    // But because its score is 55, it's still up (and the default network).
    defaultCallback.assertNoCallback();
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Disconnect our test networks.
    mWiFiNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mService.waitForIdle();
    // Check that a network is only lingered or torn down if it would not satisfy a request even
    // if it validated.
    request = new NetworkRequest.Builder().clearCapabilities().build();
    callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    // Score: 10
    mCellNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 20.
    // Cell stays up because it would satisfy the default request if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // Score: 20
    mWiFiNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi with a score of 70.
    // Cell is lingered because it would not satisfy any request, even if it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.adjustScore(50);
    // Score: 70
    mWiFiNetworkAgent.connect(false);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Tear down wifi.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Bring up wifi, then validate it. Previous versions would immediately tear down cell, but
    // it's arguably correct to linger it, since it was the default network before it validated.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mCellNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    // If a network is lingering, and we add and remove a request from it, resume lingering.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    NetworkCallback noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // TODO: should this cause an AVAILABLE callback, to indicate that the network is no longer
    // lingering?
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Similar to the above: lingering can start even after the lingered request is removed.
    // Disconnect wifi and switch to cell.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    // Cell is now the default network. Pin it with a cell-specific request.
    // Can't reuse NetworkCallbacks. http://b/20701525
    noopCallback = new NetworkCallback();
    mCm.requestNetwork(cellRequest, noopCallback);
    // Now connect wifi, and expect it to become the default network.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    // The default request is lingering on cell, but nothing happens to cell, and we send no
    // callbacks for it, because it's kept up by cellRequest.
    callback.assertNoCallback();
    // Now unregister cellRequest and expect cell to start lingering.
    mCm.unregisterNetworkCallback(noopCallback);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // Let linger run its course.
    callback.assertNoCallback();
    callback.expectCallback(CallbackState.LOST, mCellNetworkAgent, TEST_LINGER_DELAY_MS);
    // Clean up.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    defaultCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(defaultCallback);
}
#end_block

#method_before
@SmallTest
public void testBackgroundNetworks() throws Exception {
    // Create a background request. We can't do this ourselves because ConnectivityService
    // doesn't have an API for it. So just turn on mobile data always on.
    setMobileDataAlwaysOn(true);
    final NetworkRequest request = new NetworkRequest.Builder().build();
    final NetworkRequest fgRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_FOREGROUND).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    final TestNetworkCallback fgCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCm.registerNetworkCallback(fgRequest, fgCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    // When wifi connects, cell lingers.
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // When lingering is complete, cell is still there but is now in the background.
    mService.waitForIdle();
    int timeoutMs = TEST_LINGER_DELAY_MS + TEST_LINGER_DELAY_MS / 4;
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent, timeoutMs);
    callback.assertNoCallback();
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // File a cell request and check that cell comes into the foreground.
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    final TestNetworkCallback cellCallback = new TestNetworkCallback();
    mCm.requestNetwork(cellRequest, cellCallback);
    cellCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    // Because the network is already up.
    callback.assertNoCallback();
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Release the request. The network immediately goes into the background, since it was not
    // lingering.
    mCm.unregisterNetworkCallback(cellCallback);
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    callback.assertNoCallback();
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Disconnect wifi and check that cell is foreground again.
    mWiFiNetworkAgent.disconnect();
    mService.waitForIdle();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(fgCallback);
}
#method_after
@SmallTest
public void testBackgroundNetworks() throws Exception {
    // Create a background request. We can't do this ourselves because ConnectivityService
    // doesn't have an API for it. So just turn on mobile data always on.
    setMobileDataAlwaysOn(true);
    final NetworkRequest request = new NetworkRequest.Builder().build();
    final NetworkRequest fgRequest = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_FOREGROUND).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    final TestNetworkCallback fgCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    mCm.registerNetworkCallback(fgRequest, fgCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(true);
    // When wifi connects, cell lingers.
    callback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // When lingering is complete, cell is still there but is now in the background.
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent, TEST_LINGER_DELAY_MS);
    callback.assertNoCallback();
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // File a cell request and check that cell comes into the foreground.
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    final TestNetworkCallback cellCallback = new TestNetworkCallback();
    mCm.requestNetwork(cellRequest, cellCallback);
    cellCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    // Because the network is already up.
    callback.assertNoCallback();
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Release the request. The network immediately goes into the background, since it was not
    // lingering.
    mCm.unregisterNetworkCallback(cellCallback);
    fgCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    callback.assertNoCallback();
    assertFalse(isForegroundNetwork(mCellNetworkAgent));
    assertTrue(isForegroundNetwork(mWiFiNetworkAgent));
    // Disconnect wifi and check that cell is foreground again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    fgCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    assertTrue(isForegroundNetwork(mCellNetworkAgent));
    mCm.unregisterNetworkCallback(callback);
    mCm.unregisterNetworkCallback(fgCallback);
}
#end_block

#method_before
@SmallTest
public void testSatisfiedNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, 150);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, 150);
    // pass timeout and validate that UNAVAILABLE is not called
    networkCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testSatisfiedNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, 10);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    // pass timeout and validate that UNAVAILABLE is not called
    sleepFor(15);
    networkCallback.assertNoCallback();
}
#end_block

#method_before
@SmallTest
public void testSatisfiedThenLostNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, 100);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent, 150);
    sleepFor(20);
    mWiFiNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // pass timeout and validate that UNAVAILABLE is not called
    sleepFor(100);
    networkCallback.assertNoCallback();
}
#method_after
@SmallTest
public void testSatisfiedThenLostNetworkRequestDoesNotTriggerOnUnavailable() {
    NetworkRequest nr = new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.requestNetwork(nr, networkCallback, 500);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connect(false);
    networkCallback.expectCallback(CallbackState.AVAILABLE, mWiFiNetworkAgent);
    sleepFor(20);
    mWiFiNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // pass timeout and validate that UNAVAILABLE is not called
    sleepFor(600);
    networkCallback.assertNoCallback();
}
#end_block

#method_before
public void assertEventuallyTrue(BooleanSupplier fn, long maxWaitingTimeMs) {
    long start = SystemClock.elapsedRealtime();
    while (SystemClock.elapsedRealtime() <= start + maxWaitingTimeMs) {
        if (fn.getAsBoolean()) {
            return;
        }
        sleepFor(15);
    }
    assertTrue(fn.getAsBoolean());
}
#method_after
public void assertEventuallyTrue(BooleanSupplier fn, long maxWaitingTimeMs) throws Exception {
    long start = SystemClock.elapsedRealtime();
    while (SystemClock.elapsedRealtime() <= start + maxWaitingTimeMs) {
        if (fn.getAsBoolean()) {
            return;
        }
        Thread.sleep(10);
    }
    assertTrue(fn.getAsBoolean());
}
#end_block

#method_before
@SmallTest
public void testPacketKeepalives() throws Exception {
    InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    InetAddress notMyIPv4 = InetAddress.getByName("192.0.2.35");
    InetAddress myIPv6 = InetAddress.getByName("2001:db8::1");
    InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    InetAddress dstIPv6 = InetAddress.getByName("2001:4860:4860::8888");
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv6, 64));
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("fe80::1234")));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network notMyNet = new Network(61234);
    Network myNet = connectKeepaliveNetwork(lp);
    TestKeepaliveCallback callback = new TestKeepaliveCallback();
    PacketKeepalive ka;
    // Attempt to start keepalives with invalid parameters and check for errors.
    ka = mCm.startNattKeepalive(notMyNet, 25, callback, myIPv4, 1234, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_NETWORK);
    ka = mCm.startNattKeepalive(myNet, 19, callback, notMyIPv4, 1234, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_INTERVAL);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 1234, dstIPv6);
    callback.expectError(PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv6, 1234, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv6, 1234, dstIPv6);
    // NAT-T is IPv4-only.
    callback.expectError(PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 123456, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_PORT);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 123456, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_PORT);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_HARDWARE_UNSUPPORTED);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_HARDWARE_UNSUPPORTED);
    // Check that a started keepalive can be stopped.
    mWiFiNetworkAgent.setStartKeepaliveError(PacketKeepalive.SUCCESS);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    mWiFiNetworkAgent.setStopKeepaliveError(PacketKeepalive.SUCCESS);
    ka.stop();
    callback.expectStopped();
    // Check that deleting the IP address stops the keepalive.
    LinkProperties bogusLp = new LinkProperties(lp);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    bogusLp.removeLinkAddress(new LinkAddress(myIPv4, 25));
    bogusLp.addLinkAddress(new LinkAddress(notMyIPv4, 25));
    mWiFiNetworkAgent.sendLinkProperties(bogusLp);
    callback.expectError(PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
    mWiFiNetworkAgent.sendLinkProperties(lp);
    // Check that a started keepalive is stopped correctly when the network disconnects.
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    mWiFiNetworkAgent.disconnect();
    callback.expectError(PacketKeepalive.ERROR_INVALID_NETWORK);
    // ... and that stopping it after that has no adverse effects.
    // TODO: investigate assertEventuallyTrue is needed and waitForIdle() is not enough
    final Network myNetAlias = myNet;
    assertEventuallyTrue(() -> mCm.getNetworkCapabilities(myNetAlias) == null, 100);
    ka.stop();
    // Reconnect.
    myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(PacketKeepalive.SUCCESS);
    // Check things work as expected when the keepalive is stopped and the network disconnects.
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    ka.stop();
    mWiFiNetworkAgent.disconnect();
    mService.waitForIdle();
    callback.expectStopped();
    // Reconnect.
    myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(PacketKeepalive.SUCCESS);
    // Check that keepalive slots start from 1 and increment. The first one gets slot 1.
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(1);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    // The second one gets slot 2.
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(2);
    TestKeepaliveCallback callback2 = new TestKeepaliveCallback();
    PacketKeepalive ka2 = mCm.startNattKeepalive(myNet, 25, callback2, myIPv4, 6789, dstIPv4);
    callback2.expectStarted();
    // Now stop the first one and create a third. This also gets slot 1.
    ka.stop();
    callback.expectStopped();
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(1);
    TestKeepaliveCallback callback3 = new TestKeepaliveCallback();
    PacketKeepalive ka3 = mCm.startNattKeepalive(myNet, 25, callback3, myIPv4, 9876, dstIPv4);
    callback3.expectStarted();
    ka2.stop();
    callback2.expectStopped();
    ka3.stop();
    callback3.expectStopped();
}
#method_after
@SmallTest
public void testPacketKeepalives() throws Exception {
    InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    InetAddress notMyIPv4 = InetAddress.getByName("192.0.2.35");
    InetAddress myIPv6 = InetAddress.getByName("2001:db8::1");
    InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    InetAddress dstIPv6 = InetAddress.getByName("2001:4860:4860::8888");
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv6, 64));
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("fe80::1234")));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network notMyNet = new Network(61234);
    Network myNet = connectKeepaliveNetwork(lp);
    TestKeepaliveCallback callback = new TestKeepaliveCallback();
    PacketKeepalive ka;
    // Attempt to start keepalives with invalid parameters and check for errors.
    ka = mCm.startNattKeepalive(notMyNet, 25, callback, myIPv4, 1234, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_NETWORK);
    ka = mCm.startNattKeepalive(myNet, 19, callback, notMyIPv4, 1234, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_INTERVAL);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 1234, dstIPv6);
    callback.expectError(PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv6, 1234, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv6, 1234, dstIPv6);
    // NAT-T is IPv4-only.
    callback.expectError(PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 123456, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_PORT);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 123456, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_INVALID_PORT);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_HARDWARE_UNSUPPORTED);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectError(PacketKeepalive.ERROR_HARDWARE_UNSUPPORTED);
    // Check that a started keepalive can be stopped.
    mWiFiNetworkAgent.setStartKeepaliveError(PacketKeepalive.SUCCESS);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    mWiFiNetworkAgent.setStopKeepaliveError(PacketKeepalive.SUCCESS);
    ka.stop();
    callback.expectStopped();
    // Check that deleting the IP address stops the keepalive.
    LinkProperties bogusLp = new LinkProperties(lp);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    bogusLp.removeLinkAddress(new LinkAddress(myIPv4, 25));
    bogusLp.addLinkAddress(new LinkAddress(notMyIPv4, 25));
    mWiFiNetworkAgent.sendLinkProperties(bogusLp);
    callback.expectError(PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
    mWiFiNetworkAgent.sendLinkProperties(lp);
    // Check that a started keepalive is stopped correctly when the network disconnects.
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    mWiFiNetworkAgent.disconnect();
    callback.expectError(PacketKeepalive.ERROR_INVALID_NETWORK);
    // ... and that stopping it after that has no adverse effects.
    assertNull(mCm.getNetworkCapabilities(myNet));
    ka.stop();
    // Reconnect.
    myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(PacketKeepalive.SUCCESS);
    // Check things work as expected when the keepalive is stopped and the network disconnects.
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    ka.stop();
    mWiFiNetworkAgent.disconnect();
    mService.waitForIdle();
    callback.expectStopped();
    // Reconnect.
    myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(PacketKeepalive.SUCCESS);
    // Check that keepalive slots start from 1 and increment. The first one gets slot 1.
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(1);
    ka = mCm.startNattKeepalive(myNet, 25, callback, myIPv4, 12345, dstIPv4);
    callback.expectStarted();
    // The second one gets slot 2.
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(2);
    TestKeepaliveCallback callback2 = new TestKeepaliveCallback();
    PacketKeepalive ka2 = mCm.startNattKeepalive(myNet, 25, callback2, myIPv4, 6789, dstIPv4);
    callback2.expectStarted();
    // Now stop the first one and create a third. This also gets slot 1.
    ka.stop();
    callback.expectStopped();
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(1);
    TestKeepaliveCallback callback3 = new TestKeepaliveCallback();
    PacketKeepalive ka3 = mCm.startNattKeepalive(myNet, 25, callback3, myIPv4, 9876, dstIPv4);
    callback3.expectStarted();
    ka2.stop();
    callback2.expectStopped();
    ka3.stop();
    callback3.expectStopped();
}
#end_block

#method_before
/* test utilities */
static private void sleepFor(int ms) {
    try {
        Thread.sleep(ms);
    } catch (InterruptedException e) {
    }
}
#method_after
static private void sleepFor(int ms) {
    try {
        Thread.sleep(ms);
    } catch (InterruptedException e) {
    }
}
#end_block

#method_before
public Set<Integer> handleUserSwitch(int userId) {
    if (mVerboseLoggingEnabled) {
        Log.v(TAG, "Handling user switch for " + userId);
    }
    if (userId == mCurrentUserId) {
        Log.w(TAG, "User already in foreground " + userId);
        return new HashSet<>();
    }
    if (mPendingStoreRead) {
        Log.wtf(TAG, "Ignore user switch until store is read!");
        return new HashSet<>();
    }
    if (mUserManager.isUserUnlockingOrUnlocked(mCurrentUserId)) {
        saveToStore(true);
    }
    // Remove any private networks of the old user before switching the userId.
    Set<Integer> removedNetworkIds = clearInternalUserData(mCurrentUserId);
    mConfiguredNetworks.setNewUser(userId);
    mCurrentUserId = userId;
    if (mUserManager.isUserUnlockingOrUnlocked(mCurrentUserId)) {
        handleUserUnlockOrSwitch(mCurrentUserId);
    } else {
        // Cannot read data from new user's CE store file before they log-in.
        mPendingUnlockStoreRead = true;
        Log.i(TAG, "Waiting for user unlock to load from store");
    }
    return removedNetworkIds;
}
#method_after
public Set<Integer> handleUserSwitch(int userId) {
    if (mVerboseLoggingEnabled) {
        Log.v(TAG, "Handling user switch for " + userId);
    }
    if (userId == mCurrentUserId) {
        Log.w(TAG, "User already in foreground " + userId);
        return new HashSet<>();
    }
    if (mPendingStoreRead) {
        Log.wtf(TAG, "Unexpected user switch before store is read!");
        return new HashSet<>();
    }
    if (mUserManager.isUserUnlockingOrUnlocked(mCurrentUserId)) {
        saveToStore(true);
    }
    // Remove any private networks of the old user before switching the userId.
    Set<Integer> removedNetworkIds = clearInternalUserData(mCurrentUserId);
    mConfiguredNetworks.setNewUser(userId);
    mCurrentUserId = userId;
    if (mUserManager.isUserUnlockingOrUnlocked(mCurrentUserId)) {
        handleUserUnlockOrSwitch(mCurrentUserId);
    } else {
        // Cannot read data from new user's CE store file before they log-in.
        mPendingUnlockStoreRead = true;
        Log.i(TAG, "Waiting for user unlock to load from store");
    }
    return removedNetworkIds;
}
#end_block

#method_before
private static void writeProtoPortMap(Parcel dest, Map<Integer, String> protoPortMap) {
    if (protoPortMap == null) {
        dest.writeInt(-1);
        return;
    }
    dest.writeInt(protoPortMap.size());
    for (Map.Entry<Integer, String> entry : protoPortMap.entrySet()) {
        dest.writeInt(entry.getKey());
        dest.writeString(entry.getValue());
    }
}
#method_after
private static void writeProtoPortMap(Parcel dest, Map<Integer, String> protoPortMap) {
    if (protoPortMap == null) {
        dest.writeInt(NULL_VALUE);
        return;
    }
    dest.writeInt(protoPortMap.size());
    for (Map.Entry<Integer, String> entry : protoPortMap.entrySet()) {
        dest.writeInt(entry.getKey());
        dest.writeString(entry.getValue());
    }
}
#end_block

#method_before
private static void writeRoamingPartnerList(Parcel dest, int flags, List<RoamingPartner> partnerList) {
    if (partnerList == null) {
        dest.writeInt(-1);
        return;
    }
    dest.writeInt(partnerList.size());
    for (RoamingPartner partner : partnerList) {
        dest.writeParcelable(partner, flags);
    }
}
#method_after
private static void writeRoamingPartnerList(Parcel dest, int flags, List<RoamingPartner> partnerList) {
    if (partnerList == null) {
        dest.writeInt(NULL_VALUE);
        return;
    }
    dest.writeInt(partnerList.size());
    for (RoamingPartner partner : partnerList) {
        dest.writeParcelable(partner, flags);
    }
}
#end_block

#method_before
private static void parseEAPMethod(PPSNode node, Credential.UserCredential userCred) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for EAPMethod");
    }
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_EAP_TYPE:
                userCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            case NODE_INNER_METHOD:
                userCred.nonEapInnerMethod = getPpsNodeValue(child);
                break;
            case NODE_VENDOR_ID:
            case NODE_VENDOR_TYPE:
            case NODE_INNER_EAP_TYPE:
            case NODE_INNER_VENDOR_ID:
            case NODE_INNER_VENDOR_TYPE:
                // Only EAP-TTLS is currently supported for user credential, which doesn't
                // use any of these parameters.
                Log.d(TAG, "Ignore uninterested EAP method parameter: " + child.getName());
                break;
            default:
                throw new ParsingException("Unknown node under EAPMethod: " + child.getName());
        }
    }
}
#method_after
private static void parseEAPMethod(PPSNode node, Credential.UserCredential userCred) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for EAPMethod");
    }
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_EAP_TYPE:
                userCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            case NODE_INNER_METHOD:
                userCred.nonEapInnerMethod = getPpsNodeValue(child);
                break;
            case NODE_VENDOR_ID:
            case NODE_VENDOR_TYPE:
            case NODE_INNER_EAP_TYPE:
            case NODE_INNER_VENDOR_ID:
            case NODE_INNER_VENDOR_TYPE:
                // Only EAP-TTLS is currently supported for user credential, which doesn't
                // use any of these parameters.
                Log.d(TAG, "Ignore unsupported EAP method parameter: " + child.getName());
                break;
            default:
                throw new ParsingException("Unknown node under EAPMethod: " + child.getName());
        }
    }
}
#end_block

#method_before
public boolean validate() {
    if (updateIntervalInMinutes == Long.MIN_VALUE) {
        Log.d(TAG, "Update interval not specified");
        return false;
    }
    // Update not applicable.
    if (updateIntervalInMinutes == UPDATE_CHECK_INTERVAL_NEVER) {
        return true;
    }
    if (!TextUtils.equals(updateMethod, UPDATE_METHOD_OMADM) && !TextUtils.equals(updateMethod, UPDATE_METHOD_SSP)) {
        Log.d(TAG, "Unknown update method: " + updateMethod);
        return false;
    }
    if (!TextUtils.equals(restriction, UPDATE_RESTRICTION_HOMESP) && !TextUtils.equals(restriction, UPDATE_RESTRICTION_ROAMING_PARTNER) && !TextUtils.equals(restriction, UPDATE_RESTRICTION_UNRESTRICTED)) {
        Log.d(TAG, "Unknown restriction: " + restriction);
        return false;
    }
    if (TextUtils.isEmpty(serverUri)) {
        Log.d(TAG, "Missing update server URI");
        return false;
    }
    if (serverUri.getBytes(StandardCharsets.UTF_8).length > MAX_URI_BYTES) {
        Log.d(TAG, "URI bytes exceeded the max: " + serverUri.getBytes(StandardCharsets.UTF_8).length);
        return false;
    }
    if (TextUtils.isEmpty(username)) {
        Log.d(TAG, "Missing username");
        return false;
    }
    if (username.getBytes(StandardCharsets.UTF_8).length > MAX_USERNAME_BYTES) {
        Log.d(TAG, "Username bytes exceeded the max: " + username.getBytes(StandardCharsets.UTF_8).length);
        return false;
    }
    if (TextUtils.isEmpty(base64EncodedPassword)) {
        Log.d(TAG, "Missing username");
        return false;
    }
    if (base64EncodedPassword.getBytes(StandardCharsets.UTF_8).length > MAX_PASSWORD_BYTES) {
        Log.d(TAG, "Password bytes exceeded the max: " + base64EncodedPassword.getBytes(StandardCharsets.UTF_8).length);
        return false;
    }
    try {
        Base64.decode(base64EncodedPassword, Base64.DEFAULT);
    } catch (IllegalArgumentException e) {
        Log.d(TAG, "Invalid encoding for password: " + base64EncodedPassword);
        return false;
    }
    if (TextUtils.isEmpty(trustRootCertUrl)) {
        Log.d(TAG, "Missing trust root certificate URL");
        return false;
    }
    if (trustRootCertSha256Fingerprint == null) {
        Log.d(TAG, "Missing trust root certificate SHA-256 fingerprint");
        return false;
    }
    if (trustRootCertSha256Fingerprint.length != CERTIFICATE_SHA256_BYTES) {
        Log.d(TAG, "Incorrect size of trust root certificate SHA-256 fingerprint: " + trustRootCertSha256Fingerprint.length);
        return false;
    }
    return true;
}
#method_after
public boolean validate() {
    if (updateIntervalInMinutes == Long.MIN_VALUE) {
        Log.d(TAG, "Update interval not specified");
        return false;
    }
    // Update not applicable.
    if (updateIntervalInMinutes == UPDATE_CHECK_INTERVAL_NEVER) {
        return true;
    }
    if (!TextUtils.equals(updateMethod, UPDATE_METHOD_OMADM) && !TextUtils.equals(updateMethod, UPDATE_METHOD_SSP)) {
        Log.d(TAG, "Unknown update method: " + updateMethod);
        return false;
    }
    if (!TextUtils.equals(restriction, UPDATE_RESTRICTION_HOMESP) && !TextUtils.equals(restriction, UPDATE_RESTRICTION_ROAMING_PARTNER) && !TextUtils.equals(restriction, UPDATE_RESTRICTION_UNRESTRICTED)) {
        Log.d(TAG, "Unknown restriction: " + restriction);
        return false;
    }
    if (TextUtils.isEmpty(serverUri)) {
        Log.d(TAG, "Missing update server URI");
        return false;
    }
    if (serverUri.getBytes(StandardCharsets.UTF_8).length > MAX_URI_BYTES) {
        Log.d(TAG, "URI bytes exceeded the max: " + serverUri.getBytes(StandardCharsets.UTF_8).length);
        return false;
    }
    if (TextUtils.isEmpty(username)) {
        Log.d(TAG, "Missing username");
        return false;
    }
    if (username.getBytes(StandardCharsets.UTF_8).length > MAX_USERNAME_BYTES) {
        Log.d(TAG, "Username bytes exceeded the max: " + username.getBytes(StandardCharsets.UTF_8).length);
        return false;
    }
    if (TextUtils.isEmpty(base64EncodedPassword)) {
        Log.d(TAG, "Missing username");
        return false;
    }
    if (base64EncodedPassword.getBytes(StandardCharsets.UTF_8).length > MAX_PASSWORD_BYTES) {
        Log.d(TAG, "Password bytes exceeded the max: " + base64EncodedPassword.getBytes(StandardCharsets.UTF_8).length);
        return false;
    }
    try {
        Base64.decode(base64EncodedPassword, Base64.DEFAULT);
    } catch (IllegalArgumentException e) {
        Log.d(TAG, "Invalid encoding for password: " + base64EncodedPassword);
        return false;
    }
    if (TextUtils.isEmpty(trustRootCertUrl)) {
        Log.d(TAG, "Missing trust root certificate URL");
        return false;
    }
    if (trustRootCertUrl.getBytes(StandardCharsets.UTF_8).length > MAX_URL_BYTES) {
        Log.d(TAG, "Trust root cert URL bytes exceeded the max: " + trustRootCertUrl.getBytes(StandardCharsets.UTF_8).length);
        return false;
    }
    if (trustRootCertSha256Fingerprint == null) {
        Log.d(TAG, "Missing trust root certificate SHA-256 fingerprint");
        return false;
    }
    if (trustRootCertSha256Fingerprint.length != CERTIFICATE_SHA256_BYTES) {
        Log.d(TAG, "Incorrect size of trust root certificate SHA-256 fingerprint: " + trustRootCertSha256Fingerprint.length);
        return false;
    }
    return true;
}
#end_block

#method_before
private static PasspointConfiguration parsePpsNode(XMLNode node) throws ParsingException {
    PasspointConfiguration config = null;
    String nodeName = null;
    int updateIdentifier = Integer.MIN_VALUE;
    for (XMLNode child : node.getChildren()) {
        switch(child.getTag()) {
            case TAG_NODE_NAME:
                if (nodeName != null) {
                    throw new ParsingException("Duplicant NodeName: " + child.getText());
                }
                nodeName = child.getText();
                if (!TextUtils.equals(nodeName, NODE_PER_PROVIDER_SUBSCRIPTION)) {
                    throw new ParsingException("Unexpected NodeName: " + nodeName);
                }
                break;
            case TAG_NODE:
                // A node can be either an UpdateIdentifier node or a PerProviderSubscription
                // instance node.  Flatten out the XML tree first by converting it to a PPS
                // tree to reduce the complexity of the parsing code.
                PPSNode ppsNodeRoot = buildPpsNode(child);
                if (TextUtils.equals(ppsNodeRoot.getName(), NODE_UPDATE_IDENTIFIER)) {
                    if (updateIdentifier != Integer.MIN_VALUE) {
                        throw new ParsingException("Multiple node for UpdateIdentifier");
                    }
                    updateIdentifier = parseInteger(getPpsNodeValue(ppsNodeRoot));
                } else {
                    // Only one PerProviderSubscription instance is expected and allowed.
                    if (config != null) {
                        throw new ParsingException("Multiple PPS instance");
                    }
                    config = parsePpsInstance(ppsNodeRoot);
                }
                break;
            case TAG_RT_PROPERTIES:
                // Parse and verify URN stored in the RT (Run Time) Properties.
                String urn = parseUrn(child);
                if (!TextUtils.equals(urn, PPS_MO_URN)) {
                    throw new ParsingException("Unknown URN: " + urn);
                }
                break;
            default:
                throw new ParsingException("Unknown tag under PPS node: " + child.getTag());
        }
    }
    if (config != null && updateIdentifier != Integer.MIN_VALUE) {
        config.updateIdentifier = updateIdentifier;
    }
    return config;
}
#method_after
private static PasspointConfiguration parsePpsNode(XMLNode node) throws ParsingException {
    PasspointConfiguration config = null;
    String nodeName = null;
    int updateIdentifier = Integer.MIN_VALUE;
    for (XMLNode child : node.getChildren()) {
        switch(child.getTag()) {
            case TAG_NODE_NAME:
                if (nodeName != null) {
                    throw new ParsingException("Duplicate NodeName: " + child.getText());
                }
                nodeName = child.getText();
                if (!TextUtils.equals(nodeName, NODE_PER_PROVIDER_SUBSCRIPTION)) {
                    throw new ParsingException("Unexpected NodeName: " + nodeName);
                }
                break;
            case TAG_NODE:
                // A node can be either an UpdateIdentifier node or a PerProviderSubscription
                // instance node.  Flatten out the XML tree first by converting it to a PPS
                // tree to reduce the complexity of the parsing code.
                PPSNode ppsNodeRoot = buildPpsNode(child);
                if (TextUtils.equals(ppsNodeRoot.getName(), NODE_UPDATE_IDENTIFIER)) {
                    if (updateIdentifier != Integer.MIN_VALUE) {
                        throw new ParsingException("Multiple node for UpdateIdentifier");
                    }
                    updateIdentifier = parseInteger(getPpsNodeValue(ppsNodeRoot));
                } else {
                    // Only one PerProviderSubscription instance is expected and allowed.
                    if (config != null) {
                        throw new ParsingException("Multiple PPS instance");
                    }
                    config = parsePpsInstance(ppsNodeRoot);
                }
                break;
            case TAG_RT_PROPERTIES:
                // Parse and verify URN stored in the RT (Run Time) Properties.
                String urn = parseUrn(child);
                if (!TextUtils.equals(urn, PPS_MO_URN)) {
                    throw new ParsingException("Unknown URN: " + urn);
                }
                break;
            default:
                throw new ParsingException("Unknown tag under PPS node: " + child.getTag());
        }
    }
    if (config != null && updateIdentifier != Integer.MIN_VALUE) {
        config.updateIdentifier = updateIdentifier;
    }
    return config;
}
#end_block

#method_before
private static void parseEAPMethod(PPSNode node, Credential.UserCredential userCred) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for EAPMethod");
    }
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_EAP_TYPE:
                userCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            case NODE_INNER_METHOD:
                userCred.nonEapInnerMethod = getPpsNodeValue(child);
                break;
            case NODE_VENDOR_ID:
            case NODE_VENDOR_TYPE:
            case NODE_INNER_EAP_TYPE:
            case NODE_INNER_VENDOR_ID:
            case NODE_INNER_VENDOR_TYPE:
                // Only EAP-TTLS is currently supported for user credential, which doesn't
                // use any of these parameters.
                Log.d(TAG, "Ignore uninterested EAP method parameter: " + child.getName());
                break;
            default:
                throw new ParsingException("Unknown node under EAPMethod: " + child.getName());
        }
    }
}
#method_after
private static void parseEAPMethod(PPSNode node, Credential.UserCredential userCred) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for EAPMethod");
    }
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_EAP_TYPE:
                userCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            case NODE_INNER_METHOD:
                userCred.nonEapInnerMethod = getPpsNodeValue(child);
                break;
            case NODE_VENDOR_ID:
            case NODE_VENDOR_TYPE:
            case NODE_INNER_EAP_TYPE:
            case NODE_INNER_VENDOR_ID:
            case NODE_INNER_VENDOR_TYPE:
                // Only EAP-TTLS is currently supported for user credential, which doesn't
                // use any of these parameters.
                Log.d(TAG, "Ignore unsupported EAP method parameter: " + child.getName());
                break;
            default:
                throw new ParsingException("Unknown node under EAPMethod: " + child.getName());
        }
    }
}
#end_block

#method_before
public void handleOnBootPhase() {
    if (DBG)
        Slog.d(TAG, "Bluetooth boot completed");
    UserManagerInternal userManagerInternal = LocalServices.getService(UserManagerInternal.class);
    userManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
    final boolean isBluetoothDisallowed = isBluetoothDisallowed();
    if (!mPackageManagerService.isOnlyCoreApps()) {
        updateOppLauncherComponentState(isBluetoothDisallowed);
    }
    if (isBluetoothDisallowed) {
        return;
    }
    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
        if (DBG)
            Slog.d(TAG, "Auto-enabling Bluetooth.");
        sendEnableMsg(mQuietEnableExternal, "system boot");
    } else if (!isNameAndAddressSet()) {
        if (DBG)
            Slog.d(TAG, "Getting adapter name and address");
        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
        mHandler.sendMessage(getMsg);
    }
}
#method_after
public void handleOnBootPhase() {
    if (DBG)
        Slog.d(TAG, "Bluetooth boot completed");
    UserManagerInternal userManagerInternal = LocalServices.getService(UserManagerInternal.class);
    userManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
    final boolean isBluetoothDisallowed = isBluetoothDisallowed();
    PackageManagerService packageManagerService = (PackageManagerService) ServiceManager.getService("package");
    if (packageManagerService != null && !packageManagerService.isOnlyCoreApps()) {
        updateOppLauncherComponentState(isBluetoothDisallowed);
    }
    if (isBluetoothDisallowed) {
        return;
    }
    if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
        if (DBG)
            Slog.d(TAG, "Auto-enabling Bluetooth.");
        sendEnableMsg(mQuietEnableExternal, "system boot");
    } else if (!isNameAndAddressSet()) {
        if (DBG)
            Slog.d(TAG, "Getting adapter name and address");
        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
        mHandler.sendMessage(getMsg);
    }
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    String errorMsg = null;
    boolean protoOut = (args.length > 0) && args[0].startsWith("--proto");
    if (!protoOut) {
        writer.println("Bluetooth Status");
        writer.println("  enabled: " + isEnabled());
        writer.println("  state: " + BluetoothAdapter.nameForState(mState));
        writer.println("  address: " + mAddress);
        writer.println("  name: " + mName);
        if (mEnable) {
            long onDuration = System.currentTimeMillis() - mActiveLogs.getLast().getTime();
            String onDurationString = String.format("%02d:%02d:%02d.%03d", (int) (onDuration / (1000 * 60 * 60)), (int) ((onDuration / (1000 * 60)) % 60), (int) ((onDuration / 1000) % 60), (int) (onDuration % 1000));
            writer.println("  time since enabled: " + onDurationString + "\n");
        }
        writer.println("Enable log:");
        for (ActiveLog log : mActiveLogs) {
            writer.println(log);
        }
        writer.println("\n" + mBleApps.size() + " BLE Apps registered:");
        for (ClientDeathRecipient app : mBleApps.values()) {
            writer.println(app.getPackageName());
        }
        writer.flush();
        if (args.length == 0) {
            // Add arg to produce output
            args = new String[1];
            args[0] = "--print";
        }
    }
    if (mBluetoothBinder == null) {
        errorMsg = "Bluetooth Service not connected";
    } else {
        try {
            mBluetoothBinder.dump(fd, args);
        } catch (RemoteException re) {
            errorMsg = "RemoteException while dumping Bluetooth Service";
        }
    }
    if (errorMsg != null) {
        // Silently return if we are extracting metrics in Protobuf format
        if (protoOut)
            return;
        writer.println(errorMsg);
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    String errorMsg = null;
    boolean protoOut = (args.length > 0) && args[0].startsWith("--proto");
    if (!protoOut) {
        writer.println("Bluetooth Status");
        writer.println("  enabled: " + isEnabled());
        writer.println("  state: " + BluetoothAdapter.nameForState(mState));
        writer.println("  address: " + mAddress);
        writer.println("  name: " + mName);
        if (mEnable) {
            long onDuration = System.currentTimeMillis() - mActiveLogs.getLast().getTime();
            String onDurationString = String.format("%02d:%02d:%02d.%03d", (int) (onDuration / (1000 * 60 * 60)), (int) ((onDuration / (1000 * 60)) % 60), (int) ((onDuration / 1000) % 60), (int) (onDuration % 1000));
            writer.println("  time since enabled: " + onDurationString + "\n");
        }
        if (mActiveLogs.size() == 0) {
            writer.println("Bluetooth never enabled!");
        } else {
            writer.println("Enable log:");
            for (ActiveLog log : mActiveLogs) {
                writer.println("  " + log);
            }
        }
        String bleAppString = "No BLE Apps registered.";
        if (mBleApps.size() == 1) {
            bleAppString = "1 BLE App registered:";
        } else if (mBleApps.size() > 1) {
            bleAppString = mBleApps.size() + " BLE Apps registered:";
        }
        writer.println("\n" + bleAppString);
        for (ClientDeathRecipient app : mBleApps.values()) {
            writer.println("  " + app.getPackageName());
        }
        writer.println("");
        writer.flush();
        if (args.length == 0) {
            // Add arg to produce output
            args = new String[1];
            args[0] = "--print";
        }
    }
    if (mBluetoothBinder == null) {
        errorMsg = "Bluetooth Service not connected";
    } else {
        try {
            mBluetoothBinder.dump(fd, args);
        } catch (RemoteException re) {
            errorMsg = "RemoteException while dumping Bluetooth Service";
        }
    }
    if (errorMsg != null) {
        // Silently return if we are extracting metrics in Protobuf format
        if (protoOut)
            return;
        writer.println(errorMsg);
    }
}
#end_block

#method_before
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
    }
    // Trigger an immediate connection to the specified network. We're also noting the user
    // connect choice here, so that it will be considered in the next network selection.
    mWifiConnectivityManager.setUserConnectChoice(netId);
    if (mWifiInfo.getNetworkId() == netId) {
        // We're already connected to the user specified network, don't trigger a
        // reconnection.
        logi("connectToUserSelectNetwork already connecting/connected=" + netId);
    } else {
        startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    }
    return true;
}
#method_after
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        logi("connectToUserSelectNetwork Allowing uid " + uid + " with insufficient permissions to connect=" + netId);
    }
    // Trigger an immediate connection to the specified network. We're also noting the user
    // connect choice here, so that it will be considered in the next network selection.
    mWifiConnectivityManager.setUserConnectChoice(netId);
    if (mWifiInfo.getNetworkId() == netId) {
        // We're already connected to the user specified network, don't trigger a
        // reconnection.
        logi("connectToUserSelectNetwork already connecting/connected=" + netId);
    } else {
        startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    }
    return true;
}
#end_block

#method_before
private void reportConnectionAttemptEnd(int level2FailureCode, int connectivityFailureCode) {
    mWifiMetrics.endConnectionEvent(level2FailureCode, connectivityFailureCode);
    switch(level2FailureCode) {
        case WifiMetrics.ConnectionEvent.FAILURE_NONE:
        case WifiMetrics.ConnectionEvent.FAILURE_REDUNDANT_CONNECTION_ATTEMPT:
        case WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED:
            // WifiDiagnostics doesn't care about success, or pre-empted connections.
            break;
        default:
            mWifiDiagnostics.reportConnectionFailure();
    }
}
#method_after
private void reportConnectionAttemptEnd(int level2FailureCode, int connectivityFailureCode) {
    mWifiMetrics.endConnectionEvent(level2FailureCode, connectivityFailureCode);
    switch(level2FailureCode) {
        case WifiMetrics.ConnectionEvent.FAILURE_NONE:
        case WifiMetrics.ConnectionEvent.FAILURE_REDUNDANT_CONNECTION_ATTEMPT:
        case WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED:
            // WifiDiagnostics doesn't care about success, or pre-empted connections.
            break;
        default:
            mWifiDiagnostics.reportConnectionEvent(WifiDiagnostics.CONNECTION_EVENT_FAILED);
    }
}
#end_block

#method_before
private void getAdditionalWifiServiceInterfaces() {
    // First set up Wifi Direct
    if (mP2pSupported) {
        IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE);
        WifiP2pServiceImpl wifiP2pServiceImpl = (WifiP2pServiceImpl) IWifiP2pManager.Stub.asInterface(s1);
        if (wifiP2pServiceImpl != null) {
            mWifiP2pChannel = new AsyncChannel();
            mWifiP2pChannel.connect(mContext, getHandler(), wifiP2pServiceImpl.getP2pStateMachineMessenger());
        }
    }
    // Set up Wifi Aware
    if (mAwareSupported) {
        mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
    }
}
#method_after
private void getAdditionalWifiServiceInterfaces() {
    // First set up Wifi Direct
    if (mP2pSupported) {
        IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE);
        WifiP2pServiceImpl wifiP2pServiceImpl = (WifiP2pServiceImpl) IWifiP2pManager.Stub.asInterface(s1);
        if (wifiP2pServiceImpl != null) {
            mWifiP2pChannel = new AsyncChannel();
            mWifiP2pChannel.connect(mContext, getHandler(), wifiP2pServiceImpl.getP2pStateMachineMessenger());
        }
    }
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mAwareSupported && mWifiAwareManager != null) {
        if (mOperationalMode == CONNECT_MODE) {
            mWifiAwareManager.enableUsage();
        } else {
        /*
                     * Aware state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mAwareSupported) {
        if (mWifiAwareManager == null) {
            mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
        }
        if (mWifiAwareManager == null) {
            Log.e(TAG, "Can't get WifiAwareManager to enable usage!");
        } else {
            if (mOperationalMode == CONNECT_MODE) {
                mWifiAwareManager.enableUsage();
            } else {
            /*
                     * Aware state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
            }
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
@Override
public void exit() {
    mWifiDiagnostics.stopLogging();
    mIsRunning = false;
    updateBatteryWorkSource(null);
    mScanResults = new ArrayList<>();
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    mBufferedScanMsg.clear();
    if (mAwareSupported && mWifiAwareManager != null) {
        mWifiAwareManager.disableUsage();
    }
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    mCountryCode.setReadyForChange(false);
}
#method_after
@Override
public void exit() {
    mWifiDiagnostics.stopLogging();
    mIsRunning = false;
    updateBatteryWorkSource(null);
    mScanResults = new ArrayList<>();
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    mBufferedScanMsg.clear();
    if (mAwareSupported) {
        if (mWifiAwareManager == null) {
            mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
        }
        if (mWifiAwareManager == null) {
            Log.e(TAG, "Can't get WifiAwareManager (to disable usage)!");
        } else {
            mWifiAwareManager.disableUsage();
        }
    }
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    mCountryCode.setReadyForChange(false);
}
#end_block

#method_before
private String updateDefaultRouteMacAddress(int timeout) {
    String address = null;
    for (RouteInfo route : mLinkProperties.getRoutes()) {
        if (route.isDefaultRoute() && route.hasGateway()) {
            InetAddress gateway = route.getGateway();
            if (gateway instanceof Inet4Address) {
                if (mVerboseLoggingEnabled) {
                    logd("updateDefaultRouteMacAddress found Ipv4 default :" + gateway.getHostAddress());
                }
                address = macAddressFromRoute(gateway.getHostAddress());
                /* The gateway's MAC address is known */
                if ((address == null) && (timeout > 0)) {
                    boolean reachable = false;
                    try {
                        reachable = gateway.isReachable(timeout);
                    } catch (Exception e) {
                        loge("updateDefaultRouteMacAddress exception reaching :" + gateway.getHostAddress());
                    } finally {
                        if (reachable == true) {
                            address = macAddressFromRoute(gateway.getHostAddress());
                            if (mVerboseLoggingEnabled) {
                                logd("updateDefaultRouteMacAddress reachable (tried again) :" + gateway.getHostAddress() + " found " + address);
                            }
                        }
                    }
                }
                if (address != null) {
                    mWifiConfigManager.setNetworkDefaultGwMacAddress(mLastNetworkId, address);
                }
            }
        }
    }
    return address;
}
#method_after
private String updateDefaultRouteMacAddress(int timeout) {
    String address = null;
    for (RouteInfo route : mLinkProperties.getRoutes()) {
        if (route.isDefaultRoute() && route.hasGateway()) {
            InetAddress gateway = route.getGateway();
            if (gateway instanceof Inet4Address) {
                if (mVerboseLoggingEnabled) {
                    logd("updateDefaultRouteMacAddress found Ipv4 default :" + gateway.getHostAddress());
                }
                address = macAddressFromRoute(gateway.getHostAddress());
                /* The gateway's MAC address is known */
                if ((address == null) && (timeout > 0)) {
                    boolean reachable = false;
                    TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE);
                    try {
                        reachable = gateway.isReachable(timeout);
                    } catch (Exception e) {
                        loge("updateDefaultRouteMacAddress exception reaching :" + gateway.getHostAddress());
                    } finally {
                        TrafficStats.clearThreadStatsTag();
                        if (reachable == true) {
                            address = macAddressFromRoute(gateway.getHostAddress());
                            if (mVerboseLoggingEnabled) {
                                logd("updateDefaultRouteMacAddress reachable (tried again) :" + gateway.getHostAddress() + " found " + address);
                            }
                        }
                    }
                }
                if (address != null) {
                    mWifiConfigManager.setNetworkDefaultGwMacAddress(mLastNetworkId, address);
                }
            }
        }
    }
    return address;
}
#end_block

#method_before
private void reportConnectionAttemptEnd(int level2FailureCode, int connectivityFailureCode) {
    mWifiMetrics.endConnectionEvent(level2FailureCode, connectivityFailureCode);
    switch(level2FailureCode) {
        case WifiMetrics.ConnectionEvent.FAILURE_NONE:
        case WifiMetrics.ConnectionEvent.FAILURE_REDUNDANT_CONNECTION_ATTEMPT:
        case WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED:
            // WifiDiagnostics doesn't care about success, or pre-empted connections.
            break;
        default:
            mWifiDiagnostics.reportConnectionFailure();
    }
}
#method_after
private void reportConnectionAttemptEnd(int level2FailureCode, int connectivityFailureCode) {
    mWifiMetrics.endConnectionEvent(level2FailureCode, connectivityFailureCode);
    switch(level2FailureCode) {
        case WifiMetrics.ConnectionEvent.FAILURE_NONE:
        case WifiMetrics.ConnectionEvent.FAILURE_REDUNDANT_CONNECTION_ATTEMPT:
        case WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED:
            // WifiDiagnostics doesn't care about success, or pre-empted connections.
            break;
        default:
            mWifiDiagnostics.reportConnectionEvent(WifiDiagnostics.CONNECTION_EVENT_FAILED);
    }
}
#end_block

#method_before
private void getAdditionalWifiServiceInterfaces() {
    // First set up Wifi Direct
    if (mP2pSupported) {
        IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE);
        WifiP2pServiceImpl wifiP2pServiceImpl = (WifiP2pServiceImpl) IWifiP2pManager.Stub.asInterface(s1);
        if (wifiP2pServiceImpl != null) {
            mWifiP2pChannel = new AsyncChannel();
            mWifiP2pChannel.connect(mContext, getHandler(), wifiP2pServiceImpl.getP2pStateMachineMessenger());
        }
    }
    // Set up Wifi Aware
    if (mAwareSupported) {
        mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
    }
}
#method_after
private void getAdditionalWifiServiceInterfaces() {
    // First set up Wifi Direct
    if (mP2pSupported) {
        IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE);
        WifiP2pServiceImpl wifiP2pServiceImpl = (WifiP2pServiceImpl) IWifiP2pManager.Stub.asInterface(s1);
        if (wifiP2pServiceImpl != null) {
            mWifiP2pChannel = new AsyncChannel();
            mWifiP2pChannel.connect(mContext, getHandler(), wifiP2pServiceImpl.getP2pStateMachineMessenger());
        }
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                    } else {
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            mWifiConfigManager.loadFromStore();
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                    } else {
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            if (!mWifiConfigManager.loadFromStore()) {
                Log.e(TAG, "Failed to load from config store");
            }
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            // Attempt to migrate data out of legacy store.
            mWifiConfigManager.migrateFromLegacyStore();
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                try {
                    mClientInterface.disableSupplicant();
                } catch (RemoteException e) {
                // The client interface is dead, there is nothing more we can do.
                }
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            // Attempt to migrate data out of legacy store.
            if (!mWifiConfigManager.migrateFromLegacyStore()) {
                Log.e(TAG, "Failed to migrate from legacy config store");
            }
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                try {
                    mClientInterface.disableSupplicant();
                } catch (RemoteException e) {
                // The client interface is dead, there is nothing more we can do.
                }
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mAwareSupported && mWifiAwareManager != null) {
        if (mOperationalMode == CONNECT_MODE) {
            mWifiAwareManager.enableUsage();
        } else {
        /*
                     * Aware state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mAwareSupported) {
        if (mWifiAwareManager == null) {
            mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
        }
        if (mWifiAwareManager == null) {
            Log.e(TAG, "Can't get WifiAwareManager to enable usage!");
        } else {
            if (mOperationalMode == CONNECT_MODE) {
                mWifiAwareManager.enableUsage();
            } else {
            /*
                     * Aware state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
            }
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
@Override
public void exit() {
    mWifiDiagnostics.stopLogging();
    mIsRunning = false;
    updateBatteryWorkSource(null);
    mScanResults = new ArrayList<>();
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    mBufferedScanMsg.clear();
    if (mAwareSupported && mWifiAwareManager != null) {
        mWifiAwareManager.disableUsage();
    }
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    mCountryCode.setReadyForChange(false);
}
#method_after
@Override
public void exit() {
    mWifiDiagnostics.stopLogging();
    mIsRunning = false;
    updateBatteryWorkSource(null);
    mScanResults = new ArrayList<>();
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    mBufferedScanMsg.clear();
    if (mAwareSupported) {
        if (mWifiAwareManager == null) {
            mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
        }
        if (mWifiAwareManager == null) {
            Log.e(TAG, "Can't get WifiAwareManager (to disable usage)!");
        } else {
            mWifiAwareManager.disableUsage();
        }
    }
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    mCountryCode.setReadyForChange(false);
}
#end_block

#method_before
@Test
public void testMigrationFromLegacyStore() throws Exception {
    // Create the store data to be returned from legacy stores.
    List<WifiConfiguration> networks = new ArrayList<>();
    networks.add(WifiConfigurationTestUtil.createPskNetwork());
    networks.add(WifiConfigurationTestUtil.createEapNetwork());
    networks.add(WifiConfigurationTestUtil.createWepNetwork());
    String deletedEphemeralSSID = "EphemeralSSID";
    Set<String> deletedEphermalSSIDs = new HashSet<>(Arrays.asList(deletedEphemeralSSID));
    WifiConfigStoreDataLegacy storeData = new WifiConfigStoreDataLegacy(networks, deletedEphermalSSIDs);
    // New store files not present, so migrate from the old store.
    when(mWifiConfigStoreLegacy.areStoresPresent()).thenReturn(true);
    when(mWifiConfigStoreLegacy.read()).thenReturn(storeData);
    // Now trigger a load from store. This should populate the in memory list with all the
    // networks above from the legacy store.
    mWifiConfigManager.migrateFromLegacyStore();
    verify(mWifiConfigStoreLegacy).read();
    verify(mWifiConfigStoreLegacy).removeStores();
    List<WifiConfiguration> retrievedNetworks = mWifiConfigManager.getConfiguredNetworksWithPasswords();
    WifiConfigurationTestUtil.assertConfigurationsEqualForConfigManagerAddOrUpdate(networks, retrievedNetworks);
    assertTrue(mWifiConfigManager.wasEphemeralNetworkDeleted(deletedEphemeralSSID));
}
#method_after
@Test
public void testMigrationFromLegacyStore() throws Exception {
    // Create the store data to be returned from legacy stores.
    List<WifiConfiguration> networks = new ArrayList<>();
    networks.add(WifiConfigurationTestUtil.createPskNetwork());
    networks.add(WifiConfigurationTestUtil.createEapNetwork());
    networks.add(WifiConfigurationTestUtil.createWepNetwork());
    String deletedEphemeralSSID = "EphemeralSSID";
    Set<String> deletedEphermalSSIDs = new HashSet<>(Arrays.asList(deletedEphemeralSSID));
    WifiConfigStoreDataLegacy storeData = new WifiConfigStoreDataLegacy(networks, deletedEphermalSSIDs);
    when(mWifiConfigStoreLegacy.areStoresPresent()).thenReturn(true);
    when(mWifiConfigStoreLegacy.read()).thenReturn(storeData);
    // Now trigger the migration from legacy store. This should populate the in memory list with
    // all the networks above from the legacy store.
    assertTrue(mWifiConfigManager.migrateFromLegacyStore());
    verify(mWifiConfigStoreLegacy).read();
    verify(mWifiConfigStoreLegacy).removeStores();
    List<WifiConfiguration> retrievedNetworks = mWifiConfigManager.getConfiguredNetworksWithPasswords();
    WifiConfigurationTestUtil.assertConfigurationsEqualForConfigManagerAddOrUpdate(networks, retrievedNetworks);
    assertTrue(mWifiConfigManager.wasEphemeralNetworkDeleted(deletedEphemeralSSID));
}
#end_block

#method_before
@Test
public void testNoDuplicateMigrationFromLegacyStore() throws Exception {
    // New store files not present, so migrate from the old store.
    when(mWifiConfigStoreLegacy.areStoresPresent()).thenReturn(false);
    // Now trigger a load from store.
    mWifiConfigManager.migrateFromLegacyStore();
    verify(mWifiConfigStoreLegacy, never()).read();
    verify(mWifiConfigStoreLegacy, never()).removeStores();
}
#method_after
@Test
public void testNoDuplicateMigrationFromLegacyStore() throws Exception {
    when(mWifiConfigStoreLegacy.areStoresPresent()).thenReturn(false);
    // Now trigger a migration from legacy store.
    assertTrue(mWifiConfigManager.migrateFromLegacyStore());
    verify(mWifiConfigStoreLegacy, never()).read();
    verify(mWifiConfigStoreLegacy, never()).removeStores();
}
#end_block

#method_before
@Test
public void testFreshInstallDoesNotLoadFromStore() throws Exception {
    // New store files not present, so migrate from the old store.
    when(mWifiConfigStore.areStoresPresent()).thenReturn(false);
    when(mWifiConfigStoreLegacy.areStoresPresent()).thenReturn(false);
    // Now trigger a load from store. This should populate the in memory list with all the
    // networks above.
    mWifiConfigManager.loadFromStore();
    verify(mWifiConfigStore, never()).read();
    verify(mWifiConfigStoreLegacy, never()).read();
    assertTrue(mWifiConfigManager.getConfiguredNetworksWithPasswords().isEmpty());
}
#method_after
@Test
public void testFreshInstallDoesNotLoadFromStore() throws Exception {
    // New store files not present, so migrate from the old store.
    when(mWifiConfigStore.areStoresPresent()).thenReturn(false);
    when(mWifiConfigStoreLegacy.areStoresPresent()).thenReturn(false);
    // Now trigger a load from store. This should populate the in memory list with all the
    // networks above.
    assertTrue(mWifiConfigManager.loadFromStore());
    verify(mWifiConfigStore, never()).read();
    verify(mWifiConfigStoreLegacy, never()).read();
    assertTrue(mWifiConfigManager.getConfiguredNetworksWithPasswords().isEmpty());
}
#end_block

#method_before
@Test
@SmallTest
public void testAddPackageToCache() {
    setupResolver(1);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    ImsResolver.ImsServiceInfo testCachedService = mTestImsResolver.getImsServiceInfoFromCache(TEST_DEVICE_DEFAULT_NAME.getPackageName());
    assertNotNull(testCachedService);
    assertTrue(isImsServiceInfoEqual(TEST_DEVICE_DEFAULT_NAME, features, testCachedService));
}
#method_after
@Test
@SmallTest
public void testAddPackageToCache() {
    setupResolver(1);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    ImsResolver.ImsServiceInfo testCachedService = mTestImsResolver.getImsServiceInfoFromCache(TEST_DEVICE_DEFAULT_NAME.getPackageName());
    assertNotNull(testCachedService);
    assertTrue(isImsServiceInfoEqual(TEST_DEVICE_DEFAULT_NAME, features, testCachedService));
}
#end_block

#method_before
@Test
@SmallTest
public void testCarrierPackageBind() throws RemoteException {
    setupResolver(1);
    // Set CarrierConfig default package name and make it available to the package manager
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController controller = mock(ImsServiceController.class);
    mTestImsResolver.setImsServiceControllerFactory((context, componentName) -> {
        when(controller.getComponentName()).thenReturn(componentName);
        return controller;
    });
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    verify(controller).bind(convertToHashSet(features, 0));
    verify(controller, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, controller.getComponentName());
}
#method_after
@Test
@SmallTest
public void testCarrierPackageBind() throws RemoteException {
    setupResolver(1);
    // Set CarrierConfig default package name and make it available to the package manager
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController controller = mock(ImsServiceController.class);
    mTestImsResolver.setImsServiceControllerFactory((context, componentName) -> {
        when(controller.getComponentName()).thenReturn(componentName);
        return controller;
    });
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    verify(controller).bind(convertToHashSet(features, 0));
    verify(controller, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, controller.getComponentName());
}
#end_block

#method_before
@Test
@SmallTest
public void testDontBindWhenNullCarrierPackage() throws RemoteException {
    setupResolver(1);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController controller = mock(ImsServiceController.class);
    mTestImsResolver.setImsServiceControllerFactory((context, componentName) -> {
        when(controller.getComponentName()).thenReturn(componentName);
        return controller;
    });
    // Set the CarrierConfig string to null so that ImsResolver will not bind to the available
    // Services
    setConfigCarrierString(0, null);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    verify(controller, never()).bind(any());
    verify(controller, never()).unbind();
}
#method_after
@Test
@SmallTest
public void testDontBindWhenNullCarrierPackage() throws RemoteException {
    setupResolver(1);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController controller = mock(ImsServiceController.class);
    mTestImsResolver.setImsServiceControllerFactory((context, componentName) -> {
        when(controller.getComponentName()).thenReturn(componentName);
        return controller;
    });
    // Set the CarrierConfig string to null so that ImsResolver will not bind to the available
    // Services
    setConfigCarrierString(0, null);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    verify(controller, never()).bind(any());
    verify(controller, never()).unbind();
}
#end_block

#method_before
@Test
@SmallTest
public void testDevicePackageBind() throws RemoteException {
    setupResolver(1);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_RCS_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, features, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController controller = mock(ImsServiceController.class);
    mTestImsResolver.setImsServiceControllerFactory((context, componentName) -> {
        when(controller.getComponentName()).thenReturn(componentName);
        return controller;
    });
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // There is no carrier override set, so make sure that the ImsServiceController binds
    // to all SIMs.
    HashSet<Pair<Integer, Integer>> featureSet = convertToHashSet(features, 0);
    verify(controller).bind(featureSet);
    verify(controller, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, controller.getComponentName());
}
#method_after
@Test
@SmallTest
public void testDevicePackageBind() throws RemoteException {
    setupResolver(1);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_RCS_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, features, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController controller = mock(ImsServiceController.class);
    mTestImsResolver.setImsServiceControllerFactory((context, componentName) -> {
        when(controller.getComponentName()).thenReturn(componentName);
        return controller;
    });
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // There is no carrier override set, so make sure that the ImsServiceController binds
    // to all SIMs.
    HashSet<Pair<Integer, Integer>> featureSet = convertToHashSet(features, 0);
    verify(controller).bind(featureSet);
    verify(controller, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, controller.getComponentName());
}
#end_block

#method_before
@Test
@SmallTest
public void testDeviceAndCarrierPackageBind() throws RemoteException {
    setupResolver(1);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    verify(carrierController, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, carrierController.getComponentName());
    // Verify that all features that are not defined in the carrier override are bound in the
    // device controller (including emergency voice for slot 0)
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 0);
    deviceFeatureSet.removeAll(carrierFeatureSet);
    verify(deviceController).bind(deviceFeatureSet);
    verify(deviceController, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, deviceController.getComponentName());
}
#method_after
@Test
@SmallTest
public void testDeviceAndCarrierPackageBind() throws RemoteException {
    setupResolver(1);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    verify(carrierController, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, carrierController.getComponentName());
    // Verify that all features that are not defined in the carrier override are bound in the
    // device controller (including emergency voice for slot 0)
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 0);
    deviceFeatureSet.removeAll(carrierFeatureSet);
    verify(deviceController).bind(deviceFeatureSet);
    verify(deviceController, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, deviceController.getComponentName());
}
#end_block

#method_before
@Test
@SmallTest
public void testGetDeviceCarrierFeatures() throws RemoteException {
    setupResolver(2);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    IImsServiceController iDeviceController = mock(IImsServiceController.class);
    when(deviceController.getImsServiceController()).thenReturn(iDeviceController);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    IImsServiceController iCarrierController = mock(IImsServiceController.class);
    when(carrierController.getImsServiceController()).thenReturn(iCarrierController);
    mTestImsResolver.populateCacheAndStartBind();
    // Callback from mock ImsServiceControllers
    // All features on slot 1 should be the device default
    mTestImsResolver.imsServiceFeatureCreated(1, ImsFeature.EMERGENCY_VOICE, deviceController);
    mTestImsResolver.imsServiceFeatureCreated(1, ImsFeature.VOICE, deviceController);
    mTestImsResolver.imsServiceFeatureCreated(1, ImsFeature.RCS, deviceController);
    // The carrier override does not support emergency voice
    mTestImsResolver.imsServiceFeatureCreated(1, ImsFeature.EMERGENCY_VOICE, deviceController);
    // The carrier override contains these features
    mTestImsResolver.imsServiceFeatureCreated(0, ImsFeature.VOICE, carrierController);
    mTestImsResolver.imsServiceFeatureCreated(0, ImsFeature.RCS, carrierController);
    // Get the IImsServiceControllers for each feature on each slot and verify they are correct.
    assertEquals(iDeviceController, mTestImsResolver.getImsServiceControllerAndListen(1, /*Slot id*/
    ImsFeature.EMERGENCY_VOICE, null));
    assertEquals(iDeviceController, mTestImsResolver.getImsServiceControllerAndListen(1, /*Slot id*/
    ImsFeature.VOICE, null));
    assertEquals(iDeviceController, mTestImsResolver.getImsServiceControllerAndListen(1, /*Slot id*/
    ImsFeature.RCS, null));
    assertEquals(iDeviceController, mTestImsResolver.getImsServiceControllerAndListen(1, /*Slot id*/
    ImsFeature.EMERGENCY_VOICE, null));
    assertEquals(iCarrierController, mTestImsResolver.getImsServiceControllerAndListen(0, /*Slot id*/
    ImsFeature.VOICE, null));
    assertEquals(iCarrierController, mTestImsResolver.getImsServiceControllerAndListen(0, /*Slot id*/
    ImsFeature.RCS, null));
}
#method_after
@Test
@SmallTest
public void testGetDeviceCarrierFeatures() throws RemoteException {
    setupResolver(2);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    IImsServiceController iDeviceController = mock(IImsServiceController.class);
    when(deviceController.getImsServiceController()).thenReturn(iDeviceController);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    IImsServiceController iCarrierController = mock(IImsServiceController.class);
    when(carrierController.getImsServiceController()).thenReturn(iCarrierController);
    mTestImsResolver.populateCacheAndStartBind();
    // Callback from mock ImsServiceControllers
    // All features on slot 1 should be the device default
    mTestImsResolver.imsServiceFeatureCreated(1, ImsFeature.EMERGENCY_MMTEL, deviceController);
    mTestImsResolver.imsServiceFeatureCreated(1, ImsFeature.MMTEL, deviceController);
    mTestImsResolver.imsServiceFeatureCreated(1, ImsFeature.RCS, deviceController);
    // The carrier override does not support emergency voice
    mTestImsResolver.imsServiceFeatureCreated(1, ImsFeature.EMERGENCY_MMTEL, deviceController);
    // The carrier override contains these features
    mTestImsResolver.imsServiceFeatureCreated(0, ImsFeature.MMTEL, carrierController);
    mTestImsResolver.imsServiceFeatureCreated(0, ImsFeature.RCS, carrierController);
    // Get the IImsServiceControllers for each feature on each slot and verify they are correct.
    assertEquals(iDeviceController, mTestImsResolver.getImsServiceControllerAndListen(1, /*Slot id*/
    ImsFeature.EMERGENCY_MMTEL, null));
    assertEquals(iDeviceController, mTestImsResolver.getImsServiceControllerAndListen(1, /*Slot id*/
    ImsFeature.MMTEL, null));
    assertEquals(iDeviceController, mTestImsResolver.getImsServiceControllerAndListen(1, /*Slot id*/
    ImsFeature.RCS, null));
    assertEquals(iDeviceController, mTestImsResolver.getImsServiceControllerAndListen(1, /*Slot id*/
    ImsFeature.EMERGENCY_MMTEL, null));
    assertEquals(iCarrierController, mTestImsResolver.getImsServiceControllerAndListen(0, /*Slot id*/
    ImsFeature.MMTEL, null));
    assertEquals(iCarrierController, mTestImsResolver.getImsServiceControllerAndListen(0, /*Slot id*/
    ImsFeature.RCS, null));
}
#end_block

#method_before
@Test
@SmallTest
public void testAddDeviceFeatureNoCarrier() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    features.add(ImsResolver.METADATA_VOICE_FEATURE);
    // Doesn't include RCS feature by default
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController controller = mock(ImsServiceController.class);
    mTestImsResolver.setImsServiceControllerFactory((context, componentName) -> {
        when(controller.getComponentName()).thenReturn(componentName);
        return controller;
    });
    // Bind using default features
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    HashSet<Pair<Integer, Integer>> featureSet = convertToHashSet(features, 0);
    featureSet.addAll(convertToHashSet(features, 1));
    verify(controller).bind(featureSet);
    // add RCS to features list
    Set<String> newFeatures = new HashSet<>(features);
    newFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.clear();
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, newFeatures, true));
    // Tell the package manager that a new device feature is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_DEVICE_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify new feature is added to the device default.
    HashSet<Pair<Integer, Integer>> newFeatureSet = convertToHashSet(newFeatures, 0);
    newFeatureSet.addAll(convertToHashSet(newFeatures, 1));
    verify(controller).changeImsServiceFeatures(newFeatureSet);
}
#method_after
@Test
@SmallTest
public void testAddDeviceFeatureNoCarrier() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> features = new HashSet<>();
    features.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    features.add(ImsResolver.METADATA_MMTEL_FEATURE);
    // Doesn't include RCS feature by default
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, features, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController controller = mock(ImsServiceController.class);
    mTestImsResolver.setImsServiceControllerFactory((context, componentName) -> {
        when(controller.getComponentName()).thenReturn(componentName);
        return controller;
    });
    // Bind using default features
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    HashSet<Pair<Integer, Integer>> featureSet = convertToHashSet(features, 0);
    featureSet.addAll(convertToHashSet(features, 1));
    verify(controller).bind(featureSet);
    // add RCS to features list
    Set<String> newFeatures = new HashSet<>(features);
    newFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.clear();
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, newFeatures, true));
    // Tell the package manager that a new device feature is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_DEVICE_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify new feature is added to the device default.
    HashSet<Pair<Integer, Integer>> newFeatureSet = convertToHashSet(newFeatures, 0);
    newFeatureSet.addAll(convertToHashSet(newFeatures, 1));
    verify(controller).changeImsServiceFeatures(newFeatureSet);
}
#end_block

#method_before
@Test
@SmallTest
public void testAddDeviceFeatureWithCarrier() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    verify(carrierController, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, carrierController.getComponentName());
    // Verify that all features that are not defined in the carrier override are bound in the
    // device controller (including emergency voice for slot 0)
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatures.removeAll(carrierFeatures);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).bind(deviceFeatureSet);
    verify(deviceController, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, deviceController.getComponentName());
    // add RCS to features list
    Set<String> newDeviceFeatures = new HashSet<>();
    newDeviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    newDeviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    newDeviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.clear();
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, newDeviceFeatures, true));
    // Tell the package manager that a new device feature is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_DEVICE_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify new feature is added to the device default.
    // add all features for slot 1
    HashSet<Pair<Integer, Integer>> newDeviceFeatureSet = convertToHashSet(newDeviceFeatures, 1);
    // remove carrier overrides for slot 0
    newDeviceFeatures.removeAll(carrierFeatures);
    newDeviceFeatureSet.addAll(convertToHashSet(newDeviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(newDeviceFeatureSet);
    verify(carrierController, never()).changeImsServiceFeatures(any());
}
#method_after
@Test
@SmallTest
public void testAddDeviceFeatureWithCarrier() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    verify(carrierController, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, carrierController.getComponentName());
    // Verify that all features that are not defined in the carrier override are bound in the
    // device controller (including emergency voice for slot 0)
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatures.removeAll(carrierFeatures);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).bind(deviceFeatureSet);
    verify(deviceController, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, deviceController.getComponentName());
    // add RCS to features list
    Set<String> newDeviceFeatures = new HashSet<>();
    newDeviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    newDeviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    newDeviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.clear();
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, newDeviceFeatures, true));
    // Tell the package manager that a new device feature is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_DEVICE_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify new feature is added to the device default.
    // add all features for slot 1
    HashSet<Pair<Integer, Integer>> newDeviceFeatureSet = convertToHashSet(newDeviceFeatures, 1);
    // remove carrier overrides for slot 0
    newDeviceFeatures.removeAll(carrierFeatures);
    newDeviceFeatureSet.addAll(convertToHashSet(newDeviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(newDeviceFeatureSet);
    verify(carrierController, never()).changeImsServiceFeatures(any());
}
#end_block

#method_before
@Test
@SmallTest
public void testAddCarrierFeature() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    verify(carrierController, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, carrierController.getComponentName());
    // Verify that all features that are not defined in the carrier override are bound in the
    // device controller (including emergency voice for slot 0)
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatures.removeAll(carrierFeatures);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).bind(deviceFeatureSet);
    verify(deviceController, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, deviceController.getComponentName());
    // add RCS to carrier features list
    Set<String> newCarrierFeatures = new HashSet<>();
    newCarrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    newCarrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.clear();
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, newCarrierFeatures, true));
    // Tell the package manager that a new device feature is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_CARRIER_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify new feature is added to the carrier override.
    // add all features for slot 0
    HashSet<Pair<Integer, Integer>> newCarrierFeatureSet = convertToHashSet(newCarrierFeatures, 0);
    verify(carrierController).changeImsServiceFeatures(newCarrierFeatureSet);
    deviceFeatureSet.removeAll(newCarrierFeatureSet);
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#method_after
@Test
@SmallTest
public void testAddCarrierFeature() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    verify(carrierController, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, carrierController.getComponentName());
    // Verify that all features that are not defined in the carrier override are bound in the
    // device controller (including emergency voice for slot 0)
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatures.removeAll(carrierFeatures);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).bind(deviceFeatureSet);
    verify(deviceController, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, deviceController.getComponentName());
    // add RCS to carrier features list
    Set<String> newCarrierFeatures = new HashSet<>();
    newCarrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    newCarrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.clear();
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, newCarrierFeatures, true));
    // Tell the package manager that a new device feature is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_CARRIER_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify new feature is added to the carrier override.
    // add all features for slot 0
    HashSet<Pair<Integer, Integer>> newCarrierFeatureSet = convertToHashSet(newCarrierFeatures, 0);
    verify(carrierController).changeImsServiceFeatures(newCarrierFeatureSet);
    deviceFeatureSet.removeAll(newCarrierFeatureSet);
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#end_block

#method_before
@Test
@SmallTest
public void testRemoveCarrierFeature() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    verify(carrierController, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, carrierController.getComponentName());
    // Verify that all features that are not defined in the carrier override are bound in the
    // device controller (including emergency voice for slot 0)
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatures.removeAll(carrierFeatures);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).bind(deviceFeatureSet);
    verify(deviceController, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, deviceController.getComponentName());
    // remove RCS from carrier features list
    Set<String> newCarrierFeatures = new HashSet<>();
    newCarrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    info.clear();
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, newCarrierFeatures, true));
    // Tell the package manager that a new device feature is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_CARRIER_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify new feature is added to the carrier override.
    // add all features for slot 0
    HashSet<Pair<Integer, Integer>> newCarrierFeatureSet = convertToHashSet(newCarrierFeatures, 0);
    verify(carrierController).changeImsServiceFeatures(newCarrierFeatureSet);
    Set<String> newDeviceFeatures = new HashSet<>();
    newDeviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    newDeviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    newDeviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    HashSet<Pair<Integer, Integer>> newDeviceFeatureSet = convertToHashSet(newDeviceFeatures, 1);
    newDeviceFeatures.removeAll(newCarrierFeatures);
    newDeviceFeatureSet.addAll(convertToHashSet(newDeviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(newDeviceFeatureSet);
}
#method_after
@Test
@SmallTest
public void testRemoveCarrierFeature() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    verify(carrierController, never()).unbind();
    assertEquals(TEST_CARRIER_DEFAULT_NAME, carrierController.getComponentName());
    // Verify that all features that are not defined in the carrier override are bound in the
    // device controller (including emergency voice for slot 0)
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatures.removeAll(carrierFeatures);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).bind(deviceFeatureSet);
    verify(deviceController, never()).unbind();
    assertEquals(TEST_DEVICE_DEFAULT_NAME, deviceController.getComponentName());
    // remove RCS from carrier features list
    Set<String> newCarrierFeatures = new HashSet<>();
    newCarrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    info.clear();
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, newCarrierFeatures, true));
    // Tell the package manager that a new device feature is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_CARRIER_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify new feature is added to the carrier override.
    // add all features for slot 0
    HashSet<Pair<Integer, Integer>> newCarrierFeatureSet = convertToHashSet(newCarrierFeatures, 0);
    verify(carrierController).changeImsServiceFeatures(newCarrierFeatureSet);
    Set<String> newDeviceFeatures = new HashSet<>();
    newDeviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    newDeviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    newDeviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    HashSet<Pair<Integer, Integer>> newDeviceFeatureSet = convertToHashSet(newDeviceFeatures, 1);
    newDeviceFeatures.removeAll(newCarrierFeatures);
    newDeviceFeatureSet.addAll(convertToHashSet(newDeviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(newDeviceFeatureSet);
}
#end_block

#method_before
@Test
@SmallTest
public void testInstallCarrierImsService() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    // Tell the package manager that a new carrier app is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_CARRIER_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    // device features change
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    deviceFeatureSet.removeAll(carrierFeatureSet);
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#method_after
@Test
@SmallTest
public void testInstallCarrierImsService() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    // Tell the package manager that a new carrier app is installed
    Intent addPackageIntent = new Intent();
    addPackageIntent.setAction(Intent.ACTION_PACKAGE_ADDED);
    addPackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_CARRIER_DEFAULT_NAME.getPackageName()).build());
    mTestPackageBroadcastReceiver.onReceive(null, addPackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that all features that have been defined for the carrier override are bound
    HashSet<Pair<Integer, Integer>> carrierFeatureSet = convertToHashSet(carrierFeatures, 0);
    carrierFeatureSet.addAll(convertToHashSet(carrierFeatures, 0));
    verify(carrierController).bind(carrierFeatureSet);
    // device features change
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    deviceFeatureSet.removeAll(carrierFeatureSet);
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#end_block

#method_before
@Test
@SmallTest
public void testUninstallCarrierImsService() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Tell the package manager that carrier app is uninstalled
    Intent removePackageIntent = new Intent();
    removePackageIntent.setAction(Intent.ACTION_PACKAGE_REMOVED);
    removePackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_CARRIER_DEFAULT_NAME.getPackageName()).build());
    info.clear();
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    mTestPackageBroadcastReceiver.onReceive(null, removePackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that the carrier controller is unbound
    verify(carrierController).unbind();
    assertNull(mTestImsResolver.getImsServiceInfoFromCache(TEST_CARRIER_DEFAULT_NAME.getPackageName()));
    // device features change to include all supported functionality
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#method_after
@Test
@SmallTest
public void testUninstallCarrierImsService() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Tell the package manager that carrier app is uninstalled
    Intent removePackageIntent = new Intent();
    removePackageIntent.setAction(Intent.ACTION_PACKAGE_REMOVED);
    removePackageIntent.setData(new Uri.Builder().scheme("package").opaquePart(TEST_CARRIER_DEFAULT_NAME.getPackageName()).build());
    info.clear();
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    mTestPackageBroadcastReceiver.onReceive(null, removePackageIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that the carrier controller is unbound
    verify(carrierController).unbind();
    assertNull(mTestImsResolver.getImsServiceInfoFromCache(TEST_CARRIER_DEFAULT_NAME.getPackageName()));
    // device features change to include all supported functionality
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#end_block

#method_before
@Test
@SmallTest
public void testCarrierConfigChangedToNone() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    setConfigCarrierString(0, null);
    Intent carrierConfigIntent = new Intent();
    carrierConfigIntent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, 0);
    mTestCarrierConfigReceiver.onReceive(null, carrierConfigIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that the carrier controller is unbound
    verify(carrierController).unbind();
    assertNotNull(mTestImsResolver.getImsServiceInfoFromCache(TEST_CARRIER_DEFAULT_NAME.getPackageName()));
    // device features change
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#method_after
@Test
@SmallTest
public void testCarrierConfigChangedToNone() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    carrierFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures, true));
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    setConfigCarrierString(0, null);
    Intent carrierConfigIntent = new Intent();
    carrierConfigIntent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, 0);
    mTestCarrierConfigReceiver.onReceive(null, carrierConfigIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that the carrier controller is unbound
    verify(carrierController).unbind();
    assertNotNull(mTestImsResolver.getImsServiceInfoFromCache(TEST_CARRIER_DEFAULT_NAME.getPackageName()));
    // device features change
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#end_block

#method_before
@Test
@SmallTest
public void testCarrierConfigChangedToAnotherService() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_VOICE_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures1 = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures1.add(ImsResolver.METADATA_VOICE_FEATURE);
    carrierFeatures1.add(ImsResolver.METADATA_RCS_FEATURE);
    Set<String> carrierFeatures2 = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures2.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_2_DEFAULT_NAME, carrierFeatures2, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures1, true));
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController1 = mock(ImsServiceController.class);
    ImsServiceController carrierController2 = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController1, carrierController2);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    setConfigCarrierString(0, TEST_CARRIER_2_DEFAULT_NAME.getPackageName());
    Intent carrierConfigIntent = new Intent();
    carrierConfigIntent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, 0);
    mTestCarrierConfigReceiver.onReceive(null, carrierConfigIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that carrier 1 is unbound
    verify(carrierController1).unbind();
    assertNotNull(mTestImsResolver.getImsServiceInfoFromCache(TEST_CARRIER_DEFAULT_NAME.getPackageName()));
    // Verify that carrier 2 is bound
    HashSet<Pair<Integer, Integer>> carrier2FeatureSet = convertToHashSet(carrierFeatures2, 0);
    verify(carrierController2).bind(carrier2FeatureSet);
    assertNotNull(mTestImsResolver.getImsServiceInfoFromCache(TEST_CARRIER_DEFAULT_NAME.getPackageName()));
    // device features change to accommodate for the features carrier 2 lacks
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatures.removeAll(carrierFeatures2);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#method_after
@Test
@SmallTest
public void testCarrierConfigChangedToAnotherService() throws RemoteException {
    setupResolver(2);
    List<ResolveInfo> info = new ArrayList<>();
    Set<String> deviceFeatures = new HashSet<>();
    deviceFeatures.add(ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_MMTEL_FEATURE);
    deviceFeatures.add(ImsResolver.METADATA_RCS_FEATURE);
    // Set the carrier override package for slot 0
    setConfigCarrierString(0, TEST_CARRIER_DEFAULT_NAME.getPackageName());
    Set<String> carrierFeatures1 = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures1.add(ImsResolver.METADATA_MMTEL_FEATURE);
    carrierFeatures1.add(ImsResolver.METADATA_RCS_FEATURE);
    Set<String> carrierFeatures2 = new HashSet<>();
    // Carrier service doesn't support the emergency voice feature.
    carrierFeatures2.add(ImsResolver.METADATA_RCS_FEATURE);
    info.add(getResolveInfo(TEST_CARRIER_2_DEFAULT_NAME, carrierFeatures2, true));
    info.add(getResolveInfo(TEST_CARRIER_DEFAULT_NAME, carrierFeatures1, true));
    // Use device default package, which will load the ImsService that the device provides
    info.add(getResolveInfo(TEST_DEVICE_DEFAULT_NAME, deviceFeatures, true));
    when(mMockPM.queryIntentServicesAsUser(any(), anyInt(), anyInt())).thenReturn(info);
    ImsServiceController deviceController = mock(ImsServiceController.class);
    ImsServiceController carrierController1 = mock(ImsServiceController.class);
    ImsServiceController carrierController2 = mock(ImsServiceController.class);
    setImsServiceControllerFactory(deviceController, carrierController1, carrierController2);
    mTestImsResolver.populateCacheAndStartBind();
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    setConfigCarrierString(0, TEST_CARRIER_2_DEFAULT_NAME.getPackageName());
    Intent carrierConfigIntent = new Intent();
    carrierConfigIntent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, 0);
    mTestCarrierConfigReceiver.onReceive(null, carrierConfigIntent);
    waitForHandlerAction(mTestImsResolver.getHandler(), TEST_TIMEOUT);
    // Verify that carrier 1 is unbound
    verify(carrierController1).unbind();
    assertNotNull(mTestImsResolver.getImsServiceInfoFromCache(TEST_CARRIER_DEFAULT_NAME.getPackageName()));
    // Verify that carrier 2 is bound
    HashSet<Pair<Integer, Integer>> carrier2FeatureSet = convertToHashSet(carrierFeatures2, 0);
    verify(carrierController2).bind(carrier2FeatureSet);
    assertNotNull(mTestImsResolver.getImsServiceInfoFromCache(TEST_CARRIER_DEFAULT_NAME.getPackageName()));
    // device features change to accommodate for the features carrier 2 lacks
    HashSet<Pair<Integer, Integer>> deviceFeatureSet = convertToHashSet(deviceFeatures, 1);
    deviceFeatures.removeAll(carrierFeatures2);
    deviceFeatureSet.addAll(convertToHashSet(deviceFeatures, 0));
    verify(deviceController).changeImsServiceFeatures(deviceFeatureSet);
}
#end_block

#method_before
private void setConfigCarrierString(int subId, String packageName) {
    mCarrierConfigs[subId].putString(CarrierConfigManager.KEY_CONFIG_IMS_PACKAGE_OVERRIDE, packageName);
}
#method_after
private void setConfigCarrierString(int subId, String packageName) {
    mCarrierConfigs[subId].putString(CarrierConfigManager.KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING, packageName);
}
#end_block

#method_before
private int metadataStringToFeature(String f) {
    switch(f) {
        case ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE:
            return ImsFeature.EMERGENCY_VOICE;
        case ImsResolver.METADATA_VOICE_FEATURE:
            return ImsFeature.VOICE;
        case ImsResolver.METADATA_RCS_FEATURE:
            return ImsFeature.RCS;
    }
    return -1;
}
#method_after
private int metadataStringToFeature(String f) {
    switch(f) {
        case ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE:
            return ImsFeature.EMERGENCY_MMTEL;
        case ImsResolver.METADATA_MMTEL_FEATURE:
            return ImsFeature.MMTEL;
        case ImsResolver.METADATA_RCS_FEATURE:
            return ImsFeature.RCS;
    }
    return -1;
}
#end_block

#method_before
private boolean isImsServiceInfoEqual(ComponentName name, Set<String> features, ImsResolver.ImsServiceInfo sInfo) {
    if (!Objects.equals(sInfo.name, name)) {
        return false;
    }
    for (String f : features) {
        switch(f) {
            case ImsResolver.METADATA_EMERGENCY_VOICE_FEATURE:
                if (!sInfo.supportedFeatures.contains(ImsFeature.EMERGENCY_VOICE)) {
                    return false;
                }
                break;
            case ImsResolver.METADATA_VOICE_FEATURE:
                if (!sInfo.supportedFeatures.contains(ImsFeature.VOICE)) {
                    return false;
                }
                break;
            case ImsResolver.METADATA_RCS_FEATURE:
                if (!sInfo.supportedFeatures.contains(ImsFeature.RCS)) {
                    return false;
                }
                break;
        }
    }
    return true;
}
#method_after
private boolean isImsServiceInfoEqual(ComponentName name, Set<String> features, ImsResolver.ImsServiceInfo sInfo) {
    if (!Objects.equals(sInfo.name, name)) {
        return false;
    }
    for (String f : features) {
        switch(f) {
            case ImsResolver.METADATA_EMERGENCY_MMTEL_FEATURE:
                if (!sInfo.supportedFeatures.contains(ImsFeature.EMERGENCY_MMTEL)) {
                    return false;
                }
                break;
            case ImsResolver.METADATA_MMTEL_FEATURE:
                if (!sInfo.supportedFeatures.contains(ImsFeature.MMTEL)) {
                    return false;
                }
                break;
            case ImsResolver.METADATA_RCS_FEATURE:
                if (!sInfo.supportedFeatures.contains(ImsFeature.RCS)) {
                    return false;
                }
                break;
        }
    }
    return true;
}
#end_block

#method_before
private void updateBoundCarrierServices(int subId) {
    int slotId = mSubscriptionManagerProxy.getSlotId(subId);
    String newPackageName = mCarrierConfigManager.getConfigForSubId(subId).getString(CarrierConfigManager.KEY_CONFIG_IMS_PACKAGE_OVERRIDE, null);
    if (slotId != SubscriptionManager.INVALID_SIM_SLOT_INDEX && slotId < mNumSlots) {
        String oldPackageName = mCarrierServices[slotId];
        mCarrierServices[slotId] = newPackageName;
        if (!TextUtils.equals(newPackageName, oldPackageName)) {
            Log.i(TAG, "Carrier Config updated, binding new ImsService");
            // Unbind old ImsService, not needed anymore
            // ImsService is retrieved from the cache. If the cache hasn't been populated yet,
            // the calls to unbind/bind will fail (intended during initial start up).
            unbindImsService(getImsServiceInfoFromCache(oldPackageName));
            bindNewImsService(getImsServiceInfoFromCache(newPackageName));
            // Recalculate the device ImsService features to reflect changes.
            updateImsServiceFeatures(getImsServiceInfoFromCache(mDeviceService));
        }
    }
}
#method_after
private void updateBoundCarrierServices(int subId) {
    int slotId = mSubscriptionManagerProxy.getSlotId(subId);
    String newPackageName = mCarrierConfigManager.getConfigForSubId(subId).getString(CarrierConfigManager.KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING, null);
    if (slotId != SubscriptionManager.INVALID_SIM_SLOT_INDEX && slotId < mNumSlots) {
        String oldPackageName = mCarrierServices[slotId];
        mCarrierServices[slotId] = newPackageName;
        if (!TextUtils.equals(newPackageName, oldPackageName)) {
            Log.i(TAG, "Carrier Config updated, binding new ImsService");
            // Unbind old ImsService, not needed anymore
            // ImsService is retrieved from the cache. If the cache hasn't been populated yet,
            // the calls to unbind/bind will fail (intended during initial start up).
            unbindImsService(getImsServiceInfoFromCache(oldPackageName));
            bindNewImsService(getImsServiceInfoFromCache(newPackageName));
            // Recalculate the device ImsService features to reflect changes.
            updateImsServiceFeatures(getImsServiceInfoFromCache(mDeviceService));
        }
    }
}
#end_block

#method_before
// Return the ImsServiceInfo specified for the package name. If the package name is null,
private List<ImsServiceInfo> getImsServiceInfo(String packageName) {
    List<ImsServiceInfo> infos = new ArrayList<>();
    Intent serviceIntent = new Intent(SERVICE_INTERFACE);
    serviceIntent.setPackage(packageName);
    PackageManager packageManager = mContext.getPackageManager();
    for (ResolveInfo entry : packageManager.queryIntentServicesAsUser(serviceIntent, PackageManager.GET_META_DATA, mContext.getUserId())) {
        ServiceInfo serviceInfo = entry.serviceInfo;
        if (serviceInfo != null) {
            ImsServiceInfo info = new ImsServiceInfo();
            info.name = new ComponentName(serviceInfo.packageName, serviceInfo.name);
            info.supportedFeatures = new HashSet<>(ImsFeature.MAX);
            // Add all supported features
            if (serviceInfo.metaData != null) {
                if (serviceInfo.metaData.getBoolean(METADATA_EMERGENCY_VOICE_FEATURE, false)) {
                    info.supportedFeatures.add(ImsFeature.EMERGENCY_VOICE);
                }
                if (serviceInfo.metaData.getBoolean(METADATA_VOICE_FEATURE, false)) {
                    info.supportedFeatures.add(ImsFeature.VOICE);
                }
                if (serviceInfo.metaData.getBoolean(METADATA_RCS_FEATURE, false)) {
                    info.supportedFeatures.add(ImsFeature.RCS);
                }
            }
            // permissions.
            if (TextUtils.equals(serviceInfo.permission, Manifest.permission.BIND_IMS_SERVICE)) {
                Log.d(TAG, "ImsService added to cache: " + info.name + " with features: " + info.supportedFeatures);
                infos.add(info);
            } else {
                Log.w(TAG, "ImsService does not have BIND_IMS_SERVICE permission: " + info.name);
            }
        }
    }
    return infos;
}
#method_after
// Return the ImsServiceInfo specified for the package name. If the package name is null,
private List<ImsServiceInfo> getImsServiceInfo(String packageName) {
    List<ImsServiceInfo> infos = new ArrayList<>();
    Intent serviceIntent = new Intent(SERVICE_INTERFACE);
    serviceIntent.setPackage(packageName);
    PackageManager packageManager = mContext.getPackageManager();
    for (ResolveInfo entry : packageManager.queryIntentServicesAsUser(serviceIntent, PackageManager.GET_META_DATA, mContext.getUserId())) {
        ServiceInfo serviceInfo = entry.serviceInfo;
        if (serviceInfo != null) {
            ImsServiceInfo info = new ImsServiceInfo();
            info.name = new ComponentName(serviceInfo.packageName, serviceInfo.name);
            info.supportedFeatures = new HashSet<>(ImsFeature.MAX);
            // Add all supported features
            if (serviceInfo.metaData != null) {
                if (serviceInfo.metaData.getBoolean(METADATA_EMERGENCY_MMTEL_FEATURE, false)) {
                    info.supportedFeatures.add(ImsFeature.EMERGENCY_MMTEL);
                }
                if (serviceInfo.metaData.getBoolean(METADATA_MMTEL_FEATURE, false)) {
                    info.supportedFeatures.add(ImsFeature.MMTEL);
                }
                if (serviceInfo.metaData.getBoolean(METADATA_RCS_FEATURE, false)) {
                    info.supportedFeatures.add(ImsFeature.RCS);
                }
            }
            // permissions.
            if (TextUtils.equals(serviceInfo.permission, Manifest.permission.BIND_IMS_SERVICE)) {
                Log.d(TAG, "ImsService added to cache: " + info.name + " with features: " + info.supportedFeatures);
                infos.add(info);
            } else {
                Log.w(TAG, "ImsService does not have BIND_IMS_SERVICE permission: " + info.name);
            }
        }
    }
    return infos;
}
#end_block

#method_before
private String updateDefaultRouteMacAddress(int timeout) {
    String address = null;
    for (RouteInfo route : mLinkProperties.getRoutes()) {
        if (route.isDefaultRoute() && route.hasGateway()) {
            InetAddress gateway = route.getGateway();
            if (gateway instanceof Inet4Address) {
                if (mVerboseLoggingEnabled) {
                    logd("updateDefaultRouteMacAddress found Ipv4 default :" + gateway.getHostAddress());
                }
                address = macAddressFromRoute(gateway.getHostAddress());
                /* The gateway's MAC address is known */
                if ((address == null) && (timeout > 0)) {
                    boolean reachable = false;
                    try {
                        reachable = gateway.isReachable(timeout);
                    } catch (Exception e) {
                        loge("updateDefaultRouteMacAddress exception reaching :" + gateway.getHostAddress());
                    } finally {
                        if (reachable == true) {
                            address = macAddressFromRoute(gateway.getHostAddress());
                            if (mVerboseLoggingEnabled) {
                                logd("updateDefaultRouteMacAddress reachable (tried again) :" + gateway.getHostAddress() + " found " + address);
                            }
                        }
                    }
                }
                if (address != null) {
                    mWifiConfigManager.setNetworkDefaultGwMacAddress(mLastNetworkId, address);
                }
            }
        }
    }
    return address;
}
#method_after
private String updateDefaultRouteMacAddress(int timeout) {
    String address = null;
    for (RouteInfo route : mLinkProperties.getRoutes()) {
        if (route.isDefaultRoute() && route.hasGateway()) {
            InetAddress gateway = route.getGateway();
            if (gateway instanceof Inet4Address) {
                if (mVerboseLoggingEnabled) {
                    logd("updateDefaultRouteMacAddress found Ipv4 default :" + gateway.getHostAddress());
                }
                address = macAddressFromRoute(gateway.getHostAddress());
                /* The gateway's MAC address is known */
                if ((address == null) && (timeout > 0)) {
                    boolean reachable = false;
                    TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE);
                    try {
                        reachable = gateway.isReachable(timeout);
                    } catch (Exception e) {
                        loge("updateDefaultRouteMacAddress exception reaching :" + gateway.getHostAddress());
                    } finally {
                        TrafficStats.clearThreadStatsTag();
                        if (reachable == true) {
                            address = macAddressFromRoute(gateway.getHostAddress());
                            if (mVerboseLoggingEnabled) {
                                logd("updateDefaultRouteMacAddress reachable (tried again) :" + gateway.getHostAddress() + " found " + address);
                            }
                        }
                    }
                }
                if (address != null) {
                    mWifiConfigManager.setNetworkDefaultGwMacAddress(mLastNetworkId, address);
                }
            }
        }
    }
    return address;
}
#end_block

#method_before
private void getAdditionalWifiServiceInterfaces() {
    // First set up Wifi Direct
    // TODO: b/34193861 determine if we can avoid starting WIFI_P2P_SERVICE when not supported
    IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE);
    WifiP2pServiceImpl wifiP2pServiceImpl = (WifiP2pServiceImpl) IWifiP2pManager.Stub.asInterface(s1);
    if (wifiP2pServiceImpl != null) {
        mWifiP2pChannel = new AsyncChannel();
        mWifiP2pChannel.connect(mContext, getHandler(), wifiP2pServiceImpl.getP2pStateMachineMessenger());
    }
    // Set up Wifi Aware
    if (mAwareSupported) {
        mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
    }
}
#method_after
private void getAdditionalWifiServiceInterfaces() {
    // First set up Wifi Direct
    if (mP2pSupported) {
        IBinder s1 = mFacade.getService(Context.WIFI_P2P_SERVICE);
        WifiP2pServiceImpl wifiP2pServiceImpl = (WifiP2pServiceImpl) IWifiP2pManager.Stub.asInterface(s1);
        if (wifiP2pServiceImpl != null) {
            mWifiP2pChannel = new AsyncChannel();
            mWifiP2pChannel.connect(mContext, getHandler(), wifiP2pServiceImpl.getP2pStateMachineMessenger());
        }
    }
    // Set up Wifi Aware
    if (mAwareSupported) {
        mWifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
    }
}
#end_block

#method_before
public void reportConnectionEvent(byte event) {
    switch(event) {
        case BaseWifiDiagnostics.CONNECTION_EVENT_STARTED:
            enableTracing();
            return;
        case BaseWifiDiagnostics.CONNECTION_EVENT_SUCCEEDED:
            disableTracing();
            return;
        case BaseWifiDiagnostics.CONNECTION_EVENT_FAILED:
            mLastMileLogForLastFailure = readTrace();
            disableTracing();
            break;
    }
}
#method_after
public void reportConnectionEvent(byte event) {
    switch(event) {
        case BaseWifiDiagnostics.CONNECTION_EVENT_STARTED:
            enableTracing();
            return;
        case BaseWifiDiagnostics.CONNECTION_EVENT_SUCCEEDED:
            disableTracing();
            return;
        case BaseWifiDiagnostics.CONNECTION_EVENT_FAILED:
            disableTracing();
            mLastMileLogForLastFailure = readTrace();
            break;
    }
}
#end_block

#method_before
private byte[] readTrace() {
    byte[] eventData = null;
    try {
        eventData = IoUtils.readFileAsByteArray(mEventBufferPath);
    } catch (IOException e) {
        mLog.warn("Failed to read event trace: %").r(e.getMessage()).flush();
    }
    // attempt.
    try {
        FileUtils.stringToFile(mEventBufferPath, "");
    } catch (IOException e) {
        mLog.warn("Failed to clear event trace: %").r(e.getMessage()).flush();
    }
    return eventData;
}
#method_after
private byte[] readTrace() {
    try {
        return IoUtils.readFileAsByteArray(mEventBufferPath);
    } catch (IOException e) {
        mLog.warn("Failed to read event trace: %").r(e.getMessage()).flush();
        return new byte[0];
    }
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    String errorMsg = null;
    boolean protoOut = (args.length > 0) && args[0].startsWith("--proto");
    if (!protoOut) {
        writer.println("Bluetooth Status");
        writer.println("  enabled: " + isEnabled());
        writer.println("  state: " + BluetoothAdapter.nameForState(mState));
        writer.println("  address: " + mAddress);
        writer.println("  name: " + mName);
        if (mEnable) {
            long onDuration = System.currentTimeMillis() - mActiveLogs.getLast().getTime();
            String onDurationString = String.format("%02d:%02d:%02d.%03d", (int) (onDuration / (1000 * 60 * 60)), (int) ((onDuration / (1000 * 60)) % 60), (int) ((onDuration / 1000) % 60), (int) (onDuration % 1000));
            writer.println("  time since enabled: " + onDurationString + "\n");
        }
        writer.println("Enable log:");
        for (ActiveLog log : mActiveLogs) {
            writer.println("  " + log);
        }
        writer.println("\n" + mBleApps.size() + " BLE Apps registered:");
        for (ClientDeathRecipient app : mBleApps.values()) {
            writer.println(" - " + app.getPackageName());
        }
        writer.println("");
        writer.flush();
        if (args.length == 0) {
            // Add arg to produce output
            args = new String[1];
            args[0] = "--print";
        }
    }
    if (mBluetoothBinder == null) {
        errorMsg = "Bluetooth Service not connected";
    } else {
        try {
            mBluetoothBinder.dump(fd, args);
        } catch (RemoteException re) {
            errorMsg = "RemoteException while dumping Bluetooth Service";
        }
    }
    if (errorMsg != null) {
        // Silently return if we are extracting metrics in Protobuf format
        if (protoOut)
            return;
        writer.println(errorMsg);
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    String errorMsg = null;
    boolean protoOut = (args.length > 0) && args[0].startsWith("--proto");
    if (!protoOut) {
        writer.println("Bluetooth Status");
        writer.println("  enabled: " + isEnabled());
        writer.println("  state: " + BluetoothAdapter.nameForState(mState));
        writer.println("  address: " + mAddress);
        writer.println("  name: " + mName);
        if (mEnable) {
            long onDuration = System.currentTimeMillis() - mActiveLogs.getLast().getTime();
            String onDurationString = String.format("%02d:%02d:%02d.%03d", (int) (onDuration / (1000 * 60 * 60)), (int) ((onDuration / (1000 * 60)) % 60), (int) ((onDuration / 1000) % 60), (int) (onDuration % 1000));
            writer.println("  time since enabled: " + onDurationString + "\n");
        }
        if (mActiveLogs.size() == 0) {
            writer.println("Bluetooth never enabled!");
        } else {
            writer.println("Enable log:");
            for (ActiveLog log : mActiveLogs) {
                writer.println("  " + log);
            }
        }
        String bleAppString = "No BLE Apps registered.";
        if (mBleApps.size() == 1) {
            bleAppString = "1 BLE App registered:";
        } else if (mBleApps.size() > 1) {
            bleAppString = mBleApps.size() + " BLE Apps registered:";
        }
        writer.println("\n" + bleAppString);
        for (ClientDeathRecipient app : mBleApps.values()) {
            writer.println("  " + app.getPackageName());
        }
        writer.println("");
        writer.flush();
        if (args.length == 0) {
            // Add arg to produce output
            args = new String[1];
            args[0] = "--print";
        }
    }
    if (mBluetoothBinder == null) {
        errorMsg = "Bluetooth Service not connected";
    } else {
        try {
            mBluetoothBinder.dump(fd, args);
        } catch (RemoteException re) {
            errorMsg = "RemoteException while dumping Bluetooth Service";
        }
    }
    if (errorMsg != null) {
        // Silently return if we are extracting metrics in Protobuf format
        if (protoOut)
            return;
        writer.println(errorMsg);
    }
}
#end_block

#method_before
private static void parseEAPMethod(PPSNode node, Credential.UserCredential userCred) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for EAPMethod");
    }
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_EAP_TYPE:
                userCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            case NODE_INNER_METHOD:
                userCred.nonEapInnerMethod = getPpsNodeValue(child);
                break;
            case NODE_VENDOR_ID:
            case NODE_VENDOR_TYPE:
            case NODE_INNER_EAP_TYPE:
            case NODE_INNER_VENDOR_ID:
            case NODE_INNER_VENDOR_TYPE:
                // Only EAP-TTLS is currently supported for user credential, which doesn't
                // use any of these parameters.
                Log.d(TAG, "Ignore uninterested EAP method parameter: " + child.getName());
                break;
            default:
                throw new ParsingException("Unknown node under EAPMethod: " + child.getName());
        }
    }
}
#method_after
private static void parseEAPMethod(PPSNode node, Credential.UserCredential userCred) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for EAPMethod");
    }
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_EAP_TYPE:
                userCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            case NODE_INNER_METHOD:
                userCred.nonEapInnerMethod = getPpsNodeValue(child);
                break;
            case NODE_VENDOR_ID:
            case NODE_VENDOR_TYPE:
            case NODE_INNER_EAP_TYPE:
            case NODE_INNER_VENDOR_ID:
            case NODE_INNER_VENDOR_TYPE:
                // Only EAP-TTLS is currently supported for user credential, which doesn't
                // use any of these parameters.
                Log.d(TAG, "Ignore unsupported EAP method parameter: " + child.getName());
                break;
            default:
                throw new ParsingException("Unknown node under EAPMethod: " + child.getName());
        }
    }
}
#end_block

#method_before
@Test
public void validateHomeSpWithoutHomeNetworkIds() throws Exception {
    HomeSP homeSp = new HomeSP();
    homeSp.fqdn = "fqdn";
    homeSp.friendlyName = "friendly name";
    homeSp.homeNetworkIds = new HashMap<>();
    byte[] rawSsidBytes = new byte[33];
    Arrays.fill(rawSsidBytes, (byte) 'a');
    homeSp.homeNetworkIds.put(StringFactory.newStringFromBytes(rawSsidBytes, StandardCharsets.UTF_8), 0x1234L);
    assertFalse(homeSp.validate());
}
#method_after
@Test
public void validateHomeSpWithoutHomeNetworkIds() throws Exception {
    HomeSP homeSp = createHomeSpWithoutHomeNetworkIds();
    assertTrue(homeSp.validate());
}
#end_block

#method_before
@Test
public void validateHomeSpWithInvalidHomeNetworkIds() throws Exception {
    HomeSP homeSp = createHomeSpWithoutHomeNetworkIds();
    assertTrue(homeSp.validate());
}
#method_after
@Test
public void validateHomeSpWithInvalidHomeNetworkIds() throws Exception {
    HomeSP homeSp = new HomeSP();
    homeSp.fqdn = "fqdn";
    homeSp.friendlyName = "friendly name";
    homeSp.homeNetworkIds = new HashMap<>();
    byte[] rawSsidBytes = new byte[33];
    Arrays.fill(rawSsidBytes, (byte) 'a');
    homeSp.homeNetworkIds.put(StringFactory.newStringFromBytes(rawSsidBytes, StandardCharsets.UTF_8), 0x1234L);
    assertFalse(homeSp.validate());
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(intervalMs);
    out.writeInt(min2gRssi);
    out.writeInt(min5gRssi);
    if (pnoNetworks == null) {
        out.writeInt(0);
    } else {
        out.writeInt(pnoNetworks.size());
        for (PnoNetwork network : pnoNetworks) {
            network.writeToParcel(out, flags);
        }
    }
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(intervalMs);
    out.writeInt(min2gRssi);
    out.writeInt(min5gRssi);
    out.writeTypedList(pnoNetworks);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(ssid.length);
    out.writeByteArray(ssid);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(isHidden ? 1 : 0);
    out.writeByteArray(ssid);
}
#end_block

#method_before
@Override
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> potentialConnectableNetworks) {
    if (!mNetworkRecommendationsEnabled) {
        return mExternalScoreEvaluator.evaluateNetworks(scanDetails, currentNetwork, currentBssid, connected, untrustedNetworkAllowed, potentialConnectableNetworks);
    }
    List<WifiConfiguration> availableConfiguredNetworks = new ArrayList<>();
    List<ScanResult> scanResults = new ArrayList<>();
    for (int i = 0; i < scanDetails.size(); i++) {
        ScanDetail scanDetail = scanDetails.get(i);
        ScanResult scanResult = scanDetail.getScanResult();
        if (scanResult == null)
            continue;
        if (mWifiConfigManager.wasEphemeralNetworkDeleted(ScanResultUtil.createQuotedSSID(scanResult.SSID))) {
            continue;
        }
        final WifiConfiguration configuredNetwork = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail);
        scanResult.untrusted = configuredNetwork == null || configuredNetwork.ephemeral;
        if (!untrustedNetworkAllowed && scanResult.untrusted) {
            continue;
        }
        if (configuredNetwork != null) {
            availableConfiguredNetworks.add(configuredNetwork);
        }
        scanResults.add(scanResult);
        // Track potential connectable networks for the watchdog.
        if (potentialConnectableNetworks != null) {
            potentialConnectableNetworks.add(Pair.create(scanDetail, configuredNetwork));
        }
    }
    if (scanResults.isEmpty()) {
        return null;
    }
    ScanResult[] scanResultArray = scanResults.toArray(new ScanResult[scanResults.size()]);
    WifiConfiguration[] availableConfigsArray = availableConfiguredNetworks.toArray(new WifiConfiguration[availableConfiguredNetworks.size()]);
    RecommendationRequest request = new RecommendationRequest.Builder().setScanResults(scanResultArray).setConnectedWifiConfig(currentNetwork).setConnectableConfigs(availableConfigsArray).build();
    RecommendationResult result = mNetworkScoreManager.requestRecommendation(request);
    if (result == null || result.getWifiConfiguration() == null) {
        return null;
    }
    WifiConfiguration wifiConfiguration = result.getWifiConfiguration();
    ScanResult scanResult = findMatchingScanResult(scanResultArray, wifiConfiguration);
    if (scanResult == null) {
        Slog.e(TAG, "Could not match WifiConfiguration to a ScanResult.");
        return null;
    }
    int networkId = wifiConfiguration.networkId;
    if (networkId == WifiConfiguration.INVALID_NETWORK_ID) {
        networkId = addEphemeralNetwork(wifiConfiguration, scanResult);
        if (networkId == WifiConfiguration.INVALID_NETWORK_ID) {
            return null;
        }
    }
    mWifiConfigManager.setNetworkCandidateScanResult(networkId, scanResult, 0);
    return mWifiConfigManager.getConfiguredNetwork(networkId);
}
#method_after
@Override
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    if (!mNetworkRecommendationsEnabled) {
        return mExternalScoreEvaluator.evaluateNetworks(scanDetails, currentNetwork, currentBssid, connected, untrustedNetworkAllowed, connectableNetworks);
    }
    List<WifiConfiguration> availableConfiguredNetworks = new ArrayList<>();
    List<ScanResult> scanResults = new ArrayList<>();
    for (int i = 0; i < scanDetails.size(); i++) {
        ScanDetail scanDetail = scanDetails.get(i);
        ScanResult scanResult = scanDetail.getScanResult();
        if (scanResult == null)
            continue;
        if (mWifiConfigManager.wasEphemeralNetworkDeleted(ScanResultUtil.createQuotedSSID(scanResult.SSID))) {
            continue;
        }
        final WifiConfiguration configuredNetwork = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail);
        scanResult.untrusted = configuredNetwork == null || configuredNetwork.ephemeral;
        if (!untrustedNetworkAllowed && scanResult.untrusted) {
            continue;
        }
        if (configuredNetwork != null) {
            availableConfiguredNetworks.add(configuredNetwork);
        }
        scanResults.add(scanResult);
        // Track potential connectable networks for the watchdog.
        if (connectableNetworks != null) {
            connectableNetworks.add(Pair.create(scanDetail, configuredNetwork));
        }
    }
    if (scanResults.isEmpty()) {
        return null;
    }
    ScanResult[] scanResultArray = scanResults.toArray(new ScanResult[scanResults.size()]);
    WifiConfiguration[] availableConfigsArray = availableConfiguredNetworks.toArray(new WifiConfiguration[availableConfiguredNetworks.size()]);
    int lastSelectedNetworkId = mWifiConfigManager.getLastSelectedNetwork();
    long lastSelectedNetworkTimestamp = mWifiConfigManager.getLastSelectedTimeStamp();
    RecommendationRequest request = new RecommendationRequest.Builder().setScanResults(scanResultArray).setConnectedWifiConfig(currentNetwork).setConnectableConfigs(availableConfigsArray).setLastSelectedNetwork(lastSelectedNetworkId, lastSelectedNetworkTimestamp).build();
    RecommendationResult result = mNetworkScoreManager.requestRecommendation(request);
    if (result == null || result.getWifiConfiguration() == null) {
        return null;
    }
    WifiConfiguration wifiConfiguration = result.getWifiConfiguration();
    ScanResult scanResult = findMatchingScanResult(scanResultArray, wifiConfiguration);
    if (scanResult == null) {
        Slog.e(TAG, "Could not match WifiConfiguration to a ScanResult.");
        return null;
    }
    int networkId = wifiConfiguration.networkId;
    if (networkId == WifiConfiguration.INVALID_NETWORK_ID) {
        networkId = addEphemeralNetwork(wifiConfiguration, scanResult);
        if (networkId == WifiConfiguration.INVALID_NETWORK_ID) {
            return null;
        }
    }
    mWifiConfigManager.setNetworkCandidateScanResult(networkId, scanResult, 0);
    return mWifiConfigManager.getConfiguredNetwork(networkId);
}
#end_block

#method_before
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestReportMessage_descriptor;
}
#method_after
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidDeviceInfoMessage_descriptor;
}
#end_block

#method_before
protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestReportMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.android.vts.proto.VtsReportMessage.TestReportMessage.class, com.android.vts.proto.VtsReportMessage.TestReportMessage.Builder.class);
}
#method_after
protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidDeviceInfoMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage.class, com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage.Builder.class);
}
#end_block

#method_before
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        getDeviceInfoFieldBuilder();
        getBuildInfoFieldBuilder();
        getHostInfoFieldBuilder();
        getTestCaseFieldBuilder();
        getProfilingFieldBuilder();
        getSystraceFieldBuilder();
        getCoverageFieldBuilder();
    }
}
#method_after
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}
#end_block

#method_before
public Builder clear() {
    super.clear();
    testSuite_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    test_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    testType_ = com.android.vts.proto.VtsReportMessage.VtsTestType.UNKNOWN_VTS_TESTTYPE;
    bitField0_ = (bitField0_ & ~0x00000004);
    if (deviceInfoBuilder_ == null) {
        deviceInfo_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
    } else {
        deviceInfoBuilder_.clear();
    }
    if (buildInfoBuilder_ == null) {
        buildInfo_ = com.android.vts.proto.VtsReportMessage.AndroidBuildInfo.getDefaultInstance();
    } else {
        buildInfoBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000010);
    subscriberEmail_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000020);
    if (hostInfoBuilder_ == null) {
        hostInfo_ = com.android.vts.proto.VtsReportMessage.VtsHostInfo.getDefaultInstance();
    } else {
        hostInfoBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000040);
    if (testCaseBuilder_ == null) {
        testCase_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
    } else {
        testCaseBuilder_.clear();
    }
    if (profilingBuilder_ == null) {
        profiling_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000100);
    } else {
        profilingBuilder_.clear();
    }
    if (systraceBuilder_ == null) {
        systrace_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
    } else {
        systraceBuilder_.clear();
    }
    startTimestamp_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000400);
    endTimestamp_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000800);
    if (coverageBuilder_ == null) {
        coverage_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00001000);
    } else {
        coverageBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clear() {
    super.clear();
    productType_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    productVariant_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    buildFlavor_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000004);
    buildId_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000008);
    branch_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000010);
    buildAlias_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000020);
    apiLevel_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000040);
    abiName_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000080);
    abiBitness_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000100);
    serial_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000200);
    return this;
}
#end_block

#method_before
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestReportMessage_descriptor;
}
#method_after
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidDeviceInfoMessage_descriptor;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestReportMessage getDefaultInstanceForType() {
    return com.android.vts.proto.VtsReportMessage.TestReportMessage.getDefaultInstance();
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage getDefaultInstanceForType() {
    return com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage.getDefaultInstance();
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestReportMessage build() {
    com.android.vts.proto.VtsReportMessage.TestReportMessage result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage build() {
    com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestReportMessage buildPartial() {
    com.android.vts.proto.VtsReportMessage.TestReportMessage result = new com.android.vts.proto.VtsReportMessage.TestReportMessage(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.testSuite_ = testSuite_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.test_ = test_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.testType_ = testType_;
    if (deviceInfoBuilder_ == null) {
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
            deviceInfo_ = java.util.Collections.unmodifiableList(deviceInfo_);
            bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.deviceInfo_ = deviceInfo_;
    } else {
        result.deviceInfo_ = deviceInfoBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000008;
    }
    if (buildInfoBuilder_ == null) {
        result.buildInfo_ = buildInfo_;
    } else {
        result.buildInfo_ = buildInfoBuilder_.build();
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        subscriberEmail_ = java.util.Collections.unmodifiableList(subscriberEmail_);
        bitField0_ = (bitField0_ & ~0x00000020);
    }
    result.subscriberEmail_ = subscriberEmail_;
    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
        to_bitField0_ |= 0x00000010;
    }
    if (hostInfoBuilder_ == null) {
        result.hostInfo_ = hostInfo_;
    } else {
        result.hostInfo_ = hostInfoBuilder_.build();
    }
    if (testCaseBuilder_ == null) {
        if (((bitField0_ & 0x00000080) == 0x00000080)) {
            testCase_ = java.util.Collections.unmodifiableList(testCase_);
            bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.testCase_ = testCase_;
    } else {
        result.testCase_ = testCaseBuilder_.build();
    }
    if (profilingBuilder_ == null) {
        if (((bitField0_ & 0x00000100) == 0x00000100)) {
            profiling_ = java.util.Collections.unmodifiableList(profiling_);
            bitField0_ = (bitField0_ & ~0x00000100);
        }
        result.profiling_ = profiling_;
    } else {
        result.profiling_ = profilingBuilder_.build();
    }
    if (systraceBuilder_ == null) {
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
            systrace_ = java.util.Collections.unmodifiableList(systrace_);
            bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.systrace_ = systrace_;
    } else {
        result.systrace_ = systraceBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
        to_bitField0_ |= 0x00000020;
    }
    result.startTimestamp_ = startTimestamp_;
    if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
        to_bitField0_ |= 0x00000040;
    }
    result.endTimestamp_ = endTimestamp_;
    if (coverageBuilder_ == null) {
        if (((bitField0_ & 0x00001000) == 0x00001000)) {
            coverage_ = java.util.Collections.unmodifiableList(coverage_);
            bitField0_ = (bitField0_ & ~0x00001000);
        }
        result.coverage_ = coverage_;
    } else {
        result.coverage_ = coverageBuilder_.build();
    }
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage buildPartial() {
    com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage result = new com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.productType_ = productType_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.productVariant_ = productVariant_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.buildFlavor_ = buildFlavor_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.buildId_ = buildId_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.branch_ = branch_;
    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
        to_bitField0_ |= 0x00000020;
    }
    result.buildAlias_ = buildAlias_;
    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
        to_bitField0_ |= 0x00000040;
    }
    result.apiLevel_ = apiLevel_;
    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
        to_bitField0_ |= 0x00000080;
    }
    result.abiName_ = abiName_;
    if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
        to_bitField0_ |= 0x00000100;
    }
    result.abiBitness_ = abiBitness_;
    if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
        to_bitField0_ |= 0x00000200;
    }
    result.serial_ = serial_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#end_block

#method_before
public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof com.android.vts.proto.VtsReportMessage.TestReportMessage) {
        return mergeFrom((com.android.vts.proto.VtsReportMessage.TestReportMessage) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}
#method_after
public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage) {
        return mergeFrom((com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}
#end_block

#method_before
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    com.android.vts.proto.VtsReportMessage.TestReportMessage parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.android.vts.proto.VtsReportMessage.TestReportMessage) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}
#method_after
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}
#end_block

#method_before
public boolean hasBranch() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}
#method_after
public boolean hasBranch() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}
#end_block

#method_before
public Builder setBranch(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000008;
    branch_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setBranch(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000010;
    branch_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearBranch() {
    bitField0_ = (bitField0_ & ~0x00000008);
    branch_ = getDefaultInstance().getBranch();
    onChanged();
    return this;
}
#method_after
public Builder clearBranch() {
    bitField0_ = (bitField0_ & ~0x00000010);
    branch_ = getDefaultInstance().getBranch();
    onChanged();
    return this;
}
#end_block

#method_before
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestReportMessage_descriptor;
}
#method_after
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidBuildInfo_descriptor;
}
#end_block

#method_before
protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestReportMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.android.vts.proto.VtsReportMessage.TestReportMessage.class, com.android.vts.proto.VtsReportMessage.TestReportMessage.Builder.class);
}
#method_after
protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidBuildInfo_fieldAccessorTable.ensureFieldAccessorsInitialized(com.android.vts.proto.VtsReportMessage.AndroidBuildInfo.class, com.android.vts.proto.VtsReportMessage.AndroidBuildInfo.Builder.class);
}
#end_block

#method_before
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        getDeviceInfoFieldBuilder();
        getBuildInfoFieldBuilder();
        getHostInfoFieldBuilder();
        getTestCaseFieldBuilder();
        getProfilingFieldBuilder();
        getSystraceFieldBuilder();
        getCoverageFieldBuilder();
    }
}
#method_after
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}
#end_block

#method_before
public Builder clear() {
    super.clear();
    testSuite_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    test_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    testType_ = com.android.vts.proto.VtsReportMessage.VtsTestType.UNKNOWN_VTS_TESTTYPE;
    bitField0_ = (bitField0_ & ~0x00000004);
    if (deviceInfoBuilder_ == null) {
        deviceInfo_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
    } else {
        deviceInfoBuilder_.clear();
    }
    if (buildInfoBuilder_ == null) {
        buildInfo_ = com.android.vts.proto.VtsReportMessage.AndroidBuildInfo.getDefaultInstance();
    } else {
        buildInfoBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000010);
    subscriberEmail_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000020);
    if (hostInfoBuilder_ == null) {
        hostInfo_ = com.android.vts.proto.VtsReportMessage.VtsHostInfo.getDefaultInstance();
    } else {
        hostInfoBuilder_.clear();
    }
    bitField0_ = (bitField0_ & ~0x00000040);
    if (testCaseBuilder_ == null) {
        testCase_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
    } else {
        testCaseBuilder_.clear();
    }
    if (profilingBuilder_ == null) {
        profiling_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000100);
    } else {
        profilingBuilder_.clear();
    }
    if (systraceBuilder_ == null) {
        systrace_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
    } else {
        systraceBuilder_.clear();
    }
    startTimestamp_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000400);
    endTimestamp_ = 0L;
    bitField0_ = (bitField0_ & ~0x00000800);
    if (coverageBuilder_ == null) {
        coverage_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00001000);
    } else {
        coverageBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clear() {
    super.clear();
    id_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    name_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    buildType_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000004);
    branch_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000008);
    buildSummary_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000010);
    return this;
}
#end_block

#method_before
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestReportMessage_descriptor;
}
#method_after
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidBuildInfo_descriptor;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestReportMessage getDefaultInstanceForType() {
    return com.android.vts.proto.VtsReportMessage.TestReportMessage.getDefaultInstance();
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidBuildInfo getDefaultInstanceForType() {
    return com.android.vts.proto.VtsReportMessage.AndroidBuildInfo.getDefaultInstance();
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestReportMessage build() {
    com.android.vts.proto.VtsReportMessage.TestReportMessage result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidBuildInfo build() {
    com.android.vts.proto.VtsReportMessage.AndroidBuildInfo result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestReportMessage buildPartial() {
    com.android.vts.proto.VtsReportMessage.TestReportMessage result = new com.android.vts.proto.VtsReportMessage.TestReportMessage(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.testSuite_ = testSuite_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.test_ = test_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.testType_ = testType_;
    if (deviceInfoBuilder_ == null) {
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
            deviceInfo_ = java.util.Collections.unmodifiableList(deviceInfo_);
            bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.deviceInfo_ = deviceInfo_;
    } else {
        result.deviceInfo_ = deviceInfoBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000008;
    }
    if (buildInfoBuilder_ == null) {
        result.buildInfo_ = buildInfo_;
    } else {
        result.buildInfo_ = buildInfoBuilder_.build();
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        subscriberEmail_ = java.util.Collections.unmodifiableList(subscriberEmail_);
        bitField0_ = (bitField0_ & ~0x00000020);
    }
    result.subscriberEmail_ = subscriberEmail_;
    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
        to_bitField0_ |= 0x00000010;
    }
    if (hostInfoBuilder_ == null) {
        result.hostInfo_ = hostInfo_;
    } else {
        result.hostInfo_ = hostInfoBuilder_.build();
    }
    if (testCaseBuilder_ == null) {
        if (((bitField0_ & 0x00000080) == 0x00000080)) {
            testCase_ = java.util.Collections.unmodifiableList(testCase_);
            bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.testCase_ = testCase_;
    } else {
        result.testCase_ = testCaseBuilder_.build();
    }
    if (profilingBuilder_ == null) {
        if (((bitField0_ & 0x00000100) == 0x00000100)) {
            profiling_ = java.util.Collections.unmodifiableList(profiling_);
            bitField0_ = (bitField0_ & ~0x00000100);
        }
        result.profiling_ = profiling_;
    } else {
        result.profiling_ = profilingBuilder_.build();
    }
    if (systraceBuilder_ == null) {
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
            systrace_ = java.util.Collections.unmodifiableList(systrace_);
            bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.systrace_ = systrace_;
    } else {
        result.systrace_ = systraceBuilder_.build();
    }
    if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
        to_bitField0_ |= 0x00000020;
    }
    result.startTimestamp_ = startTimestamp_;
    if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
        to_bitField0_ |= 0x00000040;
    }
    result.endTimestamp_ = endTimestamp_;
    if (coverageBuilder_ == null) {
        if (((bitField0_ & 0x00001000) == 0x00001000)) {
            coverage_ = java.util.Collections.unmodifiableList(coverage_);
            bitField0_ = (bitField0_ & ~0x00001000);
        }
        result.coverage_ = coverage_;
    } else {
        result.coverage_ = coverageBuilder_.build();
    }
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidBuildInfo buildPartial() {
    com.android.vts.proto.VtsReportMessage.AndroidBuildInfo result = new com.android.vts.proto.VtsReportMessage.AndroidBuildInfo(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.id_ = id_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.name_ = name_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.buildType_ = buildType_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.branch_ = branch_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.buildSummary_ = buildSummary_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#end_block

#method_before
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    com.android.vts.proto.VtsReportMessage.TestReportMessage parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.android.vts.proto.VtsReportMessage.TestReportMessage) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}
#method_after
public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof com.android.vts.proto.VtsReportMessage.AndroidBuildInfo) {
        return mergeFrom((com.android.vts.proto.VtsReportMessage.AndroidBuildInfo) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}
#end_block

#method_before
public boolean hasName() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}
#method_after
public boolean hasName() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}
#end_block

#method_before
public Builder setName(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    name_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setName(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    name_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearName() {
    bitField0_ = (bitField0_ & ~0x00000001);
    name_ = getDefaultInstance().getName();
    onChanged();
    return this;
}
#method_after
public Builder clearName() {
    bitField0_ = (bitField0_ & ~0x00000002);
    name_ = getDefaultInstance().getName();
    onChanged();
    return this;
}
#end_block

#method_before
public boolean hasStartTimestamp() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
}
#method_after
public boolean hasStartTimestamp() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}
#end_block

#method_before
public Builder setStartTimestamp(long value) {
    bitField0_ |= 0x00000400;
    startTimestamp_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setStartTimestamp(long value) {
    bitField0_ |= 0x00000004;
    startTimestamp_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearStartTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000400);
    startTimestamp_ = 0L;
    onChanged();
    return this;
}
#method_after
public Builder clearStartTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000004);
    startTimestamp_ = 0L;
    onChanged();
    return this;
}
#end_block

#method_before
public boolean hasEndTimestamp() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
}
#method_after
public boolean hasEndTimestamp() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}
#end_block

#method_before
public Builder setEndTimestamp(long value) {
    bitField0_ |= 0x00000800;
    endTimestamp_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setEndTimestamp(long value) {
    bitField0_ |= 0x00000008;
    endTimestamp_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearEndTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000800);
    endTimestamp_ = 0L;
    onChanged();
    return this;
}
#method_after
public Builder clearEndTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000008);
    endTimestamp_ = 0L;
    onChanged();
    return this;
}
#end_block

#method_before
private void ensureCoverageIsMutable() {
    if (!((bitField0_ & 0x00001000) == 0x00001000)) {
        coverage_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.CoverageReportMessage>(coverage_);
        bitField0_ |= 0x00001000;
    }
}
#method_after
private void ensureCoverageIsMutable() {
    if (!((bitField0_ & 0x00000010) == 0x00000010)) {
        coverage_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.CoverageReportMessage>(coverage_);
        bitField0_ |= 0x00000010;
    }
}
#end_block

#method_before
public Builder clearCoverage() {
    if (coverageBuilder_ == null) {
        coverage_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
    } else {
        coverageBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clearCoverage() {
    if (coverageBuilder_ == null) {
        coverage_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
    } else {
        coverageBuilder_.clear();
    }
    return this;
}
#end_block

#method_before
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.CoverageReportMessage, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder, com.android.vts.proto.VtsReportMessage.CoverageReportMessageOrBuilder> getCoverageFieldBuilder() {
    if (coverageBuilder_ == null) {
        coverageBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.CoverageReportMessage, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder, com.android.vts.proto.VtsReportMessage.CoverageReportMessageOrBuilder>(coverage_, ((bitField0_ & 0x00001000) == 0x00001000), getParentForChildren(), isClean());
        coverage_ = null;
    }
    return coverageBuilder_;
}
#method_after
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.CoverageReportMessage, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder, com.android.vts.proto.VtsReportMessage.CoverageReportMessageOrBuilder> getCoverageFieldBuilder() {
    if (coverageBuilder_ == null) {
        coverageBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.CoverageReportMessage, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder, com.android.vts.proto.VtsReportMessage.CoverageReportMessageOrBuilder>(coverage_, ((bitField0_ & 0x00000010) == 0x00000010), getParentForChildren(), isClean());
        coverage_ = null;
    }
    return coverageBuilder_;
}
#end_block

#method_before
private void ensureProfilingIsMutable() {
    if (!((bitField0_ & 0x00000100) == 0x00000100)) {
        profiling_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage>(profiling_);
        bitField0_ |= 0x00000100;
    }
}
#method_after
private void ensureProfilingIsMutable() {
    if (!((bitField0_ & 0x00000020) == 0x00000020)) {
        profiling_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage>(profiling_);
        bitField0_ |= 0x00000020;
    }
}
#end_block

#method_before
public Builder clearProfiling() {
    if (profilingBuilder_ == null) {
        profiling_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
    } else {
        profilingBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clearProfiling() {
    if (profilingBuilder_ == null) {
        profiling_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
    } else {
        profilingBuilder_.clear();
    }
    return this;
}
#end_block

#method_before
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder, com.android.vts.proto.VtsReportMessage.ProfilingReportMessageOrBuilder> getProfilingFieldBuilder() {
    if (profilingBuilder_ == null) {
        profilingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder, com.android.vts.proto.VtsReportMessage.ProfilingReportMessageOrBuilder>(profiling_, ((bitField0_ & 0x00000100) == 0x00000100), getParentForChildren(), isClean());
        profiling_ = null;
    }
    return profilingBuilder_;
}
#method_after
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder, com.android.vts.proto.VtsReportMessage.ProfilingReportMessageOrBuilder> getProfilingFieldBuilder() {
    if (profilingBuilder_ == null) {
        profilingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder, com.android.vts.proto.VtsReportMessage.ProfilingReportMessageOrBuilder>(profiling_, ((bitField0_ & 0x00000020) == 0x00000020), getParentForChildren(), isClean());
        profiling_ = null;
    }
    return profilingBuilder_;
}
#end_block

#method_before
private void ensureSystraceIsMutable() {
    if (!((bitField0_ & 0x00000200) == 0x00000200)) {
        systrace_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.SystraceReportMessage>(systrace_);
        bitField0_ |= 0x00000200;
    }
}
#method_after
private void ensureSystraceIsMutable() {
    if (!((bitField0_ & 0x00000040) == 0x00000040)) {
        systrace_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.SystraceReportMessage>(systrace_);
        bitField0_ |= 0x00000040;
    }
}
#end_block

#method_before
public Builder clearSystrace() {
    if (systraceBuilder_ == null) {
        systrace_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
    } else {
        systraceBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clearSystrace() {
    if (systraceBuilder_ == null) {
        systrace_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
    } else {
        systraceBuilder_.clear();
    }
    return this;
}
#end_block

#method_before
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.SystraceReportMessage, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder, com.android.vts.proto.VtsReportMessage.SystraceReportMessageOrBuilder> getSystraceFieldBuilder() {
    if (systraceBuilder_ == null) {
        systraceBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.SystraceReportMessage, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder, com.android.vts.proto.VtsReportMessage.SystraceReportMessageOrBuilder>(systrace_, ((bitField0_ & 0x00000200) == 0x00000200), getParentForChildren(), isClean());
        systrace_ = null;
    }
    return systraceBuilder_;
}
#method_after
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.SystraceReportMessage, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder, com.android.vts.proto.VtsReportMessage.SystraceReportMessageOrBuilder> getSystraceFieldBuilder() {
    if (systraceBuilder_ == null) {
        systraceBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.SystraceReportMessage, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder, com.android.vts.proto.VtsReportMessage.SystraceReportMessageOrBuilder>(systrace_, ((bitField0_ & 0x00000040) == 0x00000040), getParentForChildren(), isClean());
        systrace_ = null;
    }
    return systraceBuilder_;
}
#end_block

#method_before
public boolean hasStartTimestamp() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
}
#method_after
public boolean hasStartTimestamp() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}
#end_block

#method_before
public Builder setStartTimestamp(long value) {
    bitField0_ |= 0x00000400;
    startTimestamp_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setStartTimestamp(long value) {
    bitField0_ |= 0x00000008;
    startTimestamp_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearStartTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000400);
    startTimestamp_ = 0L;
    onChanged();
    return this;
}
#method_after
public Builder clearStartTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000008);
    startTimestamp_ = 0L;
    onChanged();
    return this;
}
#end_block

#method_before
public boolean hasEndTimestamp() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
}
#method_after
public boolean hasEndTimestamp() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}
#end_block

#method_before
public Builder setEndTimestamp(long value) {
    bitField0_ |= 0x00000800;
    endTimestamp_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setEndTimestamp(long value) {
    bitField0_ |= 0x00000010;
    endTimestamp_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearEndTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000800);
    endTimestamp_ = 0L;
    onChanged();
    return this;
}
#method_after
public Builder clearEndTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000010);
    endTimestamp_ = 0L;
    onChanged();
    return this;
}
#end_block

#method_before
private void initFields() {
    processName_ = com.google.protobuf.ByteString.EMPTY;
    html_ = java.util.Collections.emptyList();
    urls_ = java.util.Collections.emptyList();
}
#method_after
private void initFields() {
    processName_ = com.google.protobuf.ByteString.EMPTY;
    html_ = java.util.Collections.emptyList();
    url_ = java.util.Collections.emptyList();
}
#end_block

#method_before
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, processName_);
    }
    for (int i = 0; i < html_.size(); i++) {
        output.writeBytes(11, html_.get(i));
    }
    for (int i = 0; i < urls_.size(); i++) {
        output.writeBytes(21, urls_.get(i));
    }
    getUnknownFields().writeTo(output);
}
#method_after
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, processName_);
    }
    for (int i = 0; i < html_.size(); i++) {
        output.writeBytes(11, html_.get(i));
    }
    for (int i = 0; i < url_.size(); i++) {
        output.writeBytes(21, url_.get(i));
    }
    getUnknownFields().writeTo(output);
}
#end_block

#method_before
public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, processName_);
    }
    {
        int dataSize = 0;
        for (int i = 0; i < html_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(html_.get(i));
        }
        size += dataSize;
        size += 1 * getHtmlList().size();
    }
    {
        int dataSize = 0;
        for (int i = 0; i < urls_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(urls_.get(i));
        }
        size += dataSize;
        size += 2 * getUrlsList().size();
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}
#method_after
public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, processName_);
    }
    {
        int dataSize = 0;
        for (int i = 0; i < html_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(html_.get(i));
        }
        size += dataSize;
        size += 1 * getHtmlList().size();
    }
    {
        int dataSize = 0;
        for (int i = 0; i < url_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(url_.get(i));
        }
        size += dataSize;
        size += 2 * getUrlList().size();
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}
#end_block

#method_before
public Builder mergeFrom(com.android.vts.proto.VtsReportMessage.SystraceReportMessage other) {
    if (other == com.android.vts.proto.VtsReportMessage.SystraceReportMessage.getDefaultInstance())
        return this;
    if (other.hasProcessName()) {
        setProcessName(other.getProcessName());
    }
    if (!other.html_.isEmpty()) {
        if (html_.isEmpty()) {
            html_ = other.html_;
            bitField0_ = (bitField0_ & ~0x00000002);
        } else {
            ensureHtmlIsMutable();
            html_.addAll(other.html_);
        }
        onChanged();
    }
    if (!other.urls_.isEmpty()) {
        if (urls_.isEmpty()) {
            urls_ = other.urls_;
            bitField0_ = (bitField0_ & ~0x00000004);
        } else {
            ensureUrlsIsMutable();
            urls_.addAll(other.urls_);
        }
        onChanged();
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}
#method_after
public Builder mergeFrom(com.android.vts.proto.VtsReportMessage.SystraceReportMessage other) {
    if (other == com.android.vts.proto.VtsReportMessage.SystraceReportMessage.getDefaultInstance())
        return this;
    if (other.hasProcessName()) {
        setProcessName(other.getProcessName());
    }
    if (!other.html_.isEmpty()) {
        if (html_.isEmpty()) {
            html_ = other.html_;
            bitField0_ = (bitField0_ & ~0x00000002);
        } else {
            ensureHtmlIsMutable();
            html_.addAll(other.html_);
        }
        onChanged();
    }
    if (!other.url_.isEmpty()) {
        if (url_.isEmpty()) {
            url_ = other.url_;
            bitField0_ = (bitField0_ & ~0x00000004);
        } else {
            ensureUrlIsMutable();
            url_.addAll(other.url_);
        }
        onChanged();
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}
#end_block

#method_before
@java.lang.Deprecated
public Builder clearHtml() {
    bitField0_ = (bitField0_ & ~0x00000100);
    html_ = getDefaultInstance().getHtml();
    onChanged();
    return this;
}
#method_after
public Builder clearHtml() {
    html_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000002);
    onChanged();
    return this;
}
#end_block

#method_before
public Builder setProfiling(int index, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder builderForValue) {
    if (profilingBuilder_ == null) {
        ensureProfilingIsMutable();
        profiling_.set(index, builderForValue.build());
        onChanged();
    } else {
        profilingBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder setProfiling(int index, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage value) {
    if (profilingBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureProfilingIsMutable();
        profiling_.set(index, value);
        onChanged();
    } else {
        profilingBuilder_.setMessage(index, value);
    }
    return this;
}
#end_block

#method_before
public Builder addProfiling(int index, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder builderForValue) {
    if (profilingBuilder_ == null) {
        ensureProfilingIsMutable();
        profiling_.add(index, builderForValue.build());
        onChanged();
    } else {
        profilingBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder addProfiling(com.android.vts.proto.VtsReportMessage.ProfilingReportMessage value) {
    if (profilingBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureProfilingIsMutable();
        profiling_.add(value);
        onChanged();
    } else {
        profilingBuilder_.addMessage(value);
    }
    return this;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder addProfilingBuilder(int index) {
    return getProfilingFieldBuilder().addBuilder(index, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.getDefaultInstance());
}
#method_after
public com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder addProfilingBuilder() {
    return getProfilingFieldBuilder().addBuilder(com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.getDefaultInstance());
}
#end_block

#method_before
public Builder setSystrace(int index, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder builderForValue) {
    if (systraceBuilder_ == null) {
        ensureSystraceIsMutable();
        systrace_.set(index, builderForValue.build());
        onChanged();
    } else {
        systraceBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder setSystrace(int index, com.android.vts.proto.VtsReportMessage.SystraceReportMessage value) {
    if (systraceBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureSystraceIsMutable();
        systrace_.set(index, value);
        onChanged();
    } else {
        systraceBuilder_.setMessage(index, value);
    }
    return this;
}
#end_block

#method_before
public Builder addSystrace(int index, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder builderForValue) {
    if (systraceBuilder_ == null) {
        ensureSystraceIsMutable();
        systrace_.add(index, builderForValue.build());
        onChanged();
    } else {
        systraceBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder addSystrace(com.android.vts.proto.VtsReportMessage.SystraceReportMessage value) {
    if (systraceBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureSystraceIsMutable();
        systrace_.add(value);
        onChanged();
    } else {
        systraceBuilder_.addMessage(value);
    }
    return this;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder addSystraceBuilder(int index) {
    return getSystraceFieldBuilder().addBuilder(index, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.getDefaultInstance());
}
#method_after
public com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder addSystraceBuilder() {
    return getSystraceFieldBuilder().addBuilder(com.android.vts.proto.VtsReportMessage.SystraceReportMessage.getDefaultInstance());
}
#end_block

#method_before
public Builder setCoverage(int index, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder builderForValue) {
    if (coverageBuilder_ == null) {
        ensureCoverageIsMutable();
        coverage_.set(index, builderForValue.build());
        onChanged();
    } else {
        coverageBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder setCoverage(int index, com.android.vts.proto.VtsReportMessage.CoverageReportMessage value) {
    if (coverageBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureCoverageIsMutable();
        coverage_.set(index, value);
        onChanged();
    } else {
        coverageBuilder_.setMessage(index, value);
    }
    return this;
}
#end_block

#method_before
public Builder addCoverage(int index, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder builderForValue) {
    if (coverageBuilder_ == null) {
        ensureCoverageIsMutable();
        coverage_.add(index, builderForValue.build());
        onChanged();
    } else {
        coverageBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder addCoverage(com.android.vts.proto.VtsReportMessage.CoverageReportMessage value) {
    if (coverageBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureCoverageIsMutable();
        coverage_.add(value);
        onChanged();
    } else {
        coverageBuilder_.addMessage(value);
    }
    return this;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder addCoverageBuilder(int index) {
    return getCoverageFieldBuilder().addBuilder(index, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.getDefaultInstance());
}
#method_after
public com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder addCoverageBuilder() {
    return getCoverageFieldBuilder().addBuilder(com.android.vts.proto.VtsReportMessage.CoverageReportMessage.getDefaultInstance());
}
#end_block

#method_before
private String updateDefaultRouteMacAddress(int timeout) {
    String address = null;
    for (RouteInfo route : mLinkProperties.getRoutes()) {
        if (route.isDefaultRoute() && route.hasGateway()) {
            InetAddress gateway = route.getGateway();
            if (gateway instanceof Inet4Address) {
                if (mVerboseLoggingEnabled) {
                    logd("updateDefaultRouteMacAddress found Ipv4 default :" + gateway.getHostAddress());
                }
                address = macAddressFromRoute(gateway.getHostAddress());
                /* The gateway's MAC address is known */
                if ((address == null) && (timeout > 0)) {
                    boolean reachable = false;
                    try {
                        reachable = gateway.isReachable(timeout);
                    } catch (Exception e) {
                        loge("updateDefaultRouteMacAddress exception reaching :" + gateway.getHostAddress());
                    } finally {
                        if (reachable == true) {
                            address = macAddressFromRoute(gateway.getHostAddress());
                            if (mVerboseLoggingEnabled) {
                                logd("updateDefaultRouteMacAddress reachable (tried again) :" + gateway.getHostAddress() + " found " + address);
                            }
                        }
                    }
                }
                if (address != null) {
                    mWifiConfigManager.setNetworkDefaultGwMacAddress(mLastNetworkId, address);
                }
            }
        }
    }
    return address;
}
#method_after
private String updateDefaultRouteMacAddress(int timeout) {
    String address = null;
    for (RouteInfo route : mLinkProperties.getRoutes()) {
        if (route.isDefaultRoute() && route.hasGateway()) {
            InetAddress gateway = route.getGateway();
            if (gateway instanceof Inet4Address) {
                if (mVerboseLoggingEnabled) {
                    logd("updateDefaultRouteMacAddress found Ipv4 default :" + gateway.getHostAddress());
                }
                address = macAddressFromRoute(gateway.getHostAddress());
                /* The gateway's MAC address is known */
                if ((address == null) && (timeout > 0)) {
                    boolean reachable = false;
                    TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE);
                    try {
                        reachable = gateway.isReachable(timeout);
                    } catch (Exception e) {
                        loge("updateDefaultRouteMacAddress exception reaching :" + gateway.getHostAddress());
                    } finally {
                        TrafficStats.clearThreadStatsTag();
                        if (reachable == true) {
                            address = macAddressFromRoute(gateway.getHostAddress());
                            if (mVerboseLoggingEnabled) {
                                logd("updateDefaultRouteMacAddress reachable (tried again) :" + gateway.getHostAddress() + " found " + address);
                            }
                        }
                    }
                }
                if (address != null) {
                    mWifiConfigManager.setNetworkDefaultGwMacAddress(mLastNetworkId, address);
                }
            }
        }
    }
    return address;
}
#end_block

#method_before
void enableVerboseLogging(int verbose) {
    if (verbose > 0) {
        mVerboseLoggingEnabled = true;
        setLogRecSize(ActivityManager.isLowRamDeviceStatic() ? NUM_LOG_RECS_VERBOSE_LOW_MEMORY : NUM_LOG_RECS_VERBOSE);
    } else {
        mVerboseLoggingEnabled = false;
        setLogRecSize(NUM_LOG_RECS_NORMAL);
    }
    configureVerboseHalLogging(mVerboseLoggingEnabled);
    setSupplicantLogLevel();
    mCountryCode.enableVerboseLogging(verbose);
    mWifiScoreReport.enableVerboseLogging(mVerboseLoggingEnabled);
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mWifiMonitor.enableVerboseLogging(verbose);
    mWifiNative.enableVerboseLogging(verbose);
    mWifiConfigManager.enableVerboseLogging(verbose);
    mSupplicantStateTracker.enableVerboseLogging(verbose);
}
#method_after
public void enableVerboseLogging(int verbose) {
    if (verbose > 0) {
        mVerboseLoggingEnabled = true;
        setLogRecSize(ActivityManager.isLowRamDeviceStatic() ? NUM_LOG_RECS_VERBOSE_LOW_MEMORY : NUM_LOG_RECS_VERBOSE);
    } else {
        mVerboseLoggingEnabled = false;
        setLogRecSize(NUM_LOG_RECS_NORMAL);
    }
    configureVerboseHalLogging(mVerboseLoggingEnabled);
    setSupplicantLogLevel();
    mCountryCode.enableVerboseLogging(verbose);
    mWifiScoreReport.enableVerboseLogging(mVerboseLoggingEnabled);
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mWifiMonitor.enableVerboseLogging(verbose);
    mWifiNative.enableVerboseLogging(verbose);
    mWifiConfigManager.enableVerboseLogging(verbose);
    mSupplicantStateTracker.enableVerboseLogging(verbose);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (args.length > 1 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0]) && WifiMetrics.CLEAN_DUMP_ARG.equals(args[1])) {
        // Dump only wifi metrics serialized proto bytes (base64)
        updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
        return;
    }
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("Supplicant status " + mWifiNative.status(true));
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (args.length > 1 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0]) && WifiMetrics.CLEAN_DUMP_ARG.equals(args[1])) {
        // Dump only wifi metrics serialized proto bytes (base64)
        updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
        return;
    }
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("Supplicant status " + mWifiNative.status(true));
    pw.println("mSystemSupportsFastBssTransition " + mWifiSupplicantControl.getSystemSupportsFastBssTransition());
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#end_block

#method_before
private static IClientInterface setupDriverForClientMode(IWificond wificond) {
    if (wificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IClientInterface clientInterface = null;
    try {
        clientInterface = wificond.createClientInterface();
    } catch (RemoteException e1) {
    }
    if (clientInterface == null) {
        Log.e(TAG, "Could not get IClientInterface instance from wificond");
        return null;
    }
    return clientInterface;
}
#method_after
private static IClientInterface setupDriverForClientMode(IWificond wificond) {
    if (wificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IClientInterface clientInterface = null;
    try {
        clientInterface = wificond.createClientInterface();
    } catch (RemoteException e1) {
    }
    if (clientInterface == null) {
        Log.e(TAG, "Could not get IClientInterface instance from wificond");
        return null;
    } else {
        Binder.allowBlocking(clientInterface.asBinder());
    }
    return clientInterface;
}
#end_block

#method_before
private IApInterface setupDriverForSoftAp() {
    if (mWificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IApInterface apInterface = null;
    try {
        apInterface = mWificond.createApInterface();
    } catch (RemoteException e1) {
    }
    if (apInterface == null) {
        Log.e(TAG, "Could not get IApInterface instance from wificond");
        return null;
    }
    if (!mWifiNative.startHal()) {
        // starting HAL is optional
        Log.e(TAG, "Failed to start HAL for AP mode");
    }
    return apInterface;
}
#method_after
private IApInterface setupDriverForSoftAp() {
    if (mWificond == null) {
        Log.e(TAG, "Failed to get reference to wificond");
        return null;
    }
    IApInterface apInterface = null;
    try {
        apInterface = mWificond.createApInterface();
    } catch (RemoteException e1) {
    }
    if (apInterface == null) {
        Log.e(TAG, "Could not get IApInterface instance from wificond");
        return null;
    } else {
        Binder.allowBlocking(apInterface.asBinder());
    }
    if (!mWifiNative.startHal()) {
        // starting HAL is optional
        Log.e(TAG, "Failed to start HAL for AP mode");
    }
    return apInterface;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                    } else {
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_BOOT_COMPLETED:
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            mWifiConfigManager.handleUserSwitch(message.arg1);
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                    } else {
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_BOOT_COMPLETED:
            // get other services that we need to manage
            getAdditionalWifiServiceInterfaces();
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            Set<Integer> removedNetworkIds = mWifiConfigManager.handleUserSwitch(message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    cleanup();
    if (mWifiP2pChannel == null && mWifiP2pServiceImpl != null) {
        mWifiP2pChannel = new AsyncChannel();
        mWifiP2pChannel.connect(mContext, getHandler(), mWifiP2pServiceImpl.getP2pStateMachineMessenger());
    }
    if (mWifiApConfigStore == null) {
        mWifiApConfigStore = mWifiInjector.getWifiApConfigStore();
    }
}
#method_after
@Override
public void enter() {
    cleanup();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            setWifiState(WIFI_STATE_ENABLED);
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            mWifiConfigManager.loadFromStore();
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                try {
                    mClientInterface.disableSupplicant();
                } catch (RemoteException e) {
                // The client interface is dead, there is nothing more we can do.
                }
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            mWifiConfigManager.loadFromStore();
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                try {
                    mClientInterface.disableSupplicant();
                } catch (RemoteException e) {
                // The client interface is dead, there is nothing more we can do.
                }
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    /* Wifi is available as long as we have a connection to supplicant */
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = new WifiConnectivityManager(mContext, WifiStateMachine.this, mWifiScanner, mWifiConfigManager, mWifiInfo, mWifiNetworkSelector, mWifiInjector, getHandler().getLooper(), hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    /* initialize network state */
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mAwareSupported && mWifiAwareManager != null) {
        if (mOperationalMode == CONNECT_MODE) {
            mWifiAwareManager.enableUsage();
        } else {
        /*
                     * Aware state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = mWifiInjector.makeWifiConnectivityManager(mWifiInfo, hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mAwareSupported && mWifiAwareManager != null) {
        if (mOperationalMode == CONNECT_MODE) {
            mWifiAwareManager.enableUsage();
        } else {
        /*
                     * Aware state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
void registerDisconnected() {
    if (mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
        mWifiConfigManager.updateNetworkAfterDisconnect(mLastNetworkId);
        // We are switching away from this configuration,
        // hence record the time we were connected last
        WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
        if (config != null) {
            if (config.ephemeral) {
                // Remove ephemeral WifiConfigurations from file
                mWifiConfigManager.removeNetwork(mLastNetworkId, Process.WIFI_UID);
            }
        }
    }
}
#method_after
void registerDisconnected() {
    if (mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
        mWifiConfigManager.updateNetworkAfterDisconnect(mLastNetworkId);
        // We are switching away from this configuration,
        // hence record the time we were connected last
        WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
        if (config != null) {
            // temporary networks.
            if (config.ephemeral || config.isPasspoint()) {
                mWifiConfigManager.removeNetwork(mLastNetworkId, Process.WIFI_UID);
            }
        }
    }
}
#end_block

#method_before
@Override
public void enter() {
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
}
#method_after
@Override
public void enter() {
    // Let the system know that wifi is available in client mode.
    setWifiState(WIFI_STATE_ENABLED);
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // initialize network state
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
}
#end_block

#method_before
@Override
public void exit() {
    // Inform WifiConnectivityManager that Wifi is disabled
    mWifiConnectivityManager.setWifiEnabled(false);
    // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
}
#method_after
@Override
public void exit() {
    // Let the system know that wifi is not available since we are exiting client mode.
    mNetworkInfo.setIsAvailable(false);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    // Inform WifiConnectivityManager that Wifi is disabled
    mWifiConnectivityManager.setWifiEnabled(false);
    // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " targetRoamBSSID " + mTargetRoamBSSID);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForUser(message.arg1);
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    Set<Integer> removedNetworkIds;
    int reasonCode;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            reasonCode = message.arg2;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false, reasonCode);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            removedNetworkIds = mWifiConfigManager.removeNetworksForUser((Integer) message.arg1);
            if (removedNetworkIds.contains(mTargetNetworkId) || removedNetworkIds.contains(mLastNetworkId)) {
                // Disconnect and let autojoin reselect a new network.
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            reasonCode = message.arg2;
            // network.
            if (getCurrentWifiConfiguration() != null) {
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                transitionTo(mObtainingIpState);
            } else {
                logw("Connected to unknown networkId " + mLastNetworkId + ", disconnecting...");
                sendMessage(CMD_DISCONNECT);
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
                if (message.arg1 == SCAN_ONLY_WITH_WIFI_OFF_MODE || message.arg1 == DISABLED_MODE) {
                    noteWifiDisabledWhileAssociated();
                }
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            fetchPktcntNative(info);
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            fetchPktcntNative(info);
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    WifiConfiguration config;
    switch(message.what) {
        case CMD_IP_CONFIGURATION_LOST:
            config = getCurrentWifiConfiguration();
            if (config != null) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTOROAM_FAILURE);
            }
            return NOT_HANDLED;
        case CMD_UNWANTED_NETWORK:
            if (mVerboseLoggingEnabled) {
                log("Roaming and CS doesnt want the network -> ignore");
            }
            return HANDLED;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                deferMessage(message);
            }
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            /**
             * If we get a SUPPLICANT_STATE_CHANGE_EVENT indicating a DISCONNECT
             * before NETWORK_DISCONNECTION_EVENT
             * And there is an associated BSSID corresponding to our target BSSID, then
             * we have missed the network disconnection, transition to mDisconnectedState
             * and handle the rest of the events there.
             */
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (stateChangeResult.state == SupplicantState.DISCONNECTED || stateChangeResult.state == SupplicantState.INACTIVE || stateChangeResult.state == SupplicantState.INTERFACE_DISABLED) {
                if (mVerboseLoggingEnabled) {
                    log("STATE_CHANGE_EVENT in roaming state " + stateChangeResult.toString());
                }
                if (stateChangeResult.BSSID != null && stateChangeResult.BSSID.equals(mTargetRoamBSSID)) {
                    handleNetworkDisconnect();
                    transitionTo(mDisconnectedState);
                }
            }
            if (stateChangeResult.state == SupplicantState.ASSOCIATED) {
                // We completed the layer2 roaming part
                mAssociated = true;
                if (stateChangeResult.BSSID != null) {
                    mTargetRoamBSSID = stateChangeResult.BSSID;
                }
            }
            break;
        case CMD_ROAM_WATCHDOG_TIMER:
            if (roamWatchdogCount == message.arg1) {
                if (mVerboseLoggingEnabled)
                    log("roaming watchdog! -> disconnect");
                mWifiMetrics.endConnectionEvent(WifiMetrics.ConnectionEvent.FAILURE_ROAM_TIMEOUT, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                mRoamFailCount++;
                handleNetworkDisconnect();
                mWifiNative.disconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mAssociated) {
                if (mVerboseLoggingEnabled) {
                    log("roaming and Network connection established");
                }
                mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
                mLastBssid = (String) message.obj;
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true);
                sendNetworkStateChangeBroadcast(mLastBssid);
                // Successful framework roam! (probably)
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                // We must clear the config BSSID, as the wifi chipset may decide to roam
                // from this point on and having the BSSID specified by QNS would cause
                // the roam to fail and the device to disconnect.
                // When transition from RoamingState to DisconnectingState or
                // DisconnectedState, the config BSSID is cleared by
                // handleNetworkDisconnect().
                clearTargetBssid("RoamingCompleted");
                // We used to transition to ObtainingIpState in an
                // attempt to do DHCPv4 RENEWs on framework roams.
                // DHCP can take too long to time out, and we now rely
                // upon IpManager's use of IpReachabilityMonitor to
                // confirm our current network configuration.
                // 
                // mIpManager.confirmConfiguration() is called within
                // the handling of SupplicantState.COMPLETED.
                transitionTo(mConnectedState);
            } else {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Throw away but only if it corresponds to the network we're roaming to
            String bssid = (String) message.obj;
            if (true) {
                String target = "";
                if (mTargetRoamBSSID != null)
                    target = mTargetRoamBSSID;
                log("NETWORK_DISCONNECTION_EVENT in roaming state" + " BSSID=" + bssid + " target=" + target);
            }
            if (bssid != null && bssid.equals(mTargetRoamBSSID)) {
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            // Auth error while roaming
            int netId = lookupFrameworkNetworkId(message.arg1);
            logd("SSID_TEMP_DISABLED nid=" + Integer.toString(mLastNetworkId) + " id=" + netId + " isRoaming=" + isRoaming() + " roam=" + mAutoRoaming);
            if (netId == mLastNetworkId) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTOROAM_FAILURE);
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectingState);
            }
            return NOT_HANDLED;
        case CMD_START_SCAN:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    WifiConfiguration config;
    switch(message.what) {
        case CMD_IP_CONFIGURATION_LOST:
            config = getCurrentWifiConfiguration();
            if (config != null) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTOROAM_FAILURE);
            }
            return NOT_HANDLED;
        case CMD_UNWANTED_NETWORK:
            if (mVerboseLoggingEnabled) {
                log("Roaming and CS doesnt want the network -> ignore");
            }
            return HANDLED;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                deferMessage(message);
            }
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            /**
             * If we get a SUPPLICANT_STATE_CHANGE_EVENT indicating a DISCONNECT
             * before NETWORK_DISCONNECTION_EVENT
             * And there is an associated BSSID corresponding to our target BSSID, then
             * we have missed the network disconnection, transition to mDisconnectedState
             * and handle the rest of the events there.
             */
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (stateChangeResult.state == SupplicantState.DISCONNECTED || stateChangeResult.state == SupplicantState.INACTIVE || stateChangeResult.state == SupplicantState.INTERFACE_DISABLED) {
                if (mVerboseLoggingEnabled) {
                    log("STATE_CHANGE_EVENT in roaming state " + stateChangeResult.toString());
                }
                if (stateChangeResult.BSSID != null && stateChangeResult.BSSID.equals(mTargetRoamBSSID)) {
                    handleNetworkDisconnect();
                    transitionTo(mDisconnectedState);
                }
            }
            if (stateChangeResult.state == SupplicantState.ASSOCIATED) {
                // We completed the layer2 roaming part
                mAssociated = true;
                if (stateChangeResult.BSSID != null) {
                    mTargetRoamBSSID = stateChangeResult.BSSID;
                }
            }
            break;
        case CMD_ROAM_WATCHDOG_TIMER:
            if (roamWatchdogCount == message.arg1) {
                if (mVerboseLoggingEnabled)
                    log("roaming watchdog! -> disconnect");
                mWifiMetrics.endConnectionEvent(WifiMetrics.ConnectionEvent.FAILURE_ROAM_TIMEOUT, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                mRoamFailCount++;
                handleNetworkDisconnect();
                mWifiNative.disconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mAssociated) {
                if (mVerboseLoggingEnabled) {
                    log("roaming and Network connection established");
                }
                mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
                mLastBssid = (String) message.obj;
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                int reasonCode = message.arg2;
                mWifiConnectivityManager.trackBssid(mLastBssid, true, reasonCode);
                sendNetworkStateChangeBroadcast(mLastBssid);
                // Successful framework roam! (probably)
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                // We must clear the config BSSID, as the wifi chipset may decide to roam
                // from this point on and having the BSSID specified by QNS would cause
                // the roam to fail and the device to disconnect.
                // When transition from RoamingState to DisconnectingState or
                // DisconnectedState, the config BSSID is cleared by
                // handleNetworkDisconnect().
                clearTargetBssid("RoamingCompleted");
                // We used to transition to ObtainingIpState in an
                // attempt to do DHCPv4 RENEWs on framework roams.
                // DHCP can take too long to time out, and we now rely
                // upon IpManager's use of IpReachabilityMonitor to
                // confirm our current network configuration.
                // 
                // mIpManager.confirmConfiguration() is called within
                // the handling of SupplicantState.COMPLETED.
                transitionTo(mConnectedState);
            } else {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Throw away but only if it corresponds to the network we're roaming to
            String bssid = (String) message.obj;
            if (true) {
                String target = "";
                if (mTargetRoamBSSID != null)
                    target = mTargetRoamBSSID;
                log("NETWORK_DISCONNECTION_EVENT in roaming state" + " BSSID=" + bssid + " target=" + target);
            }
            if (bssid != null && bssid.equals(mTargetRoamBSSID)) {
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            // Auth error while roaming
            int netId = lookupFrameworkNetworkId(message.arg1);
            logd("SSID_TEMP_DISABLED nid=" + Integer.toString(mLastNetworkId) + " id=" + netId + " isRoaming=" + isRoaming() + " roam=" + mAutoRoaming);
            if (netId == mLastNetworkId) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTOROAM_FAILURE);
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectingState);
            }
            return NOT_HANDLED;
        case CMD_START_SCAN:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config = null;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_UNWANTED_NETWORK:
            if (message.arg1 == NETWORK_STATUS_UNWANTED_DISCONNECT) {
                mWifiNative.disconnect();
                transitionTo(mDisconnectingState);
            } else if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN || message.arg1 == NETWORK_STATUS_UNWANTED_VALIDATION_FAILED) {
                Log.d(TAG, (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN ? "NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN" : "NETWORK_STATUS_UNWANTED_VALIDATION_FAILED"));
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // Disable autojoin
                    if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN) {
                        mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, false);
                        mWifiConfigManager.updateNetworkSelectionStatus(config.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET);
                    }
                    mWifiConfigManager.incrementNetworkNoInternetAccessReports(config.networkId);
                }
            }
            return HANDLED;
        case CMD_NETWORK_STATUS:
            if (message.arg1 == NetworkAgent.VALID_NETWORK) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // re-enable autojoin
                    mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, true);
                }
            }
            return HANDLED;
        case CMD_ACCEPT_UNVALIDATED:
            boolean accept = (message.arg1 != 0);
            mWifiConfigManager.setNetworkNoInternetAccessExpected(mLastNetworkId, accept);
            return HANDLED;
        case CMD_TEST_NETWORK_DISCONNECT:
            // Force a disconnect
            if (message.arg1 == testNetworkDisconnectCounter) {
                mWifiNative.disconnect();
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // ASSOCIATING to a new BSSID while already connected, indicates
            // that driver is roaming
            mLastDriverRoamAttempt = mClock.getWallClockMillis();
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            long lastRoam = 0;
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            if (mLastDriverRoamAttempt != 0) {
                // Calculate time since last driver roam attempt
                lastRoam = mClock.getWallClockMillis() - mLastDriverRoamAttempt;
                mLastDriverRoamAttempt = 0;
            }
            if (unexpectedDisconnectedReason(message.arg2)) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
            }
            config = getCurrentWifiConfiguration();
            if (mEnableLinkDebouncing && mScreenOn && !isLinkDebouncing() && config != null && config.getNetworkSelectionStatus().isNetworkEnabled() && config.networkId != mWifiConfigManager.getLastSelectedNetwork() && (message.arg2 != 3 || /* reason cannot be 3, i.e. locally generated */
            (lastRoam > 0 && lastRoam < 2000)) && ((ScanResult.is24GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5) || (ScanResult.is5GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5))) {
                // Start de-bouncing the L2 disconnection:
                // this L2 disconnection might be spurious.
                // Hence we allow 4 seconds for the state machine to try
                // to reconnect, go thru the
                // roaming cycle and enter Obtaining IP address
                // before signalling the disconnect to ConnectivityService and L3
                startScanForConfiguration(getCurrentWifiConfiguration());
                mIsLinkDebouncing = true;
                sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT, 0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " reason=" + message.arg2 + " -> debounce");
                }
                return HANDLED;
            } else {
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " was debouncing=" + isLinkDebouncing() + " reason=" + message.arg2 + " Network Selection Status=" + (config == null ? "Unavailable" : config.getNetworkSelectionStatus().getNetworkStatusString()));
                }
            }
            break;
        case CMD_START_ROAM:
            // Clear the driver roam indication since we are attempting a framework roam
            mLastDriverRoamAttempt = 0;
            /* Connect command coming from auto-join */
            int netId = message.arg1;
            ScanResult candidate = (ScanResult) message.obj;
            String bssid = SUPPLICANT_BSSID_ANY;
            if (candidate != null) {
                bssid = candidate.BSSID;
            }
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_ROAM and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            logd("CMD_START_ROAM sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " targetRoamBSSID " + mTargetRoamBSSID);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE);
            if (mWifiSupplicantControl.roamToNetwork(config)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = true;
                transitionTo(mRoamingState);
            } else {
                loge("CMD_START_ROAM Failed to start roaming to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int intervalSeconds = message.arg2;
                KeepalivePacketData pkt = (KeepalivePacketData) message.obj;
                byte[] dstMac;
                try {
                    InetAddress gateway = RouteInfo.selectBestRoute(mLinkProperties.getRoutes(), pkt.dstAddress).getGateway();
                    String dstMacStr = macAddressFromRoute(gateway.getHostAddress());
                    dstMac = macAddressFromString(dstMacStr);
                } catch (NullPointerException | IllegalArgumentException e) {
                    loge("Can't find MAC address for next hop to " + pkt.dstAddress);
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ConnectivityManager.PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
                    break;
                }
                pkt.dstMac = dstMac;
                int result = startWifiIPPacketOffload(slot, pkt, intervalSeconds);
                mNetworkAgent.onPacketKeepaliveEvent(slot, result);
                break;
            }
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config = null;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_UNWANTED_NETWORK:
            if (message.arg1 == NETWORK_STATUS_UNWANTED_DISCONNECT) {
                mWifiNative.disconnect();
                transitionTo(mDisconnectingState);
            } else if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN || message.arg1 == NETWORK_STATUS_UNWANTED_VALIDATION_FAILED) {
                Log.d(TAG, (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN ? "NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN" : "NETWORK_STATUS_UNWANTED_VALIDATION_FAILED"));
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // Disable autojoin
                    if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN) {
                        mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, false);
                        mWifiConfigManager.updateNetworkSelectionStatus(config.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET);
                    }
                    mWifiConfigManager.incrementNetworkNoInternetAccessReports(config.networkId);
                }
            }
            return HANDLED;
        case CMD_NETWORK_STATUS:
            if (message.arg1 == NetworkAgent.VALID_NETWORK) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // re-enable autojoin
                    mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, true);
                }
            }
            return HANDLED;
        case CMD_ACCEPT_UNVALIDATED:
            boolean accept = (message.arg1 != 0);
            mWifiConfigManager.setNetworkNoInternetAccessExpected(mLastNetworkId, accept);
            return HANDLED;
        case CMD_TEST_NETWORK_DISCONNECT:
            // Force a disconnect
            if (message.arg1 == testNetworkDisconnectCounter) {
                mWifiNative.disconnect();
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // ASSOCIATING to a new BSSID while already connected, indicates
            // that driver is roaming
            mLastDriverRoamAttempt = mClock.getWallClockMillis();
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            long lastRoam = 0;
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            if (mLastDriverRoamAttempt != 0) {
                // Calculate time since last driver roam attempt
                lastRoam = mClock.getWallClockMillis() - mLastDriverRoamAttempt;
                mLastDriverRoamAttempt = 0;
            }
            if (unexpectedDisconnectedReason(message.arg2)) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
            }
            config = getCurrentWifiConfiguration();
            if (mEnableLinkDebouncing && mScreenOn && !isLinkDebouncing() && config != null && config.getNetworkSelectionStatus().isNetworkEnabled() && config.networkId != mWifiConfigManager.getLastSelectedNetwork() && (message.arg2 != 3 || /* reason cannot be 3, i.e. locally generated */
            (lastRoam > 0 && lastRoam < 2000)) && ((ScanResult.is24GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5) || (ScanResult.is5GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5))) {
                // Start de-bouncing the L2 disconnection:
                // this L2 disconnection might be spurious.
                // Hence we allow 4 seconds for the state machine to try
                // to reconnect, go thru the
                // roaming cycle and enter Obtaining IP address
                // before signalling the disconnect to ConnectivityService and L3
                startScanForConfiguration(getCurrentWifiConfiguration());
                mIsLinkDebouncing = true;
                sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT, 0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " reason=" + message.arg2 + " -> debounce");
                }
                return HANDLED;
            } else {
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " was debouncing=" + isLinkDebouncing() + " reason=" + message.arg2 + " Network Selection Status=" + (config == null ? "Unavailable" : config.getNetworkSelectionStatus().getNetworkStatusString()));
                }
            }
            break;
        case CMD_START_ROAM:
            // Clear the driver roam indication since we are attempting a framework roam
            mLastDriverRoamAttempt = 0;
            /* Connect command coming from auto-join */
            int netId = message.arg1;
            ScanResult candidate = (ScanResult) message.obj;
            String bssid = SUPPLICANT_BSSID_ANY;
            if (candidate != null) {
                bssid = candidate.BSSID;
            }
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_ROAM and no config, bail out...");
                break;
            }
            setTargetBssid(config, bssid);
            mTargetNetworkId = netId;
            logd("CMD_START_ROAM sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " targetRoamBSSID " + mTargetRoamBSSID);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE);
            if (mWifiSupplicantControl.roamToNetwork(config)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = true;
                transitionTo(mRoamingState);
            } else {
                loge("CMD_START_ROAM Failed to start roaming to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int intervalSeconds = message.arg2;
                KeepalivePacketData pkt = (KeepalivePacketData) message.obj;
                byte[] dstMac;
                try {
                    InetAddress gateway = RouteInfo.selectBestRoute(mLinkProperties.getRoutes(), pkt.dstAddress).getGateway();
                    String dstMacStr = macAddressFromRoute(gateway.getHostAddress());
                    dstMac = macAddressFromString(dstMacStr);
                } catch (NullPointerException | IllegalArgumentException e) {
                    loge("Can't find MAC address for next hop to " + pkt.dstAddress);
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ConnectivityManager.PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
                    break;
                }
                pkt.dstMac = dstMac;
                int result = startWifiIPPacketOffload(slot, pkt, intervalSeconds);
                mNetworkAgent.onPacketKeepaliveEvent(slot, result);
                break;
            }
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
/**
 * Returns the IMEI. Return null if IMEI is not available.
 *
 * <p>Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public String getImei() {
    return getImei(getDefaultSim());
}
#method_after
@SystemApi
public String getImei() {
    return getImei(getDefaultSim());
}
#end_block

#method_before
/**
 * Returns the IMEI. Return null if IMEI is not available.
 *
 * <p>Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param slotId of which deviceID is returned
 */
public String getImei(int slotId) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getImeiForSlot(slotId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
@SystemApi
public String getImei(int slotId) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getImeiForSlot(slotId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
@SystemApi
public int setAllowedCarriers(int slotId, List<CarrierIdentifier> carriers) {
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.setAllowedCarriers(slotId, carriers);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    }
    return -1;
}
#method_after
@SystemApi
public int setAllowedCarriers(int slotId, List<CarrierIdentifier> carriers) {
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.setAllowedCarriers(slotId, carriers);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    } catch (NullPointerException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    }
    return -1;
}
#end_block

#method_before
@SystemApi
public List<CarrierIdentifier> getAllowedCarriers(int slotId) {
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.getAllowedCarriers(slotId);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getAllowedCarriers", e);
    }
    return new ArrayList<CarrierIdentifier>(0);
}
#method_after
@SystemApi
public List<CarrierIdentifier> getAllowedCarriers(int slotId) {
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.getAllowedCarriers(slotId);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getAllowedCarriers", e);
    } catch (NullPointerException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    }
    return new ArrayList<CarrierIdentifier>(0);
}
#end_block

#method_before
private void addValidationLogs(ReadOnlyLocalLog log, Network network) {
    synchronized (mValidationLogs) {
        while (mValidationLogs.size() >= MAX_VALIDATION_LOGS) {
            mValidationLogs.removeLast();
        }
        mValidationLogs.addFirst(new Pair(network, log));
    }
}
#method_after
private void addValidationLogs(ReadOnlyLocalLog log, Network network, String networkExtraInfo) {
    synchronized (mValidationLogs) {
        while (mValidationLogs.size() >= MAX_VALIDATION_LOGS) {
            mValidationLogs.removeLast();
        }
        mValidationLogs.addFirst(new ValidationLog(network, networkExtraInfo, log));
    }
}
#end_block

#method_before
public NetworkAgentInfo getNetworkForType(int type) {
    if (isTypeSupported(type) && !mTypeLists[type].isEmpty()) {
        return mTypeLists[type].get(0);
    } else {
        return null;
    }
}
#method_after
public NetworkAgentInfo getNetworkForType(int type) {
    synchronized (mTypeLists) {
        if (isTypeSupported(type) && !mTypeLists[type].isEmpty()) {
            return mTypeLists[type].get(0);
        }
    }
    return null;
}
#end_block

#method_before
public void add(int type, NetworkAgentInfo nai) {
    if (!isTypeSupported(type)) {
        // Invalid network type.
        return;
    }
    if (VDBG)
        log("Adding agent " + nai + " for legacy network type " + type);
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list.contains(nai)) {
        return;
    }
    list.add(nai);
    // Send a broadcast if this is the first network of its type or if it's the default.
    final boolean isDefaultNetwork = isDefaultNetwork(nai);
    if (list.size() == 1 || isDefaultNetwork) {
        maybeLogBroadcast(nai, DetailedState.CONNECTED, type, isDefaultNetwork);
        sendLegacyNetworkBroadcast(nai, DetailedState.CONNECTED, type);
    }
}
#method_after
public void add(int type, NetworkAgentInfo nai) {
    if (!isTypeSupported(type)) {
        // Invalid network type.
        return;
    }
    if (VDBG)
        log("Adding agent " + nai + " for legacy network type " + type);
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list.contains(nai)) {
        return;
    }
    synchronized (mTypeLists) {
        list.add(nai);
    }
    // Send a broadcast if this is the first network of its type or if it's the default.
    final boolean isDefaultNetwork = isDefaultNetwork(nai);
    if ((list.size() == 1) || isDefaultNetwork) {
        maybeLogBroadcast(nai, DetailedState.CONNECTED, type, isDefaultNetwork);
        sendLegacyNetworkBroadcast(nai, DetailedState.CONNECTED, type);
    }
}
#end_block

#method_before
public void remove(int type, NetworkAgentInfo nai, boolean wasDefault) {
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list == null || list.isEmpty()) {
        return;
    }
    final boolean wasFirstNetwork = list.get(0).equals(nai);
    if (!list.remove(nai)) {
        return;
    }
    final DetailedState state = DetailedState.DISCONNECTED;
    if (wasFirstNetwork || wasDefault) {
        maybeLogBroadcast(nai, state, type, wasDefault);
        sendLegacyNetworkBroadcast(nai, state, type);
    }
    if (!list.isEmpty() && wasFirstNetwork) {
        if (DBG)
            log("Other network available for type " + type + ", sending connected broadcast");
        final NetworkAgentInfo replacement = list.get(0);
        maybeLogBroadcast(replacement, state, type, isDefaultNetwork(replacement));
        sendLegacyNetworkBroadcast(replacement, state, type);
    }
}
#method_after
public void remove(int type, NetworkAgentInfo nai, boolean wasDefault) {
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list == null || list.isEmpty()) {
        return;
    }
    final boolean wasFirstNetwork = list.get(0).equals(nai);
    synchronized (mTypeLists) {
        if (!list.remove(nai)) {
            return;
        }
    }
    final DetailedState state = DetailedState.DISCONNECTED;
    if (wasFirstNetwork || wasDefault) {
        maybeLogBroadcast(nai, state, type, wasDefault);
        sendLegacyNetworkBroadcast(nai, state, type);
    }
    if (!list.isEmpty() && wasFirstNetwork) {
        if (DBG)
            log("Other network available for type " + type + ", sending connected broadcast");
        final NetworkAgentInfo replacement = list.get(0);
        maybeLogBroadcast(replacement, state, type, isDefaultNetwork(replacement));
        sendLegacyNetworkBroadcast(replacement, state, type);
    }
}
#end_block

#method_before
// send out another legacy broadcast - currently only used for suspend/unsuspend
public void update(NetworkAgentInfo nai) {
    final boolean isDefault = isDefaultNetwork(nai);
    final DetailedState state = nai.networkInfo.getDetailedState();
    for (int type = 0; type < mTypeLists.length; type++) {
        final ArrayList<NetworkAgentInfo> list = mTypeLists[type];
        final boolean contains = (list != null && list.contains(nai));
        final boolean isFirst = (list != null && list.size() > 0 && nai == list.get(0));
        if (isFirst || (contains && isDefault)) {
            maybeLogBroadcast(nai, state, type, isDefault);
            sendLegacyNetworkBroadcast(nai, state, type);
        }
    }
}
#method_after
// send out another legacy broadcast - currently only used for suspend/unsuspend
public void update(NetworkAgentInfo nai) {
    final boolean isDefault = isDefaultNetwork(nai);
    final DetailedState state = nai.networkInfo.getDetailedState();
    for (int type = 0; type < mTypeLists.length; type++) {
        final ArrayList<NetworkAgentInfo> list = mTypeLists[type];
        final boolean contains = (list != null && list.contains(nai));
        final boolean isFirst = contains && (nai == list.get(0));
        if (isFirst || contains && isDefault) {
            maybeLogBroadcast(nai, state, type, isDefault);
            sendLegacyNetworkBroadcast(nai, state, type);
        }
    }
}
#end_block

#method_before
public void dump(IndentingPrintWriter pw) {
    pw.println("mLegacyTypeTracker:");
    pw.increaseIndent();
    pw.print("Supported types:");
    for (int type = 0; type < mTypeLists.length; type++) {
        if (mTypeLists[type] != null)
            pw.print(" " + type);
    }
    pw.println();
    pw.println("Current state:");
    pw.increaseIndent();
    for (int type = 0; type < mTypeLists.length; type++) {
        if (mTypeLists[type] == null || mTypeLists[type].size() == 0)
            continue;
        for (NetworkAgentInfo nai : mTypeLists[type]) {
            pw.println(type + " " + naiToString(nai));
        }
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
    pw.println();
}
#method_after
public void dump(IndentingPrintWriter pw) {
    pw.println("mLegacyTypeTracker:");
    pw.increaseIndent();
    pw.print("Supported types:");
    for (int type = 0; type < mTypeLists.length; type++) {
        if (mTypeLists[type] != null)
            pw.print(" " + type);
    }
    pw.println();
    pw.println("Current state:");
    pw.increaseIndent();
    synchronized (mTypeLists) {
        for (int type = 0; type < mTypeLists.length; type++) {
            if (mTypeLists[type] == null || mTypeLists[type].isEmpty())
                continue;
            for (NetworkAgentInfo nai : mTypeLists[type]) {
                pw.println(type + " " + naiToString(nai));
            }
        }
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
    pw.println();
}
#end_block

#method_before
private void handleMobileDataAlwaysOn() {
    final boolean enable = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.MOBILE_DATA_ALWAYS_ON, 0) == 1);
    final boolean isEnabled = (mNetworkRequests.get(mDefaultMobileDataRequest) != null);
    if (enable == isEnabled) {
        // Nothing to do.
        return;
    }
    if (enable) {
        handleRegisterNetworkRequest(new NetworkRequestInfo(null, mDefaultMobileDataRequest, new Binder(), NetworkRequestInfo.REQUEST));
    } else {
        handleReleaseNetworkRequest(mDefaultMobileDataRequest, Process.SYSTEM_UID);
    }
}
#method_after
private void handleMobileDataAlwaysOn() {
    final boolean enable = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.MOBILE_DATA_ALWAYS_ON, 0) == 1);
    final boolean isEnabled = (mNetworkRequests.get(mDefaultMobileDataRequest) != null);
    if (enable == isEnabled) {
        // Nothing to do.
        return;
    }
    if (enable) {
        handleRegisterNetworkRequest(new NetworkRequestInfo(null, mDefaultMobileDataRequest, new Binder(), NetworkRequestType.REQUEST));
    } else {
        handleReleaseNetworkRequest(mDefaultMobileDataRequest, Process.SYSTEM_UID);
    }
}
#end_block

#method_before
private NetworkState getFilteredNetworkState(int networkType, int uid) {
    NetworkInfo info = null;
    LinkProperties lp = null;
    NetworkCapabilities nc = null;
    Network network = null;
    String subscriberId = null;
    if (mLegacyTypeTracker.isTypeSupported(networkType)) {
        NetworkAgentInfo nai = mLegacyTypeTracker.getNetworkForType(networkType);
        if (nai != null) {
            synchronized (nai) {
                info = new NetworkInfo(nai.networkInfo);
                lp = new LinkProperties(nai.linkProperties);
                nc = new NetworkCapabilities(nai.networkCapabilities);
                // Network objects are outwardly immutable so there is no point to duplicating.
                // Duplicating also precludes sharing socket factories and connection pools.
                network = nai.network;
                subscriberId = (nai.networkMisc != null) ? nai.networkMisc.subscriberId : null;
            }
            info.setType(networkType);
        } else {
            info = new NetworkInfo(networkType, 0, getNetworkTypeName(networkType), "");
            info.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
            info.setIsAvailable(true);
            lp = new LinkProperties();
            nc = new NetworkCapabilities();
            network = null;
        }
        info = getFilteredNetworkInfo(info, lp, uid);
    }
    return new NetworkState(info, lp, nc, network, subscriberId, null);
}
#method_after
private NetworkState getFilteredNetworkState(int networkType, int uid, boolean ignoreBlocked) {
    if (mLegacyTypeTracker.isTypeSupported(networkType)) {
        final NetworkAgentInfo nai = mLegacyTypeTracker.getNetworkForType(networkType);
        final NetworkState state;
        if (nai != null) {
            state = nai.getNetworkState();
            state.networkInfo.setType(networkType);
        } else {
            final NetworkInfo info = new NetworkInfo(networkType, 0, getNetworkTypeName(networkType), "");
            info.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
            info.setIsAvailable(true);
            state = new NetworkState(info, new LinkProperties(), new NetworkCapabilities(), null, null, null);
        }
        filterNetworkStateForUid(state, uid, ignoreBlocked);
        return state;
    } else {
        return NetworkState.EMPTY;
    }
}
#end_block

#method_before
private NetworkState getUnfilteredActiveNetworkState(int uid) {
    NetworkInfo info = null;
    LinkProperties lp = null;
    NetworkCapabilities nc = null;
    Network network = null;
    String subscriberId = null;
    NetworkAgentInfo nai = getDefaultNetwork();
    final Network[] networks = getVpnUnderlyingNetworks(uid);
    if (networks != null) {
        // first one.
        if (networks.length > 0) {
            nai = getNetworkAgentInfoForNetwork(networks[0]);
        } else {
            nai = null;
        }
    }
    if (nai != null) {
        synchronized (nai) {
            info = new NetworkInfo(nai.networkInfo);
            lp = new LinkProperties(nai.linkProperties);
            nc = new NetworkCapabilities(nai.networkCapabilities);
            // Network objects are outwardly immutable so there is no point to duplicating.
            // Duplicating also precludes sharing socket factories and connection pools.
            network = nai.network;
            subscriberId = (nai.networkMisc != null) ? nai.networkMisc.subscriberId : null;
        }
    }
    return new NetworkState(info, lp, nc, network, subscriberId, null);
}
#method_after
private NetworkState getUnfilteredActiveNetworkState(int uid) {
    NetworkAgentInfo nai = getDefaultNetwork();
    final Network[] networks = getVpnUnderlyingNetworks(uid);
    if (networks != null) {
        // first one.
        if (networks.length > 0) {
            nai = getNetworkAgentInfoForNetwork(networks[0]);
        } else {
            nai = null;
        }
    }
    if (nai != null) {
        return nai.getNetworkState();
    } else {
        return NetworkState.EMPTY;
    }
}
#end_block

#method_before
private boolean isNetworkWithLinkPropertiesBlocked(LinkProperties lp, int uid) {
    final boolean networkCostly;
    final int uidRules;
    final String iface = (lp == null ? "" : lp.getInterfaceName());
    synchronized (mRulesLock) {
        networkCostly = mMeteredIfaces.contains(iface);
        uidRules = mUidRules.get(uid, RULE_ALLOW_ALL);
    }
    if (uidRules == RULE_REJECT_ALL) {
        return true;
    } else if ((uidRules == RULE_REJECT_METERED) && networkCostly) {
        return true;
    } else {
        return false;
    }
}
#method_after
private boolean isNetworkWithLinkPropertiesBlocked(LinkProperties lp, int uid, boolean ignoreBlocked) {
    // Networks aren't blocked when ignoring blocked status
    if (ignoreBlocked)
        return false;
    // Networks are never blocked for system services
    if (isSystem(uid))
        return false;
    final boolean networkMetered;
    final int uidRules;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(UserHandle.getUserId(uid));
        if (vpn != null && vpn.isBlockingUid(uid)) {
            return true;
        }
    }
    final String iface = (lp == null ? "" : lp.getInterfaceName());
    synchronized (mRulesLock) {
        networkMetered = mMeteredIfaces.contains(iface);
        uidRules = mUidRules.get(uid, RULE_NONE);
    }
    boolean allowed = true;
    // Check Data Saver Mode first...
    if (networkMetered) {
        if ((uidRules & RULE_REJECT_METERED) != 0) {
            if (LOGD_RULES)
                Log.d(TAG, "uid " + uid + " is blacklisted");
            // Explicitly blacklisted.
            allowed = false;
        } else {
            allowed = !mRestrictBackground || (uidRules & RULE_ALLOW_METERED) != 0 || (uidRules & RULE_TEMPORARY_ALLOW_METERED) != 0;
            if (LOGD_RULES)
                Log.d(TAG, "allowed status for uid " + uid + " when" + " mRestrictBackground=" + mRestrictBackground + ", whitelisted=" + ((uidRules & RULE_ALLOW_METERED) != 0) + ", tempWhitelist= + ((uidRules & RULE_TEMPORARY_ALLOW_METERED) != 0)" + ": " + allowed);
        }
    }
    // ...then power restrictions.
    if (allowed) {
        allowed = (uidRules & RULE_REJECT_ALL) == 0;
        if (LOGD_RULES)
            Log.d(TAG, "allowed status for uid " + uid + " when" + " rule is " + uidRulesToString(uidRules) + ": " + allowed);
    }
    return !allowed;
}
#end_block

#method_before
@Override
public NetworkInfo getActiveNetworkInfo() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    NetworkState state = getUnfilteredActiveNetworkState(uid);
    return getFilteredNetworkInfo(state.networkInfo, state.linkProperties, uid);
}
#method_after
@Override
public NetworkInfo getActiveNetworkInfo() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    final NetworkState state = getUnfilteredActiveNetworkState(uid);
    filterNetworkStateForUid(state, uid, false);
    maybeLogBlockedNetworkInfo(state.networkInfo, uid);
    return state.networkInfo;
}
#end_block

#method_before
@Override
public Network getActiveNetwork() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        synchronized (mNetworkForNetId) {
            nai = mNetworkForNetId.get(vpnNetId);
        }
        if (nai != null)
            return nai.network;
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid))
        nai = null;
    return nai != null ? nai.network : null;
}
#method_after
@Override
public Network getActiveNetwork() {
    enforceAccessPermission();
    return getActiveNetworkForUidInternal(Binder.getCallingUid(), false);
}
#end_block

#method_before
@Override
public NetworkInfo getActiveNetworkInfoForUid(int uid) {
    enforceConnectivityInternalPermission();
    NetworkState state = getUnfilteredActiveNetworkState(uid);
    return getFilteredNetworkInfo(state.networkInfo, state.linkProperties, uid);
}
#method_after
@Override
public NetworkInfo getActiveNetworkInfoForUid(int uid, boolean ignoreBlocked) {
    enforceConnectivityInternalPermission();
    final NetworkState state = getUnfilteredActiveNetworkState(uid);
    filterNetworkStateForUid(state, uid, ignoreBlocked);
    return state.networkInfo;
}
#end_block

#method_before
@Override
public NetworkInfo getNetworkInfo(int networkType) {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    if (getVpnUnderlyingNetworks(uid) != null) {
        // A VPN is active, so we may need to return one of its underlying networks. This
        // information is not available in LegacyTypeTracker, so we have to get it from
        // getUnfilteredActiveNetworkState.
        NetworkState state = getUnfilteredActiveNetworkState(uid);
        if (state.networkInfo != null && state.networkInfo.getType() == networkType) {
            return getFilteredNetworkInfo(state.networkInfo, state.linkProperties, uid);
        }
    }
    NetworkState state = getFilteredNetworkState(networkType, uid);
    return state.networkInfo;
}
#method_after
@Override
public NetworkInfo getNetworkInfo(int networkType) {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    if (getVpnUnderlyingNetworks(uid) != null) {
        // A VPN is active, so we may need to return one of its underlying networks. This
        // information is not available in LegacyTypeTracker, so we have to get it from
        // getUnfilteredActiveNetworkState.
        final NetworkState state = getUnfilteredActiveNetworkState(uid);
        if (state.networkInfo != null && state.networkInfo.getType() == networkType) {
            filterNetworkStateForUid(state, uid, false);
            return state.networkInfo;
        }
    }
    final NetworkState state = getFilteredNetworkState(networkType, uid, false);
    return state.networkInfo;
}
#end_block

#method_before
@Override
public Network getNetworkForType(int networkType) {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    NetworkState state = getFilteredNetworkState(networkType, uid);
    if (!isNetworkWithLinkPropertiesBlocked(state.linkProperties, uid)) {
        return state.network;
    }
    return null;
}
#method_after
@Override
public Network getNetworkForType(int networkType) {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    NetworkState state = getFilteredNetworkState(networkType, uid, false);
    if (!isNetworkWithLinkPropertiesBlocked(state.linkProperties, uid, false)) {
        return state.network;
    }
    return null;
}
#end_block

#method_before
@Override
public NetworkState[] getAllNetworkState() {
    // Require internal since we're handing out IMSI details
    enforceConnectivityInternalPermission();
    final ArrayList<NetworkState> result = Lists.newArrayList();
    for (Network network : getAllNetworks()) {
        final NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
        if (nai != null) {
            synchronized (nai) {
                final String subscriberId = (nai.networkMisc != null) ? nai.networkMisc.subscriberId : null;
                result.add(new NetworkState(nai.networkInfo, nai.linkProperties, nai.networkCapabilities, network, subscriberId, null));
            }
        }
    }
    return result.toArray(new NetworkState[result.size()]);
}
#method_after
@Override
public NetworkState[] getAllNetworkState() {
    // Require internal since we're handing out IMSI details
    enforceConnectivityInternalPermission();
    final ArrayList<NetworkState> result = Lists.newArrayList();
    for (Network network : getAllNetworks()) {
        final NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
        if (nai != null) {
            result.add(nai.getNetworkState());
        }
    }
    return result.toArray(new NetworkState[result.size()]);
}
#end_block

#method_before
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    final long token = Binder.clearCallingIdentity();
    try {
        return isActiveNetworkMeteredUnchecked(uid);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final NetworkInfo info = getActiveNetworkInfo();
    return (info != null) ? info.isMetered() : false;
}
#end_block

#method_before
private boolean addLegacyRouteToHost(LinkProperties lp, InetAddress addr, int netId, int uid) {
    RouteInfo bestRoute = RouteInfo.selectBestRoute(lp.getAllRoutes(), addr);
    if (bestRoute == null) {
        bestRoute = RouteInfo.makeHostRoute(addr, lp.getInterfaceName());
    } else {
        String iface = bestRoute.getInterface();
        if (bestRoute.getGateway().equals(addr)) {
            // if there is no better route, add the implied hostroute for our gateway
            bestRoute = RouteInfo.makeHostRoute(addr, iface);
        } else {
            // if we will connect to this through another route, add a direct route
            // to it's gateway
            bestRoute = RouteInfo.makeHostRoute(addr, bestRoute.getGateway(), iface);
        }
    }
    if (DBG)
        log("Adding " + bestRoute + " for interface " + bestRoute.getInterface());
    try {
        mNetd.addLegacyRouteForNetId(netId, bestRoute, uid);
    } catch (Exception e) {
        // never crash - catch them all
        if (DBG)
            loge("Exception trying to add a route: " + e);
        return false;
    }
    return true;
}
#method_after
private boolean addLegacyRouteToHost(LinkProperties lp, InetAddress addr, int netId, int uid) {
    RouteInfo bestRoute = RouteInfo.selectBestRoute(lp.getAllRoutes(), addr);
    if (bestRoute == null) {
        bestRoute = RouteInfo.makeHostRoute(addr, lp.getInterfaceName());
    } else {
        String iface = bestRoute.getInterface();
        if (bestRoute.getGateway().equals(addr)) {
            // if there is no better route, add the implied hostroute for our gateway
            bestRoute = RouteInfo.makeHostRoute(addr, iface);
        } else {
            // if we will connect to this through another route, add a direct route
            // to it's gateway
            bestRoute = RouteInfo.makeHostRoute(addr, bestRoute.getGateway(), iface);
        }
    }
    if (DBG)
        log("Adding legacy route " + bestRoute + " for UID/PID " + uid + "/" + Binder.getCallingPid());
    try {
        mNetd.addLegacyRouteForNetId(netId, bestRoute, uid);
    } catch (Exception e) {
        // never crash - catch them all
        if (DBG)
            loge("Exception trying to add a route: " + e);
        return false;
    }
    return true;
}
#end_block

#method_before
private Intent makeGeneralIntent(NetworkInfo info, String bcastType) {
    if (mLockdownTracker != null) {
        info = mLockdownTracker.augmentNetworkInfo(info);
    }
    Intent intent = new Intent(bcastType);
    intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO, new NetworkInfo(info));
    intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, info.getType());
    if (info.isFailover()) {
        intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER, true);
        info.setFailover(false);
    }
    if (info.getReason() != null) {
        intent.putExtra(ConnectivityManager.EXTRA_REASON, info.getReason());
    }
    if (info.getExtraInfo() != null) {
        intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO, info.getExtraInfo());
    }
    intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION, mDefaultInetConditionPublished);
    return intent;
}
#method_after
private Intent makeGeneralIntent(NetworkInfo info, String bcastType) {
    if (mLockdownTracker != null) {
        info = new NetworkInfo(info);
        mLockdownTracker.augmentNetworkInfo(info);
    }
    Intent intent = new Intent(bcastType);
    intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO, new NetworkInfo(info));
    intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, info.getType());
    if (info.isFailover()) {
        intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER, true);
        info.setFailover(false);
    }
    if (info.getReason() != null) {
        intent.putExtra(ConnectivityManager.EXTRA_REASON, info.getReason());
    }
    if (info.getExtraInfo() != null) {
        intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO, info.getExtraInfo());
    }
    intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION, mDefaultInetConditionPublished);
    return intent;
}
#end_block

#method_before
private void sendStickyBroadcast(Intent intent) {
    synchronized (this) {
        if (!mSystemReady) {
            mInitialBroadcast = new Intent(intent);
        }
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        if (DBG) {
            log("sendStickyBroadcast: action=" + intent.getAction());
        }
        final long ident = Binder.clearCallingIdentity();
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            final NetworkInfo ni = intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
            if (ni.getType() == ConnectivityManager.TYPE_MOBILE_SUPL) {
                intent.setAction(ConnectivityManager.CONNECTIVITY_ACTION_SUPL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            }
            final IBatteryStats bs = BatteryStatsService.getService();
            try {
                bs.noteConnectivityChanged(intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE), ni != null ? ni.getState().toString() : "?");
            } catch (RemoteException e) {
            }
        }
        try {
            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
private void sendStickyBroadcast(Intent intent) {
    synchronized (this) {
        if (!mSystemReady) {
            mInitialBroadcast = new Intent(intent);
        }
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        if (VDBG) {
            log("sendStickyBroadcast: action=" + intent.getAction());
        }
        Bundle options = null;
        final long ident = Binder.clearCallingIdentity();
        if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) {
            final NetworkInfo ni = intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
            if (ni.getType() == ConnectivityManager.TYPE_MOBILE_SUPL) {
                intent.setAction(ConnectivityManager.CONNECTIVITY_ACTION_SUPL);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            } else {
                BroadcastOptions opts = BroadcastOptions.makeBasic();
                opts.setMaxManifestReceiverApiLevel(Build.VERSION_CODES.M);
                options = opts.toBundle();
            }
            final IBatteryStats bs = BatteryStatsService.getService();
            try {
                bs.noteConnectivityChanged(intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE), ni != null ? ni.getState().toString() : "?");
            } catch (RemoteException e) {
            }
        }
        try {
            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL, options);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#end_block

#method_before
void systemReady() {
    loadGlobalProxy();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // load the global proxy at startup
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_APPLY_GLOBAL_HTTP_PROXY));
    // for user to unlock device.
    if (!updateLockdownVpn()) {
        final IntentFilter filter = new IntentFilter(Intent.ACTION_USER_PRESENT);
        mContext.registerReceiver(mUserPresentReceiver, filter);
    }
    // Configure whether mobile data is always on.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#method_after
void systemReady() {
    loadGlobalProxy();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // load the global proxy at startup
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_APPLY_GLOBAL_HTTP_PROXY));
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Configure whether mobile data is always on.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#end_block

#method_before
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (LinkProperties.isValidMtu(mtu, newLp.hasGlobalIPv6Address()) == false) {
        loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (DBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNetd.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#method_after
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (LinkProperties.isValidMtu(mtu, newLp.hasGlobalIPv6Address()) == false) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNetd.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#end_block

#method_before
private void updateTcpBufferSizes(NetworkAgentInfo nai) {
    if (isDefaultNetwork(nai) == false) {
        return;
    }
    String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (DBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        final String prefix = "/sys/kernel/ipv4/tcp_";
        FileUtils.stringToFile(prefix + "rmem_min", values[0]);
        FileUtils.stringToFile(prefix + "rmem_def", values[1]);
        FileUtils.stringToFile(prefix + "rmem_max", values[2]);
        FileUtils.stringToFile(prefix + "wmem_min", values[3]);
        FileUtils.stringToFile(prefix + "wmem_def", values[4]);
        FileUtils.stringToFile(prefix + "wmem_max", values[5]);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (IOException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, getDefaultTcpRwnd());
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        SystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#method_after
private void updateTcpBufferSizes(NetworkAgentInfo nai) {
    if (isDefaultNetwork(nai) == false) {
        return;
    }
    String tcpBufferSizes = nai.linkProperties.getTcpBufferSizes();
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        final String prefix = "/sys/kernel/ipv4/tcp_";
        FileUtils.stringToFile(prefix + "rmem_min", values[0]);
        FileUtils.stringToFile(prefix + "rmem_def", values[1]);
        FileUtils.stringToFile(prefix + "rmem_max", values[2]);
        FileUtils.stringToFile(prefix + "wmem_min", values[3]);
        FileUtils.stringToFile(prefix + "wmem_def", values[4]);
        FileUtils.stringToFile(prefix + "wmem_max", values[5]);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (IOException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, getDefaultTcpRwnd());
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        SystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#end_block

#method_before
@Override
public int getRestoreDefaultNetworkDelay(int networkType) {
    String restoreDefaultNetworkDelayStr = SystemProperties.get(NETWORK_RESTORE_DELAY_PROP_NAME);
    if (restoreDefaultNetworkDelayStr != null && restoreDefaultNetworkDelayStr.length() != 0) {
        try {
            return Integer.valueOf(restoreDefaultNetworkDelayStr);
        } catch (NumberFormatException e) {
        }
    }
    // if the system property isn't set, use the value for the apn type
    int ret = RESTORE_DEFAULT_NETWORK_DELAY;
    if ((networkType <= ConnectivityManager.MAX_NETWORK_TYPE) && (mNetConfigs[networkType] != null)) {
        ret = mNetConfigs[networkType].restoreTime;
    }
    return ret;
}
#method_after
@Override
public int getRestoreDefaultNetworkDelay(int networkType) {
    String restoreDefaultNetworkDelayStr = SystemProperties.get(NETWORK_RESTORE_DELAY_PROP_NAME);
    if (restoreDefaultNetworkDelayStr != null && restoreDefaultNetworkDelayStr.length() != 0) {
        try {
            return Integer.parseInt(restoreDefaultNetworkDelayStr);
        } catch (NumberFormatException e) {
        }
    }
    // if the system property isn't set, use the value for the apn type
    int ret = RESTORE_DEFAULT_NETWORK_DELAY;
    if ((networkType <= ConnectivityManager.MAX_NETWORK_TYPE) && (mNetConfigs[networkType] != null)) {
        ret = mNetConfigs[networkType].restoreTime;
    }
    return ret;
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    final List<NetworkDiagnostics> netDiags = new ArrayList<NetworkDiagnostics>();
    if (argsContain(args, "--diag")) {
        final long DIAG_TIME_MS = 5000;
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            // Start gathering diagnostic information.
            netDiags.add(new NetworkDiagnostics(nai.network, // Must be a copy.
            new LinkProperties(nai.linkProperties), DIAG_TIME_MS));
        }
        for (NetworkDiagnostics netDiag : netDiags) {
            pw.println();
            netDiag.waitForMeasurements();
            netDiag.dump(pw);
        }
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println("Requests:");
        pw.increaseIndent();
        for (int i = 0; i < nai.networkRequests.size(); i++) {
            pw.println(nai.networkRequests.valueAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        for (NetworkRequest nr : nai.networkLingered) pw.println(nr.toString());
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    synchronized (this) {
        pw.print("mNetTransitionWakeLock: currently " + (mNetTransitionWakeLock.isHeld() ? "" : "not ") + "held");
        if (!TextUtils.isEmpty(mNetTransitionWakeLockCausedBy)) {
            pw.println(", last requested for " + mNetTransitionWakeLockCausedBy);
        } else {
            pw.println(", last requested never");
        }
    }
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    if (mInetLog != null && mInetLog.size() > 0) {
        pw.println();
        pw.println("Inet condition reports:");
        pw.increaseIndent();
        for (int i = 0; i < mInetLog.size(); i++) {
            pw.println(mInetLog.get(i));
        }
        pw.decreaseIndent();
    }
    if (argsContain(args, "--short") == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (Pair<Network, ReadOnlyLocalLog> p : mValidationLogs) {
                pw.println(p.first);
                pw.increaseIndent();
                p.second.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (argsContain(args, "--diag")) {
        dumpNetworkDiagnostics(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println("Requests:");
        pw.increaseIndent();
        for (int i = 0; i < nai.networkRequests.size(); i++) {
            pw.println(nai.networkRequests.valueAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        for (NetworkRequest nr : nai.networkLingered) pw.println(nr.toString());
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Metered Interfaces:");
    pw.increaseIndent();
    for (String value : mMeteredIfaces) {
        pw.println(value);
    }
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        final int uid = mUidRules.keyAt(i);
        pw.print("UID=");
        pw.print(uid);
        final int uidRules = mUidRules.get(uid, RULE_NONE);
        pw.print(" rules=");
        pw.print(uidRulesToString(uidRules));
        pw.println();
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    synchronized (this) {
        pw.print("mNetTransitionWakeLock: currently " + (mNetTransitionWakeLock.isHeld() ? "" : "not ") + "held");
        if (!TextUtils.isEmpty(mNetTransitionWakeLockCausedBy)) {
            pw.println(", last requested for " + mNetTransitionWakeLockCausedBy);
        } else {
            pw.println(", last requested never");
        }
    }
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    if (mInetLog != null && mInetLog.size() > 0) {
        pw.println();
        pw.println("Inet condition reports:");
        pw.increaseIndent();
        for (int i = 0; i < mInetLog.size(); i++) {
            pw.println(mInetLog.get(i));
        }
        pw.decreaseIndent();
    }
    if (argsContain(args, "--short") == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private boolean isLiveNetworkAgent(NetworkAgentInfo nai, String msg) {
    if (nai.network == null)
        return false;
    final NetworkAgentInfo officialNai = getNetworkAgentInfoForNetwork(nai.network);
    if (officialNai != null && officialNai.equals(nai))
        return true;
    if (officialNai != null || VDBG) {
        loge(msg + " - isLiveNetworkAgent found mismatched netId: " + officialNai + " - " + nai);
    }
    return false;
}
#method_after
private boolean isLiveNetworkAgent(NetworkAgentInfo nai, int what) {
    if (nai.network == null)
        return false;
    final NetworkAgentInfo officialNai = getNetworkAgentInfoForNetwork(nai.network);
    if (officialNai != null && officialNai.equals(nai))
        return true;
    if (officialNai != null || VDBG) {
        final String msg = sMagicDecoderRing.get(what, Integer.toString(what));
        loge(msg + " - isLiveNetworkAgent found mismatched netId: " + officialNai + " - " + nai);
    }
    return false;
}
#end_block

#method_before
private boolean isRequest(NetworkRequest request) {
    return mNetworkRequests.get(request).isRequest;
}
#method_after
private boolean isRequest(NetworkRequest request) {
    return mNetworkRequests.get(request).isRequest();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    NetworkInfo info;
    switch(msg.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                handleAsyncChannelHalfConnect(msg);
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECT:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai != null)
                    nai.asyncChannel.disconnect();
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                handleAsyncChannelDisconnected(msg);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai == null) {
                    loge("EVENT_NETWORK_CAPABILITIES_CHANGED from unknown NetworkAgent");
                } else {
                    final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                    if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                        Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                    }
                    if (nai.created && !nai.networkCapabilities.equalImmutableCapabilities(networkCapabilities)) {
                        Slog.wtf(TAG, "BUG: " + nai + " changed immutable capabilities: " + nai.networkCapabilities + " -> " + networkCapabilities);
                    }
                    updateCapabilities(nai, networkCapabilities);
                }
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai == null) {
                    loge("NetworkAgent not found for EVENT_NETWORK_PROPERTIES_CHANGED");
                } else {
                    if (VDBG) {
                        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created);
                    }
                    LinkProperties oldLp = nai.linkProperties;
                    synchronized (nai) {
                        nai.linkProperties = (LinkProperties) msg.obj;
                    }
                    if (nai.created)
                        updateLinkProperties(nai, oldLp);
                }
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai == null) {
                    loge("EVENT_NETWORK_INFO_CHANGED from unknown NetworkAgent");
                    break;
                }
                info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai == null) {
                    loge("EVENT_NETWORK_SCORE_CHANGED from unknown NetworkAgent");
                    break;
                }
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score.intValue());
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_ADDED:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai == null) {
                    loge("EVENT_UID_RANGES_ADDED from unknown NetworkAgent");
                    break;
                }
                try {
                    mNetd.addVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in addVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_REMOVED:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai == null) {
                    loge("EVENT_UID_RANGES_REMOVED from unknown NetworkAgent");
                    break;
                }
                try {
                    mNetd.removeVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in removeVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai == null) {
                    loge("EVENT_SET_EXPLICITLY_SELECTED from unknown NetworkAgent");
                    break;
                }
                if (nai.created && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: created network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
                if (nai == null) {
                    loge("EVENT_PACKET_KEEPALIVE from unknown NetworkAgent");
                    break;
                }
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                NetworkAgentInfo nai = (NetworkAgentInfo) msg.obj;
                if (isLiveNetworkAgent(nai, "EVENT_NETWORK_TESTED")) {
                    final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                    if (DBG)
                        log(nai.name() + " validation " + (valid ? " passed" : "failed"));
                    if (valid != nai.lastValidated) {
                        final int oldScore = nai.getCurrentScore();
                        nai.lastValidated = valid;
                        nai.everValidated |= valid;
                        updateCapabilities(nai, nai.networkCapabilities);
                        // If score has changed, rebroadcast to NetworkFactories. b/17726566
                        if (oldScore != nai.getCurrentScore())
                            sendUpdatedScoreToFactories(nai);
                    }
                    updateInetCondition(nai);
                    // Let the NetworkAgent know the state of its network
                    nai.asyncChannel.sendMessage(android.net.NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, null);
                }
                break;
            }
        case NetworkMonitor.EVENT_NETWORK_LINGER_COMPLETE:
            {
                NetworkAgentInfo nai = (NetworkAgentInfo) msg.obj;
                if (isLiveNetworkAgent(nai, "EVENT_NETWORK_LINGER_COMPLETE")) {
                    handleLingerComplete(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = (msg.arg1 != 0);
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(netId);
                }
                // If captive portal status has changed, update capabilities.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    updateCapabilities(nai, nai.networkCapabilities);
                }
                if (!visible) {
                    setProvNotificationVisibleIntent(false, netId, null, 0, null, null, false);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    setProvNotificationVisibleIntent(true, netId, NotificationType.SIGN_IN, nai.networkInfo.getType(), nai.networkInfo.getExtraInfo(), (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                }
                break;
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (!maybeHandleAsyncChannelMessage(msg) && !maybeHandleNetworkMonitorMessage(msg)) {
        maybeHandleNetworkAgentMessage(msg);
    }
}
#end_block

#method_before
private void linger(NetworkAgentInfo nai) {
    nai.lingering = true;
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_LINGER);
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOSING);
}
#method_after
private void linger(NetworkAgentInfo nai) {
    nai.lingering = true;
    NetworkEvent.logEvent(nai.network.netId, NetworkEvent.NETWORK_LINGER);
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_LINGER);
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOSING);
}
#end_block

#method_before
// Cancel any lingering so the linger timeout doesn't teardown a network.
// This should be called when a network begins satisfying a NetworkRequest.
// Note: depending on what state the NetworkMonitor is in (e.g.,
// if it's awaiting captive portal login, or if validation failed), this
private void unlinger(NetworkAgentInfo nai) {
    nai.networkLingered.clear();
    if (!nai.lingering)
        return;
    nai.lingering = false;
    if (VDBG)
        log("Canceling linger of " + nai.name());
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
}
#method_after
// Cancel any lingering so the linger timeout doesn't teardown a network.
// This should be called when a network begins satisfying a NetworkRequest.
// Note: depending on what state the NetworkMonitor is in (e.g.,
// if it's awaiting captive portal login, or if validation failed), this
private void unlinger(NetworkAgentInfo nai) {
    nai.networkLingered.clear();
    if (!nai.lingering)
        return;
    nai.lingering = false;
    NetworkEvent.logEvent(nai.network.netId, NetworkEvent.NETWORK_UNLINGER);
    if (VDBG)
        log("Canceling linger of " + nai.name());
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
}
#end_block

#method_before
private void handleAsyncChannelHalfConnect(Message msg) {
    AsyncChannel ac = (AsyncChannel) msg.obj;
    if (mNetworkFactoryInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkFactory connected");
            // A network factory has connected.  Send it all current NetworkRequests.
            for (NetworkRequestInfo nri : mNetworkRequests.values()) {
                if (nri.isRequest == false)
                    continue;
                NetworkAgentInfo nai = mNetworkForRequestId.get(nri.request.requestId);
                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, (nai != null ? nai.getCurrentScore() : 0), 0, nri.request);
            }
        } else {
            loge("Error connecting NetworkFactory");
            mNetworkFactoryInfos.remove(msg.obj);
        }
    } else if (mNetworkAgentInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkAgent connected");
            // A network agent has requested a connection.  Establish the connection.
            mNetworkAgentInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
        } else {
            loge("Error connecting NetworkAgent");
            NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
            if (nai != null) {
                final boolean wasDefault = isDefaultNetwork(nai);
                synchronized (mNetworkForNetId) {
                    mNetworkForNetId.remove(nai.network.netId);
                    mNetIdInUse.delete(nai.network.netId);
                }
                // Just in case.
                mLegacyTypeTracker.remove(nai, wasDefault);
            }
        }
    }
}
#method_after
private void handleAsyncChannelHalfConnect(Message msg) {
    AsyncChannel ac = (AsyncChannel) msg.obj;
    if (mNetworkFactoryInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkFactory connected");
            // A network factory has connected.  Send it all current NetworkRequests.
            for (NetworkRequestInfo nri : mNetworkRequests.values()) {
                if (!nri.isRequest())
                    continue;
                NetworkAgentInfo nai = mNetworkForRequestId.get(nri.request.requestId);
                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, (nai != null ? nai.getCurrentScore() : 0), 0, nri.request);
            }
        } else {
            loge("Error connecting NetworkFactory");
            mNetworkFactoryInfos.remove(msg.obj);
        }
    } else if (mNetworkAgentInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkAgent connected");
            // A network agent has requested a connection.  Establish the connection.
            mNetworkAgentInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
        } else {
            loge("Error connecting NetworkAgent");
            NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
            if (nai != null) {
                final boolean wasDefault = isDefaultNetwork(nai);
                synchronized (mNetworkForNetId) {
                    mNetworkForNetId.remove(nai.network.netId);
                    mNetIdInUse.delete(nai.network.netId);
                }
                // Just in case.
                mLegacyTypeTracker.remove(nai, wasDefault);
            }
        }
    }
}
#end_block

#method_before
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.networkRequests.size());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
        }
        notifyIfacesChanged();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        updateClat(null, nai.linkProperties, nai);
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.networkRequests.size(); i++) {
            NetworkRequest request = nai.networkRequests.valueAt(i);
            NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                mNetworkForRequestId.remove(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        if (nai.networkRequests.get(mDefaultRequest.requestId) != null) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            requestNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#method_after
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.networkRequests.size());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            logDefaultNetworkEvent(null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        updateClat(null, nai.linkProperties, nai);
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.networkRequests.size(); i++) {
            NetworkRequest request = nai.networkRequests.valueAt(i);
            NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                mNetworkForRequestId.remove(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        if (nai.networkRequests.get(mDefaultRequest.requestId) != null) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            requestNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#end_block

#method_before
private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
    mNetworkRequests.put(nri.request, nri);
    mNetworkRequestInfoLogs.log("REGISTER " + nri);
    if (!nri.isRequest) {
        for (NetworkAgentInfo network : mNetworkAgentInfos.values()) {
            if (nri.request.networkCapabilities.hasSignalStrength() && network.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(network, "REGISTER", nri.request);
            }
        }
    }
    rematchAllNetworksAndRequests(null, 0);
    if (nri.isRequest && mNetworkForRequestId.get(nri.request.requestId) == null) {
        sendUpdatedScoreToFactories(nri.request, 0);
    }
}
#method_after
private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
    mNetworkRequests.put(nri.request, nri);
    mNetworkRequestInfoLogs.log("REGISTER " + nri);
    if (!nri.isRequest()) {
        for (NetworkAgentInfo network : mNetworkAgentInfos.values()) {
            if (nri.request.networkCapabilities.hasSignalStrength() && network.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(network, "REGISTER", nri.request);
            }
        }
    }
    rematchAllNetworksAndRequests(null, 0);
    if (nri.isRequest() && mNetworkForRequestId.get(nri.request.requestId) == null) {
        sendUpdatedScoreToFactories(nri.request, 0);
    }
}
#end_block

#method_before
// Is nai unneeded by all NetworkRequests (and should be disconnected)?
// This is whether it is satisfying any NetworkRequests or were it to become validated,
private boolean unneeded(NetworkAgentInfo nai) {
    if (!nai.created || nai.isVPN() || nai.lingering)
        return false;
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // there is hope for it to become one if it validated, then it is needed.
        if (nri.isRequest && nai.satisfies(nri.request) && (nai.networkRequests.get(nri.request.requestId) != null || // WiFi ends up validating and out scoring cellular.
        mNetworkForRequestId.get(nri.request.requestId).getCurrentScore() < nai.getCurrentScoreAsValidated())) {
            return false;
        }
    }
    return true;
}
#method_after
// Is nai unneeded by all NetworkRequests (and should be disconnected)?
// This is whether it is satisfying any NetworkRequests or were it to become validated,
private boolean unneeded(NetworkAgentInfo nai) {
    if (!nai.everConnected || nai.isVPN() || nai.lingering)
        return false;
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // there is hope for it to become one if it validated, then it is needed.
        if (nri.isRequest() && nai.satisfies(nri.request) && (nai.networkRequests.get(nri.request.requestId) != null || // WiFi ends up validating and out scoring cellular.
        mNetworkForRequestId.get(nri.request.requestId).getCurrentScore() < nai.getCurrentScoreAsValidated())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void handleReleaseNetworkRequest(NetworkRequest request, int callingUid) {
    NetworkRequestInfo nri = mNetworkRequests.get(request);
    if (nri != null) {
        if (Process.SYSTEM_UID != callingUid && nri.mUid != callingUid) {
            if (DBG)
                log("Attempt to release unowned NetworkRequest " + request);
            return;
        }
        if (DBG)
            log("releasing NetworkRequest " + request);
        nri.unlinkDeathRecipient();
        mNetworkRequests.remove(request);
        mNetworkRequestInfoLogs.log("RELEASE " + nri);
        if (nri.isRequest) {
            // Find all networks that are satisfying this request and remove the request
            // from their request lists.
            // TODO - it's my understanding that for a request there is only a single
            // network satisfying it, so this loop is wasteful
            boolean wasKept = false;
            for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                if (nai.networkRequests.get(nri.request.requestId) != null) {
                    nai.networkRequests.remove(nri.request.requestId);
                    if (DBG) {
                        log(" Removing from current network " + nai.name() + ", leaving " + nai.networkRequests.size() + " requests.");
                    }
                    if (unneeded(nai)) {
                        if (DBG)
                            log("no live requests for " + nai.name() + "; disconnecting");
                        teardownUnneededNetwork(nai);
                    } else {
                        // suspect there should only be one pass through here
                        // but if any were kept do the check below
                        wasKept |= true;
                    }
                }
            }
            NetworkAgentInfo nai = mNetworkForRequestId.get(nri.request.requestId);
            if (nai != null) {
                mNetworkForRequestId.remove(nri.request.requestId);
            }
            // phantom disconnect for this type.
            if (nri.request.legacyType != TYPE_NONE && nai != null) {
                boolean doRemove = true;
                if (wasKept) {
                    // same legacy type - if so, don't remove the nai
                    for (int i = 0; i < nai.networkRequests.size(); i++) {
                        NetworkRequest otherRequest = nai.networkRequests.valueAt(i);
                        if (otherRequest.legacyType == nri.request.legacyType && isRequest(otherRequest)) {
                            if (DBG)
                                log(" still have other legacy request - leaving");
                            doRemove = false;
                        }
                    }
                }
                if (doRemove) {
                    mLegacyTypeTracker.remove(nri.request.legacyType, nai, false);
                }
            }
            for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
                nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_CANCEL_REQUEST, nri.request);
            }
        } else {
            // if this listen request applies and remove it.
            for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                nai.networkRequests.remove(nri.request.requestId);
                if (nri.request.networkCapabilities.hasSignalStrength() && nai.satisfiesImmutableCapabilitiesOf(nri.request)) {
                    updateSignalStrengthThresholds(nai, "RELEASE", nri.request);
                }
            }
        }
        callCallbackForRequest(nri, null, ConnectivityManager.CALLBACK_RELEASED);
    }
}
#method_after
private void handleReleaseNetworkRequest(NetworkRequest request, int callingUid) {
    NetworkRequestInfo nri = mNetworkRequests.get(request);
    if (nri != null) {
        if (Process.SYSTEM_UID != callingUid && nri.mUid != callingUid) {
            if (DBG)
                log("Attempt to release unowned NetworkRequest " + request);
            return;
        }
        if (VDBG || (DBG && nri.isRequest()))
            log("releasing NetworkRequest " + request);
        nri.unlinkDeathRecipient();
        mNetworkRequests.remove(request);
        synchronized (mUidToNetworkRequestCount) {
            int requests = mUidToNetworkRequestCount.get(nri.mUid, 0);
            if (requests < 1) {
                Slog.wtf(TAG, "BUG: too small request count " + requests + " for UID " + nri.mUid);
            } else if (requests == 1) {
                mUidToNetworkRequestCount.removeAt(mUidToNetworkRequestCount.indexOfKey(nri.mUid));
            } else {
                mUidToNetworkRequestCount.put(nri.mUid, requests - 1);
            }
        }
        mNetworkRequestInfoLogs.log("RELEASE " + nri);
        if (nri.isRequest()) {
            // Find all networks that are satisfying this request and remove the request
            // from their request lists.
            // TODO - it's my understanding that for a request there is only a single
            // network satisfying it, so this loop is wasteful
            boolean wasKept = false;
            for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                if (nai.networkRequests.get(nri.request.requestId) != null) {
                    nai.networkRequests.remove(nri.request.requestId);
                    if (VDBG) {
                        log(" Removing from current network " + nai.name() + ", leaving " + nai.networkRequests.size() + " requests.");
                    }
                    if (unneeded(nai)) {
                        if (DBG)
                            log("no live requests for " + nai.name() + "; disconnecting");
                        teardownUnneededNetwork(nai);
                    } else {
                        // suspect there should only be one pass through here
                        // but if any were kept do the check below
                        wasKept |= true;
                    }
                }
            }
            NetworkAgentInfo nai = mNetworkForRequestId.get(nri.request.requestId);
            if (nai != null) {
                mNetworkForRequestId.remove(nri.request.requestId);
            }
            // phantom disconnect for this type.
            if (nri.request.legacyType != TYPE_NONE && nai != null) {
                boolean doRemove = true;
                if (wasKept) {
                    // same legacy type - if so, don't remove the nai
                    for (int i = 0; i < nai.networkRequests.size(); i++) {
                        NetworkRequest otherRequest = nai.networkRequests.valueAt(i);
                        if (otherRequest.legacyType == nri.request.legacyType && isRequest(otherRequest)) {
                            if (DBG)
                                log(" still have other legacy request - leaving");
                            doRemove = false;
                        }
                    }
                }
                if (doRemove) {
                    mLegacyTypeTracker.remove(nri.request.legacyType, nai, false);
                }
            }
            for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
                nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_CANCEL_REQUEST, nri.request);
            }
        } else {
            // if this listen request applies and remove it.
            for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                nai.networkRequests.remove(nri.request.requestId);
                if (nri.request.networkCapabilities.hasSignalStrength() && nai.satisfiesImmutableCapabilitiesOf(nri.request)) {
                    updateSignalStrengthThresholds(nai, "RELEASE", nri.request);
                }
            }
        }
        callCallbackForRequest(nri, null, ConnectivityManager.CALLBACK_RELEASED);
    }
}
#end_block

#method_before
private void scheduleUnvalidatedPrompt(NetworkAgentInfo nai) {
    if (DBG)
        log("scheduleUnvalidatedPrompt " + nai.network);
    mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_PROMPT_UNVALIDATED, nai.network), PROMPT_UNVALIDATED_DELAY_MS);
}
#method_after
private void scheduleUnvalidatedPrompt(NetworkAgentInfo nai) {
    if (VDBG)
        log("scheduleUnvalidatedPrompt " + nai.network);
    mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_PROMPT_UNVALIDATED, nai.network), PROMPT_UNVALIDATED_DELAY_MS);
}
#end_block

#method_before
private void handlePromptUnvalidated(Network network) {
    if (DBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // Also don't prompt on captive portals because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated) {
        return;
    }
    Intent intent = new Intent(ConnectivityManager.ACTION_PROMPT_UNVALIDATED);
    intent.setData(Uri.fromParts("netId", Integer.toString(network.netId), null));
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    intent.setClassName("com.android.settings", "com.android.settings.wifi.WifiNoInternetDialog");
    PendingIntent pendingIntent = PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, UserHandle.CURRENT);
    setProvNotificationVisibleIntent(true, nai.network.netId, NotificationType.NO_INTERNET, nai.networkInfo.getType(), nai.networkInfo.getExtraInfo(), pendingIntent, true);
}
#method_after
private void handlePromptUnvalidated(Network network) {
    if (VDBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // Also don't prompt on captive portals because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated) {
        return;
    }
    Intent intent = new Intent(ConnectivityManager.ACTION_PROMPT_UNVALIDATED);
    intent.setData(Uri.fromParts("netId", Integer.toString(network.netId), null));
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    intent.setClassName("com.android.settings", "com.android.settings.wifi.WifiNoInternetDialog");
    PendingIntent pendingIntent = PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, UserHandle.CURRENT);
    setProvNotificationVisibleIntent(true, nai.network.netId, NotificationType.NO_INTERNET, nai.networkInfo.getType(), nai.networkInfo.getExtraInfo(), pendingIntent, true);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                String causedBy = null;
                synchronized (ConnectivityService.this) {
                    if (msg.arg1 == mNetTransitionWakeLockSerialNumber && mNetTransitionWakeLock.isHeld()) {
                        mNetTransitionWakeLock.release();
                        causedBy = mNetTransitionWakeLockCausedBy;
                    } else {
                        break;
                    }
                }
                if (msg.what == EVENT_EXPIRE_NET_TRANSITION_WAKELOCK) {
                    log("Failed to find a new network - expiring NetTransition Wakelock");
                } else {
                    log("NetTransition Wakelock (" + (causedBy == null ? "unknown" : causedBy) + " cleared because we found a replacement network");
                }
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_SEND_STICKY_BROADCAST_INTENT:
            {
                Intent intent = (Intent) msg.obj;
                sendStickyBroadcast(intent);
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                handleSetAcceptUnvalidated((Network) msg.obj, msg.arg1 != 0, msg.arg2 != 0);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                break;
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                String causedBy = null;
                synchronized (ConnectivityService.this) {
                    if (msg.arg1 == mNetTransitionWakeLockSerialNumber && mNetTransitionWakeLock.isHeld()) {
                        mNetTransitionWakeLock.release();
                        causedBy = mNetTransitionWakeLockCausedBy;
                    } else {
                        break;
                    }
                }
                if (VDBG) {
                    if (msg.what == EVENT_EXPIRE_NET_TRANSITION_WAKELOCK) {
                        log("Failed to find a new network - expiring NetTransition Wakelock");
                    } else {
                        log("NetTransition Wakelock (" + (causedBy == null ? "unknown" : causedBy) + " cleared because we found a replacement network");
                    }
                }
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                handleSetAcceptUnvalidated((Network) msg.obj, msg.arg1 != 0, msg.arg2 != 0);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                break;
            }
    }
}
#end_block

#method_before
public int tether(String iface) {
    ConnectivityManager.enforceTetherChangePermission(mContext);
    if (isTetheringSupported()) {
        return mTethering.tether(iface);
    } else {
        return ConnectivityManager.TETHER_ERROR_UNSUPPORTED;
    }
}
#method_after
public int tether(String iface) {
    ConnectivityManager.enforceTetherChangePermission(mContext);
    if (isTetheringSupported()) {
        final int status = mTethering.tether(iface);
        if (status == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
            try {
                mPolicyManager.onTetheringChanged(iface, true);
            } catch (RemoteException e) {
            }
        }
        return status;
    } else {
        return ConnectivityManager.TETHER_ERROR_UNSUPPORTED;
    }
}
#end_block

#method_before
public int untether(String iface) {
    ConnectivityManager.enforceTetherChangePermission(mContext);
    if (isTetheringSupported()) {
        return mTethering.untether(iface);
    } else {
        return ConnectivityManager.TETHER_ERROR_UNSUPPORTED;
    }
}
#method_after
public int untether(String iface) {
    ConnectivityManager.enforceTetherChangePermission(mContext);
    if (isTetheringSupported()) {
        final int status = mTethering.untether(iface);
        if (status == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
            try {
                mPolicyManager.onTetheringChanged(iface, false);
            } catch (RemoteException e) {
            }
        }
        return status;
    } else {
        return ConnectivityManager.TETHER_ERROR_UNSUPPORTED;
    }
}
#end_block

#method_before
// if ro.tether.denied = true we default to no tethering
// gservices could set the secure setting to 1 though to enable it on a build where it
public boolean isTetheringSupported() {
    enforceTetherAccessPermission();
    int defaultVal = (SystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1);
    boolean tetherEnabledInSettings = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TETHER_SUPPORTED, defaultVal) != 0) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING);
    return tetherEnabledInSettings && ((mTethering.getTetherableUsbRegexs().length != 0 || mTethering.getTetherableWifiRegexs().length != 0 || mTethering.getTetherableBluetoothRegexs().length != 0) && mTethering.getUpstreamIfaceTypes().length != 0);
}
#method_after
// if ro.tether.denied = true we default to no tethering
// gservices could set the secure setting to 1 though to enable it on a build where it
@Override
public boolean isTetheringSupported() {
    enforceTetherAccessPermission();
    int defaultVal = (SystemProperties.get("ro.tether.denied").equals("true") ? 0 : 1);
    boolean tetherEnabledInSettings = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TETHER_SUPPORTED, defaultVal) != 0) && !mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING);
    return tetherEnabledInSettings && mUserManager.isAdminUser() && ((mTethering.getTetherableUsbRegexs().length != 0 || mTethering.getTetherableWifiRegexs().length != 0 || mTethering.getTetherableBluetoothRegexs().length != 0) && mTethering.getUpstreamIfaceTypes().length != 0);
}
#end_block

#method_before
public void reportNetworkConnectivity(Network network, boolean hasConnectivity) {
    enforceAccessPermission();
    enforceInternetPermission();
    NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated)
        return;
    final int uid = Binder.getCallingUid();
    if (DBG) {
        log("reportNetworkConnectivity(" + nai.network.netId + ", " + hasConnectivity + ") by " + uid);
    }
    synchronized (nai) {
        // which isn't meant to work on uncreated networks.
        if (!nai.created)
            return;
        if (isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid))
            return;
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid);
    }
}
#method_after
public void reportNetworkConnectivity(Network network, boolean hasConnectivity) {
    enforceAccessPermission();
    enforceInternetPermission();
    NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated)
        return;
    final int uid = Binder.getCallingUid();
    if (DBG) {
        log("reportNetworkConnectivity(" + nai.network.netId + ", " + hasConnectivity + ") by " + uid);
    }
    synchronized (nai) {
        // rematchNetworkAndRequests() which is not meant to work on such networks.
        if (!nai.everConnected)
            return;
        if (isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, false))
            return;
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid);
    }
}
#end_block

#method_before
@Override
public LegacyVpnInfo getLegacyVpnInfo(int userId) {
    enforceCrossUserPermission(userId);
    if (mLockdownEnabled) {
        return null;
    }
    synchronized (mVpns) {
        return mVpns.get(userId).getLegacyVpnInfo();
    }
}
#method_after
@Override
public LegacyVpnInfo getLegacyVpnInfo(int userId) {
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        return mVpns.get(userId).getLegacyVpnInfo();
    }
}
#end_block

#method_before
@Override
public boolean updateLockdownVpn() {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        Slog.w(TAG, "Lockdown VPN only available to AID_SYSTEM");
        return false;
    }
    // Tear down existing lockdown if profile was removed
    mLockdownEnabled = LockdownVpnTracker.isEnabled();
    if (mLockdownEnabled) {
        if (!mKeyStore.isUnlocked()) {
            Slog.w(TAG, "KeyStore locked; unable to create LockdownTracker");
            return false;
        }
        final String profileName = new String(mKeyStore.get(Credentials.LOCKDOWN_VPN));
        final VpnProfile profile = VpnProfile.decode(profileName, mKeyStore.get(Credentials.VPN + profileName));
        if (profile == null) {
            Slog.e(TAG, "Lockdown VPN configured invalid profile " + profileName);
            setLockdownTracker(null);
            return true;
        }
        int user = UserHandle.getUserId(Binder.getCallingUid());
        synchronized (mVpns) {
            setLockdownTracker(new LockdownVpnTracker(mContext, mNetd, this, mVpns.get(user), profile));
        }
    } else {
        setLockdownTracker(null);
    }
    return true;
}
#method_after
@Override
public boolean updateLockdownVpn() {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        Slog.w(TAG, "Lockdown VPN only available to AID_SYSTEM");
        return false;
    }
    // Tear down existing lockdown if profile was removed
    mLockdownEnabled = LockdownVpnTracker.isEnabled();
    if (mLockdownEnabled) {
        final String profileName = new String(mKeyStore.get(Credentials.LOCKDOWN_VPN));
        final VpnProfile profile = VpnProfile.decode(profileName, mKeyStore.get(Credentials.VPN + profileName));
        if (profile == null) {
            Slog.e(TAG, "Lockdown VPN configured invalid profile " + profileName);
            setLockdownTracker(null);
            return true;
        }
        int user = UserHandle.getUserId(Binder.getCallingUid());
        synchronized (mVpns) {
            Vpn vpn = mVpns.get(user);
            if (vpn == null) {
                Slog.w(TAG, "VPN for user " + user + " not ready yet. Skipping lockdown");
                return false;
            }
            setLockdownTracker(new LockdownVpnTracker(mContext, mNetd, this, vpn, profile));
        }
    } else {
        setLockdownTracker(null);
    }
    return true;
}
#end_block

#method_before
private void setProvNotificationVisible(boolean visible, int networkType, String action) {
    if (DBG) {
        log("setProvNotificationVisible: E visible=" + visible + " networkType=" + networkType + " action=" + action);
    }
    Intent intent = new Intent(action);
    PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, intent, 0);
    // Concatenate the range of types onto the range of NetIDs.
    int id = MAX_NET_ID + 1 + (networkType - ConnectivityManager.TYPE_NONE);
    setProvNotificationVisibleIntent(visible, id, NotificationType.SIGN_IN, networkType, null, pendingIntent, false);
}
#method_after
private void setProvNotificationVisible(boolean visible, int networkType, String action) {
    Intent intent = new Intent(action);
    PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, intent, 0);
    // Concatenate the range of types onto the range of NetIDs.
    int id = MAX_NET_ID + 1 + (networkType - ConnectivityManager.TYPE_NONE);
    setProvNotificationVisibleIntent(visible, id, NotificationType.SIGN_IN, networkType, null, pendingIntent, false);
}
#end_block

#method_before
private void setProvNotificationVisibleIntent(boolean visible, int id, NotificationType notifyType, int networkType, String extraInfo, PendingIntent intent, boolean highPriority) {
    if (DBG) {
        log("setProvNotificationVisibleIntent " + notifyType + " visible=" + visible + " networkType=" + getNetworkTypeName(networkType) + " extraInfo=" + extraInfo + " highPriority=" + highPriority);
    }
    Resources r = Resources.getSystem();
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (visible) {
        CharSequence title;
        CharSequence details;
        int icon;
        if (notifyType == NotificationType.NO_INTERNET && networkType == ConnectivityManager.TYPE_WIFI) {
            title = r.getString(R.string.wifi_no_internet, 0);
            details = r.getString(R.string.wifi_no_internet_detailed);
            // TODO: Need new icon.
            icon = R.drawable.stat_notify_wifi_in_range;
        } else if (notifyType == NotificationType.SIGN_IN) {
            switch(networkType) {
                case ConnectivityManager.TYPE_WIFI:
                    title = r.getString(R.string.wifi_available_sign_in, 0);
                    details = r.getString(R.string.network_available_sign_in_detailed, extraInfo);
                    icon = R.drawable.stat_notify_wifi_in_range;
                    break;
                case ConnectivityManager.TYPE_MOBILE:
                case ConnectivityManager.TYPE_MOBILE_HIPRI:
                    title = r.getString(R.string.network_available_sign_in, 0);
                    // TODO: Change this to pull from NetworkInfo once a printable
                    // name has been added to it
                    details = mTelephonyManager.getNetworkOperatorName();
                    icon = R.drawable.stat_notify_rssi_in_range;
                    break;
                default:
                    title = r.getString(R.string.network_available_sign_in, 0);
                    details = r.getString(R.string.network_available_sign_in_detailed, extraInfo);
                    icon = R.drawable.stat_notify_rssi_in_range;
                    break;
            }
        } else {
            Slog.wtf(TAG, "Unknown notification type " + notifyType + "on network type " + getNetworkTypeName(networkType));
            return;
        }
        Notification notification = new Notification.Builder(mContext).setWhen(0).setSmallIcon(icon).setAutoCancel(true).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).setContentIntent(intent).setLocalOnly(true).setPriority(highPriority ? Notification.PRIORITY_HIGH : Notification.PRIORITY_DEFAULT).setDefaults(highPriority ? Notification.DEFAULT_ALL : 0).setOnlyAlertOnce(true).build();
        try {
            notificationManager.notify(NOTIFICATION_ID, id, notification);
        } catch (NullPointerException npe) {
            loge("setNotificationVisible: visible notificationManager npe=" + npe);
            npe.printStackTrace();
        }
    } else {
        try {
            notificationManager.cancel(NOTIFICATION_ID, id);
        } catch (NullPointerException npe) {
            loge("setNotificationVisible: cancel notificationManager npe=" + npe);
            npe.printStackTrace();
        }
    }
}
#method_after
private void setProvNotificationVisibleIntent(boolean visible, int id, NotificationType notifyType, int networkType, String extraInfo, PendingIntent intent, boolean highPriority) {
    if (VDBG || (DBG && visible)) {
        log("setProvNotificationVisibleIntent " + notifyType + " visible=" + visible + " networkType=" + getNetworkTypeName(networkType) + " extraInfo=" + extraInfo + " highPriority=" + highPriority);
    }
    Resources r = Resources.getSystem();
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (visible) {
        CharSequence title;
        CharSequence details;
        int icon;
        if (notifyType == NotificationType.NO_INTERNET && networkType == ConnectivityManager.TYPE_WIFI) {
            title = r.getString(R.string.wifi_no_internet, 0);
            details = r.getString(R.string.wifi_no_internet_detailed);
            // TODO: Need new icon.
            icon = R.drawable.stat_notify_wifi_in_range;
        } else if (notifyType == NotificationType.SIGN_IN) {
            switch(networkType) {
                case ConnectivityManager.TYPE_WIFI:
                    title = r.getString(R.string.wifi_available_sign_in, 0);
                    details = r.getString(R.string.network_available_sign_in_detailed, extraInfo);
                    icon = R.drawable.stat_notify_wifi_in_range;
                    break;
                case ConnectivityManager.TYPE_MOBILE:
                case ConnectivityManager.TYPE_MOBILE_HIPRI:
                    title = r.getString(R.string.network_available_sign_in, 0);
                    // TODO: Change this to pull from NetworkInfo once a printable
                    // name has been added to it
                    details = mTelephonyManager.getNetworkOperatorName();
                    icon = R.drawable.stat_notify_rssi_in_range;
                    break;
                default:
                    title = r.getString(R.string.network_available_sign_in, 0);
                    details = r.getString(R.string.network_available_sign_in_detailed, extraInfo);
                    icon = R.drawable.stat_notify_rssi_in_range;
                    break;
            }
        } else {
            Slog.wtf(TAG, "Unknown notification type " + notifyType + "on network type " + getNetworkTypeName(networkType));
            return;
        }
        Notification notification = new Notification.Builder(mContext).setWhen(0).setSmallIcon(icon).setAutoCancel(true).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).setContentIntent(intent).setLocalOnly(true).setPriority(highPriority ? Notification.PRIORITY_HIGH : Notification.PRIORITY_DEFAULT).setDefaults(highPriority ? Notification.DEFAULT_ALL : 0).setOnlyAlertOnce(true).build();
        try {
            notificationManager.notifyAsUser(NOTIFICATION_ID, id, notification, UserHandle.ALL);
        } catch (NullPointerException npe) {
            loge("setNotificationVisible: visible notificationManager npe=" + npe);
            npe.printStackTrace();
        }
    } else {
        try {
            notificationManager.cancelAsUser(NOTIFICATION_ID, id, UserHandle.ALL);
        } catch (NullPointerException npe) {
            loge("setNotificationVisible: cancel notificationManager npe=" + npe);
            npe.printStackTrace();
        }
    }
}
#end_block

#method_before
private void onUserStart(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn != null) {
            loge("Starting user already has a VPN");
            return;
        }
        userVpn = new Vpn(mHandler.getLooper(), mContext, mNetd, userId);
        mVpns.put(userId, userVpn);
    }
}
#method_after
private void onUserStart(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn != null) {
            loge("Starting user already has a VPN");
            return;
        }
        userVpn = new Vpn(mHandler.getLooper(), mContext, mNetd, userId);
        mVpns.put(userId, userVpn);
        final ContentResolver cr = mContext.getContentResolver();
        String alwaysOnPackage = Settings.Secure.getStringForUser(cr, Settings.Secure.ALWAYS_ON_VPN_APP, userId);
        final boolean alwaysOnLockdown = Settings.Secure.getIntForUser(cr, Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, /* default */
        0, userId) != 0;
        if (alwaysOnPackage != null) {
            userVpn.setAlwaysOnPackage(alwaysOnPackage, alwaysOnLockdown);
        }
    }
    if (mUserManager.getUserInfo(userId).isPrimary() && LockdownVpnTracker.isEnabled()) {
        updateLockdownVpn();
    }
}
#end_block

#method_before
private void onUserStop(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn == null) {
            loge("Stopping user has no VPN");
            return;
        }
        mVpns.delete(userId);
    }
}
#method_after
private void onUserStop(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn == null) {
            loge("Stopped user has no VPN");
            return;
        }
        userVpn.onUserStopped();
        mVpns.delete(userId);
    }
}
#end_block

#method_before
public String toString() {
    return (isRequest ? "Request" : "Listen") + " from uid/pid:" + mUid + "/" + mPid + " for " + request + (mPendingIntent == null ? "" : " to trigger " + mPendingIntent);
}
#method_after
public String toString() {
    return typeString() + " from uid/pid:" + mUid + "/" + mPid + " for " + request + (mPendingIntent == null ? "" : " to trigger " + mPendingIntent);
}
#end_block

#method_before
private void updateSignalStrengthThresholds(NetworkAgentInfo nai, String reason, NetworkRequest request) {
    ArrayList<Integer> thresholdsArray = getSignalStrengthThresholds(nai);
    Bundle thresholds = new Bundle();
    thresholds.putIntegerArrayList("thresholds", thresholdsArray);
    // TODO: Switch to VDBG.
    if (DBG) {
        String detail;
        if (request != null && request.networkCapabilities.hasSignalStrength()) {
            detail = reason + " " + request.networkCapabilities.getSignalStrength();
        } else {
            detail = reason;
        }
        log(String.format("updateSignalStrengthThresholds: %s, sending %s to %s", detail, Arrays.toString(thresholdsArray.toArray()), nai.name()));
    }
    nai.asyncChannel.sendMessage(android.net.NetworkAgent.CMD_SET_SIGNAL_STRENGTH_THRESHOLDS, 0, 0, thresholds);
}
#method_after
private void updateSignalStrengthThresholds(NetworkAgentInfo nai, String reason, NetworkRequest request) {
    ArrayList<Integer> thresholdsArray = getSignalStrengthThresholds(nai);
    Bundle thresholds = new Bundle();
    thresholds.putIntegerArrayList("thresholds", thresholdsArray);
    if (VDBG || (DBG && !"CONNECT".equals(reason))) {
        String detail;
        if (request != null && request.networkCapabilities.hasSignalStrength()) {
            detail = reason + " " + request.networkCapabilities.getSignalStrength();
        } else {
            detail = reason;
        }
        log(String.format("updateSignalStrengthThresholds: %s, sending %s to %s", detail, Arrays.toString(thresholdsArray.toArray()), nai.name()));
    }
    nai.asyncChannel.sendMessage(android.net.NetworkAgent.CMD_SET_SIGNAL_STRENGTH_THRESHOLDS, 0, 0, thresholds);
}
#end_block

#method_before
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    if (timeoutMs < 0 || timeoutMs > ConnectivityManager.MAX_NETWORK_REQUEST_TIMEOUT_MS) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId());
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder, NetworkRequestInfo.REQUEST);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#method_after
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequestType type = (networkCapabilities == null) ? NetworkRequestType.TRACK_DEFAULT : NetworkRequestType.REQUEST;
    // the system default network.
    if (type == NetworkRequestType.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
    }
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    if (timeoutMs < 0 || timeoutMs > ConnectivityManager.MAX_NETWORK_REQUEST_TIMEOUT_MS) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    if (NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER.equals(networkCapabilities.getNetworkSpecifier())) {
        throw new IllegalArgumentException("Invalid network specifier - must not be '" + NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER + "'");
    }
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId());
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder, type);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#end_block

#method_before
private void enforceMeteredApnPolicy(NetworkCapabilities networkCapabilities) {
    // if UID is restricted, don't allow them to bring up metered APNs
    if (networkCapabilities.hasCapability(NET_CAPABILITY_NOT_METERED) == false) {
        final int uidRules;
        final int uid = Binder.getCallingUid();
        synchronized (mRulesLock) {
            uidRules = mUidRules.get(uid, RULE_ALLOW_ALL);
        }
        if (uidRules != RULE_ALLOW_ALL) {
            // we could silently fail or we can filter the available nets to only give
            // them those they have access to.  Chose the more useful
            networkCapabilities.addCapability(NET_CAPABILITY_NOT_METERED);
        }
    }
}
#method_after
private void enforceMeteredApnPolicy(NetworkCapabilities networkCapabilities) {
    final int uid = Binder.getCallingUid();
    if (isSystem(uid)) {
        return;
    }
    // if UID is restricted, don't allow them to bring up metered APNs
    if (networkCapabilities.hasCapability(NET_CAPABILITY_NOT_METERED) == false) {
        final int uidRules;
        synchronized (mRulesLock) {
            uidRules = mUidRules.get(uid, RULE_ALLOW_ALL);
        }
        if (mRestrictBackground && (uidRules & RULE_ALLOW_METERED) == 0 && (uidRules & RULE_TEMPORARY_ALLOW_METERED) == 0) {
            // we could silently fail or we can filter the available nets to only give
            // them those they have access to.  Chose the more useful option.
            networkCapabilities.addCapability(NET_CAPABILITY_NOT_METERED);
        }
    }
}
#end_block

#method_before
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId());
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation, NetworkRequestInfo.REQUEST);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId());
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation, NetworkRequestType.REQUEST);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkRequest networkRequest = new NetworkRequest(new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId());
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder, NetworkRequestInfo.LISTEN);
    if (DBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkRequest networkRequest = new NetworkRequest(new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId());
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder, NetworkRequestType.LISTEN);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkRequest networkRequest = new NetworkRequest(new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId());
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation, NetworkRequestInfo.LISTEN);
    if (DBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#method_after
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkRequest networkRequest = new NetworkRequest(new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId());
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation, NetworkRequestType.LISTEN);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), new LinkProperties(linkProperties), new NetworkCapabilities(networkCapabilities), currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network);
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), new LinkProperties(linkProperties), new NetworkCapabilities(networkCapabilities), currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, networkInfo.getExtraInfo());
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = networkAgent.linkProperties;
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    // TODO: deprecate and remove mDefaultDns when we can do so safely. See http://b/18327075
    // In L, we used it only when the network had Internet access but provided no DNS servers.
    // For now, just disable it, and if disabling it doesn't break things, remove it.
    // final boolean useDefaultDns = networkAgent.networkCapabilities.hasCapability(
    // NET_CAPABILITY_INTERNET);
    final boolean useDefaultDns = false;
    final boolean flushDns = updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId, flushDns, useDefaultDns);
    updateClat(newLp, oldLp, networkAgent);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp, networkAgent);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        notifyIfacesChanged();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = networkAgent.linkProperties;
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    updateClat(newLp, oldLp, networkAgent);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp, networkAgent);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) {
    CompareResult<RouteInfo> routeDiff = new CompareResult<RouteInfo>();
    if (oldLp != null) {
        routeDiff = oldLp.compareAllRoutes(newLp);
    } else if (newLp != null) {
        routeDiff.added = newLp.getAllRoutes();
    }
    // do this twice, adding non-nexthop routes first, then routes they are dependent on
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway())
            continue;
        if (DBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getDestination().getAddress() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for non-gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway() == false)
            continue;
        if (DBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getGateway() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.removed) {
        if (DBG)
            log("Removing Route [" + route + "] from network " + netId);
        try {
            mNetd.removeRoute(netId, route);
        } catch (Exception e) {
            loge("Exception in removeRoute: " + e);
        }
    }
    return !routeDiff.added.isEmpty() || !routeDiff.removed.isEmpty();
}
#method_after
private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) {
    CompareResult<RouteInfo> routeDiff = new CompareResult<RouteInfo>();
    if (oldLp != null) {
        routeDiff = oldLp.compareAllRoutes(newLp);
    } else if (newLp != null) {
        routeDiff.added = newLp.getAllRoutes();
    }
    // do this twice, adding non-nexthop routes first, then routes they are dependent on
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway())
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getDestination().getAddress() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for non-gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway() == false)
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getGateway() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.removed) {
        if (VDBG)
            log("Removing Route [" + route + "] from network " + netId);
        try {
            mNetd.removeRoute(netId, route);
        } catch (Exception e) {
            loge("Exception in removeRoute: " + e);
        }
    }
    return !routeDiff.added.isEmpty() || !routeDiff.removed.isEmpty();
}
#end_block

#method_before
private void updateDnses(LinkProperties newLp, LinkProperties oldLp, int netId, boolean flush, boolean useDefaultDns) {
    if (oldLp == null || (newLp.isIdenticalDnses(oldLp) == false)) {
        Collection<InetAddress> dnses = newLp.getDnsServers();
        if (dnses.size() == 0 && mDefaultDns != null && useDefaultDns) {
            dnses = new ArrayList();
            dnses.add(mDefaultDns);
            if (DBG) {
                loge("no dns provided for netId " + netId + ", so using defaults");
            }
        }
        if (DBG)
            log("Setting Dns servers for network " + netId + " to " + dnses);
        try {
            mNetd.setDnsServersForNetwork(netId, NetworkUtils.makeStrings(dnses), newLp.getDomains());
        } catch (Exception e) {
            loge("Exception in setDnsServersForNetwork: " + e);
        }
        final NetworkAgentInfo defaultNai = getDefaultNetwork();
        if (defaultNai != null && defaultNai.network.netId == netId) {
            setDefaultDnsSystemProperties(dnses);
        }
        flushVmDnsCache();
    } else if (flush) {
        try {
            mNetd.flushNetworkDnsCache(netId);
        } catch (Exception e) {
            loge("Exception in flushNetworkDnsCache: " + e);
        }
        flushVmDnsCache();
    }
}
#method_after
private void updateDnses(LinkProperties newLp, LinkProperties oldLp, int netId) {
    if (oldLp != null && newLp.isIdenticalDnses(oldLp)) {
        // no updating necessary
        return;
    }
    Collection<InetAddress> dnses = newLp.getDnsServers();
    if (DBG)
        log("Setting DNS servers for network " + netId + " to " + dnses);
    try {
        mNetd.setDnsConfigurationForNetwork(netId, NetworkUtils.makeStrings(dnses), newLp.getDomains());
    } catch (Exception e) {
        loge("Exception in setDnsConfigurationForNetwork: " + e);
    }
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    if (defaultNai != null && defaultNai.network.netId == netId) {
        setDefaultDnsSystemProperties(dnses);
    }
    flushVmDnsCache();
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks) {
    if (!newNetwork.created)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    if (VDBG)
        log(" network has: " + newNetwork.networkCapabilities);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            if (!nri.isRequest) {
                // Add it to newNetwork regardless of score.
                if (newNetwork.addRequest(nri.request))
                    addedRequests.add(nri);
                continue;
            }
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + newNetwork.getCurrentScore());
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < newNetwork.getCurrentScore()) {
                if (DBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (DBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.networkRequests.remove(nri.request.requestId);
                    currentNetwork.networkLingered.add(nri.request);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (DBG)
                        log("   accepting network in place of null");
                }
                unlinger(newNetwork);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, newNetwork.getCurrentScore());
                if (mDefaultRequest.requestId == nri.request.requestId) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                }
            }
        } else if (newNetwork.networkRequests.get(nri.request.requestId) != null) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.networkRequests.remove(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                if (nri.isRequest == true) {
                    Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
                }
            }
            // TODO: technically, sending CALLBACK_LOST here is
            // incorrect if nri is a request (not a listen) and there
            // is a replacement network currently connected that can
            // satisfy it. However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST);
        }
    }
    // Linger any networks that are no longer needed.
    for (NetworkAgentInfo nai : affectedNetworks) {
        if (nai.lingering) {
        // Already lingered.  Nothing to do.  This can only happen if "nai" is in
        // "affectedNetworks" twice.  The reasoning being that to get added to
        // "affectedNetworks", "nai" must have been satisfying a NetworkRequest
        // (i.e. not lingered) so it could have only been lingered by this loop.
        // unneeded(nai) will be false and we'll call unlinger() below which would
        // be bad, so handle it here.
        } else if (unneeded(nai)) {
            linger(nai);
        } else {
            // Clear nai.networkLingered we might have added above.
            unlinger(nai);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        synchronized (ConnectivityService.this) {
            // to reconnect over the new network
            if (mNetTransitionWakeLock.isHeld()) {
                mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK, mNetTransitionWakeLockSerialNumber, 0), 1000);
            }
        }
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkCallback(newNetwork, nri);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.networkRequests.size(); i++) {
            NetworkRequest nr = newNetwork.networkRequests.valueAt(i);
            if (nr.legacyType != TYPE_NONE && isRequest(nr)) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai)) {
                if (DBG)
                    log("Reaping " + nai.name());
                teardownUnneededNetwork(nai);
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    if (VDBG)
        log(" network has: " + newNetwork.networkCapabilities);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            if (!nri.isRequest()) {
                // Add it to newNetwork regardless of score.
                if (newNetwork.addRequest(nri.request))
                    addedRequests.add(nri);
                continue;
            }
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + newNetwork.getCurrentScore());
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < newNetwork.getCurrentScore()) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.networkRequests.remove(nri.request.requestId);
                    currentNetwork.networkLingered.add(nri.request);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                unlinger(newNetwork);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, newNetwork.getCurrentScore());
                if (mDefaultRequest.requestId == nri.request.requestId) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                }
            }
        } else if (newNetwork.networkRequests.get(nri.request.requestId) != null) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.networkRequests.remove(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                if (nri.isRequest()) {
                    Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
                }
            }
            // TODO: technically, sending CALLBACK_LOST here is
            // incorrect if nri is a request (not a listen) and there
            // is a replacement network currently connected that can
            // satisfy it. However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST);
        }
    }
    // Linger any networks that are no longer needed.
    for (NetworkAgentInfo nai : affectedNetworks) {
        if (nai.lingering) {
        // Already lingered.  Nothing to do.  This can only happen if "nai" is in
        // "affectedNetworks" twice.  The reasoning being that to get added to
        // "affectedNetworks", "nai" must have been satisfying a NetworkRequest
        // (i.e. not lingered) so it could have only been lingered by this loop.
        // unneeded(nai) will be false and we'll call unlinger() below which would
        // be bad, so handle it here.
        } else if (unneeded(nai)) {
            linger(nai);
        } else {
            // Clear nai.networkLingered we might have added above.
            unlinger(nai);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        synchronized (ConnectivityService.this) {
            // to reconnect over the new network
            if (mNetTransitionWakeLock.isHeld()) {
                mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK, mNetTransitionWakeLockSerialNumber, 0), 1000);
            }
        }
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkCallback(newNetwork, nri);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.networkRequests.size(); i++) {
            NetworkRequest nr = newNetwork.networkRequests.valueAt(i);
            if (nr.legacyType != TYPE_NONE && isRequest(nr)) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai)) {
                if (DBG)
                    log("Reaping " + nai.name());
                teardownUnneededNetwork(nai);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (oldInfo != null && oldInfo.getState() == state) {
        if (VDBG)
            log("ignoring duplicate network state non-change");
        return;
    }
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (state == NetworkInfo.State.CONNECTED && !networkAgent.created) {
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, networkAgent.networkCapabilities.hasCapability(NET_CAPABILITY_NOT_RESTRICTED) ? null : NetworkManagementService.PERMISSION_SYSTEM);
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
        updateLinkProperties(networkAgent, null);
        notifyIfacesChanged();
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: rescore and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (oldInfo != null && oldInfo.getState() == state) {
        if (oldInfo.isRoaming() != newInfo.isRoaming()) {
            if (VDBG)
                log("roaming status changed, notifying NetworkStatsService");
            notifyIfacesChangedForNetworkStats();
        } else if (VDBG)
            log("ignoring duplicate network state non-change");
        // In either case, no further work should be needed.
        return;
    }
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, networkAgent.networkCapabilities.hasCapability(NET_CAPABILITY_NOT_RESTRICTED) ? null : NetworkManagementService.PERMISSION_SYSTEM);
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        updateLinkProperties(networkAgent, null);
        notifyIfacesChangedForNetworkStats();
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: rescore and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
private void updateNetworkScore(NetworkAgentInfo nai, int score) {
    if (DBG)
        log("updateNetworkScore for " + nai.name() + " to " + score);
    if (score < 0) {
        loge("updateNetworkScore for " + nai.name() + " got a negative score (" + score + ").  Bumping score to min of 0");
        score = 0;
    }
    final int oldScore = nai.getCurrentScore();
    nai.setCurrentScore(score);
    rematchAllNetworksAndRequests(nai, oldScore);
    sendUpdatedScoreToFactories(nai);
}
#method_after
private void updateNetworkScore(NetworkAgentInfo nai, int score) {
    if (VDBG)
        log("updateNetworkScore for " + nai.name() + " to " + score);
    if (score < 0) {
        loge("updateNetworkScore for " + nai.name() + " got a negative score (" + score + ").  Bumping score to min of 0");
        score = 0;
    }
    final int oldScore = nai.getCurrentScore();
    nai.setCurrentScore(score);
    rematchAllNetworksAndRequests(nai, oldScore);
    sendUpdatedScoreToFactories(nai);
}
#end_block

#method_before
protected void notifyNetworkCallbacks(NetworkAgentInfo networkAgent, int notifyType) {
    if (DBG)
        log("notifyType " + notifyTypeToName(notifyType) + " for " + networkAgent.name());
    for (int i = 0; i < networkAgent.networkRequests.size(); i++) {
        NetworkRequest nr = networkAgent.networkRequests.valueAt(i);
        NetworkRequestInfo nri = mNetworkRequests.get(nr);
        if (VDBG)
            log(" sending notification for " + nr);
        if (nri.mPendingIntent == null) {
            callCallbackForRequest(nri, networkAgent, notifyType);
        } else {
            sendPendingIntentForRequest(nri, networkAgent, notifyType);
        }
    }
}
#method_after
protected void notifyNetworkCallbacks(NetworkAgentInfo networkAgent, int notifyType) {
    if (VDBG)
        log("notifyType " + notifyTypeToName(notifyType) + " for " + networkAgent.name());
    for (int i = 0; i < networkAgent.networkRequests.size(); i++) {
        NetworkRequest nr = networkAgent.networkRequests.valueAt(i);
        NetworkRequestInfo nri = mNetworkRequests.get(nr);
        if (VDBG)
            log(" sending notification for " + nr);
        if (nri.mPendingIntent == null) {
            callCallbackForRequest(nri, networkAgent, notifyType);
        } else {
            sendPendingIntentForRequest(nri, networkAgent, notifyType);
        }
    }
}
#end_block

#method_before
@Override
public boolean setUnderlyingNetworksForVpn(Network[] networks) {
    throwIfLockdownEnabled();
    int user = UserHandle.getUserId(Binder.getCallingUid());
    boolean success;
    synchronized (mVpns) {
        success = mVpns.get(user).setUnderlyingNetworks(networks);
    }
    if (success) {
        notifyIfacesChanged();
    }
    return success;
}
#method_after
@Override
public boolean setUnderlyingNetworksForVpn(Network[] networks) {
    throwIfLockdownEnabled();
    int user = UserHandle.getUserId(Binder.getCallingUid());
    boolean success;
    synchronized (mVpns) {
        success = mVpns.get(user).setUnderlyingNetworks(networks);
    }
    if (success) {
        notifyIfacesChangedForNetworkStats();
    }
    return success;
}
#end_block

#method_before
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final int userId = UserHandle.getCallingUserId();
    // Turn airplane mode off
    setAirplaneMode(false);
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Untether
        for (String tether : getTetheredIfaces()) {
            untether(tether);
        }
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN)) {
        // Turn Always-on VPN off
        if (mLockdownEnabled) {
            mKeyStore.delete(Credentials.LOCKDOWN_VPN);
            updateLockdownVpn();
        }
        // Turn VPN off
        VpnConfig vpnConfig = getVpnConfig(userId);
        if (vpnConfig != null) {
            if (vpnConfig.legacy) {
                prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN, userId);
            } else {
                // Prevent this app (packagename = vpnConfig.user) from initiating VPN connections
                // in the future without user intervention.
                setVpnPackageAuthorization(vpnConfig.user, userId, false);
                prepareVpn(vpnConfig.user, VpnConfig.LEGACY_VPN, userId);
            }
        }
    }
}
#method_after
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final int userId = UserHandle.getCallingUserId();
    // Turn airplane mode off
    setAirplaneMode(false);
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Untether
        for (String tether : getTetheredIfaces()) {
            untether(tether);
        }
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN)) {
        // Remove always-on package
        synchronized (mVpns) {
            final String alwaysOnPackage = getAlwaysOnVpnPackage(userId);
            if (alwaysOnPackage != null) {
                setAlwaysOnVpnPackage(userId, null, false);
                setVpnPackageAuthorization(alwaysOnPackage, userId, false);
            }
        }
        // Turn Always-on VPN off
        if (mLockdownEnabled && userId == UserHandle.USER_SYSTEM) {
            final long ident = Binder.clearCallingIdentity();
            try {
                mKeyStore.delete(Credentials.LOCKDOWN_VPN);
                mLockdownEnabled = false;
                setLockdownTracker(null);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
        // Turn VPN off
        VpnConfig vpnConfig = getVpnConfig(userId);
        if (vpnConfig != null) {
            if (vpnConfig.legacy) {
                prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN, userId);
            } else {
                // Prevent this app (packagename = vpnConfig.user) from initiating VPN connections
                // in the future without user intervention.
                setVpnPackageAuthorization(vpnConfig.user, userId, false);
                prepareVpn(null, VpnConfig.LEGACY_VPN, userId);
            }
        }
    }
}
#end_block

#method_before
public boolean isUsb(String iface) {
    for (String regex : tetherableUsbRegexs) {
        if (iface.matches(regex))
            return true;
    }
    return false;
}
#method_after
public boolean isUsb(String iface) {
    return matchesDownstreamRegexs(iface, tetherableUsbRegexs);
}
#end_block

#method_before
public boolean isWifi(String iface) {
    for (String regex : tetherableWifiRegexs) {
        if (iface.matches(regex))
            return true;
    }
    return false;
}
#method_after
public boolean isWifi(String iface) {
    return matchesDownstreamRegexs(iface, tetherableWifiRegexs);
}
#end_block

#method_before
public boolean isBluetooth(String iface) {
    for (String regex : tetherableBluetoothRegexs) {
        if (iface.matches(regex))
            return true;
    }
    return false;
}
#method_after
public boolean isBluetooth(String iface) {
    return matchesDownstreamRegexs(iface, tetherableBluetoothRegexs);
}
#end_block

#method_before
private static Collection<Integer> getUpstreamIfaceTypes(Context ctx, boolean requiresDun) {
    final int[] ifaceTypes = ctx.getResources().getIntArray(com.android.internal.R.array.config_tether_upstream_types);
    final ArrayList<Integer> upstreamIfaceTypes = new ArrayList<>(ifaceTypes.length);
    for (int i : ifaceTypes) {
        upstreamIfaceTypes.add(i);
    }
    // TODO: Perform this filtering step in the above for loop.
    if (requiresDun) {
        while (upstreamIfaceTypes.contains(TYPE_MOBILE)) {
            upstreamIfaceTypes.remove(TYPE_MOBILE);
        }
        while (upstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI)) {
            upstreamIfaceTypes.remove(TYPE_MOBILE_HIPRI);
        }
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE_DUN)) {
            upstreamIfaceTypes.add(TYPE_MOBILE_DUN);
        }
    } else {
        while (upstreamIfaceTypes.contains(TYPE_MOBILE_DUN)) {
            upstreamIfaceTypes.remove(TYPE_MOBILE_DUN);
        }
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE)) {
            upstreamIfaceTypes.add(TYPE_MOBILE);
        }
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI)) {
            upstreamIfaceTypes.add(TYPE_MOBILE_HIPRI);
        }
    }
    return upstreamIfaceTypes;
}
#method_after
private static Collection<Integer> getUpstreamIfaceTypes(Context ctx, boolean requiresDun) {
    final int[] ifaceTypes = ctx.getResources().getIntArray(com.android.internal.R.array.config_tether_upstream_types);
    final ArrayList<Integer> upstreamIfaceTypes = new ArrayList<>(ifaceTypes.length);
    for (int i : ifaceTypes) {
        switch(i) {
            case TYPE_MOBILE:
            case TYPE_MOBILE_HIPRI:
                if (requiresDun)
                    continue;
                break;
            case TYPE_MOBILE_DUN:
                if (!requiresDun)
                    continue;
                break;
        }
        upstreamIfaceTypes.add(i);
    }
    // specified by configuration resources.
    if (requiresDun) {
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE_DUN)) {
            upstreamIfaceTypes.add(TYPE_MOBILE_DUN);
        }
    } else {
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE)) {
            upstreamIfaceTypes.add(TYPE_MOBILE);
        }
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI)) {
            upstreamIfaceTypes.add(TYPE_MOBILE_HIPRI);
        }
    }
    return upstreamIfaceTypes;
}
#end_block

#method_before
@Test
public void testRequestsMobileNetwork() throws Exception {
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.start();
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.updateMobileRequiresDun(false);
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.registerMobileNetworkRequest();
    assertTrue(mUNM.mobileNetworkRequested());
    assertHipriRequested();
    mUNM.stop();
    assertFalse(mUNM.mobileNetworkRequested());
    assertTrue(mCM.hasNoCallbacks());
}
#method_after
@Test
public void testRequestsMobileNetwork() throws Exception {
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.start();
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.updateMobileRequiresDun(false);
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.registerMobileNetworkRequest();
    assertTrue(mUNM.mobileNetworkRequested());
    assertUpstreamTypeRequested(TYPE_MOBILE_HIPRI);
    assertFalse(mCM.isDunRequested());
    mUNM.stop();
    assertFalse(mUNM.mobileNetworkRequested());
    assertTrue(mCM.hasNoCallbacks());
}
#end_block

#method_before
@Test
public void testRequestsDunNetwork() throws Exception {
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.start();
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.updateMobileRequiresDun(true);
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.registerMobileNetworkRequest();
    assertTrue(mUNM.mobileNetworkRequested());
    assertDunRequested();
    mUNM.stop();
    assertFalse(mUNM.mobileNetworkRequested());
    assertTrue(mCM.hasNoCallbacks());
}
#method_after
@Test
public void testRequestsDunNetwork() throws Exception {
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.start();
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.updateMobileRequiresDun(true);
    assertFalse(mUNM.mobileNetworkRequested());
    assertEquals(0, mCM.requested.size());
    mUNM.registerMobileNetworkRequest();
    assertTrue(mUNM.mobileNetworkRequested());
    assertUpstreamTypeRequested(TYPE_MOBILE_DUN);
    assertTrue(mCM.isDunRequested());
    mUNM.stop();
    assertFalse(mUNM.mobileNetworkRequested());
    assertTrue(mCM.hasNoCallbacks());
}
#end_block

#method_before
@Test
public void testUpdateMobileRequiredDun() throws Exception {
    mUNM.start();
    // Test going from no-DUN to DUN correctly re-registers callbacks.
    mUNM.updateMobileRequiresDun(false);
    mUNM.registerMobileNetworkRequest();
    assertTrue(mUNM.mobileNetworkRequested());
    assertHipriRequested();
    mUNM.updateMobileRequiresDun(true);
    assertTrue(mUNM.mobileNetworkRequested());
    assertDunRequested();
    // Test going from DUN to no-DUN correctly re-registers callbacks.
    mUNM.updateMobileRequiresDun(false);
    assertTrue(mUNM.mobileNetworkRequested());
    assertHipriRequested();
    mUNM.stop();
    assertFalse(mUNM.mobileNetworkRequested());
}
#method_after
@Test
public void testUpdateMobileRequiredDun() throws Exception {
    mUNM.start();
    // Test going from no-DUN to DUN correctly re-registers callbacks.
    mUNM.updateMobileRequiresDun(false);
    mUNM.registerMobileNetworkRequest();
    assertTrue(mUNM.mobileNetworkRequested());
    assertUpstreamTypeRequested(TYPE_MOBILE_HIPRI);
    assertFalse(mCM.isDunRequested());
    mUNM.updateMobileRequiresDun(true);
    assertTrue(mUNM.mobileNetworkRequested());
    assertUpstreamTypeRequested(TYPE_MOBILE_DUN);
    assertTrue(mCM.isDunRequested());
    // Test going from DUN to no-DUN correctly re-registers callbacks.
    mUNM.updateMobileRequiresDun(false);
    assertTrue(mUNM.mobileNetworkRequested());
    assertUpstreamTypeRequested(TYPE_MOBILE_HIPRI);
    assertFalse(mCM.isDunRequested());
    mUNM.stop();
    assertFalse(mUNM.mobileNetworkRequested());
}
#end_block

#method_before
public void testSpliteratorObjectArray() {
    String[] array = { "a", "b", "c", "d", "e", "f", "g", "h" };
    Spliterator<String> sp = Spliterators.spliterator(array, 0);
    assertEquals(8, sp.estimateSize());
    assertEquals(8, sp.getExactSizeIfKnown());
}
#method_after
public void testSpliteratorObjectArray() {
    String[] array = { "a", "b", "c", "d", "e", "f", "g", "h" };
    ArrayList<String> expectedValues = new ArrayList<>(Arrays.asList(array));
    Spliterator<String> sp = Spliterators.spliterator(array, 0);
    assertEquals(8, sp.estimateSize());
    assertEquals(8, sp.getExactSizeIfKnown());
    sp = Spliterators.spliterator(array, 0);
    SpliteratorTester.runBasicIterationTests(sp, expectedValues);
    sp = Spliterators.spliterator(array, 0);
    SpliteratorTester.testSpliteratorNPE(sp);
    sp = Spliterators.spliterator(array, 0);
    SpliteratorTester.runBasicSplitTests(sp, expectedValues, String::compareTo);
    sp = Spliterators.spliterator(array, 0);
    SpliteratorTester.runSizedTests(sp, 8);
    sp = Spliterators.spliterator(array, 0);
    SpliteratorTester.runSubSizedTests(sp, 8);
    // Assert the spliterator inherits any characteristics we ask it to.
    sp = Spliterators.spliterator(array, Spliterator.ORDERED);
    assertTrue(sp.hasCharacteristics(Spliterator.ORDERED));
}
#end_block

#method_before
@Override
public void onReceive(Context content, Intent intent) {
    String action = intent.getAction();
    if (action == null) {
        return;
    }
    if (action.equals(UsbManager.ACTION_USB_STATE)) {
        synchronized (Tethering.this.mPublicSync) {
            boolean usbConnected = intent.getBooleanExtra(UsbManager.USB_CONNECTED, false);
            mRndisEnabled = intent.getBooleanExtra(UsbManager.USB_FUNCTION_RNDIS, false);
            // start tethering if we have a request pending
            if (usbConnected && mRndisEnabled && mUsbTetherRequested) {
                tetherMatchingInterfaces(true, ConnectivityManager.TETHERING_USB);
            }
            mUsbTetherRequested = false;
        }
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
        if (networkInfo != null && networkInfo.getDetailedState() != NetworkInfo.DetailedState.FAILED) {
            if (VDBG)
                Log.d(TAG, "Tethering got CONNECTIVITY_ACTION");
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_UPSTREAM_CHANGED);
        }
    } else if (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) {
        synchronized (Tethering.this.mPublicSync) {
            int curState = intent.getIntExtra(WifiManager.EXTRA_WIFI_AP_STATE, WifiManager.WIFI_AP_STATE_DISABLED);
            switch(curState) {
                case WifiManager.WIFI_AP_STATE_ENABLING:
                    // We can see this state on the way to both enabled and failure states.
                    break;
                case WifiManager.WIFI_AP_STATE_ENABLED:
                    // When the AP comes up and we've been requested to tether it, do so.
                    if (mWifiTetherRequested) {
                        tetherMatchingInterfaces(true, ConnectivityManager.TETHERING_WIFI);
                    }
                    break;
                case WifiManager.WIFI_AP_STATE_DISABLED:
                case WifiManager.WIFI_AP_STATE_DISABLING:
                case WifiManager.WIFI_AP_STATE_FAILED:
                default:
                    if (DBG) {
                        Log.d(TAG, "Canceling WiFi tethering request - AP_STATE=" + curState);
                    }
                    // themselves down.
                    for (int i = 0; i < mTetherStates.size(); i++) {
                        TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).mStateMachine;
                        if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
                            tism.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
                            // There should be at most one of these.
                            break;
                        }
                    }
                    // Regardless of whether we requested this transition, the AP has gone
                    // down.  Don't try to tether again unless we're requested to do so.
                    mWifiTetherRequested = false;
                    break;
            }
        }
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        updateConfiguration();
    }
}
#method_after
@Override
public void onReceive(Context content, Intent intent) {
    final String action = intent.getAction();
    if (action == null)
        return;
    if (action.equals(UsbManager.ACTION_USB_STATE)) {
        handleUsbAction(intent);
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        handleConnectivityAction(intent);
    } else if (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) {
        handleWifiApAction(intent);
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        updateConfiguration();
    }
}
#end_block

#method_before
public void startListening() {
    if (DBG)
        Log.d(TAG, "startListening for SIM changes");
    if (mBroadcastReceiver != null)
        return;
    mBroadcastReceiver = new SimChangeBroadcastReceiver(mSimBcastGenerationNumber.incrementAndGet());
    final IntentFilter filter = new IntentFilter();
    filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#method_after
public void startListening() {
    if (DBG)
        Log.d(TAG, "startListening for SIM changes");
    if (mBroadcastReceiver != null)
        return;
    mBroadcastReceiver = new SimChangeBroadcastReceiver(mSimBcastGenerationNumber.incrementAndGet());
    final IntentFilter filter = new IntentFilter();
    filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
    mContext.registerReceiver(mBroadcastReceiver, filter, null, mTetherMasterSM.getHandler());
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    final int currentGenerationNumber = mSimBcastGenerationNumber.get();
    if (DBG) {
        Log.d(TAG, "simchange mGenerationNumber=" + mGenerationNumber + ", current generationNumber=" + currentGenerationNumber);
    }
    if (mGenerationNumber != currentGenerationNumber)
        return;
    final String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
    Log.d(TAG, "got Sim changed to state " + state + ", mSimAbsentSeen=" + mSimAbsentSeen);
    if (simCardAbsent(state)) {
        if (!mSimAbsentSeen)
            mSimAbsentSeen = true;
        return;
    }
    if (simCardLoaded(state)) {
        if (!mSimAbsentSeen)
            return;
        mSimAbsentSeen = false;
        if (!hasMobileHotspotProvisionApp())
            return;
        ArrayList<Integer> tethered = new ArrayList<Integer>();
        synchronized (mPublicSync) {
            for (int i = 0; i < mTetherStates.size(); i++) {
                TetherState tetherState = mTetherStates.valueAt(i);
                if (tetherState.mLastState != IControlsTethering.STATE_TETHERED) {
                    // Skip interfaces that aren't tethered.
                    continue;
                }
                String iface = mTetherStates.keyAt(i);
                int interfaceType = ifaceNameToType(iface);
                if (interfaceType != ConnectivityManager.TETHERING_INVALID) {
                    tethered.add(new Integer(interfaceType));
                }
            }
        }
        for (int tetherType : tethered) {
            startProvisionIntent(tetherType);
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    final int currentGenerationNumber = mSimBcastGenerationNumber.get();
    if (DBG) {
        Log.d(TAG, "simchange mGenerationNumber=" + mGenerationNumber + ", current generationNumber=" + currentGenerationNumber);
    }
    if (mGenerationNumber != currentGenerationNumber)
        return;
    final String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
    Log.d(TAG, "got Sim changed to state " + state + ", mSimAbsentSeen=" + mSimAbsentSeen);
    if (isSimCardAbsent(state)) {
        if (!mSimAbsentSeen)
            mSimAbsentSeen = true;
        return;
    }
    if (isSimCardLoaded(state) && mSimAbsentSeen) {
        mSimAbsentSeen = false;
        if (!hasMobileHotspotProvisionApp())
            return;
        ArrayList<Integer> tethered = new ArrayList<Integer>();
        synchronized (mPublicSync) {
            for (int i = 0; i < mTetherStates.size(); i++) {
                TetherState tetherState = mTetherStates.valueAt(i);
                if (tetherState.mLastState != IControlsTethering.STATE_TETHERED) {
                    // Skip interfaces that aren't tethered.
                    continue;
                }
                String iface = mTetherStates.keyAt(i);
                int interfaceType = ifaceNameToType(iface);
                if (interfaceType != ConnectivityManager.TETHERING_INVALID) {
                    tethered.add(new Integer(interfaceType));
                }
            }
        }
        for (int tetherType : tethered) {
            startProvisionIntent(tetherType);
        }
    }
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(isFullScan ? 1 : 0);
    if (channelSettings == null) {
        out.writeInt(0);
    } else {
        out.writeInt(channelSettings.size());
        for (ChannelSettings channel : channelSettings) {
            channel.writeToParcel(out, flags);
        }
    }
    if (hiddenNetworks == null) {
        out.writeInt(0);
    } else {
        out.writeInt(hiddenNetworks.size());
        for (HiddenNetwork network : hiddenNetworks) {
            network.writeToParcel(out, flags);
        }
    }
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(isFullScan ? 1 : 0);
    out.writeTypedList(channelSettings);
    out.writeTypedList(hiddenNetworks);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(ssid.length);
    out.writeByteArray(ssid);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeByteArray(ssid);
}
#end_block

#method_before
@Rpc(description = "Connects to the network with the given configuration")
public void wifiConnectByConfig(@RpcParameter(name = "config") JSONObject config) throws JSONException, GeneralSecurityException {
    WifiConfiguration wifiConfig;
    WifiActionListener listener;
    // Check if this is 802.11x or 802.11x config.
    if (config.has("FQDN")) {
        // FQDN indicates that this config is for an enterprise network.
        wifiConfig = genWifiEnterpriseConfig(config);
        listener = new WifiActionListener(mEventFacade, WifiConstants.WIFI_ENTERPRISE_CONNECT_CALLBACK);
    } else {
        wifiConfig = genWifiConfig(config);
        listener = new WifiActionListener(mEventFacade, WifiConstants.WIFI_CONNECT_BY_CONFIG_CALLBACK);
    }
    mWifi.connect(wifiConfig, listener);
}
#method_after
@Rpc(description = "Connects to the network with the given configuration")
public void wifiConnectByConfig(@RpcParameter(name = "config") JSONObject config) throws JSONException, GeneralSecurityException {
    WifiConfiguration wifiConfig;
    WifiActionListener listener;
    // Check if this is 802.1x or 802.11x config.
    if (config.has(WifiEnterpriseConfig.EAP_KEY)) {
        wifiConfig = genWifiEnterpriseConfig(config);
    } else {
        wifiConfig = genWifiConfig(config);
    }
    listener = new WifiActionListener(mEventFacade, WifiConstants.WIFI_CONNECT_BY_CONFIG_CALLBACK);
    mWifi.connect(wifiConfig, listener);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CALL_PHONE)
public void placeCall(Uri address, Bundle extras) {
    ITelecomService service = getTelecomService();
    if (service != null) {
        if (address == null) {
            Log.w(TAG, "Cannot place call to empty address.");
        }
        try {
            service.placeCall(address, extras == null ? new Bundle() : extras, mContext.getOpPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error calling ITelecomService#placeCall", e);
        }
    }
}
#method_after
@RequiresPermission(anyOf = { android.Manifest.permission.CALL_PHONE, android.Manifest.permission.MANAGE_OWN_CALLS })
public void placeCall(Uri address, Bundle extras) {
    ITelecomService service = getTelecomService();
    if (service != null) {
        if (address == null) {
            Log.w(TAG, "Cannot place call to empty address.");
        }
        try {
            service.placeCall(address, extras == null ? new Bundle() : extras, mContext.getOpPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error calling ITelecomService#placeCall", e);
        }
    }
}
#end_block

#method_before
private void invokeForAllObservers(CallbackInvocation runnable) {
    final int length = mObservers.beginBroadcast();
    try {
        for (int i = 0; i < length; i++) {
            try {
                runnable.call(mObservers.getBroadcastItem(i));
            } catch (RemoteException | RuntimeException e) {
            }
        }
    } finally {
        mObservers.finishBroadcast();
    }
}
#method_after
private void invokeForAllObservers(NetworkManagementEventCallback eventCallback) {
    final int length = mObservers.beginBroadcast();
    try {
        for (int i = 0; i < length; i++) {
            try {
                eventCallback.sendCallback(mObservers.getBroadcastItem(i));
            } catch (RemoteException | RuntimeException e) {
            }
        }
    } finally {
        mObservers.finishBroadcast();
    }
}
#end_block

#method_before
private void notifyInterfaceStatusChanged(String iface, boolean up) {
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            o.interfaceStatusChanged(iface, up);
        }
    });
}
#method_after
private void notifyInterfaceStatusChanged(String iface, boolean up) {
    invokeForAllObservers(o -> o.interfaceStatusChanged(iface, up));
}
#end_block

#method_before
private void notifyInterfaceLinkStateChanged(String iface, boolean up) {
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            o.interfaceLinkStateChanged(iface, up);
        }
    });
}
#method_after
private void notifyInterfaceLinkStateChanged(String iface, boolean up) {
    invokeForAllObservers(o -> o.interfaceLinkStateChanged(iface, up));
}
#end_block

#method_before
private void notifyInterfaceAdded(String iface) {
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            o.interfaceAdded(iface);
        }
    });
}
#method_after
private void notifyInterfaceAdded(String iface) {
    invokeForAllObservers(o -> o.interfaceAdded(iface));
}
#end_block

#method_before
private void notifyInterfaceRemoved(String iface) {
    // netd already clears out quota and alerts for removed ifaces; update
    // our sanity-checking state.
    mActiveAlerts.remove(iface);
    mActiveQuotas.remove(iface);
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            o.interfaceRemoved(iface);
        }
    });
}
#method_after
private void notifyInterfaceRemoved(String iface) {
    // netd already clears out quota and alerts for removed ifaces; update
    // our sanity-checking state.
    mActiveAlerts.remove(iface);
    mActiveQuotas.remove(iface);
    invokeForAllObservers(o -> o.interfaceRemoved(iface));
}
#end_block

#method_before
private void notifyLimitReached(String limitName, String iface) {
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            o.limitReached(limitName, iface);
        }
    });
}
#method_after
private void notifyLimitReached(String limitName, String iface) {
    invokeForAllObservers(o -> o.limitReached(limitName, iface));
}
#end_block

#method_before
private void notifyInterfaceClassActivity(int type, int powerState, long tsNanos, int uid, boolean fromRadio) {
    final boolean isMobile = ConnectivityManager.isNetworkTypeMobile(type);
    if (isMobile) {
        if (!fromRadio) {
            if (mMobileActivityFromRadio) {
                // If this call is not coming from a report from the radio itself, but we
                // have previously received reports from the radio, then we will take the
                // power state to just be whatever the radio last reported.
                powerState = mLastPowerStateFromRadio;
            }
        } else {
            mMobileActivityFromRadio = true;
        }
        if (mLastPowerStateFromRadio != powerState) {
            mLastPowerStateFromRadio = powerState;
            try {
                getBatteryStats().noteMobileRadioPowerState(powerState, tsNanos, uid);
            } catch (RemoteException e) {
            }
        }
    }
    if (ConnectivityManager.isNetworkTypeWifi(type)) {
        if (mLastPowerStateFromWifi != powerState) {
            mLastPowerStateFromWifi = powerState;
            try {
                getBatteryStats().noteWifiRadioPowerState(powerState, tsNanos, uid);
            } catch (RemoteException e) {
            }
        }
    }
    boolean isActive = powerState == DataConnectionRealTimeInfo.DC_POWER_STATE_MEDIUM || powerState == DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH;
    if (!isMobile || fromRadio || !mMobileActivityFromRadio) {
        // Report the change in data activity.  We don't do this if this is a change
        // on the mobile network, that is not coming from the radio itself, and we
        // have previously seen change reports from the radio.  In that case only
        // the radio is the authority for the current state.
        final boolean active = isActive;
        invokeForAllObservers(new CallbackInvocation() {

            @Override
            public void call(INetworkManagementEventObserver o) throws RemoteException {
                o.interfaceClassDataActivityChanged(Integer.toString(type), active, tsNanos);
            }
        });
    }
    boolean report = false;
    synchronized (mIdleTimerLock) {
        if (mActiveIdleTimers.isEmpty()) {
            // If there are no idle timers, we are not monitoring activity, so we
            // are always considered active.
            isActive = true;
        }
        if (mNetworkActive != isActive) {
            mNetworkActive = isActive;
            report = isActive;
        }
    }
    if (report) {
        reportNetworkActive();
    }
}
#method_after
private void notifyInterfaceClassActivity(int type, int powerState, long tsNanos, int uid, boolean fromRadio) {
    final boolean isMobile = ConnectivityManager.isNetworkTypeMobile(type);
    if (isMobile) {
        if (!fromRadio) {
            if (mMobileActivityFromRadio) {
                // If this call is not coming from a report from the radio itself, but we
                // have previously received reports from the radio, then we will take the
                // power state to just be whatever the radio last reported.
                powerState = mLastPowerStateFromRadio;
            }
        } else {
            mMobileActivityFromRadio = true;
        }
        if (mLastPowerStateFromRadio != powerState) {
            mLastPowerStateFromRadio = powerState;
            try {
                getBatteryStats().noteMobileRadioPowerState(powerState, tsNanos, uid);
            } catch (RemoteException e) {
            }
        }
    }
    if (ConnectivityManager.isNetworkTypeWifi(type)) {
        if (mLastPowerStateFromWifi != powerState) {
            mLastPowerStateFromWifi = powerState;
            try {
                getBatteryStats().noteWifiRadioPowerState(powerState, tsNanos, uid);
            } catch (RemoteException e) {
            }
        }
    }
    boolean isActive = powerState == DataConnectionRealTimeInfo.DC_POWER_STATE_MEDIUM || powerState == DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH;
    if (!isMobile || fromRadio || !mMobileActivityFromRadio) {
        // Report the change in data activity.  We don't do this if this is a change
        // on the mobile network, that is not coming from the radio itself, and we
        // have previously seen change reports from the radio.  In that case only
        // the radio is the authority for the current state.
        final boolean active = isActive;
        invokeForAllObservers(o -> o.interfaceClassDataActivityChanged(Integer.toString(type), active, tsNanos));
    }
    boolean report = false;
    synchronized (mIdleTimerLock) {
        if (mActiveIdleTimers.isEmpty()) {
            // If there are no idle timers, we are not monitoring activity, so we
            // are always considered active.
            isActive = true;
        }
        if (mNetworkActive != isActive) {
            mNetworkActive = isActive;
            report = isActive;
        }
    }
    if (report) {
        reportNetworkActive();
    }
}
#end_block

#method_before
private void notifyAddressUpdated(String iface, LinkAddress address) {
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            o.addressUpdated(iface, address);
        }
    });
}
#method_after
private void notifyAddressUpdated(String iface, LinkAddress address) {
    invokeForAllObservers(o -> o.addressUpdated(iface, address));
}
#end_block

#method_before
private void notifyAddressRemoved(String iface, LinkAddress address) {
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            o.addressRemoved(iface, address);
        }
    });
}
#method_after
private void notifyAddressRemoved(String iface, LinkAddress address) {
    invokeForAllObservers(o -> o.addressRemoved(iface, address));
}
#end_block

#method_before
private void notifyInterfaceDnsServerInfo(String iface, long lifetime, String[] addresses) {
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            o.interfaceDnsServerInfo(iface, lifetime, addresses);
        }
    });
}
#method_after
private void notifyInterfaceDnsServerInfo(String iface, long lifetime, String[] addresses) {
    invokeForAllObservers(o -> o.interfaceDnsServerInfo(iface, lifetime, addresses));
}
#end_block

#method_before
private void notifyRouteChange(String action, RouteInfo route) {
    invokeForAllObservers(new CallbackInvocation() {

        @Override
        public void call(INetworkManagementEventObserver o) throws RemoteException {
            if (action.equals("updated")) {
                o.routeUpdated(route);
            } else {
                o.routeRemoved(route);
            }
        }
    });
}
#method_after
private void notifyRouteChange(String action, RouteInfo route) {
    if (action.equals("updated")) {
        invokeForAllObservers(o -> o.routeUpdated(route));
    } else {
        invokeForAllObservers(o -> o.routeRemoved(route));
    }
}
#end_block

#method_before
public static TimeZone getDefault() {
    if (defaultZone == null) {
        // Avoid deadlock between java.util.TimeZone and ICU TimeZone.
        synchronized (java.util.TimeZone.class) {
            synchronized (TimeZone.class) {
                if (defaultZone == null) {
                    if (TZ_IMPL == TIMEZONE_JDK) {
                        defaultZone = new JavaTimeZone();
                    } else {
                        java.util.TimeZone temp = java.util.TimeZone.getDefault();
                        defaultZone = getFrozenTimeZone(temp.getID());
                    }
                }
            }
        }
    // Android patch (http://b/30937209) end.
    }
    return defaultZone.cloneAsThawed();
}
#method_after
public static TimeZone getDefault() {
    if (defaultZone == null) {
        // icu.util.TimeZone.clearCachedDefault() so always acquires them in order (1) then (2).
        synchronized (java.util.TimeZone.class) {
            synchronized (TimeZone.class) {
                if (defaultZone == null) {
                    if (TZ_IMPL == TIMEZONE_JDK) {
                        defaultZone = new JavaTimeZone();
                    } else {
                        java.util.TimeZone temp = java.util.TimeZone.getDefault();
                        defaultZone = getFrozenTimeZone(temp.getID());
                    }
                }
            }
        }
    // Android patch (http://b/30937209) end.
    }
    return defaultZone.cloneAsThawed();
}
#end_block

#method_before
public static TimeZone getDefault() {
    if (defaultZone == null) {
        // Avoid deadlock between java.util.TimeZone and ICU TimeZone.
        synchronized (java.util.TimeZone.class) {
            synchronized (TimeZone.class) {
                if (defaultZone == null) {
                    if (TZ_IMPL == TIMEZONE_JDK) {
                        defaultZone = new JavaTimeZone();
                    } else {
                        java.util.TimeZone temp = java.util.TimeZone.getDefault();
                        defaultZone = getFrozenTimeZone(temp.getID());
                    }
                }
            }
        }
    // Android patch (http://b/30937209) end.
    }
    return defaultZone.cloneAsThawed();
}
#method_after
public static TimeZone getDefault() {
    if (defaultZone == null) {
        // icu.util.TimeZone.clearCachedDefault() so always acquires them in order (1) then (2).
        synchronized (java.util.TimeZone.class) {
            synchronized (TimeZone.class) {
                if (defaultZone == null) {
                    if (TZ_IMPL == TIMEZONE_JDK) {
                        defaultZone = new JavaTimeZone();
                    } else {
                        java.util.TimeZone temp = java.util.TimeZone.getDefault();
                        defaultZone = getFrozenTimeZone(temp.getID());
                    }
                }
            }
        }
    // Android patch (http://b/30937209) end.
    }
    return defaultZone.cloneAsThawed();
}
#end_block

#method_before
private static void checkRemaining(DataInputStream in, int length) throws IOException {
    if (length < 0) {
        throw new IOException("Length is negative: " + length);
    }
    if (length > in.available()) {
        throw new IOException("Length of blob is longer than available: " + length + " > " + in.available());
    }
}
#method_after
private static void checkRemaining(ByteBuffer buf, int length) throws IOException {
    if (length < 0) {
        throw new IOException("Length is negative: " + length);
    }
    if (length > buf.remaining()) {
        throw new IOException("Length of blob is longer than available: " + length + " > " + buf.remaining());
    }
}
#end_block

#method_before
public OpenSSLSessionImpl toSession(byte[] data, String host, int port) {
    ByteArrayInputStream bais = new ByteArrayInputStream(data);
    DataInputStream dais = new DataInputStream(bais);
    try {
        int type = dais.readInt();
        if (type != OPEN_SSL && type != OPEN_SSL_WITH_OCSP && type != OPEN_SSL_WITH_TLS_SCT) {
            throw new IOException("Unexpected type ID: " + type);
        }
        int length = dais.readInt();
        checkRemaining(dais, length);
        byte[] sessionData = new byte[length];
        dais.readFully(sessionData);
        int count = dais.readInt();
        checkRemaining(dais, count);
        X509Certificate[] certs = new X509Certificate[count];
        for (int i = 0; i < count; i++) {
            length = dais.readInt();
            checkRemaining(dais, length);
            byte[] certData = new byte[length];
            dais.readFully(certData);
            certs[i] = OpenSSLX509Certificate.fromX509Der(certData);
        }
        byte[] ocspData = null;
        if (type >= OPEN_SSL_WITH_OCSP) {
            // We only support one OCSP response now, but in the future
            // we may support RFC 6961 which has multiple.
            int countOcspResponses = dais.readInt();
            if (countOcspResponses == 1) {
                int ocspLength = dais.readInt();
                checkRemaining(dais, ocspLength);
                ocspData = new byte[ocspLength];
                dais.readFully(ocspData);
            } else {
                return null;
            }
        }
        byte[] tlsSctData = null;
        if (type == OPEN_SSL_WITH_TLS_SCT) {
            int tlsSctDataLength = dais.readInt();
            checkRemaining(dais, tlsSctDataLength);
            if (tlsSctDataLength > 0) {
                tlsSctData = new byte[tlsSctDataLength];
                dais.readFully(tlsSctData);
            }
        }
        if (dais.available() != 0) {
            log(new AssertionError("Read entire session, but data still remains; rejecting"));
        }
        return new OpenSSLSessionImpl(sessionData, host, port, certs, ocspData, tlsSctData, this);
    } catch (IOException e) {
        log(e);
        return null;
    }
}
#method_after
public OpenSSLSessionImpl toSession(byte[] data, String host, int port) {
    ByteBuffer buf = ByteBuffer.wrap(data);
    try {
        int type = buf.get();
        if (type != OPEN_SSL && type != OPEN_SSL_WITH_OCSP && type != OPEN_SSL_WITH_TLS_SCT) {
            throw new IOException("Unexpected type ID: " + type);
        }
        int length = buf.getInt();
        checkRemaining(buf, length);
        byte[] sessionData = new byte[length];
        buf.get(sessionData);
        int count = buf.getInt();
        checkRemaining(buf, count);
        X509Certificate[] certs = new X509Certificate[count];
        for (int i = 0; i < count; i++) {
            length = buf.getInt();
            checkRemaining(buf, length);
            byte[] certData = new byte[length];
            buf.get(certData);
            certs[i] = OpenSSLX509Certificate.fromX509Der(certData);
        }
        byte[] ocspData = null;
        if (type >= OPEN_SSL_WITH_OCSP) {
            // We only support one OCSP response now, but in the future
            // we may support RFC 6961 which has multiple.
            int countOcspResponses = buf.getInt();
            checkRemaining(buf, countOcspResponses);
            if (countOcspResponses >= 1) {
                int ocspLength = buf.getInt();
                checkRemaining(buf, ocspLength);
                ocspData = new byte[ocspLength];
                buf.get(ocspData);
                // Skip the rest of the responses.
                for (int i = 1; i < countOcspResponses; i++) {
                    ocspLength = buf.getInt();
                    checkRemaining(buf, ocspLength);
                    buf.position(buf.position() + ocspLength);
                }
            }
        }
        byte[] tlsSctData = null;
        if (type == OPEN_SSL_WITH_TLS_SCT) {
            int tlsSctDataLength = buf.getInt();
            checkRemaining(buf, tlsSctDataLength);
            if (tlsSctDataLength > 0) {
                tlsSctData = new byte[tlsSctDataLength];
                buf.get(tlsSctData);
            }
        }
        if (buf.remaining() != 0) {
            log(new AssertionError("Read entire session, but data still remains; rejecting"));
            return null;
        }
        return new OpenSSLSessionImpl(sessionData, host, port, certs, ocspData, tlsSctData, this);
    } catch (IOException e) {
        log(e);
        return null;
    } catch (BufferUnderflowException e) {
        log(e);
        return null;
    }
}
#end_block

#method_before
static void log(Throwable t) {
    new Exception("Error converting session", t).printStackTrace();
}
#method_after
static void log(Throwable t) {
    System.out.println("Error inflating SSL session: " + (t.getMessage() != null ? t.getMessage() : t.getClass().getName()));
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    System.loadLibrary(args[1]);
    // Wait a little bit to ensure daemons had time to start up completely.
    Thread.yield();
    Thread.sleep(500);
    doTest();
}
#method_after
public static void main(String[] args) throws Exception {
    System.loadLibrary(args[1]);
    doTest();
}
#end_block

#method_before
private static void doTest() throws Exception {
    Thread t1 = Thread.currentThread();
    ThreadGroup curGroup = t1.getThreadGroup();
    ThreadGroup rootGroup = curGroup;
    while (rootGroup.getParent() != null) {
        rootGroup = rootGroup.getParent();
    }
    ThreadGroup[] topGroups = getTopThreadGroups();
    if (topGroups == null || topGroups.length != 1 || topGroups[0] != rootGroup) {
        System.out.println(Arrays.toString(topGroups));
        throw new RuntimeException("Unexpected topGroups");
    }
    printThreadGroupInfo(curGroup);
    printThreadGroupInfo(rootGroup);
    checkChildren(curGroup);
}
#method_after
private static void doTest() throws Exception {
    Thread t1 = Thread.currentThread();
    ThreadGroup curGroup = t1.getThreadGroup();
    ThreadGroup rootGroup = curGroup;
    while (rootGroup.getParent() != null) {
        rootGroup = rootGroup.getParent();
    }
    ThreadGroup[] topGroups = getTopThreadGroups();
    if (topGroups == null || topGroups.length != 1 || topGroups[0] != rootGroup) {
        System.out.println(Arrays.toString(topGroups));
        throw new RuntimeException("Unexpected topGroups");
    }
    printThreadGroupInfo(curGroup);
    printThreadGroupInfo(rootGroup);
    waitGroupChildren(rootGroup, 5, /* # daemons */
    30);
    checkChildren(curGroup);
}
#end_block

#method_before
@Override
public void requestNetwork(NetworkRequest req, NetworkCallback cb, int timeoutMs, int legacyType) {
    assertFalse(requested.containsKey(cb));
    requested.put(cb, req);
    assertFalse(legacyTypeMap.containsKey(cb));
    legacyTypeMap.put(cb, legacyType);
}
#method_after
@Override
public void requestNetwork(NetworkRequest req, NetworkCallback cb, int timeoutMs, int legacyType) {
    assertFalse(requested.containsKey(cb));
    requested.put(cb, req);
    assertFalse(legacyTypeMap.containsKey(cb));
    if (legacyType != ConnectivityManager.TYPE_NONE) {
        legacyTypeMap.put(cb, legacyType);
    }
}
#end_block

#method_before
public void testReceiveTwice() throws Exception {
    try (DatagramSocket ds = new DatagramSocket();
        DatagramSocket sds = new DatagramSocket()) {
        sds.connect(ds.getLocalSocketAddress());
        DatagramPacket p = new DatagramPacket(new byte[16], 16);
        DatagramPacket smallPacket = new DatagramPacket("01234".getBytes("UTF-8"), 5);
        sds.send(smallPacket);
        ds.receive(p);
        assertPacketDataEquals(smallPacket, p);
        final int largePacketLength = 20;
        DatagramPacket largetPacket = new DatagramPacket("0123456789".getBytes("UTF-8"), 10);
        sds.send(largetPacket);
        ds.receive(p);
        assertPacketDataEquals(largetPacket, p);
    }
}
#method_after
// Receive twice reusing the same DatagramPacket.
public void testReceiveTwice() throws Exception {
    try (DatagramSocket ds = new DatagramSocket();
        DatagramSocket sds = new DatagramSocket()) {
        sds.connect(ds.getLocalSocketAddress());
        DatagramPacket p = new DatagramPacket(new byte[16], 16);
        byte[] smallPacketBytes = "01234".getBytes("UTF-8");
        DatagramPacket smallPacket = new DatagramPacket(smallPacketBytes, smallPacketBytes.length);
        sds.send(smallPacket);
        ds.receive(p);
        assertPacketDataEquals(smallPacket, p);
        byte[] largePacketBytes = "0123456789".getBytes("UTF-8");
        DatagramPacket largerPacket = new DatagramPacket(largePacketBytes, largePacketBytes.length);
        sds.send(largerPacket);
        ds.receive(p);
        assertPacketDataEquals(largerPacket, p);
    }
}
#end_block

#method_before
@Override
public void run() {
    // Wait for the previous thread since it has been interrupted.
    Log.v(TAG, "Waiting");
    synchronized (TAG) {
        Log.v(TAG, "Executing");
        execute();
        monitorDaemons();
    }
}
#method_after
@Override
public void run() {
    // Wait for the previous thread since it has been interrupted.
    Log.v(TAG, "Waiting");
    synchronized (TAG) {
        Log.v(TAG, "Executing");
        try {
            execute();
            monitorDaemons();
            // Clear interrupt flag if execute called exit.
            interrupted();
        } catch (InterruptedException e) {
        } finally {
            for (LocalSocket socket : mSockets) {
                IoUtils.closeQuietly(socket);
            }
            // message to server.
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
            }
            for (String daemon : mDaemons) {
                SystemService.stop(daemon);
            }
        }
        agentDisconnect();
    }
}
#end_block

#method_before
private void execute() {
    // Catch all exceptions so we can clean up few things.
    boolean initFinished = false;
    try {
        // Initialize the timer.
        checkpoint(false);
        // Wait for the daemons to stop.
        for (String daemon : mDaemons) {
            while (!SystemService.isStopped(daemon)) {
                checkpoint(true);
            }
        }
        // Clear the previous state.
        File state = new File("/data/misc/vpn/state");
        state.delete();
        if (state.exists()) {
            throw new IllegalStateException("Cannot delete the state");
        }
        new File("/data/misc/vpn/abort").delete();
        initFinished = true;
        // Check if we need to restart any of the daemons.
        boolean restart = false;
        for (String[] arguments : mArguments) {
            restart = restart || (arguments != null);
        }
        if (!restart) {
            agentDisconnect();
            return;
        }
        updateState(DetailedState.CONNECTING, "execute");
        // Start the daemon with arguments.
        for (int i = 0; i < mDaemons.length; ++i) {
            String[] arguments = mArguments[i];
            if (arguments == null) {
                continue;
            }
            // Start the daemon.
            String daemon = mDaemons[i];
            SystemService.start(daemon);
            // Wait for the daemon to start.
            while (!SystemService.isRunning(daemon)) {
                checkpoint(true);
            }
            // Create the control socket.
            mSockets[i] = new LocalSocket();
            LocalSocketAddress address = new LocalSocketAddress(daemon, LocalSocketAddress.Namespace.RESERVED);
            // Wait for the socket to connect.
            while (true) {
                try {
                    mSockets[i].connect(address);
                    break;
                } catch (Exception e) {
                // ignore
                }
                checkpoint(true);
            }
            mSockets[i].setSoTimeout(500);
            // Send over the arguments.
            OutputStream out = mSockets[i].getOutputStream();
            for (String argument : arguments) {
                byte[] bytes = argument.getBytes(StandardCharsets.UTF_8);
                if (bytes.length >= 0xFFFF) {
                    throw new IllegalArgumentException("Argument is too large");
                }
                out.write(bytes.length >> 8);
                out.write(bytes.length);
                out.write(bytes);
                checkpoint(false);
            }
            out.write(0xFF);
            out.write(0xFF);
            out.flush();
            // Wait for End-of-File.
            InputStream in = mSockets[i].getInputStream();
            while (true) {
                try {
                    if (in.read() == -1) {
                        break;
                    }
                } catch (Exception e) {
                // ignore
                }
                checkpoint(true);
            }
        }
        // Wait for the daemons to create the new state.
        while (!state.exists()) {
            // Check if a running daemon is dead.
            for (int i = 0; i < mDaemons.length; ++i) {
                String daemon = mDaemons[i];
                if (mArguments[i] != null && !SystemService.isRunning(daemon)) {
                    throw new IllegalStateException(daemon + " is dead");
                }
            }
            checkpoint(true);
        }
        // Now we are connected. Read and parse the new state.
        String[] parameters = FileUtils.readTextFile(state, 0, null).split("\n", -1);
        if (parameters.length != 7) {
            throw new IllegalStateException("Cannot parse the state");
        }
        // Set the interface and the addresses in the config.
        mConfig.interfaze = parameters[0].trim();
        mConfig.addLegacyAddresses(parameters[1]);
        // Set the routes if they are not set in the config.
        if (mConfig.routes == null || mConfig.routes.isEmpty()) {
            mConfig.addLegacyRoutes(parameters[2]);
        }
        // Set the DNS servers if they are not set in the config.
        if (mConfig.dnsServers == null || mConfig.dnsServers.size() == 0) {
            String dnsServers = parameters[3].trim();
            if (!dnsServers.isEmpty()) {
                mConfig.dnsServers = Arrays.asList(dnsServers.split(" "));
            }
        }
        // Set the search domains if they are not set in the config.
        if (mConfig.searchDomains == null || mConfig.searchDomains.size() == 0) {
            String searchDomains = parameters[4].trim();
            if (!searchDomains.isEmpty()) {
                mConfig.searchDomains = Arrays.asList(searchDomains.split(" "));
            }
        }
        // Add a throw route for the VPN server endpoint, if one was specified.
        String endpoint = parameters[5];
        if (!endpoint.isEmpty()) {
            try {
                InetAddress addr = InetAddress.parseNumericAddress(endpoint);
                if (addr instanceof Inet4Address) {
                    mConfig.routes.add(new RouteInfo(new IpPrefix(addr, 32), RTN_THROW));
                } else if (addr instanceof Inet6Address) {
                    mConfig.routes.add(new RouteInfo(new IpPrefix(addr, 128), RTN_THROW));
                } else {
                    Log.e(TAG, "Unknown IP address family for VPN endpoint: " + endpoint);
                }
            } catch (IllegalArgumentException e) {
                Log.e(TAG, "Exception constructing throw route to " + endpoint + ": " + e);
            }
        }
        // Here is the last step and it must be done synchronously.
        synchronized (Vpn.this) {
            // Set the start time
            mConfig.startTime = SystemClock.elapsedRealtime();
            // Check if the thread is interrupted while we are waiting.
            checkpoint(false);
            // Check if the interface is gone while we are waiting.
            if (jniCheck(mConfig.interfaze) == 0) {
                throw new IllegalStateException(mConfig.interfaze + " is gone");
            }
            // Now INetworkManagementEventObserver is watching our back.
            mInterface = mConfig.interfaze;
            mVpnUsers = new ArrayList<UidRange>();
            agentConnect();
            Log.i(TAG, "Connected!");
        }
    } catch (Exception e) {
        Log.i(TAG, "Aborting", e);
        updateState(DetailedState.FAILED, e.getMessage());
        exit();
    } finally {
        // Kill the daemons if they fail to stop.
        if (!initFinished) {
            for (String daemon : mDaemons) {
                SystemService.stop(daemon);
            }
        }
        // Do not leave an unstable state.
        if (!initFinished || mNetworkInfo.getDetailedState() == DetailedState.CONNECTING) {
            agentDisconnect();
        }
    }
}
#method_after
private void execute() {
    // Catch all exceptions so we can clean up few things.
    boolean initFinished = false;
    try {
        // Initialize the timer.
        checkpoint(false);
        // Wait for the daemons to stop.
        for (String daemon : mDaemons) {
            while (!SystemService.isStopped(daemon)) {
                checkpoint(true);
            }
        }
        // Clear the previous state.
        File state = new File("/data/misc/vpn/state");
        state.delete();
        if (state.exists()) {
            throw new IllegalStateException("Cannot delete the state");
        }
        new File("/data/misc/vpn/abort").delete();
        initFinished = true;
        // Check if we need to restart any of the daemons.
        boolean restart = false;
        for (String[] arguments : mArguments) {
            restart = restart || (arguments != null);
        }
        if (!restart) {
            agentDisconnect();
            return;
        }
        updateState(DetailedState.CONNECTING, "execute");
        // Start the daemon with arguments.
        for (int i = 0; i < mDaemons.length; ++i) {
            String[] arguments = mArguments[i];
            if (arguments == null) {
                continue;
            }
            // Start the daemon.
            String daemon = mDaemons[i];
            SystemService.start(daemon);
            // Wait for the daemon to start.
            while (!SystemService.isRunning(daemon)) {
                checkpoint(true);
            }
            // Create the control socket.
            mSockets[i] = new LocalSocket();
            LocalSocketAddress address = new LocalSocketAddress(daemon, LocalSocketAddress.Namespace.RESERVED);
            // Wait for the socket to connect.
            while (true) {
                try {
                    mSockets[i].connect(address);
                    break;
                } catch (Exception e) {
                // ignore
                }
                checkpoint(true);
            }
            mSockets[i].setSoTimeout(500);
            // Send over the arguments.
            OutputStream out = mSockets[i].getOutputStream();
            for (String argument : arguments) {
                byte[] bytes = argument.getBytes(StandardCharsets.UTF_8);
                if (bytes.length >= 0xFFFF) {
                    throw new IllegalArgumentException("Argument is too large");
                }
                out.write(bytes.length >> 8);
                out.write(bytes.length);
                out.write(bytes);
                checkpoint(false);
            }
            out.write(0xFF);
            out.write(0xFF);
            out.flush();
            // Wait for End-of-File.
            InputStream in = mSockets[i].getInputStream();
            while (true) {
                try {
                    if (in.read() == -1) {
                        break;
                    }
                } catch (Exception e) {
                // ignore
                }
                checkpoint(true);
            }
        }
        // Wait for the daemons to create the new state.
        while (!state.exists()) {
            // Check if a running daemon is dead.
            for (int i = 0; i < mDaemons.length; ++i) {
                String daemon = mDaemons[i];
                if (mArguments[i] != null && !SystemService.isRunning(daemon)) {
                    throw new IllegalStateException(daemon + " is dead");
                }
            }
            checkpoint(true);
        }
        // Now we are connected. Read and parse the new state.
        String[] parameters = FileUtils.readTextFile(state, 0, null).split("\n", -1);
        if (parameters.length != 7) {
            throw new IllegalStateException("Cannot parse the state");
        }
        // Set the interface and the addresses in the config.
        mConfig.interfaze = parameters[0].trim();
        mConfig.addLegacyAddresses(parameters[1]);
        // Set the routes if they are not set in the config.
        if (mConfig.routes == null || mConfig.routes.isEmpty()) {
            mConfig.addLegacyRoutes(parameters[2]);
        }
        // Set the DNS servers if they are not set in the config.
        if (mConfig.dnsServers == null || mConfig.dnsServers.size() == 0) {
            String dnsServers = parameters[3].trim();
            if (!dnsServers.isEmpty()) {
                mConfig.dnsServers = Arrays.asList(dnsServers.split(" "));
            }
        }
        // Set the search domains if they are not set in the config.
        if (mConfig.searchDomains == null || mConfig.searchDomains.size() == 0) {
            String searchDomains = parameters[4].trim();
            if (!searchDomains.isEmpty()) {
                mConfig.searchDomains = Arrays.asList(searchDomains.split(" "));
            }
        }
        // Add a throw route for the VPN server endpoint, if one was specified.
        String endpoint = parameters[5];
        if (!endpoint.isEmpty()) {
            try {
                InetAddress addr = InetAddress.parseNumericAddress(endpoint);
                if (addr instanceof Inet4Address) {
                    mConfig.routes.add(new RouteInfo(new IpPrefix(addr, 32), RTN_THROW));
                } else if (addr instanceof Inet6Address) {
                    mConfig.routes.add(new RouteInfo(new IpPrefix(addr, 128), RTN_THROW));
                } else {
                    Log.e(TAG, "Unknown IP address family for VPN endpoint: " + endpoint);
                }
            } catch (IllegalArgumentException e) {
                Log.e(TAG, "Exception constructing throw route to " + endpoint + ": " + e);
            }
        }
        // Here is the last step and it must be done synchronously.
        synchronized (Vpn.this) {
            // Set the start time
            mConfig.startTime = SystemClock.elapsedRealtime();
            // Check if the thread is interrupted while we are waiting.
            checkpoint(false);
            // Check if the interface is gone while we are waiting.
            if (jniCheck(mConfig.interfaze) == 0) {
                throw new IllegalStateException(mConfig.interfaze + " is gone");
            }
            // Now INetworkManagementEventObserver is watching our back.
            mInterface = mConfig.interfaze;
            mVpnUsers = new ArrayList<UidRange>();
            agentConnect();
            Log.i(TAG, "Connected!");
        }
    } catch (Exception e) {
        Log.i(TAG, "Aborting", e);
        updateState(DetailedState.FAILED, e.getMessage());
        exit();
    }
}
#end_block

#method_before
private void monitorDaemons() {
    if (!mNetworkInfo.isConnected()) {
        return;
    }
    try {
        while (true) {
            Thread.sleep(2000);
            for (int i = 0; i < mDaemons.length; i++) {
                if (mArguments[i] != null && SystemService.isStopped(mDaemons[i])) {
                    return;
                }
            }
        }
    } catch (InterruptedException e) {
        Log.d(TAG, "interrupted during monitorDaemons(); stopping services");
    } finally {
        for (LocalSocket socket : mSockets) {
            IoUtils.closeQuietly(socket);
        }
        agentDisconnect();
    }
}
#method_after
private void monitorDaemons() throws InterruptedException {
    if (!mNetworkInfo.isConnected()) {
        return;
    }
    while (true) {
        Thread.sleep(2000);
        for (int i = 0; i < mDaemons.length; i++) {
            if (mArguments[i] != null && SystemService.isStopped(mDaemons[i])) {
                return;
            }
        }
    }
}
#end_block

#method_before
// / CHECK-START: void LoadedByMyClassLoader.bar() inliner (before)
// / CHECK:      LoadClass
// / CHECK-NEXT: ClinitCheck
// / CHECK-NEXT: InvokeStaticOrDirect
// / CHECK-NEXT: LoadClass
// / CHECK-NEXT: ClinitCheck
// / CHECK-NEXT: StaticFieldGet
// / CHECK-NEXT: LoadString
// / CHECK-NEXT: NullCheck
// / CHECK-NEXT: InvokeVirtual
// / CHECK-START: void LoadedByMyClassLoader.bar() inliner (after)
// / CHECK:      LoadClass
// / CHECK-NEXT: ClinitCheck
/* We inlined FirstSeenByMyClassLoader.$inline$bar */
// / CHECK-NEXT: LoadClass
// / CHECK-NEXT: ClinitCheck
// / CHECK-NEXT: StaticFieldGet
// / CHECK-NEXT: LoadString
// / CHECK-NEXT: NullCheck
// / CHECK-NEXT: InvokeVirtual
// / CHECK-START: void LoadedByMyClassLoader.bar() register (before)
/* Load and initialize FirstSeenByMyClassLoader */
// / CHECK:      LoadClass gen_clinit_check:true
/* Load and initialize System */
// There may be MipsComputeBaseMethodAddress here.
// / CHECK:      LoadClass
// The ClinitCheck may (non-PIC) or may not (PIC) be merged into the LoadClass.
// / CHECK:      StaticFieldGet
// There may be HArmDexCacheArraysBase or HX86ComputeBaseMethodAddress here.
// / CHECK:      LoadString
// / CHECK-NEXT: NullCheck
public static void bar() {
    FirstSeenByMyClassLoader.$inline$bar();
    System.out.println("In between the two calls.");
    FirstSeenByMyClassLoader.$noinline$bar();
}
#method_after
// / CHECK-START: void LoadedByMyClassLoader.bar() inliner (before)
// / CHECK:      LoadClass class_name:FirstSeenByMyClassLoader
// / CHECK-NEXT: ClinitCheck
// / CHECK-NEXT: InvokeStaticOrDirect
// / CHECK-NEXT: LoadClass class_name:java.lang.System
// / CHECK-NEXT: ClinitCheck
// / CHECK-NEXT: StaticFieldGet
// / CHECK-NEXT: LoadString
// / CHECK-NEXT: NullCheck
// / CHECK-NEXT: InvokeVirtual
// / CHECK-START: void LoadedByMyClassLoader.bar() inliner (after)
// / CHECK:      LoadClass class_name:FirstSeenByMyClassLoader
// / CHECK-NEXT: ClinitCheck
/* We inlined FirstSeenByMyClassLoader.$inline$bar */
// / CHECK-NEXT: LoadClass class_name:java.lang.System
// / CHECK-NEXT: ClinitCheck
// / CHECK-NEXT: StaticFieldGet
// / CHECK-NEXT: LoadString
// / CHECK-NEXT: NullCheck
// / CHECK-NEXT: InvokeVirtual
// / CHECK-START: void LoadedByMyClassLoader.bar() register (before)
/* Load and initialize FirstSeenByMyClassLoader */
// / CHECK:      LoadClass class_name:FirstSeenByMyClassLoader gen_clinit_check:true
/* Load and initialize System */
// There may be MipsComputeBaseMethodAddress here.
// / CHECK:      LoadClass class_name:java.lang.System
// The ClinitCheck may (PIC) or may not (non-PIC) be merged into the LoadClass.
// (The merging checks for environment match but HLoadClass/kBootImageAddress
// used for non-PIC mode does not have an environment at all.)
// / CHECK:      StaticFieldGet
// There may be HX86ComputeBaseMethodAddress or MipsComputeBaseMethodAddress here.
// / CHECK:      LoadString
// / CHECK-NEXT: NullCheck
public static void bar() {
    FirstSeenByMyClassLoader.$inline$bar();
    System.out.println("In between the two calls.");
    FirstSeenByMyClassLoader.$noinline$bar();
}
#end_block

#method_before
@Deprecated
@Rpc(description = "Connects to the network with the given configuration")
public Boolean wifiConnect(@RpcParameter(name = "config") JSONObject config) throws JSONException {
    Log.w("wifiConnect() is deprecated; use wifiConnectByConfig() instead.");
    wifiConnectByConfig(config);
    return true;
}
#method_after
@RpcDeprecated(value = "wifiConnectByConfig")
@Rpc(description = "Connects to the network with the given configuration")
public Boolean wifiConnect(@RpcParameter(name = "config") JSONObject config) throws JSONException {
    wifiConnectByConfig(config);
    return true;
}
#end_block

#method_before
public void test_readlink() throws Exception {
    String tmpDir = System.getProperty("java.io.tmpdir");
    String path = tmpDir + "/symlink";
    try {
        // ext2 and ext4 have PAGE_SIZE limits on symlink targets.
        // If file encryption is enabled, there's extra overhead to store the
        // size of the encrypted symlink target. There's also an off-by-one
        // in current kernels (and marlin/sailfish where we're seeing this
        // failure are still on 3.18, far from current). Given that we don't
        // really care here, just use 2048 instead. http://b/33306057.
        int size = 2048;
        String xs = "";
        for (int i = 0; i < size - 1; ++i) xs += "x";
        Libcore.os.symlink(xs, path);
        assertEquals(xs, Libcore.os.readlink(path));
    } finally {
        new File(path).delete();
    }
}
#method_after
public void test_readlink() throws Exception {
    File path = new File(IoUtils.createTemporaryDirectory("test_readlink"), "symlink");
    // ext2 and ext4 have PAGE_SIZE limits on symlink targets.
    // If file encryption is enabled, there's extra overhead to store the
    // size of the encrypted symlink target. There's also an off-by-one
    // in current kernels (and marlin/sailfish where we're seeing this
    // failure are still on 3.18, far from current). Given that we don't
    // really care here, just use 2048 instead. http://b/33306057.
    int size = 2048;
    String xs = "";
    for (int i = 0; i < size - 1; ++i) xs += "x";
    Libcore.os.symlink(xs, path.getPath());
    assertEquals(xs, Libcore.os.readlink(path.getPath()));
}
#end_block

#method_before
public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type) {
    ContentResolver contentResolver = context.getContentResolver();
    String scheme = uri.getScheme();
    String fileName = null;
    String contentType;
    long length = 0;
    // bluetooth
    if ("content".equals(scheme)) {
        contentType = contentResolver.getType(uri);
        Cursor metadataCursor;
        try {
            metadataCursor = contentResolver.query(uri, new String[] { OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE }, null, null, null);
        } catch (SQLiteException e) {
            // some content providers don't support the DISPLAY_NAME or SIZE columns
            metadataCursor = null;
        } catch (SecurityException e) {
            Log.e(TAG, "generateFileInfo: Permission error, could not access URI: " + uri);
            return SEND_FILE_INFO_ERROR;
        }
        if (metadataCursor != null) {
            try {
                if (metadataCursor.moveToFirst()) {
                    fileName = metadataCursor.getString(metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME));
                    length = metadataCursor.getLong(metadataCursor.getColumnIndex(OpenableColumns.SIZE));
                    if (D)
                        Log.d(TAG, "fileName = " + fileName + " length = " + length);
                }
            } finally {
                metadataCursor.close();
            }
        }
        if (fileName == null) {
            // use last segment of URI if DISPLAY_NAME query fails
            fileName = uri.getLastPathSegment();
        }
    } else if ("file".equals(scheme)) {
        fileName = uri.getLastPathSegment();
        contentType = type;
        File f = new File(uri.getPath());
        length = f.length();
    } else {
        // currently don't accept other scheme
        return SEND_FILE_INFO_ERROR;
    }
    FileInputStream is = null;
    if (scheme.equals("content")) {
        try {
            // We've found that content providers don't always have the
            // right size in _OpenableColumns.SIZE
            // As a second source of getting the correct file length,
            // get a file descriptor and get the stat length
            AssetFileDescriptor fd = contentResolver.openAssetFileDescriptor(uri, "r");
            long statLength = fd.getLength();
            if (length != statLength && statLength > 0) {
                Log.e(TAG, "Content provider length is wrong (" + Long.toString(length) + "), using stat length (" + Long.toString(statLength) + ")");
                length = statLength;
            }
            try {
                // This creates an auto-closing input-stream, so
                // the file descriptor will be closed whenever the InputStream
                // is closed.
                is = fd.createInputStream();
                // by reading through the entire stream
                if (length == 0) {
                    length = getStreamSize(is);
                    Log.w(TAG, "File length not provided. Length from stream = " + length);
                    // Reset the stream
                    fd = contentResolver.openAssetFileDescriptor(uri, "r");
                    is = fd.createInputStream();
                }
            } catch (IOException e) {
                try {
                    fd.close();
                } catch (IOException e2) {
                // Ignore
                }
            }
        } catch (FileNotFoundException e) {
        // Ignore
        }
    }
    if (is == null) {
        try {
            is = (FileInputStream) contentResolver.openInputStream(uri);
            // by reading through the entire stream
            if (length == 0) {
                length = getStreamSize(is);
                // Reset the stream
                is = (FileInputStream) contentResolver.openInputStream(uri);
            }
        } catch (FileNotFoundException e) {
            return SEND_FILE_INFO_ERROR;
        } catch (IOException e) {
            return SEND_FILE_INFO_ERROR;
        }
    }
    if (length == 0) {
        Log.e(TAG, "Could not determine size of file");
        return SEND_FILE_INFO_ERROR;
    }
    return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);
}
#method_after
public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type) {
    ContentResolver contentResolver = context.getContentResolver();
    String scheme = uri.getScheme();
    String fileName = null;
    String contentType;
    long length = 0;
    // bluetooth
    if ("content".equals(scheme)) {
        contentType = contentResolver.getType(uri);
        Cursor metadataCursor;
        try {
            metadataCursor = contentResolver.query(uri, new String[] { OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE }, null, null, null);
        } catch (SQLiteException e) {
            // some content providers don't support the DISPLAY_NAME or SIZE columns
            metadataCursor = null;
        } catch (SecurityException e) {
            Log.e(TAG, "generateFileInfo: Permission error, could not access URI: " + uri);
            return SEND_FILE_INFO_ERROR;
        }
        if (metadataCursor != null) {
            try {
                if (metadataCursor.moveToFirst()) {
                    fileName = metadataCursor.getString(metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME));
                    length = metadataCursor.getLong(metadataCursor.getColumnIndex(OpenableColumns.SIZE));
                    if (D)
                        Log.d(TAG, "fileName = " + fileName + " length = " + length);
                }
            } finally {
                metadataCursor.close();
            }
        }
        if (fileName == null) {
            // use last segment of URI if DISPLAY_NAME query fails
            fileName = uri.getLastPathSegment();
        }
    } else if ("file".equals(scheme)) {
        fileName = uri.getLastPathSegment();
        contentType = type;
        File f = new File(uri.getPath());
        length = f.length();
    } else {
        // currently don't accept other scheme
        return SEND_FILE_INFO_ERROR;
    }
    FileInputStream is = null;
    if (scheme.equals("content")) {
        try {
            // We've found that content providers don't always have the
            // right size in _OpenableColumns.SIZE
            // As a second source of getting the correct file length,
            // get a file descriptor and get the stat length
            AssetFileDescriptor fd = contentResolver.openAssetFileDescriptor(uri, "r");
            long statLength = fd.getLength();
            if (length != statLength && statLength > 0) {
                Log.e(TAG, "Content provider length is wrong (" + Long.toString(length) + "), using stat length (" + Long.toString(statLength) + ")");
                length = statLength;
            }
            try {
                // This creates an auto-closing input-stream, so
                // the file descriptor will be closed whenever the InputStream
                // is closed.
                is = fd.createInputStream();
                // by reading through the entire stream
                if (length == 0) {
                    length = getStreamSize(is);
                    Log.w(TAG, "File length not provided. Length from stream = " + length);
                    // Reset the stream
                    fd = contentResolver.openAssetFileDescriptor(uri, "r");
                    is = fd.createInputStream();
                }
            } catch (IOException e) {
                try {
                    fd.close();
                } catch (IOException e2) {
                // Ignore
                }
            }
        } catch (FileNotFoundException e) {
        // Ignore
        }
    }
    if (is == null) {
        try {
            is = (FileInputStream) contentResolver.openInputStream(uri);
            // by reading through the entire stream
            if (length == 0) {
                length = getStreamSize(is);
                // Reset the stream
                is = (FileInputStream) contentResolver.openInputStream(uri);
            }
        } catch (FileNotFoundException e) {
            return SEND_FILE_INFO_ERROR;
        } catch (IOException e) {
            return SEND_FILE_INFO_ERROR;
        }
    }
    if (length == 0) {
        Log.e(TAG, "Could not determine size of file");
        return SEND_FILE_INFO_ERROR;
    } else if (length > 0xffffffffL) {
        String msg = "Files bigger than 4GB can't be transferred";
        Log.e(TAG, msg);
        throw new IllegalArgumentException(msg);
    }
    return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);
}
#end_block

#method_before
private static long getStreamSize(FileInputStream is) throws IOException {
    long length = 0;
    byte[] unused = new byte[4096];
    int bytesRead = -1;
    while ((bytesRead = is.read(unused, 0, 4096)) != -1) {
        length += bytesRead;
    }
    return length;
}
#method_after
private static long getStreamSize(FileInputStream is) throws IOException {
    long length = 0;
    byte[] unused = new byte[4096];
    int bytesRead = is.read(unused, 0, 4096);
    while (bytesRead != -1) {
        length += bytesRead;
        bytesRead = is.read(unused, 0, 4096);
    }
    return length;
}
#end_block

#method_before
public void start() {
    if (!mStarted.compareAndSet(false, true)) {
        return;
    }
    IntentFilter filter = new IntentFilter();
    filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
    filter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
    filter.addAction(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION);
    filter.addAction(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);
    // TODO(b/33695273): conditionally register this receiver based on wifi enabled setting
    mContext.registerReceiver(mBroadcastReceiver, filter, null, mHandler);
    mContentResolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.WIFI_WAKEUP_ENABLED), true, mContentObserver);
    mContentResolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mContentObserver);
    mContentObserver.onChange(true);
    handleConfiguredNetworksChanged();
}
#method_after
public void start() {
    if (!mStarted.compareAndSet(false, true)) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "Starting WifiWakeupController.");
    }
    IntentFilter filter = new IntentFilter();
    filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
    filter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
    filter.addAction(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION);
    filter.addAction(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);
    // TODO(b/33695273): conditionally register this receiver based on wifi enabled setting
    mContext.registerReceiver(mBroadcastReceiver, filter, null, mHandler);
    mContentResolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.WIFI_WAKEUP_ENABLED), true, mContentObserver);
    mContentResolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mContentObserver);
    mContentObserver.onChange(true);
    handleWifiStateChanged();
    handleWifiApStateChanged();
    handleConfiguredNetworksChanged();
    handleScanResultsAvailable();
}
#end_block

#method_before
public void stop() {
    if (!mStarted.compareAndSet(true, false)) {
        return;
    }
    mContext.unregisterReceiver(mBroadcastReceiver);
    mContentResolver.unregisterContentObserver(mContentObserver);
}
#method_after
public void stop() {
    if (!mStarted.compareAndSet(true, false)) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "Stopping WifiWakeupController.");
    }
    mContext.unregisterReceiver(mBroadcastReceiver);
    mContentResolver.unregisterContentObserver(mContentObserver);
}
#end_block

#method_before
private void handleWifiApStateChanged(Intent intent) {
    mWifiApState = intent.getIntExtra(WifiManager.EXTRA_WIFI_AP_STATE, WifiManager.WIFI_AP_STATE_DISABLED);
}
#method_after
private void handleWifiApStateChanged() {
    mWifiApState = mWifiManager.getWifiApState();
    if (VERBOSE) {
        Log.v(TAG, "handleWifiApStateChanged: " + mWifiApState);
    }
}
#end_block

#method_before
private void handleConfiguredNetworksChanged() {
    List<WifiConfiguration> wifiConfigurations = mWifiManager.getConfiguredNetworks();
    if (wifiConfigurations == null) {
        return;
    }
    mSavedNetworks.clear();
    mSavedSsids.clear();
    for (int i = 0; i < wifiConfigurations.size(); i++) {
        WifiConfiguration wifiConfiguration = wifiConfigurations.get(i);
        if (wifiConfiguration.status != WifiConfiguration.Status.ENABLED && wifiConfiguration.status != WifiConfiguration.Status.CURRENT) {
            // Ignore networks that are not connected or enabled.
            continue;
        }
        if (wifiConfiguration.ephemeral || wifiConfiguration.useExternalScores) {
            // Ignore ephemeral and externally scored networks.
            continue;
        }
        if (wifiConfiguration.hasNoInternetAccess() || wifiConfiguration.noInternetAccessExpected) {
            // Ignore networks that will likely not have internet access.
            continue;
        }
        String ssid = WifiInfo.removeDoubleQuotes(wifiConfiguration.SSID);
        if (TextUtils.isEmpty(ssid)) {
            continue;
        }
        mSavedNetworks.put(ssid, wifiConfiguration);
        mSavedSsids.add(ssid);
    }
    mSavedSsidsInLastScan.retainAll(mSavedSsids);
}
#method_after
private void handleConfiguredNetworksChanged() {
    List<WifiConfiguration> wifiConfigurations = mWifiManager.getConfiguredNetworks();
    if (wifiConfigurations == null) {
        return;
    }
    if (VERBOSE) {
        Log.v(TAG, "handleConfiguredNetworksChanged: " + wifiConfigurations.size());
    }
    mSavedNetworks.clear();
    mSavedSsids.clear();
    for (int i = 0; i < wifiConfigurations.size(); i++) {
        WifiConfiguration wifiConfiguration = wifiConfigurations.get(i);
        if (wifiConfiguration.status != WifiConfiguration.Status.ENABLED && wifiConfiguration.status != WifiConfiguration.Status.CURRENT) {
            // Ignore networks that are not connected or enabled.
            continue;
        }
        if (wifiConfiguration.useExternalScores) {
            // Ignore externally scored networks.
            continue;
        }
        if (wifiConfiguration.hasNoInternetAccess() || wifiConfiguration.isNoInternetAccessExpected()) {
            // Ignore networks that will likely not have internet access.
            continue;
        }
        String ssid = WifiConfigurationUtil.removeDoubleQuotes(wifiConfiguration);
        if (TextUtils.isEmpty(ssid)) {
            continue;
        }
        mSavedNetworks.put(ssid, wifiConfiguration);
        mSavedSsids.add(ssid);
    }
    mSavedSsidsInLastScan.retainAll(mSavedSsids);
}
#end_block

#method_before
private void handleWifiStateChanged(Intent intent) {
    mWifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, -1);
    switch(mWifiState) {
        case WifiManager.WIFI_STATE_ENABLED:
            mSavedSsidsOnDisable.clear();
            break;
        case WifiManager.WIFI_STATE_DISABLED:
            for (String ssid : mSavedSsidsInLastScan) {
                mSavedSsidsOnDisable.put(ssid, NUM_SCANS_TO_CONFIRM_AP_LOSS);
            }
            break;
    }
}
#method_after
private void handleWifiStateChanged() {
    mWifiState = mWifiManager.getWifiState();
    if (VERBOSE) {
        Log.v(TAG, "handleWifiStateChanged: " + mWifiState);
    }
    switch(mWifiState) {
        case WifiManager.WIFI_STATE_ENABLED:
            mSavedSsidsOnDisable.clear();
            break;
        case WifiManager.WIFI_STATE_DISABLED:
            for (String ssid : mSavedSsidsInLastScan) {
                mSavedSsidsOnDisable.put(ssid, NUM_SCANS_TO_CONFIRM_AP_LOSS);
            }
            break;
    }
}
#end_block

#method_before
private void handleScanResultsAvailable() {
    List<ScanResult> scanResults = mWifiManager.getScanResults();
    mSavedSsidsInLastScan.clear();
    for (int i = 0; i < scanResults.size(); i++) {
        String ssid = scanResults.get(i).SSID;
        if (mSavedSsids.contains(ssid)) {
            mSavedSsidsInLastScan.add(ssid);
        }
    }
    if (mAirplaneModeEnabled || mWifiState != WifiManager.WIFI_STATE_DISABLED || mWifiApState != WifiManager.WIFI_AP_STATE_DISABLED) {
        return;
    }
    // Update mSavedSsidsOnDisable to remove ssids that the user has moved away from.
    for (Map.Entry<String, Integer> entry : mSavedSsidsOnDisable.entrySet()) {
        if (mSavedSsidsInLastScan.contains(entry.getKey())) {
            mSavedSsidsOnDisable.put(entry.getKey(), NUM_SCANS_TO_CONFIRM_AP_LOSS);
        } else {
            if (entry.getValue() > 1) {
                mSavedSsidsOnDisable.put(entry.getKey(), entry.getValue() - 1);
            } else {
                mSavedSsidsOnDisable.remove(entry.getKey());
            }
        }
    }
    if (!mSavedSsidsOnDisable.isEmpty()) {
        if (DEBUG) {
            Log.d(TAG, "Latest scan result contains ssids from the disabled set: " + mSavedSsidsOnDisable);
        }
        return;
    }
    WifiConfiguration selectedNetwork = mWifiWakeupNetworkSelector.selectNetwork(mSavedNetworks, scanResults);
    if (selectedNetwork != null) {
        if (DEBUG) {
            Log.d(TAG, "Enabling wifi for ssid: " + selectedNetwork.SSID);
        }
        mWifiManager.setWifiEnabled(true);
        mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(selectedNetwork);
    }
}
#method_after
private void handleScanResultsAvailable() {
    List<ScanResult> scanResults = mWifiManager.getScanResults();
    if (scanResults == null) {
        return;
    }
    if (VERBOSE) {
        Log.v(TAG, "handleScanResultsAvailable: " + scanResults.size());
    }
    mSavedSsidsInLastScan.clear();
    for (int i = 0; i < scanResults.size(); i++) {
        String ssid = scanResults.get(i).SSID;
        if (mSavedSsids.contains(ssid)) {
            mSavedSsidsInLastScan.add(ssid);
        }
    }
    if (mAirplaneModeEnabled || mWifiState != WifiManager.WIFI_STATE_DISABLED || mWifiApState != WifiManager.WIFI_AP_STATE_DISABLED) {
        return;
    }
    // Update mSavedSsidsOnDisable to remove ssids that the user has moved away from.
    for (Map.Entry<String, Integer> entry : mSavedSsidsOnDisable.entrySet()) {
        if (mSavedSsidsInLastScan.contains(entry.getKey())) {
            mSavedSsidsOnDisable.put(entry.getKey(), NUM_SCANS_TO_CONFIRM_AP_LOSS);
        } else {
            if (entry.getValue() > 1) {
                mSavedSsidsOnDisable.put(entry.getKey(), entry.getValue() - 1);
            } else {
                mSavedSsidsOnDisable.remove(entry.getKey());
            }
        }
    }
    if (!mSavedSsidsOnDisable.isEmpty()) {
        if (DEBUG) {
            Log.d(TAG, "Latest scan result contains ssids from the disabled set: " + mSavedSsidsOnDisable);
        }
        return;
    }
    WifiConfiguration selectedNetwork = mWifiWakeupNetworkSelector.selectNetwork(mSavedNetworks, scanResults);
    if (selectedNetwork != null) {
        if (DEBUG) {
            Log.d(TAG, "Enabling wifi for ssid: " + selectedNetwork.SSID);
        }
        mWifiManager.setWifiEnabled(true);
        mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(selectedNetwork);
    }
}
#end_block

#method_before
public void maybeShowWifiEnabledNotification(WifiConfiguration wifiConfiguration) {
    Set<String> ssidSet = mSharedPreferences.getStringSet(KEY_SHOWN_SSIDS, Collections.EMPTY_SET);
    if (ssidSet.contains(wifiConfiguration.SSID)) {
        if (DEBUG) {
            Log.d(TAG, "Already showed Wi-Fi Enabled notification for ssid: " + wifiConfiguration.SSID);
        }
        return;
    }
    ssidSet = new ArraySet<>(ssidSet);
    ssidSet.add(wifiConfiguration.SSID);
    mSharedPreferences.edit().putStringSet(KEY_SHOWN_SSIDS, ssidSet).apply();
    String title = mResources.getString(R.string.wifi_wakeup_enabled_notification_title);
    String summary = mResources.getString(R.string.wifi_wakeup_enabled_notification_context, wifiConfiguration.SSID);
    PendingIntent savedNetworkSettingsPendingIntent = PendingIntent.getActivity(mContext, 0, // TODO(b/34135303): update action
    new Intent(Settings.ACTION_WIFI_SAVED_NETWORK_SETTINGS), PendingIntent.FLAG_UPDATE_CURRENT);
    PendingIntent deletePendingIntent = PendingIntent.getActivity(mContext, 0, new Intent(ACTION_DISMISS_WIFI_ENABLED_NOTIFICATION), PendingIntent.FLAG_UPDATE_CURRENT);
    Bundle extras = new Bundle();
    extras.putString(Notification.EXTRA_SUBSTITUTE_APP_NAME, mResources.getString(com.android.internal.R.string.android_system_label));
    Notification notification = new Notification.Builder(mContext).setContentTitle(title).setSmallIcon(com.android.internal.R.drawable.stat_notify_wifi_in_range).setStyle(new Notification.BigTextStyle().bigText(summary)).setAutoCancel(true).setDeleteIntent(deletePendingIntent).setPriority(Notification.PRIORITY_LOW).setVisibility(Notification.VISIBILITY_PUBLIC).setCategory(Notification.CATEGORY_STATUS).setContentIntent(savedNetworkSettingsPendingIntent).addExtras(extras).build();
    mNotificationManager.notifyAsUser(TAG, NOTIFICATION_ID, notification, UserHandle.ALL);
    mNotificationShown = true;
    mContext.registerReceiver(mBroadcastReceiver, INTENT_FILTER);
    mHandler.postDelayed(mCancelNotification, NETWORK_CONNECTED_TIMEOUT_MILLIS);
}
#method_after
public void maybeShowWifiEnabledNotification(@NonNull WifiConfiguration wifiConfiguration) {
    Set<String> ssidSet = mSharedPreferences.getStringSet(KEY_SHOWN_SSIDS, null);
    if (ssidSet == null) {
        ssidSet = new ArraySet<>();
    } else if (ssidSet.contains(wifiConfiguration.SSID)) {
        if (DEBUG) {
            Log.d(TAG, "Already showed Wi-Fi Enabled notification for ssid: " + wifiConfiguration.SSID);
        }
        return;
    }
    ssidSet.add(wifiConfiguration.SSID);
    mSharedPreferences.edit().putStringSet(KEY_SHOWN_SSIDS, ssidSet).apply();
    String title = mResources.getString(R.string.wifi_wakeup_enabled_notification_title);
    String summary = mResources.getString(R.string.wifi_wakeup_enabled_notification_context, wifiConfiguration.SSID);
    PendingIntent savedNetworkSettingsPendingIntent = PendingIntent.getActivity(mContext, 0, // TODO(b/34135303): update action
    new Intent(Settings.ACTION_WIFI_SETTINGS), PendingIntent.FLAG_UPDATE_CURRENT);
    PendingIntent deletePendingIntent = PendingIntent.getActivity(mContext, 0, new Intent(ACTION_DISMISS_WIFI_ENABLED_NOTIFICATION), PendingIntent.FLAG_UPDATE_CURRENT);
    Bundle extras = new Bundle();
    extras.putString(Notification.EXTRA_SUBSTITUTE_APP_NAME, mResources.getString(R.string.android_system_label));
    Notification notification = new Notification.Builder(mContext).setContentTitle(title).setSmallIcon(R.drawable.ic_wifi_signal_4).setStyle(new Notification.BigTextStyle().bigText(summary)).setAutoCancel(true).setDeleteIntent(deletePendingIntent).setPriority(Notification.PRIORITY_LOW).setVisibility(Notification.VISIBILITY_PUBLIC).setCategory(Notification.CATEGORY_STATUS).setContentIntent(savedNetworkSettingsPendingIntent).addExtras(extras).build();
    mNotificationManager.notify(TAG, NOTIFICATION_ID, notification);
    mNotificationShown = true;
    mContext.registerReceiver(mBroadcastReceiver, INTENT_FILTER, null, /* broadcastPermission*/
    mHandler);
    mHandler.postDelayed(mCancelNotification, NETWORK_CONNECTED_TIMEOUT_MILLIS);
}
#end_block

#method_before
private void cancelNotificationAndUnregisterReceiver() {
    if (mNotificationShown) {
        mNotificationShown = false;
        mConnectedSsid = null;
        mNotificationManager.cancelAsUser(TAG, NOTIFICATION_ID, UserHandle.ALL);
        mContext.unregisterReceiver(mBroadcastReceiver);
    }
}
#method_after
private void cancelNotificationAndUnregisterReceiver() {
    if (mNotificationShown) {
        mNotificationShown = false;
        mConnectedSsid = null;
        mNotificationManager.cancel(TAG, NOTIFICATION_ID);
        mContext.unregisterReceiver(mBroadcastReceiver);
    }
}
#end_block

#method_before
@Override
public void onCreate() {
    mHandlerThread = new HandlerThread("RecommendationProvider");
    mHandlerThread.start();
    Looper looper = mHandlerThread.getLooper();
    mHandler = new Handler(looper);
    mProvider = new DefaultNetworkRecommendationProvider(mHandler, getSystemService(NetworkScoreManager.class), new DefaultNetworkRecommendationProvider.ScoreStorage());
    mWifiNotificationController = new WifiNotificationController(this, looper, null);
    WifiManager wifiManager = getSystemService(WifiManager.class);
    WifiWakeupNetworkSelector wifiWakeupNetworkSelector = new WifiWakeupNetworkSelector(getResources());
    WifiWakeupNotificationHelper wifiWakeupNotificationHelper = new WifiWakeupNotificationHelper(this, getResources(), new Handler(looper), getSystemService(NotificationManager.class), wifiManager);
    mWifiWakeupController = new WifiWakeupController(this, getContentResolver(), looper, wifiManager, wifiWakeupNetworkSelector, wifiWakeupNotificationHelper);
}
#method_after
@Override
public void onCreate() {
    mHandlerThread = new HandlerThread("RecommendationProvider");
    mHandlerThread.start();
    Looper looper = mHandlerThread.getLooper();
    mHandler = new Handler(looper);
    NetworkScoreManager networkScoreManager = getSystemService(NetworkScoreManager.class);
    mProvider = new DefaultNetworkRecommendationProvider(mHandler, networkScoreManager, new DefaultNetworkRecommendationProvider.ScoreStorage());
    NotificationManager notificationManager = getSystemService(NotificationManager.class);
    WifiManager wifiManager = getSystemService(WifiManager.class);
    Resources resources = getResources();
    ContentResolver contentResolver = getContentResolver();
    mWifiNotificationController = new WifiNotificationController(this, contentResolver, new Handler(looper), mProvider, wifiManager, notificationManager, new WifiNotificationHelper(this, mProvider));
    WifiWakeupNetworkSelector wifiWakeupNetworkSelector = new WifiWakeupNetworkSelector(resources);
    WifiWakeupNotificationHelper wifiWakeupNotificationHelper = new WifiWakeupNotificationHelper(this, resources, new Handler(looper), notificationManager, wifiManager);
    mWifiWakeupController = new WifiWakeupController(this, contentResolver, looper, wifiManager, wifiWakeupNetworkSelector, wifiWakeupNotificationHelper);
}
#end_block

#method_before
@Override
public IBinder onBind(Intent intent) {
    mWifiWakeupController.start();
    return mProvider.getBinder();
}
#method_after
@Override
public IBinder onBind(Intent intent) {
    mWifiWakeupController.start();
    mWifiNotificationController.start();
    return mProvider.getBinder();
}
#end_block

#method_before
@Override
public boolean onUnbind(Intent intent) {
    mWifiWakeupController.stop();
    return super.onUnbind(intent);
}
#method_after
@Override
public boolean onUnbind(Intent intent) {
    mWifiWakeupController.stop();
    mWifiNotificationController.stop();
    return super.onUnbind(intent);
}
#end_block

#method_before
@Test
public void notificationShowsOncePerSsid() {
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    verify(mNotificationManager, times(1)).notifyAsUser(anyString(), anyInt(), any(Notification.class), any(UserHandle.class));
    Set<String> ssidSet = mSharedPreferences.getStringSet(WifiWakeupNotificationHelper.KEY_SHOWN_SSIDS, null);
    assertEquals(1, ssidSet.size());
    assertTrue(ssidSet.contains(WIFI_CONFIGURATION.SSID));
}
#method_after
@Test
public void notificationShowsOncePerSsid() {
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    verify(mNotificationManager, times(1)).notify(anyString(), anyInt(), any(Notification.class));
    Set<String> ssidSet = mSharedPreferences.getStringSet(WifiWakeupNotificationHelper.KEY_SHOWN_SSIDS, null);
    assertEquals(1, ssidSet.size());
    assertTrue(ssidSet.contains(WIFI_CONFIGURATION.SSID));
}
#end_block

#method_before
@Test
public void notificationCanceledWhenNeverConnected() {
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    mWifiWakeupNotificationHelper.mCancelNotification.run();
    verify(mNotificationManager).cancelAsUser(anyString(), anyInt(), any(UserHandle.class));
}
#method_after
@Test
public void notificationCanceledWhenNeverConnected() {
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    mWifiWakeupNotificationHelper.mCancelNotification.run();
    verify(mNotificationManager).cancel(anyString(), anyInt());
}
#end_block

#method_before
@Test
public void notificationCanceledWhenWifiDisabled() {
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    when(mWifiManager.isWifiEnabled()).thenReturn(false);
    mWifiWakeupNotificationHelper.mBroadcastReceiver.onReceive(mContext, new Intent(WifiManager.WIFI_STATE_CHANGED_ACTION));
    verify(mNotificationManager).cancelAsUser(anyString(), anyInt(), any(UserHandle.class));
}
#method_after
@Test
public void notificationCanceledWhenWifiDisabled() {
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    when(mWifiManager.isWifiEnabled()).thenReturn(false);
    mWifiWakeupNotificationHelper.mBroadcastReceiver.onReceive(mContext, new Intent(WifiManager.WIFI_STATE_CHANGED_ACTION));
    verify(mNotificationManager).cancel(anyString(), anyInt());
}
#end_block

#method_before
@Test
public void notificationCanceledWhenSsidChanged() {
    WifiInfo firstWifiInfo = new WifiInfo();
    firstWifiInfo.setSSID(WifiSsid.createFromAsciiEncoded(SSID));
    WifiInfo secondWifiInfo = new WifiInfo();
    firstWifiInfo.setSSID(WifiSsid.createFromAsciiEncoded("blah"));
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    when(mWifiManager.isWifiEnabled()).thenReturn(true);
    when(mWifiManager.getConnectionInfo()).thenReturn(firstWifiInfo, secondWifiInfo);
    mWifiWakeupNotificationHelper.mBroadcastReceiver.onReceive(mContext, new Intent(WifiManager.WIFI_STATE_CHANGED_ACTION));
    verify(mNotificationManager, never()).cancelAsUser(anyString(), anyInt(), any(UserHandle.class));
    mWifiWakeupNotificationHelper.mBroadcastReceiver.onReceive(mContext, new Intent(WifiManager.WIFI_STATE_CHANGED_ACTION));
    verify(mNotificationManager).cancelAsUser(anyString(), anyInt(), any(UserHandle.class));
}
#method_after
@Test
public void notificationCanceledWhenSsidChanged() {
    WifiInfo firstWifiInfo = new WifiInfo();
    firstWifiInfo.setSSID(WifiSsid.createFromAsciiEncoded(SSID));
    WifiInfo secondWifiInfo = new WifiInfo();
    firstWifiInfo.setSSID(WifiSsid.createFromAsciiEncoded("blah"));
    mWifiWakeupNotificationHelper.maybeShowWifiEnabledNotification(WIFI_CONFIGURATION);
    when(mWifiManager.isWifiEnabled()).thenReturn(true);
    when(mWifiManager.getConnectionInfo()).thenReturn(firstWifiInfo, secondWifiInfo);
    mWifiWakeupNotificationHelper.mBroadcastReceiver.onReceive(mContext, new Intent(WifiManager.WIFI_STATE_CHANGED_ACTION));
    verify(mNotificationManager, never()).cancel(anyString(), anyInt());
    mWifiWakeupNotificationHelper.mBroadcastReceiver.onReceive(mContext, new Intent(WifiManager.WIFI_STATE_CHANGED_ACTION));
    verify(mNotificationManager).cancel(anyString(), anyInt());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mWifiWakeupEnabledOriginalValue = Settings.Global.getInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 0);
    mAirplaneModeOriginalValue = Settings.Global.getInt(mContentResolver, Settings.Global.AIRPLANE_MODE_ON, 0);
    Settings.Global.putInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 1);
    Settings.Global.putInt(mContentResolver, Settings.Global.AIRPLANE_MODE_ON, 0);
    mWifiWakeupController = new WifiWakeupController(mContext, mContentResolver, Looper.getMainLooper(), mWifiManager, mWifiWakeupNetworkSelector, mWifiWakeupNotificationHelper);
    mWifiWakeupController.start();
    verify(mContext).registerReceiver(mBroadcastReceiverCaptor.capture(), any(IntentFilter.class), anyString(), any(Handler.class));
    mBroadcastReceiver = mBroadcastReceiverCaptor.getValue();
    TestUtil.sendWifiApStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_AP_STATE_DISABLED);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mWifiWakeupEnabledOriginalValue = Settings.Global.getInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 0);
    mAirplaneModeOriginalValue = Settings.Global.getInt(mContentResolver, Settings.Global.AIRPLANE_MODE_ON, 0);
    Settings.Global.putInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 1);
    Settings.Global.putInt(mContentResolver, Settings.Global.AIRPLANE_MODE_ON, 0);
    when(mWifiManager.getWifiApState()).thenReturn(WifiManager.WIFI_AP_STATE_DISABLED);
    mWifiWakeupController = new WifiWakeupController(mContext, mContentResolver, Looper.getMainLooper(), mWifiManager, mWifiWakeupNetworkSelector, mWifiWakeupNotificationHelper);
    mWifiWakeupController.start();
    verify(mContext).registerReceiver(mBroadcastReceiverCaptor.capture(), any(IntentFilter.class), anyString(), any(Handler.class));
    mBroadcastReceiver = mBroadcastReceiverCaptor.getValue();
}
#end_block

#method_before
@Test
public void wifiEnabled_userDisabledWifiNearSavedNetwork_thenLeaves_thenMovesBack() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT), Lists.newArrayList(OPEN_SCAN_RESULT), Lists.newArrayList(OPEN_SCAN_RESULT), Lists.newArrayList(OPEN_SCAN_RESULT), Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(null, SAVED_WIFI_CONFIGURATION);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager).setWifiEnabled(true);
    verify(mWifiWakeupNotificationHelper).maybeShowWifiEnabledNotification(SAVED_WIFI_CONFIGURATION);
}
#method_after
@Test
public void wifiEnabled_userDisabledWifiNearSavedNetwork_thenLeaves_thenMovesBack() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT), Lists.newArrayList(OPEN_SCAN_RESULT), Lists.newArrayList(OPEN_SCAN_RESULT), Lists.newArrayList(OPEN_SCAN_RESULT), Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(null, SAVED_WIFI_CONFIGURATION);
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_ENABLED, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager).setWifiEnabled(true);
    verify(mWifiWakeupNotificationHelper).maybeShowWifiEnabledNotification(SAVED_WIFI_CONFIGURATION);
}
#end_block

#method_before
@Test
public void wifiEnabled_userDisabledWifiNearSavedNetwork_thenMovesToAnotherSavedNetwork() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION2));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT), Lists.newArrayList(SAVED_SCAN_RESULT2));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(SAVED_WIFI_CONFIGURATION2);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    verify(mWifiManager, never()).setWifiEnabled(true);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager).setWifiEnabled(true);
    verify(mWifiWakeupNotificationHelper).maybeShowWifiEnabledNotification(SAVED_WIFI_CONFIGURATION2);
}
#method_after
@Test
public void wifiEnabled_userDisabledWifiNearSavedNetwork_thenMovesToAnotherSavedNetwork() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION2));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT), Lists.newArrayList(SAVED_SCAN_RESULT2));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(SAVED_WIFI_CONFIGURATION2);
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_ENABLED, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager).setWifiEnabled(true);
    verify(mWifiWakeupNotificationHelper).maybeShowWifiEnabledNotification(SAVED_WIFI_CONFIGURATION2);
}
#end_block

#method_before
@Test
public void wifiEnabled_userDisablesWifiNearExternallyScoredNetwork_thenNetworkIsSelected() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT_EXTERNAL));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(null, SAVED_WIFI_CONFIGURATION_EXTERNAL);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager).setWifiEnabled(true);
    verify(mWifiWakeupNotificationHelper).maybeShowWifiEnabledNotification(SAVED_WIFI_CONFIGURATION_EXTERNAL);
}
#method_after
@Test
public void wifiEnabled_userDisablesWifiNearExternallyScoredNetwork_thenNetworkIsSelected() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT_EXTERNAL));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(null, SAVED_WIFI_CONFIGURATION_EXTERNAL);
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager).setWifiEnabled(true);
    verify(mWifiWakeupNotificationHelper).maybeShowWifiEnabledNotification(SAVED_WIFI_CONFIGURATION_EXTERNAL);
}
#end_block

#method_before
@Test
public void wifiNotEnabled_wifiAlreadyEnabled() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#method_after
@Test
public void wifiNotEnabled_wifiAlreadyEnabled() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#end_block

#method_before
@Test
public void wifiNotEnabled_userNearSavedNetworkButNotSelected() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(null);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#method_after
@Test
public void wifiNotEnabled_userNearSavedNetworkButNotSelected() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(null);
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#end_block

#method_before
@Test
public void wifiNotEnabled_userDisablesWifiWakeupFeature() {
    Settings.Global.putInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 0);
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    mWifiWakeupController.mContentObserver.onChange(true);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#method_after
@Test
public void wifiNotEnabled_userDisablesWifiWakeupFeature() {
    Settings.Global.putInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 0);
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_DISABLED);
    mWifiWakeupController.mContentObserver.onChange(true);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#end_block

#method_before
@Test
public void wifiNotEnabled_userIsInAirplaneMode() {
    Settings.Global.putInt(mContentResolver, Settings.Global.AIRPLANE_MODE_ON, 1);
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    mWifiWakeupController.mContentObserver.onChange(true);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#method_after
@Test
public void wifiNotEnabled_userIsInAirplaneMode() {
    Settings.Global.putInt(mContentResolver, Settings.Global.AIRPLANE_MODE_ON, 1);
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_DISABLED);
    mWifiWakeupController.mContentObserver.onChange(true);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#end_block

#method_before
@Test
public void wifiNotEnabled_wifiApStateIsNotDisabled() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    mWifiWakeupController.mContentObserver.onChange(true);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendWifiApStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_AP_STATE_ENABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#method_after
@Test
public void wifiNotEnabled_wifiApStateIsNotDisabled() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_DISABLED);
    when(mWifiManager.getWifiApState()).thenReturn(WifiManager.WIFI_AP_STATE_ENABLED);
    mWifiWakeupController.mContentObserver.onChange(true);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendWifiApStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#end_block

#method_before
@Test
public void wifiNotEnabled_userDisablesWifiNearSavedNetwork_thenDoesNotLeave() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#method_after
@Test
public void wifiNotEnabled_userDisablesWifiNearSavedNetwork_thenDoesNotLeave() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION_EXTERNAL));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#end_block

#method_before
@Test
public void wifiNotEnabled_userDisablesWifiNearSavedNetwork_thenRemovesNetwork_thenStays() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION), Lists.<WifiConfiguration>newArrayList());
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT)).thenReturn(Lists.<ScanResult>newArrayList()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(null);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#method_after
@Test
public void wifiNotEnabled_userDisablesWifiNearSavedNetwork_thenRemovesNetwork_thenStays() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION), Lists.<WifiConfiguration>newArrayList());
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT)).thenReturn(Lists.<ScanResult>newArrayList()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiWakeupNetworkSelector.selectNetwork(anyMap(), anyList())).thenReturn(null);
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_ENABLED, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#end_block

#method_before
@Test
public void wifiNotEnabled_userDisablesWifiNear2SavedNetworks_thenLeavesRangeOfOneOfThem() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION2));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT, SAVED_SCAN_RESULT2), Lists.newArrayList(SAVED_SCAN_RESULT));
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#method_after
@Test
public void wifiNotEnabled_userDisablesWifiNear2SavedNetworks_thenLeavesRangeOfOneOfThem() {
    when(mWifiManager.getConfiguredNetworks()).thenReturn(Lists.newArrayList(SAVED_WIFI_CONFIGURATION, SAVED_WIFI_CONFIGURATION2));
    when(mWifiManager.getScanResults()).thenReturn(Lists.newArrayList(SAVED_SCAN_RESULT, SAVED_SCAN_RESULT2), Lists.newArrayList(SAVED_SCAN_RESULT));
    when(mWifiManager.getWifiState()).thenReturn(WifiManager.WIFI_STATE_ENABLED, WifiManager.WIFI_STATE_DISABLED);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendConfiguredNetworksChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verifyZeroInteractions(mWifiWakeupNetworkSelector);
    verify(mWifiManager, never()).setWifiEnabled(true);
}
#end_block

#method_before
@Nullable
public PersistableBundle getConfig() {
    return getConfigForSubId(SubscriptionManager.getDefaultSubId());
}
#method_after
@Nullable
public PersistableBundle getConfig() {
    return getConfigForSubId(SubscriptionManager.getDefaultSubscriptionId());
}
#end_block

#method_before
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    super.onCreateOptionsMenu(menu);
    Resources r = getResources();
    // Added the icons to the context menu
    menu.add(0, MENU_ADD, 0, r.getString(R.string.menu_add)).setIcon(android.R.drawable.ic_menu_add);
    menu.add(0, MENU_EDIT, 0, r.getString(R.string.menu_edit)).setIcon(android.R.drawable.ic_menu_edit);
    menu.add(0, MENU_DELETE, 0, r.getString(R.string.menu_delete)).setIcon(android.R.drawable.ic_menu_delete);
    menu.add(0, MENU_DIAL, 0, r.getString(R.string.menu_dial_string));
    return true;
}
#method_after
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    super.onCreateOptionsMenu(menu);
    Resources r = getResources();
    // Added the icons to the context menu
    menu.add(0, MENU_ADD, 0, r.getString(R.string.menu_add)).setIcon(android.R.drawable.ic_menu_add);
    menu.add(0, MENU_EDIT, 0, r.getString(R.string.menu_edit)).setIcon(android.R.drawable.ic_menu_edit);
    menu.add(0, MENU_DELETE, 0, r.getString(R.string.menu_delete)).setIcon(android.R.drawable.ic_menu_delete);
    menu.add(0, MENU_DIAL, 0, r.getString(R.string.menu_dial));
    return true;
}
#end_block

#method_before
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    super.onPrepareOptionsMenu(menu);
    boolean hasSelection = (getSelectedItemPosition() >= 0);
    menu.findItem(MENU_ADD).setVisible(true);
    menu.findItem(MENU_EDIT).setVisible(hasSelection);
    menu.findItem(MENU_DELETE).setVisible(hasSelection);
    menu.findItem(MENU_DIAL).setVisible(hasSelection && mConfigResUtil.getBooleanValue(this, "config_fdn_direct_dial"));
    return true;
}
#method_after
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    super.onPrepareOptionsMenu(menu);
    boolean hasSelection = (getSelectedItemPosition() >= 0);
    menu.findItem(MENU_ADD).setVisible(true);
    menu.findItem(MENU_EDIT).setVisible(hasSelection);
    menu.findItem(MENU_DELETE).setVisible(hasSelection);
    menu.findItem(MENU_DIAL).setVisible(hasSelection && mFdnDialDirectlySupported);
    return true;
}
#end_block

#method_before
@Override
public void onListItemClick(ListView l, View v, int position, long id) {
    // TODO: is this what we really want?
    if (!mConfigResUtil.getBooleanValue(this, "config_fdn_direct_dial")) {
        editSelected(position);
    } else {
        SelectionPopUpMenu menu = new SelectionPopUpMenu(getApplicationContext(), v, position);
        menu.showPopUp();
    }
}
#method_after
@Override
public void onListItemClick(ListView l, View v, int position, long id) {
    mPopup = new SelectionPopupMenu(this, v, position);
    mPopup.showPopUp();
}
#end_block

#method_before
private void deleteSelected() {
    if (mCursor.moveToPosition(getSelectedItemPosition())) {
        String name = mCursor.getString(NAME_COLUMN);
        String number = mCursor.getString(NUMBER_COLUMN);
        Intent intent = mSubscriptionInfoHelper.getIntent(DeleteFdnContactScreen.class);
        intent.putExtra(INTENT_EXTRA_NAME, name);
        intent.putExtra(INTENT_EXTRA_NUMBER, number);
        startActivity(intent);
    }
}
#method_after
private void deleteSelected() {
    deleteSelected(getSelectedItemPosition());
}
#end_block

#method_before
private void deleteSelected() {
    if (mCursor.moveToPosition(getSelectedItemPosition())) {
        String name = mCursor.getString(NAME_COLUMN);
        String number = mCursor.getString(NUMBER_COLUMN);
        Intent intent = mSubscriptionInfoHelper.getIntent(DeleteFdnContactScreen.class);
        intent.putExtra(INTENT_EXTRA_NAME, name);
        intent.putExtra(INTENT_EXTRA_NUMBER, number);
        startActivity(intent);
    }
}
#method_after
private void deleteSelected(int position) {
    if (mCursor.moveToPosition(position)) {
        String name = mCursor.getString(NAME_COLUMN);
        String number = mCursor.getString(NUMBER_COLUMN);
        Intent intent = mSubscriptionInfoHelper.getIntent(DeleteFdnContactScreen.class);
        intent.putExtra(INTENT_EXTRA_NAME, name);
        intent.putExtra(INTENT_EXTRA_NUMBER, number);
        startActivity(intent);
    }
}
#end_block

#method_before
private void dialSelected(int position) {
    int prviousPos = mCursor.getPosition();
    String number = null;
    if (mCursor.moveToPosition(position)) {
        number = mCursor.getString(NUMBER_COLUMN);
    }
    mCursor.moveToPosition(prviousPos);
    if (number != null) {
        Uri uri = Uri.fromParts(PhoneAccount.SCHEME_TEL, number, null);
        final Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED, uri);
        startActivity(intent);
    }
}
#method_after
private void dialSelected(int position) {
    if (mCursor.moveToPosition(position)) {
        String number = mCursor.getString(NUMBER_COLUMN);
        if (!TextUtils.isEmpty(number)) {
            Uri uri = Uri.fromParts(PhoneAccount.SCHEME_TEL, number, null);
            final Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED, uri);
            startActivity(intent);
        }
    }
}
#end_block

#method_before
public static final String[] getKeywordValuesForLocale(String key, ULocale locale, boolean commonlyUsed) {
    // Resolve region
    String prefRegion = ULocale.getRegionForSupplementalData(locale, true);
    // Read preferred calendar values from supplementalData calendarPreferences
    ArrayList<String> values = new ArrayList<String>();
    UResourceBundle rb = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
    UResourceBundle calPref = rb.get("calendarPreferenceData");
    UResourceBundle order = null;
    try {
        order = calPref.get(prefRegion);
    } catch (MissingResourceException mre) {
        // use "001" as fallback
        order = calPref.get("001");
    }
    String[] caltypes = order.getStringArray();
    if (commonlyUsed) {
        // we have all commonly used calendar for the target region
        return caltypes;
    }
    // if not commonlyUsed, add all preferred calendars in the order
    for (int i = 0; i < caltypes.length; i++) {
        values.add(caltypes[i]);
    }
    // then, add other available clanedars
    for (CalType t : CalType.values()) {
        if (!values.contains(t.id)) {
            values.add(t.id);
        }
    }
    return values.toArray(new String[values.size()]);
}
#method_after
public static final String[] getKeywordValuesForLocale(String key, ULocale locale, boolean commonlyUsed) {
    // Resolve region
    String prefRegion = ULocale.getRegionForSupplementalData(locale, true);
    // Read preferred calendar values from supplementalData calendarPreferences
    ArrayList<String> values = new ArrayList<String>();
    UResourceBundle rb = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
    UResourceBundle calPref = rb.get("calendarPreferenceData");
    UResourceBundle order = null;
    try {
        order = calPref.get(prefRegion);
    } catch (MissingResourceException mre) {
        // use "001" as fallback
        order = calPref.get("001");
    }
    String[] caltypes = order.getStringArray();
    if (commonlyUsed) {
        // we have all commonly used calendar for the target region
        return caltypes;
    }
    // if not commonlyUsed, add all preferred calendars in the order
    for (int i = 0; i < caltypes.length; i++) {
        values.add(caltypes[i]);
    }
    // then, add other available clanedars
    for (CalType t : CalType.values()) {
        if (!values.contains(t.id)) {
            values.add(t.id);
        }
    }
    return values.toArray(new String[values.size()]);
}
#end_block

#method_before
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (this.getClass() != obj.getClass()) {
        return false;
    }
    Calendar that = (Calendar) obj;
    return isEquivalentTo(that) && getTimeInMillis() == that.getTime().getTime();
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (this.getClass() != obj.getClass()) {
        return false;
    }
    Calendar that = (Calendar) obj;
    return isEquivalentTo(that) && getTimeInMillis() == that.getTime().getTime();
}
#end_block

#method_before
public int hashCode() {
    /* Don't include the time because (a) we don't want the hash value to
         * move around just because a calendar is set to different times, and
         * (b) we don't want to trigger a time computation just to get a hash.
         * Note that it is not necessary for unequal objects to always have
         * unequal hashes, but equal objects must have equal hashes.  */
    return (lenient ? 1 : 0) | (firstDayOfWeek << 1) | (minimalDaysInFirstWeek << 4) | (repeatedWallTime << 7) | (skippedWallTime << 9) | (zone.hashCode() << 11);
}
#method_after
@Override
public int hashCode() {
    /* Don't include the time because (a) we don't want the hash value to
         * move around just because a calendar is set to different times, and
         * (b) we don't want to trigger a time computation just to get a hash.
         * Note that it is not necessary for unequal objects to always have
         * unequal hashes, but equal objects must have equal hashes.  */
    return (lenient ? 1 : 0) | (firstDayOfWeek << 1) | (minimalDaysInFirstWeek << 4) | (repeatedWallTime << 7) | (skippedWallTime << 9) | (zone.hashCode() << 11);
}
#end_block

#method_before
public int compareTo(Calendar that) {
    long v = getTimeInMillis() - that.getTimeInMillis();
    return v < 0 ? -1 : (v > 0 ? 1 : 0);
}
#method_after
@Override
public int compareTo(Calendar that) {
    long v = getTimeInMillis() - that.getTimeInMillis();
    return v < 0 ? -1 : (v > 0 ? 1 : 0);
}
#end_block

#method_before
// Android patch (http://b/28832222) start.
// Expose method to get format string for java.time.
public static String getDateTimeFormatString(String calType, ULocale loc, int dateStyle, int timeStyle) {
    if (timeStyle < DateFormat.NONE || timeStyle > DateFormat.SHORT) {
        throw new IllegalArgumentException("Illegal time style " + timeStyle);
    }
    if (dateStyle < DateFormat.NONE || dateStyle > DateFormat.SHORT) {
        throw new IllegalArgumentException("Illegal date style " + dateStyle);
    }
    PatternData patternData = PatternData.make(calType, loc);
    // Resolve a pattern for the date/time style
    String pattern = null;
    if ((timeStyle >= 0) && (dateStyle >= 0)) {
        pattern = SimpleFormatterImpl.formatRawPattern(patternData.getDateTimePattern(dateStyle), 2, 2, patternData.patterns[timeStyle], patternData.patterns[dateStyle + 4]);
    } else if (timeStyle >= 0) {
        pattern = patternData.patterns[timeStyle];
    } else if (dateStyle >= 0) {
        pattern = patternData.patterns[dateStyle + 4];
    } else {
        throw new IllegalArgumentException("No date or time style specified");
    }
    return pattern;
}
#method_after
// Android patch (http://b/28832222) start.
// Expose method to get format string for java.time.
/**
 * Get the date time format string for the specified values.
 * This is a copy of {@link #formatHelper(Calendar, ULocale, int, int)} with the following
 * changes:
 * <ul>
 *     <li>Made public, but hidden</li>
 *     <li>take calendar type string instead of Calendar</li>
 *     <li>Ignore overrides</li>
 *     <li>Return format string instead of DateFormat.</li>
 * </ul>
 * This is not meant as public API.
 * @hide draft / provisional / internal are hidden on Android
 */
public static String getDateTimeFormatString(ULocale loc, String calType, int dateStyle, int timeStyle) {
    if (timeStyle < DateFormat.NONE || timeStyle > DateFormat.SHORT) {
        throw new IllegalArgumentException("Illegal time style " + timeStyle);
    }
    if (dateStyle < DateFormat.NONE || dateStyle > DateFormat.SHORT) {
        throw new IllegalArgumentException("Illegal date style " + dateStyle);
    }
    PatternData patternData = PatternData.make(loc, calType);
    // Resolve a pattern for the date/time style
    String pattern = null;
    if ((timeStyle >= 0) && (dateStyle >= 0)) {
        pattern = SimpleFormatterImpl.formatRawPattern(patternData.getDateTimePattern(dateStyle), 2, 2, patternData.patterns[timeStyle], patternData.patterns[dateStyle + 4]);
    } else if (timeStyle >= 0) {
        pattern = patternData.patterns[timeStyle];
    } else if (dateStyle >= 0) {
        pattern = patternData.patterns[dateStyle + 4];
    } else {
        throw new IllegalArgumentException("No date or time style specified");
    }
    return pattern;
}
#end_block

#method_before
private static PatternData make(Calendar cal, ULocale loc) {
    // Android patch (http://b/28832222) start.
    return make(cal.getType(), loc);
}
#method_after
private static PatternData make(Calendar cal, ULocale loc) {
    // Android patch (http://b/28832222) start.
    return make(loc, cal.getType());
}
#end_block

#method_before
private static PatternData make(String calType, ULocale loc) {
    // Android patch (http://b/28832222) end.
    // First, try to get a pattern from PATTERN_CACHE
    String key = loc.getBaseName() + "+" + calType;
    PatternData patternData = PATTERN_CACHE.get(key);
    if (patternData == null) {
        // Cache missed.  Get one from bundle
        try {
            CalendarData calData = new CalendarData(loc, calType);
            patternData = new PatternData(calData.getDateTimePatterns(), calData.getOverrides());
        } catch (MissingResourceException e) {
            patternData = new PatternData(DEFAULT_PATTERNS, null);
        }
        PATTERN_CACHE.put(key, patternData);
    }
    return patternData;
}
#method_after
private static PatternData make(ULocale loc, String calType) {
    // Android patch (http://b/28832222) end.
    // First, try to get a pattern from PATTERN_CACHE
    String key = loc.getBaseName() + "+" + calType;
    PatternData patternData = PATTERN_CACHE.get(key);
    if (patternData == null) {
        // Cache missed.  Get one from bundle
        try {
            patternData = getPatternData(loc, calType);
        } catch (MissingResourceException e) {
            patternData = new PatternData(DEFAULT_PATTERNS, null);
        }
        PATTERN_CACHE.put(key, patternData);
    }
    return patternData;
}
#end_block

#method_before
// -------------------------------------------------------------------------
// End of weekend support
// -------------------------------------------------------------------------
public Object clone() {
    try {
        Calendar other = (Calendar) super.clone();
        other.fields = new int[fields.length];
        other.stamp = new int[fields.length];
        System.arraycopy(this.fields, 0, other.fields, 0, fields.length);
        System.arraycopy(this.stamp, 0, other.stamp, 0, fields.length);
        other.zone = (TimeZone) zone.clone();
        return other;
    } catch (CloneNotSupportedException e) {
        // this shouldn't happen, since we are Cloneable
        throw new ICUCloneNotSupportedException(e);
    }
}
#method_after
// -------------------------------------------------------------------------
// End of weekend support
// -------------------------------------------------------------------------
@Override
public Object clone() {
    try {
        Calendar other = (Calendar) super.clone();
        other.fields = new int[fields.length];
        other.stamp = new int[fields.length];
        System.arraycopy(this.fields, 0, other.fields, 0, fields.length);
        System.arraycopy(this.stamp, 0, other.stamp, 0, fields.length);
        other.zone = (TimeZone) zone.clone();
        return other;
    } catch (CloneNotSupportedException e) {
        // this shouldn't happen, since we are Cloneable
        throw new ICUCloneNotSupportedException(e);
    }
}
#end_block

#method_before
public String toString() {
    StringBuilder buffer = new StringBuilder();
    buffer.append(getClass().getName());
    buffer.append("[time=");
    buffer.append(isTimeSet ? String.valueOf(time) : "?");
    buffer.append(",areFieldsSet=");
    buffer.append(areFieldsSet);
    buffer.append(",areAllFieldsSet=");
    buffer.append(areAllFieldsSet);
    buffer.append(",lenient=");
    buffer.append(lenient);
    buffer.append(",zone=");
    buffer.append(zone);
    buffer.append(",firstDayOfWeek=");
    buffer.append(firstDayOfWeek);
    buffer.append(",minimalDaysInFirstWeek=");
    buffer.append(minimalDaysInFirstWeek);
    buffer.append(",repeatedWallTime=");
    buffer.append(repeatedWallTime);
    buffer.append(",skippedWallTime=");
    buffer.append(skippedWallTime);
    for (int i = 0; i < fields.length; ++i) {
        buffer.append(',').append(fieldName(i)).append('=');
        buffer.append(isSet(i) ? String.valueOf(fields[i]) : "?");
    }
    buffer.append(']');
    return buffer.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder buffer = new StringBuilder();
    buffer.append(getClass().getName());
    buffer.append("[time=");
    buffer.append(isTimeSet ? String.valueOf(time) : "?");
    buffer.append(",areFieldsSet=");
    buffer.append(areFieldsSet);
    buffer.append(",areAllFieldsSet=");
    buffer.append(areAllFieldsSet);
    buffer.append(",lenient=");
    buffer.append(lenient);
    buffer.append(",zone=");
    buffer.append(zone);
    buffer.append(",firstDayOfWeek=");
    buffer.append(firstDayOfWeek);
    buffer.append(",minimalDaysInFirstWeek=");
    buffer.append(minimalDaysInFirstWeek);
    buffer.append(",repeatedWallTime=");
    buffer.append(repeatedWallTime);
    buffer.append(",skippedWallTime=");
    buffer.append(skippedWallTime);
    for (int i = 0; i < fields.length; ++i) {
        buffer.append(',').append(fieldName(i)).append('=');
        buffer.append(isSet(i) ? String.valueOf(fields[i]) : "?");
    }
    buffer.append(']');
    return buffer.toString();
}
#end_block

#method_before
private static WeekData getWeekDataForRegionInternal(String region) {
    if (region == null) {
        region = "001";
    }
    UResourceBundle rb = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
    UResourceBundle weekDataInfo = rb.get("weekData");
    UResourceBundle weekDataBundle = null;
    try {
        weekDataBundle = weekDataInfo.get(region);
    } catch (MissingResourceException mre) {
        if (!region.equals("001")) {
            // use "001" as fallback
            weekDataBundle = weekDataInfo.get("001");
        } else {
            throw mre;
        }
    }
    int[] wdi = weekDataBundle.getIntVector();
    return new WeekData(wdi[0], wdi[1], wdi[2], wdi[3], wdi[4], wdi[5]);
}
#method_after
private static WeekData getWeekDataForRegionInternal(String region) {
    if (region == null) {
        region = "001";
    }
    UResourceBundle rb = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
    UResourceBundle weekDataInfo = rb.get("weekData");
    UResourceBundle weekDataBundle = null;
    try {
        weekDataBundle = weekDataInfo.get(region);
    } catch (MissingResourceException mre) {
        if (!region.equals("001")) {
            // use "001" as fallback
            weekDataBundle = weekDataInfo.get("001");
        } else {
            throw mre;
        }
    }
    int[] wdi = weekDataBundle.getIntVector();
    return new WeekData(wdi[0], wdi[1], wdi[2], wdi[3], wdi[4], wdi[5]);
}
#end_block

#method_before
protected int computeZoneOffset(long millis, int millisInDay) {
    int[] offsets = new int[2];
    long wall = millis + millisInDay;
    if (zone instanceof BasicTimeZone) {
        int duplicatedTimeOpt = (repeatedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_FORMER : BasicTimeZone.LOCAL_LATTER;
        int nonExistingTimeOpt = (skippedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_LATTER : BasicTimeZone.LOCAL_FORMER;
        ((BasicTimeZone) zone).getOffsetFromLocal(wall, nonExistingTimeOpt, duplicatedTimeOpt, offsets);
    } else {
        // By default, TimeZone#getOffset behaves WALLTIME_LAST for both.
        zone.getOffset(wall, true, offsets);
        boolean sawRecentNegativeShift = false;
        if (repeatedWallTime == WALLTIME_FIRST) {
            // Check if the given wall time falls into repeated time range
            long tgmt = wall - (offsets[0] + offsets[1]);
            // Any negative zone transition within last 6 hours?
            // Note: The maximum historic negative zone transition is -3 hours in the tz database.
            // 6 hour window would be sufficient for this purpose.
            int offsetBefore6 = zone.getOffset(tgmt - 6 * 60 * 60 * 1000);
            int offsetDelta = (offsets[0] + offsets[1]) - offsetBefore6;
            assert offsetDelta < -6 * 60 * 60 * 1000 : offsetDelta;
            if (offsetDelta < 0) {
                sawRecentNegativeShift = true;
                // Negative shift within last 6 hours. When WALLTIME_FIRST is used and the given wall time falls
                // into the repeated time range, use offsets before the transition.
                // Note: If it does not fall into the repeated time range, offsets remain unchanged below.
                zone.getOffset(wall + offsetDelta, true, offsets);
            }
        }
        if (!sawRecentNegativeShift && skippedWallTime == WALLTIME_FIRST) {
            // When skipped wall time option is WALLTIME_FIRST,
            // recalculate offsets from the resolved time (non-wall).
            // When the given wall time falls into skipped wall time,
            // the offsets will be based on the zone offsets AFTER
            // the transition (which means, earliest possibe interpretation).
            long tgmt = wall - (offsets[0] + offsets[1]);
            zone.getOffset(tgmt, false, offsets);
        }
    }
    return offsets[0] + offsets[1];
}
#method_after
protected int computeZoneOffset(long millis, int millisInDay) {
    int[] offsets = new int[2];
    long wall = millis + millisInDay;
    if (zone instanceof BasicTimeZone) {
        int duplicatedTimeOpt = (repeatedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_FORMER : BasicTimeZone.LOCAL_LATTER;
        int nonExistingTimeOpt = (skippedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_LATTER : BasicTimeZone.LOCAL_FORMER;
        ((BasicTimeZone) zone).getOffsetFromLocal(wall, nonExistingTimeOpt, duplicatedTimeOpt, offsets);
    } else {
        // By default, TimeZone#getOffset behaves WALLTIME_LAST for both.
        zone.getOffset(wall, true, offsets);
        boolean sawRecentNegativeShift = false;
        if (repeatedWallTime == WALLTIME_FIRST) {
            // Check if the given wall time falls into repeated time range
            long tgmt = wall - (offsets[0] + offsets[1]);
            // Any negative zone transition within last 6 hours?
            // Note: The maximum historic negative zone transition is -3 hours in the tz database.
            // 6 hour window would be sufficient for this purpose.
            int offsetBefore6 = zone.getOffset(tgmt - 6 * 60 * 60 * 1000);
            int offsetDelta = (offsets[0] + offsets[1]) - offsetBefore6;
            assert offsetDelta > -6 * 60 * 60 * 1000 : offsetDelta;
            if (offsetDelta < 0) {
                sawRecentNegativeShift = true;
                // Negative shift within last 6 hours. When WALLTIME_FIRST is used and the given wall time falls
                // into the repeated time range, use offsets before the transition.
                // Note: If it does not fall into the repeated time range, offsets remain unchanged below.
                zone.getOffset(wall + offsetDelta, true, offsets);
            }
        }
        if (!sawRecentNegativeShift && skippedWallTime == WALLTIME_FIRST) {
            // When skipped wall time option is WALLTIME_FIRST,
            // recalculate offsets from the resolved time (non-wall).
            // When the given wall time falls into skipped wall time,
            // the offsets will be based on the zone offsets AFTER
            // the transition (which means, earliest possibe interpretation).
            long tgmt = wall - (offsets[0] + offsets[1]);
            zone.getOffset(tgmt, false, offsets);
        }
    }
    return offsets[0] + offsets[1];
}
#end_block

#method_before
public static final String[] getKeywordValuesForLocale(String key, ULocale locale, boolean commonlyUsed) {
    // Resolve region
    String prefRegion = ULocale.getRegionForSupplementalData(locale, true);
    // Read preferred calendar values from supplementalData calendarPreferences
    ArrayList<String> values = new ArrayList<String>();
    UResourceBundle rb = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
    UResourceBundle calPref = rb.get("calendarPreferenceData");
    UResourceBundle order = null;
    try {
        order = calPref.get(prefRegion);
    } catch (MissingResourceException mre) {
        // use "001" as fallback
        order = calPref.get("001");
    }
    String[] caltypes = order.getStringArray();
    if (commonlyUsed) {
        // we have all commonly used calendar for the target region
        return caltypes;
    }
    // if not commonlyUsed, add all preferred calendars in the order
    for (int i = 0; i < caltypes.length; i++) {
        values.add(caltypes[i]);
    }
    // then, add other available clanedars
    for (CalType t : CalType.values()) {
        if (!values.contains(t.id)) {
            values.add(t.id);
        }
    }
    return values.toArray(new String[values.size()]);
}
#method_after
public static final String[] getKeywordValuesForLocale(String key, ULocale locale, boolean commonlyUsed) {
    // Resolve region
    String prefRegion = ULocale.getRegionForSupplementalData(locale, true);
    // Read preferred calendar values from supplementalData calendarPreferences
    ArrayList<String> values = new ArrayList<String>();
    UResourceBundle rb = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
    UResourceBundle calPref = rb.get("calendarPreferenceData");
    UResourceBundle order = null;
    try {
        order = calPref.get(prefRegion);
    } catch (MissingResourceException mre) {
        // use "001" as fallback
        order = calPref.get("001");
    }
    String[] caltypes = order.getStringArray();
    if (commonlyUsed) {
        // we have all commonly used calendar for the target region
        return caltypes;
    }
    // if not commonlyUsed, add all preferred calendars in the order
    for (int i = 0; i < caltypes.length; i++) {
        values.add(caltypes[i]);
    }
    // then, add other available clanedars
    for (CalType t : CalType.values()) {
        if (!values.contains(t.id)) {
            values.add(t.id);
        }
    }
    return values.toArray(new String[values.size()]);
}
#end_block

#method_before
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (this.getClass() != obj.getClass()) {
        return false;
    }
    Calendar that = (Calendar) obj;
    return isEquivalentTo(that) && getTimeInMillis() == that.getTime().getTime();
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (this.getClass() != obj.getClass()) {
        return false;
    }
    Calendar that = (Calendar) obj;
    return isEquivalentTo(that) && getTimeInMillis() == that.getTime().getTime();
}
#end_block

#method_before
public int hashCode() {
    /* Don't include the time because (a) we don't want the hash value to
         * move around just because a calendar is set to different times, and
         * (b) we don't want to trigger a time computation just to get a hash.
         * Note that it is not necessary for unequal objects to always have
         * unequal hashes, but equal objects must have equal hashes.  */
    return (lenient ? 1 : 0) | (firstDayOfWeek << 1) | (minimalDaysInFirstWeek << 4) | (repeatedWallTime << 7) | (skippedWallTime << 9) | (zone.hashCode() << 11);
}
#method_after
@Override
public int hashCode() {
    /* Don't include the time because (a) we don't want the hash value to
         * move around just because a calendar is set to different times, and
         * (b) we don't want to trigger a time computation just to get a hash.
         * Note that it is not necessary for unequal objects to always have
         * unequal hashes, but equal objects must have equal hashes.  */
    return (lenient ? 1 : 0) | (firstDayOfWeek << 1) | (minimalDaysInFirstWeek << 4) | (repeatedWallTime << 7) | (skippedWallTime << 9) | (zone.hashCode() << 11);
}
#end_block

#method_before
public int compareTo(Calendar that) {
    long v = getTimeInMillis() - that.getTimeInMillis();
    return v < 0 ? -1 : (v > 0 ? 1 : 0);
}
#method_after
@Override
public int compareTo(Calendar that) {
    long v = getTimeInMillis() - that.getTimeInMillis();
    return v < 0 ? -1 : (v > 0 ? 1 : 0);
}
#end_block

#method_before
// Android patch (http://b/28832222) start.
// Expose method to get format string for java.time.
public static String getDateTimeFormatString(String calType, ULocale loc, int dateStyle, int timeStyle) {
    if (timeStyle < DateFormat.NONE || timeStyle > DateFormat.SHORT) {
        throw new IllegalArgumentException("Illegal time style " + timeStyle);
    }
    if (dateStyle < DateFormat.NONE || dateStyle > DateFormat.SHORT) {
        throw new IllegalArgumentException("Illegal date style " + dateStyle);
    }
    PatternData patternData = PatternData.make(calType, loc);
    // Resolve a pattern for the date/time style
    String pattern = null;
    if ((timeStyle >= 0) && (dateStyle >= 0)) {
        pattern = SimpleFormatterImpl.formatRawPattern(patternData.getDateTimePattern(dateStyle), 2, 2, patternData.patterns[timeStyle], patternData.patterns[dateStyle + 4]);
    } else if (timeStyle >= 0) {
        pattern = patternData.patterns[timeStyle];
    } else if (dateStyle >= 0) {
        pattern = patternData.patterns[dateStyle + 4];
    } else {
        throw new IllegalArgumentException("No date or time style specified");
    }
    return pattern;
}
#method_after
// Android patch (http://b/28832222) start.
// Expose method to get format string for java.time.
/**
 * Get the date time format string for the specified values.
 * This is a copy of {@link #formatHelper(Calendar, ULocale, int, int)} with the following
 * changes:
 * <ul>
 *     <li>Made public, but hidden</li>
 *     <li>take calendar type string instead of Calendar</li>
 *     <li>Ignore overrides</li>
 *     <li>Return format string instead of DateFormat.</li>
 * </ul>
 * This is not meant as public API.
 * @internal
 */
public static String getDateTimeFormatString(ULocale loc, String calType, int dateStyle, int timeStyle) {
    if (timeStyle < DateFormat.NONE || timeStyle > DateFormat.SHORT) {
        throw new IllegalArgumentException("Illegal time style " + timeStyle);
    }
    if (dateStyle < DateFormat.NONE || dateStyle > DateFormat.SHORT) {
        throw new IllegalArgumentException("Illegal date style " + dateStyle);
    }
    PatternData patternData = PatternData.make(loc, calType);
    // Resolve a pattern for the date/time style
    String pattern = null;
    if ((timeStyle >= 0) && (dateStyle >= 0)) {
        pattern = SimpleFormatterImpl.formatRawPattern(patternData.getDateTimePattern(dateStyle), 2, 2, patternData.patterns[timeStyle], patternData.patterns[dateStyle + 4]);
    } else if (timeStyle >= 0) {
        pattern = patternData.patterns[timeStyle];
    } else if (dateStyle >= 0) {
        pattern = patternData.patterns[dateStyle + 4];
    } else {
        throw new IllegalArgumentException("No date or time style specified");
    }
    return pattern;
}
#end_block

#method_before
private static PatternData make(Calendar cal, ULocale loc) {
    // Android patch (http://b/28832222) start.
    return make(cal.getType(), loc);
}
#method_after
private static PatternData make(Calendar cal, ULocale loc) {
    // Android patch (http://b/28832222) start.
    return make(loc, cal.getType());
}
#end_block

#method_before
private static PatternData make(String calType, ULocale loc) {
    // Android patch (http://b/28832222) end.
    // First, try to get a pattern from PATTERN_CACHE
    String key = loc.getBaseName() + "+" + calType;
    PatternData patternData = PATTERN_CACHE.get(key);
    if (patternData == null) {
        // Cache missed.  Get one from bundle
        try {
            CalendarData calData = new CalendarData(loc, calType);
            patternData = new PatternData(calData.getDateTimePatterns(), calData.getOverrides());
        } catch (MissingResourceException e) {
            patternData = new PatternData(DEFAULT_PATTERNS, null);
        }
        PATTERN_CACHE.put(key, patternData);
    }
    return patternData;
}
#method_after
private static PatternData make(ULocale loc, String calType) {
    // Android patch (http://b/28832222) end.
    // First, try to get a pattern from PATTERN_CACHE
    String key = loc.getBaseName() + "+" + calType;
    PatternData patternData = PATTERN_CACHE.get(key);
    if (patternData == null) {
        // Cache missed.  Get one from bundle
        try {
            patternData = getPatternData(loc, calType);
        } catch (MissingResourceException e) {
            patternData = new PatternData(DEFAULT_PATTERNS, null);
        }
        PATTERN_CACHE.put(key, patternData);
    }
    return patternData;
}
#end_block

#method_before
// -------------------------------------------------------------------------
// End of weekend support
// -------------------------------------------------------------------------
public Object clone() {
    try {
        Calendar other = (Calendar) super.clone();
        other.fields = new int[fields.length];
        other.stamp = new int[fields.length];
        System.arraycopy(this.fields, 0, other.fields, 0, fields.length);
        System.arraycopy(this.stamp, 0, other.stamp, 0, fields.length);
        other.zone = (TimeZone) zone.clone();
        return other;
    } catch (CloneNotSupportedException e) {
        // this shouldn't happen, since we are Cloneable
        throw new ICUCloneNotSupportedException(e);
    }
}
#method_after
// -------------------------------------------------------------------------
// End of weekend support
// -------------------------------------------------------------------------
@Override
public Object clone() {
    try {
        Calendar other = (Calendar) super.clone();
        other.fields = new int[fields.length];
        other.stamp = new int[fields.length];
        System.arraycopy(this.fields, 0, other.fields, 0, fields.length);
        System.arraycopy(this.stamp, 0, other.stamp, 0, fields.length);
        other.zone = (TimeZone) zone.clone();
        return other;
    } catch (CloneNotSupportedException e) {
        // this shouldn't happen, since we are Cloneable
        throw new ICUCloneNotSupportedException(e);
    }
}
#end_block

#method_before
public String toString() {
    StringBuilder buffer = new StringBuilder();
    buffer.append(getClass().getName());
    buffer.append("[time=");
    buffer.append(isTimeSet ? String.valueOf(time) : "?");
    buffer.append(",areFieldsSet=");
    buffer.append(areFieldsSet);
    buffer.append(",areAllFieldsSet=");
    buffer.append(areAllFieldsSet);
    buffer.append(",lenient=");
    buffer.append(lenient);
    buffer.append(",zone=");
    buffer.append(zone);
    buffer.append(",firstDayOfWeek=");
    buffer.append(firstDayOfWeek);
    buffer.append(",minimalDaysInFirstWeek=");
    buffer.append(minimalDaysInFirstWeek);
    buffer.append(",repeatedWallTime=");
    buffer.append(repeatedWallTime);
    buffer.append(",skippedWallTime=");
    buffer.append(skippedWallTime);
    for (int i = 0; i < fields.length; ++i) {
        buffer.append(',').append(fieldName(i)).append('=');
        buffer.append(isSet(i) ? String.valueOf(fields[i]) : "?");
    }
    buffer.append(']');
    return buffer.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder buffer = new StringBuilder();
    buffer.append(getClass().getName());
    buffer.append("[time=");
    buffer.append(isTimeSet ? String.valueOf(time) : "?");
    buffer.append(",areFieldsSet=");
    buffer.append(areFieldsSet);
    buffer.append(",areAllFieldsSet=");
    buffer.append(areAllFieldsSet);
    buffer.append(",lenient=");
    buffer.append(lenient);
    buffer.append(",zone=");
    buffer.append(zone);
    buffer.append(",firstDayOfWeek=");
    buffer.append(firstDayOfWeek);
    buffer.append(",minimalDaysInFirstWeek=");
    buffer.append(minimalDaysInFirstWeek);
    buffer.append(",repeatedWallTime=");
    buffer.append(repeatedWallTime);
    buffer.append(",skippedWallTime=");
    buffer.append(skippedWallTime);
    for (int i = 0; i < fields.length; ++i) {
        buffer.append(',').append(fieldName(i)).append('=');
        buffer.append(isSet(i) ? String.valueOf(fields[i]) : "?");
    }
    buffer.append(']');
    return buffer.toString();
}
#end_block

#method_before
private static WeekData getWeekDataForRegionInternal(String region) {
    if (region == null) {
        region = "001";
    }
    UResourceBundle rb = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
    UResourceBundle weekDataInfo = rb.get("weekData");
    UResourceBundle weekDataBundle = null;
    try {
        weekDataBundle = weekDataInfo.get(region);
    } catch (MissingResourceException mre) {
        if (!region.equals("001")) {
            // use "001" as fallback
            weekDataBundle = weekDataInfo.get("001");
        } else {
            throw mre;
        }
    }
    int[] wdi = weekDataBundle.getIntVector();
    return new WeekData(wdi[0], wdi[1], wdi[2], wdi[3], wdi[4], wdi[5]);
}
#method_after
private static WeekData getWeekDataForRegionInternal(String region) {
    if (region == null) {
        region = "001";
    }
    UResourceBundle rb = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
    UResourceBundle weekDataInfo = rb.get("weekData");
    UResourceBundle weekDataBundle = null;
    try {
        weekDataBundle = weekDataInfo.get(region);
    } catch (MissingResourceException mre) {
        if (!region.equals("001")) {
            // use "001" as fallback
            weekDataBundle = weekDataInfo.get("001");
        } else {
            throw mre;
        }
    }
    int[] wdi = weekDataBundle.getIntVector();
    return new WeekData(wdi[0], wdi[1], wdi[2], wdi[3], wdi[4], wdi[5]);
}
#end_block

#method_before
protected int computeZoneOffset(long millis, int millisInDay) {
    int[] offsets = new int[2];
    long wall = millis + millisInDay;
    if (zone instanceof BasicTimeZone) {
        int duplicatedTimeOpt = (repeatedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_FORMER : BasicTimeZone.LOCAL_LATTER;
        int nonExistingTimeOpt = (skippedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_LATTER : BasicTimeZone.LOCAL_FORMER;
        ((BasicTimeZone) zone).getOffsetFromLocal(wall, nonExistingTimeOpt, duplicatedTimeOpt, offsets);
    } else {
        // By default, TimeZone#getOffset behaves WALLTIME_LAST for both.
        zone.getOffset(wall, true, offsets);
        boolean sawRecentNegativeShift = false;
        if (repeatedWallTime == WALLTIME_FIRST) {
            // Check if the given wall time falls into repeated time range
            long tgmt = wall - (offsets[0] + offsets[1]);
            // Any negative zone transition within last 6 hours?
            // Note: The maximum historic negative zone transition is -3 hours in the tz database.
            // 6 hour window would be sufficient for this purpose.
            int offsetBefore6 = zone.getOffset(tgmt - 6 * 60 * 60 * 1000);
            int offsetDelta = (offsets[0] + offsets[1]) - offsetBefore6;
            assert offsetDelta < -6 * 60 * 60 * 1000 : offsetDelta;
            if (offsetDelta < 0) {
                sawRecentNegativeShift = true;
                // Negative shift within last 6 hours. When WALLTIME_FIRST is used and the given wall time falls
                // into the repeated time range, use offsets before the transition.
                // Note: If it does not fall into the repeated time range, offsets remain unchanged below.
                zone.getOffset(wall + offsetDelta, true, offsets);
            }
        }
        if (!sawRecentNegativeShift && skippedWallTime == WALLTIME_FIRST) {
            // When skipped wall time option is WALLTIME_FIRST,
            // recalculate offsets from the resolved time (non-wall).
            // When the given wall time falls into skipped wall time,
            // the offsets will be based on the zone offsets AFTER
            // the transition (which means, earliest possibe interpretation).
            long tgmt = wall - (offsets[0] + offsets[1]);
            zone.getOffset(tgmt, false, offsets);
        }
    }
    return offsets[0] + offsets[1];
}
#method_after
protected int computeZoneOffset(long millis, int millisInDay) {
    int[] offsets = new int[2];
    long wall = millis + millisInDay;
    if (zone instanceof BasicTimeZone) {
        int duplicatedTimeOpt = (repeatedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_FORMER : BasicTimeZone.LOCAL_LATTER;
        int nonExistingTimeOpt = (skippedWallTime == WALLTIME_FIRST) ? BasicTimeZone.LOCAL_LATTER : BasicTimeZone.LOCAL_FORMER;
        ((BasicTimeZone) zone).getOffsetFromLocal(wall, nonExistingTimeOpt, duplicatedTimeOpt, offsets);
    } else {
        // By default, TimeZone#getOffset behaves WALLTIME_LAST for both.
        zone.getOffset(wall, true, offsets);
        boolean sawRecentNegativeShift = false;
        if (repeatedWallTime == WALLTIME_FIRST) {
            // Check if the given wall time falls into repeated time range
            long tgmt = wall - (offsets[0] + offsets[1]);
            // Any negative zone transition within last 6 hours?
            // Note: The maximum historic negative zone transition is -3 hours in the tz database.
            // 6 hour window would be sufficient for this purpose.
            int offsetBefore6 = zone.getOffset(tgmt - 6 * 60 * 60 * 1000);
            int offsetDelta = (offsets[0] + offsets[1]) - offsetBefore6;
            assert offsetDelta > -6 * 60 * 60 * 1000 : offsetDelta;
            if (offsetDelta < 0) {
                sawRecentNegativeShift = true;
                // Negative shift within last 6 hours. When WALLTIME_FIRST is used and the given wall time falls
                // into the repeated time range, use offsets before the transition.
                // Note: If it does not fall into the repeated time range, offsets remain unchanged below.
                zone.getOffset(wall + offsetDelta, true, offsets);
            }
        }
        if (!sawRecentNegativeShift && skippedWallTime == WALLTIME_FIRST) {
            // When skipped wall time option is WALLTIME_FIRST,
            // recalculate offsets from the resolved time (non-wall).
            // When the given wall time falls into skipped wall time,
            // the offsets will be based on the zone offsets AFTER
            // the transition (which means, earliest possibe interpretation).
            long tgmt = wall - (offsets[0] + offsets[1]);
            zone.getOffset(tgmt, false, offsets);
        }
    }
    return offsets[0] + offsets[1];
}
#end_block

#method_before
public Object clone() {
    try {
        DateFormatSymbols other = (DateFormatSymbols) super.clone();
        return other;
    } catch (CloneNotSupportedException e) {
        // /CLOVER:OFF
        throw new ICUCloneNotSupportedException(e);
    // /CLOVER:ON
    }
}
#method_after
@Override
public Object clone() {
    try {
        DateFormatSymbols other = (DateFormatSymbols) super.clone();
        return other;
    } catch (CloneNotSupportedException e) {
        // /CLOVER:OFF
        throw new ICUCloneNotSupportedException(e);
    // /CLOVER:ON
    }
}
#end_block

#method_before
public int hashCode() {
    // Is this sufficient?
    return requestedLocale.toString().hashCode();
}
#method_after
@Override
public int hashCode() {
    // Is this sufficient?
    return requestedLocale.toString().hashCode();
}
#end_block

#method_before
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null || getClass() != obj.getClass())
        return false;
    DateFormatSymbols that = (DateFormatSymbols) obj;
    return (Utility.arrayEquals(eras, that.eras) && Utility.arrayEquals(eraNames, that.eraNames) && Utility.arrayEquals(months, that.months) && Utility.arrayEquals(shortMonths, that.shortMonths) && Utility.arrayEquals(narrowMonths, that.narrowMonths) && Utility.arrayEquals(standaloneMonths, that.standaloneMonths) && Utility.arrayEquals(standaloneShortMonths, that.standaloneShortMonths) && Utility.arrayEquals(standaloneNarrowMonths, that.standaloneNarrowMonths) && Utility.arrayEquals(weekdays, that.weekdays) && Utility.arrayEquals(shortWeekdays, that.shortWeekdays) && Utility.arrayEquals(shorterWeekdays, that.shorterWeekdays) && Utility.arrayEquals(narrowWeekdays, that.narrowWeekdays) && Utility.arrayEquals(standaloneWeekdays, that.standaloneWeekdays) && Utility.arrayEquals(standaloneShortWeekdays, that.standaloneShortWeekdays) && Utility.arrayEquals(standaloneShorterWeekdays, that.standaloneShorterWeekdays) && Utility.arrayEquals(standaloneNarrowWeekdays, that.standaloneNarrowWeekdays) && Utility.arrayEquals(ampms, that.ampms) && Utility.arrayEquals(ampmsNarrow, that.ampmsNarrow) && Utility.arrayEquals(abbreviatedDayPeriods, that.abbreviatedDayPeriods) && Utility.arrayEquals(wideDayPeriods, that.wideDayPeriods) && Utility.arrayEquals(narrowDayPeriods, that.narrowDayPeriods) && Utility.arrayEquals(standaloneAbbreviatedDayPeriods, that.standaloneAbbreviatedDayPeriods) && Utility.arrayEquals(standaloneWideDayPeriods, that.standaloneWideDayPeriods) && Utility.arrayEquals(standaloneNarrowDayPeriods, that.standaloneNarrowDayPeriods) && Utility.arrayEquals(timeSeparator, that.timeSeparator) && arrayOfArrayEquals(zoneStrings, that.zoneStrings) && // I thought canolicalize() would map the codes but .. alas! it doesn't.
    requestedLocale.getDisplayName().equals(that.requestedLocale.getDisplayName()) && Utility.arrayEquals(localPatternChars, that.localPatternChars));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null || getClass() != obj.getClass())
        return false;
    DateFormatSymbols that = (DateFormatSymbols) obj;
    return (Utility.arrayEquals(eras, that.eras) && Utility.arrayEquals(eraNames, that.eraNames) && Utility.arrayEquals(months, that.months) && Utility.arrayEquals(shortMonths, that.shortMonths) && Utility.arrayEquals(narrowMonths, that.narrowMonths) && Utility.arrayEquals(standaloneMonths, that.standaloneMonths) && Utility.arrayEquals(standaloneShortMonths, that.standaloneShortMonths) && Utility.arrayEquals(standaloneNarrowMonths, that.standaloneNarrowMonths) && Utility.arrayEquals(weekdays, that.weekdays) && Utility.arrayEquals(shortWeekdays, that.shortWeekdays) && Utility.arrayEquals(shorterWeekdays, that.shorterWeekdays) && Utility.arrayEquals(narrowWeekdays, that.narrowWeekdays) && Utility.arrayEquals(standaloneWeekdays, that.standaloneWeekdays) && Utility.arrayEquals(standaloneShortWeekdays, that.standaloneShortWeekdays) && Utility.arrayEquals(standaloneShorterWeekdays, that.standaloneShorterWeekdays) && Utility.arrayEquals(standaloneNarrowWeekdays, that.standaloneNarrowWeekdays) && Utility.arrayEquals(ampms, that.ampms) && Utility.arrayEquals(ampmsNarrow, that.ampmsNarrow) && Utility.arrayEquals(abbreviatedDayPeriods, that.abbreviatedDayPeriods) && Utility.arrayEquals(wideDayPeriods, that.wideDayPeriods) && Utility.arrayEquals(narrowDayPeriods, that.narrowDayPeriods) && Utility.arrayEquals(standaloneAbbreviatedDayPeriods, that.standaloneAbbreviatedDayPeriods) && Utility.arrayEquals(standaloneWideDayPeriods, that.standaloneWideDayPeriods) && Utility.arrayEquals(standaloneNarrowDayPeriods, that.standaloneNarrowDayPeriods) && Utility.arrayEquals(timeSeparator, that.timeSeparator) && arrayOfArrayEquals(zoneStrings, that.zoneStrings) && // I thought canolicalize() would map the codes but .. alas! it doesn't.
    requestedLocale.getDisplayName().equals(that.requestedLocale.getDisplayName()) && Utility.arrayEquals(localPatternChars, that.localPatternChars));
}
#end_block

#method_before
/**
 * Initializes format symbols for the locale and calendar type
 * @param desiredLocale The locale whose symbols are desired.
 * @param type          The calendar type whose date format symbols are desired.
 * @stable ICU 3.0
 */
// TODO: This protected seems to be marked as @stable accidentally.
protected void initializeData(ULocale desiredLocale, String type) {
    String key = desiredLocale.getBaseName() + "+" + type;
    String ns = desiredLocale.getKeywordValue("numbers");
    if (ns != null && ns.length() > 0) {
        key += "+" + ns;
    }
    DateFormatSymbols dfs = DFSCACHE.get(key);
    if (dfs == null) {
        // Initialize data from scratch put a clone of this instance into the cache
        CalendarData calData = new CalendarData(desiredLocale, type);
        initializeData(desiredLocale, calData);
        // Do not cache subclass instances
        if (this.getClass().getName().equals("com.ibm.icu.text.DateFormatSymbols")) {
            dfs = (DateFormatSymbols) this.clone();
            DFSCACHE.put(key, dfs);
        }
    } else {
        initializeData(dfs);
    }
}
#method_after
/**
 * Initializes format symbols for the locale and calendar type
 * @param desiredLocale The locale whose symbols are desired.
 * @param type          The calendar type whose date format symbols are desired.
 * @stable ICU 3.0
 */
// TODO: This protected seems to be marked as @stable accidentally.
protected void initializeData(ULocale desiredLocale, String type) {
    String key = desiredLocale.getBaseName() + '+' + type;
    String ns = desiredLocale.getKeywordValue("numbers");
    if (ns != null && ns.length() > 0) {
        key += '+' + ns;
    }
    DateFormatSymbols dfs = DFSCACHE.getInstance(key, desiredLocale);
    initializeData(dfs);
}
#end_block

#method_before
@Deprecated
protected // This API was accidentally marked as @stable ICU 3.0 formerly.
void initializeData(ULocale desiredLocale, CalendarData calData) {
    // FIXME: cache only ResourceBundle. Hence every time, will do
    // getObject(). This won't be necessary if the Resource itself
    // is cached.
    eras = calData.getEras("abbreviated");
    eraNames = calData.getEras("wide");
    narrowEras = calData.getEras("narrow");
    months = calData.getStringArray("monthNames", "wide");
    shortMonths = calData.getStringArray("monthNames", "abbreviated");
    narrowMonths = calData.getStringArray("monthNames", "narrow");
    standaloneMonths = calData.getStringArray("monthNames", "stand-alone", "wide");
    standaloneShortMonths = calData.getStringArray("monthNames", "stand-alone", "abbreviated");
    standaloneNarrowMonths = calData.getStringArray("monthNames", "stand-alone", "narrow");
    String[] lWeekdays = calData.getStringArray("dayNames", "wide");
    weekdays = new String[8];
    // 1-based
    weekdays[0] = "";
    System.arraycopy(lWeekdays, 0, weekdays, 1, lWeekdays.length);
    String[] aWeekdays = calData.getStringArray("dayNames", "abbreviated");
    shortWeekdays = new String[8];
    // 1-based
    shortWeekdays[0] = "";
    System.arraycopy(aWeekdays, 0, shortWeekdays, 1, aWeekdays.length);
    String[] sWeekdays = calData.getStringArray("dayNames", "short");
    shorterWeekdays = new String[8];
    // 1-based
    shorterWeekdays[0] = "";
    System.arraycopy(sWeekdays, 0, shorterWeekdays, 1, sWeekdays.length);
    String[] nWeekdays = null;
    try {
        nWeekdays = calData.getStringArray("dayNames", "narrow");
    } catch (MissingResourceException e) {
        try {
            nWeekdays = calData.getStringArray("dayNames", "stand-alone", "narrow");
        } catch (MissingResourceException e1) {
            nWeekdays = calData.getStringArray("dayNames", "abbreviated");
        }
    }
    narrowWeekdays = new String[8];
    // 1-based
    narrowWeekdays[0] = "";
    System.arraycopy(nWeekdays, 0, narrowWeekdays, 1, nWeekdays.length);
    String[] swWeekdays = null;
    swWeekdays = calData.getStringArray("dayNames", "stand-alone", "wide");
    standaloneWeekdays = new String[8];
    // 1-based
    standaloneWeekdays[0] = "";
    System.arraycopy(swWeekdays, 0, standaloneWeekdays, 1, swWeekdays.length);
    String[] saWeekdays = null;
    saWeekdays = calData.getStringArray("dayNames", "stand-alone", "abbreviated");
    standaloneShortWeekdays = new String[8];
    // 1-based
    standaloneShortWeekdays[0] = "";
    System.arraycopy(saWeekdays, 0, standaloneShortWeekdays, 1, saWeekdays.length);
    String[] ssWeekdays = null;
    ssWeekdays = calData.getStringArray("dayNames", "stand-alone", "short");
    standaloneShorterWeekdays = new String[8];
    // 1-based
    standaloneShorterWeekdays[0] = "";
    System.arraycopy(ssWeekdays, 0, standaloneShorterWeekdays, 1, ssWeekdays.length);
    String[] snWeekdays = null;
    snWeekdays = calData.getStringArray("dayNames", "stand-alone", "narrow");
    standaloneNarrowWeekdays = new String[8];
    // 1-based
    standaloneNarrowWeekdays[0] = "";
    System.arraycopy(snWeekdays, 0, standaloneNarrowWeekdays, 1, snWeekdays.length);
    ampms = calData.getStringArray("AmPmMarkers");
    ampmsNarrow = calData.getStringArray("AmPmMarkersNarrow");
    quarters = calData.getStringArray("quarters", "wide");
    shortQuarters = calData.getStringArray("quarters", "abbreviated");
    standaloneQuarters = calData.getStringArray("quarters", "stand-alone", "wide");
    standaloneShortQuarters = calData.getStringArray("quarters", "stand-alone", "abbreviated");
    abbreviatedDayPeriods = loadDayPeriodStrings(calData, false, "abbreviated");
    wideDayPeriods = loadDayPeriodStrings(calData, false, "wide");
    narrowDayPeriods = loadDayPeriodStrings(calData, false, "narrow");
    standaloneAbbreviatedDayPeriods = loadDayPeriodStrings(calData, true, "abbreviated");
    standaloneWideDayPeriods = loadDayPeriodStrings(calData, true, "wide");
    standaloneNarrowDayPeriods = loadDayPeriodStrings(calData, true, "narrow");
    // The code for getting individual symbols in the leapMonthSymbols array is here
    // rather than in CalendarData because it depends on DateFormatSymbols constants...
    ICUResourceBundle monthPatternsBundle = null;
    try {
        monthPatternsBundle = calData.get("monthPatterns");
    } catch (MissingResourceException e) {
        // probably redundant
        monthPatternsBundle = null;
    }
    if (monthPatternsBundle != null) {
        leapMonthPatterns = new String[DT_MONTH_PATTERN_COUNT];
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_WIDE] = calData.get("monthPatterns", "wide").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_ABBREV] = calData.get("monthPatterns", "abbreviated").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_NARROW] = calData.get("monthPatterns", "narrow").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_WIDE] = calData.get("monthPatterns", "stand-alone", "wide").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_ABBREV] = calData.get("monthPatterns", "stand-alone", "abbreviated").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_NARROW] = calData.get("monthPatterns", "stand-alone", "narrow").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_NUMERIC] = calData.get("monthPatterns", "numeric", "all").get("leap").getString();
    }
    ICUResourceBundle cyclicNameSetsBundle = null;
    try {
        cyclicNameSetsBundle = calData.get("cyclicNameSets");
    } catch (MissingResourceException e) {
        // probably redundant
        cyclicNameSetsBundle = null;
    }
    if (cyclicNameSetsBundle != null) {
        shortYearNames = calData.get("cyclicNameSets", "years", "format", "abbreviated").getStringArray();
        shortZodiacNames = calData.get("cyclicNameSets", "zodiacs", "format", "abbreviated").getStringArray();
    }
    requestedLocale = desiredLocale;
    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, desiredLocale);
    // Because localized date/time pattern characters will be obsolete in CLDR,
    // we decided not to maintain localized pattern characters in ICU any more.
    // We always use the base pattern characters by default. (ticket#5597)
    // localPatternChars = rb.getString("localPatternChars");
    localPatternChars = patternChars;
    // TODO: obtain correct actual/valid locale later
    ULocale uloc = rb.getULocale();
    setLocale(uloc, uloc);
    capitalization = new HashMap<CapitalizationContextUsage, boolean[]>();
    boolean[] noTransforms = new boolean[2];
    noTransforms[0] = false;
    noTransforms[1] = false;
    CapitalizationContextUsage[] allUsages = CapitalizationContextUsage.values();
    for (CapitalizationContextUsage usage : allUsages) {
        capitalization.put(usage, noTransforms);
    }
    UResourceBundle contextTransformsBundle = null;
    try {
        contextTransformsBundle = (UResourceBundle) rb.getWithFallback("contextTransforms");
    } catch (MissingResourceException e) {
        // probably redundant
        contextTransformsBundle = null;
    }
    if (contextTransformsBundle != null) {
        UResourceBundleIterator ctIterator = contextTransformsBundle.getIterator();
        while (ctIterator.hasNext()) {
            UResourceBundle contextTransformUsage = ctIterator.next();
            int[] intVector = contextTransformUsage.getIntVector();
            if (intVector.length >= 2) {
                String usageKey = contextTransformUsage.getKey();
                CapitalizationContextUsage usage = contextUsageTypeMap.get(usageKey);
                if (usage != null) {
                    boolean[] transforms = new boolean[2];
                    transforms[0] = (intVector[0] != 0);
                    transforms[1] = (intVector[1] != 0);
                    capitalization.put(usage, transforms);
                }
            }
        }
    }
    NumberingSystem ns = NumberingSystem.getInstance(desiredLocale);
    // Latin is default.
    String nsName = ns == null ? "latn" : ns.getName();
    String tsPath = "NumberElements/" + nsName + "/symbols/timeSeparator";
    try {
        setTimeSeparatorString(rb.getStringWithFallback(tsPath));
    } catch (MissingResourceException e) {
        setTimeSeparatorString(DEFAULT_TIME_SEPARATOR);
    }
}
#method_after
@Deprecated
protected // This API was accidentally marked as @stable ICU 3.0 formerly.
void initializeData(ULocale desiredLocale, ICUResourceBundle b, String calendarType) {
    // Create a CalendarSink to load this data and a resource bundle
    CalendarDataSink calendarSink = new CalendarDataSink();
    if (b == null) {
        b = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, desiredLocale);
    }
    // Iterate over the resource bundle data following the fallbacks through different calendar types
    while (calendarType != null) {
        // Enumerate this calendar type. If the calendar is not found fallback to gregorian.
        ICUResourceBundle dataForType = b.findWithFallback("calendar/" + calendarType);
        if (dataForType == null) {
            if (!"gregorian".equals(calendarType)) {
                calendarType = "gregorian";
                calendarSink.visitAllResources();
                continue;
            }
            throw new MissingResourceException("The 'gregorian' calendar type wasn't found for the locale: " + desiredLocale.getBaseName(), getClass().getName(), "gregorian");
        }
        calendarSink.preEnumerate(calendarType);
        dataForType.getAllItemsWithFallback("", calendarSink);
        // Stop loading when gregorian was loaded
        if (calendarType.equals("gregorian")) {
            break;
        }
        // Get the next calendar type to process from the sink
        calendarType = calendarSink.nextCalendarType;
        // Gregorian is always the last fallback
        if (calendarType == null) {
            calendarType = "gregorian";
            calendarSink.visitAllResources();
        }
    }
    Map<String, String[]> arrays = calendarSink.arrays;
    Map<String, Map<String, String>> maps = calendarSink.maps;
    eras = arrays.get("eras/abbreviated");
    eraNames = arrays.get("eras/wide");
    narrowEras = arrays.get("eras/narrow");
    months = arrays.get("monthNames/format/wide");
    shortMonths = arrays.get("monthNames/format/abbreviated");
    narrowMonths = arrays.get("monthNames/format/narrow");
    standaloneMonths = arrays.get("monthNames/stand-alone/wide");
    standaloneShortMonths = arrays.get("monthNames/stand-alone/abbreviated");
    standaloneNarrowMonths = arrays.get("monthNames/stand-alone/narrow");
    String[] lWeekdays = arrays.get("dayNames/format/wide");
    weekdays = new String[8];
    // 1-based
    weekdays[0] = "";
    System.arraycopy(lWeekdays, 0, weekdays, 1, lWeekdays.length);
    String[] aWeekdays = arrays.get("dayNames/format/abbreviated");
    shortWeekdays = new String[8];
    // 1-based
    shortWeekdays[0] = "";
    System.arraycopy(aWeekdays, 0, shortWeekdays, 1, aWeekdays.length);
    String[] sWeekdays = arrays.get("dayNames/format/short");
    shorterWeekdays = new String[8];
    // 1-based
    shorterWeekdays[0] = "";
    System.arraycopy(sWeekdays, 0, shorterWeekdays, 1, sWeekdays.length);
    String[] nWeekdays = arrays.get("dayNames/format/narrow");
    if (nWeekdays == null) {
        nWeekdays = arrays.get("dayNames/stand-alone/narrow");
        if (nWeekdays == null) {
            nWeekdays = arrays.get("dayNames/format/abbreviated");
            if (nWeekdays == null) {
                throw new MissingResourceException("Resource not found", getClass().getName(), "dayNames/format/abbreviated");
            }
        }
    }
    narrowWeekdays = new String[8];
    // 1-based
    narrowWeekdays[0] = "";
    System.arraycopy(nWeekdays, 0, narrowWeekdays, 1, nWeekdays.length);
    String[] swWeekdays = null;
    swWeekdays = arrays.get("dayNames/stand-alone/wide");
    standaloneWeekdays = new String[8];
    // 1-based
    standaloneWeekdays[0] = "";
    System.arraycopy(swWeekdays, 0, standaloneWeekdays, 1, swWeekdays.length);
    String[] saWeekdays = null;
    saWeekdays = arrays.get("dayNames/stand-alone/abbreviated");
    standaloneShortWeekdays = new String[8];
    // 1-based
    standaloneShortWeekdays[0] = "";
    System.arraycopy(saWeekdays, 0, standaloneShortWeekdays, 1, saWeekdays.length);
    String[] ssWeekdays = null;
    ssWeekdays = arrays.get("dayNames/stand-alone/short");
    standaloneShorterWeekdays = new String[8];
    // 1-based
    standaloneShorterWeekdays[0] = "";
    System.arraycopy(ssWeekdays, 0, standaloneShorterWeekdays, 1, ssWeekdays.length);
    String[] snWeekdays = null;
    snWeekdays = arrays.get("dayNames/stand-alone/narrow");
    standaloneNarrowWeekdays = new String[8];
    // 1-based
    standaloneNarrowWeekdays[0] = "";
    System.arraycopy(snWeekdays, 0, standaloneNarrowWeekdays, 1, snWeekdays.length);
    ampms = arrays.get("AmPmMarkers");
    ampmsNarrow = arrays.get("AmPmMarkersNarrow");
    quarters = arrays.get("quarters/format/wide");
    shortQuarters = arrays.get("quarters/format/abbreviated");
    standaloneQuarters = arrays.get("quarters/stand-alone/wide");
    standaloneShortQuarters = arrays.get("quarters/stand-alone/abbreviated");
    abbreviatedDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/abbreviated"));
    wideDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/wide"));
    narrowDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/narrow"));
    standaloneAbbreviatedDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/abbreviated"));
    standaloneWideDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/wide"));
    standaloneNarrowDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/narrow"));
    for (int i = 0; i < DT_MONTH_PATTERN_COUNT; i++) {
        String monthPatternPath = LEAP_MONTH_PATTERNS_PATHS[i];
        if (monthPatternPath != null) {
            Map<String, String> monthPatternMap = maps.get(monthPatternPath);
            if (monthPatternMap != null) {
                String leapMonthPattern = monthPatternMap.get("leap");
                if (leapMonthPattern != null) {
                    if (leapMonthPatterns == null) {
                        leapMonthPatterns = new String[DT_MONTH_PATTERN_COUNT];
                    }
                    leapMonthPatterns[i] = leapMonthPattern;
                }
            }
        }
    }
    shortYearNames = arrays.get("cyclicNameSets/years/format/abbreviated");
    shortZodiacNames = arrays.get("cyclicNameSets/zodiacs/format/abbreviated");
    requestedLocale = desiredLocale;
    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, desiredLocale);
    localPatternChars = patternChars;
    // TODO: obtain correct actual/valid locale later
    ULocale uloc = rb.getULocale();
    setLocale(uloc, uloc);
    capitalization = new HashMap<CapitalizationContextUsage, boolean[]>();
    boolean[] noTransforms = new boolean[2];
    noTransforms[0] = false;
    noTransforms[1] = false;
    CapitalizationContextUsage[] allUsages = CapitalizationContextUsage.values();
    for (CapitalizationContextUsage usage : allUsages) {
        capitalization.put(usage, noTransforms);
    }
    UResourceBundle contextTransformsBundle = null;
    try {
        contextTransformsBundle = rb.getWithFallback("contextTransforms");
    } catch (MissingResourceException e) {
        // probably redundant
        contextTransformsBundle = null;
    }
    if (contextTransformsBundle != null) {
        UResourceBundleIterator ctIterator = contextTransformsBundle.getIterator();
        while (ctIterator.hasNext()) {
            UResourceBundle contextTransformUsage = ctIterator.next();
            int[] intVector = contextTransformUsage.getIntVector();
            if (intVector.length >= 2) {
                String usageKey = contextTransformUsage.getKey();
                CapitalizationContextUsage usage = contextUsageTypeMap.get(usageKey);
                if (usage != null) {
                    boolean[] transforms = new boolean[2];
                    transforms[0] = (intVector[0] != 0);
                    transforms[1] = (intVector[1] != 0);
                    capitalization.put(usage, transforms);
                }
            }
        }
    }
    NumberingSystem ns = NumberingSystem.getInstance(desiredLocale);
    // Latin is default.
    String nsName = ns == null ? "latn" : ns.getName();
    String tsPath = "NumberElements/" + nsName + "/symbols/timeSeparator";
    try {
        setTimeSeparatorString(rb.getStringWithFallback(tsPath));
    } catch (MissingResourceException e) {
        setTimeSeparatorString(DEFAULT_TIME_SEPARATOR);
    }
}
#end_block

#method_before
private String[] loadDayPeriodStrings(CalendarData calData, boolean standalone, String width) {
    String[] dayPeriodKeys = { "midnight", "noon", "morning1", "afternoon1", "evening1", "night1", "morning2", "afternoon2", "evening2", "night2" };
    ICUResourceBundle b;
    String[] strings = new String[10];
    try {
        if (standalone) {
            b = calData.get("dayPeriod", "standalone", width);
        } else {
            b = calData.get("dayPeriod", "format", width);
        }
    } catch (MissingResourceException e) {
        // Array of null's.
        return strings;
    }
    for (int i = 0; i < 10; ++i) {
        // Null if string doesn't exist.
        strings[i] = b.findStringWithFallback(dayPeriodKeys[i]);
    }
    return strings;
}
#method_after
private String[] loadDayPeriodStrings(Map<String, String> resourceMap) {
    String[] strings = new String[DAY_PERIOD_KEYS.length];
    if (resourceMap != null) {
        for (int i = 0; i < DAY_PERIOD_KEYS.length; ++i) {
            // Null if string doesn't exist.
            strings[i] = resourceMap.get(DAY_PERIOD_KEYS[i]);
        }
    }
    return strings;
}
#end_block

#method_before
public Object clone() {
    try {
        DateFormatSymbols other = (DateFormatSymbols) super.clone();
        return other;
    } catch (CloneNotSupportedException e) {
        // /CLOVER:OFF
        throw new ICUCloneNotSupportedException(e);
    // /CLOVER:ON
    }
}
#method_after
@Override
public Object clone() {
    try {
        DateFormatSymbols other = (DateFormatSymbols) super.clone();
        return other;
    } catch (CloneNotSupportedException e) {
        // /CLOVER:OFF
        throw new ICUCloneNotSupportedException(e);
    // /CLOVER:ON
    }
}
#end_block

#method_before
public int hashCode() {
    // Is this sufficient?
    return requestedLocale.toString().hashCode();
}
#method_after
@Override
public int hashCode() {
    // Is this sufficient?
    return requestedLocale.toString().hashCode();
}
#end_block

#method_before
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null || getClass() != obj.getClass())
        return false;
    DateFormatSymbols that = (DateFormatSymbols) obj;
    return (Utility.arrayEquals(eras, that.eras) && Utility.arrayEquals(eraNames, that.eraNames) && Utility.arrayEquals(months, that.months) && Utility.arrayEquals(shortMonths, that.shortMonths) && Utility.arrayEquals(narrowMonths, that.narrowMonths) && Utility.arrayEquals(standaloneMonths, that.standaloneMonths) && Utility.arrayEquals(standaloneShortMonths, that.standaloneShortMonths) && Utility.arrayEquals(standaloneNarrowMonths, that.standaloneNarrowMonths) && Utility.arrayEquals(weekdays, that.weekdays) && Utility.arrayEquals(shortWeekdays, that.shortWeekdays) && Utility.arrayEquals(shorterWeekdays, that.shorterWeekdays) && Utility.arrayEquals(narrowWeekdays, that.narrowWeekdays) && Utility.arrayEquals(standaloneWeekdays, that.standaloneWeekdays) && Utility.arrayEquals(standaloneShortWeekdays, that.standaloneShortWeekdays) && Utility.arrayEquals(standaloneShorterWeekdays, that.standaloneShorterWeekdays) && Utility.arrayEquals(standaloneNarrowWeekdays, that.standaloneNarrowWeekdays) && Utility.arrayEquals(ampms, that.ampms) && Utility.arrayEquals(ampmsNarrow, that.ampmsNarrow) && Utility.arrayEquals(abbreviatedDayPeriods, that.abbreviatedDayPeriods) && Utility.arrayEquals(wideDayPeriods, that.wideDayPeriods) && Utility.arrayEquals(narrowDayPeriods, that.narrowDayPeriods) && Utility.arrayEquals(standaloneAbbreviatedDayPeriods, that.standaloneAbbreviatedDayPeriods) && Utility.arrayEquals(standaloneWideDayPeriods, that.standaloneWideDayPeriods) && Utility.arrayEquals(standaloneNarrowDayPeriods, that.standaloneNarrowDayPeriods) && Utility.arrayEquals(timeSeparator, that.timeSeparator) && arrayOfArrayEquals(zoneStrings, that.zoneStrings) && // I thought canolicalize() would map the codes but .. alas! it doesn't.
    requestedLocale.getDisplayName().equals(that.requestedLocale.getDisplayName()) && Utility.arrayEquals(localPatternChars, that.localPatternChars));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null || getClass() != obj.getClass())
        return false;
    DateFormatSymbols that = (DateFormatSymbols) obj;
    return (Utility.arrayEquals(eras, that.eras) && Utility.arrayEquals(eraNames, that.eraNames) && Utility.arrayEquals(months, that.months) && Utility.arrayEquals(shortMonths, that.shortMonths) && Utility.arrayEquals(narrowMonths, that.narrowMonths) && Utility.arrayEquals(standaloneMonths, that.standaloneMonths) && Utility.arrayEquals(standaloneShortMonths, that.standaloneShortMonths) && Utility.arrayEquals(standaloneNarrowMonths, that.standaloneNarrowMonths) && Utility.arrayEquals(weekdays, that.weekdays) && Utility.arrayEquals(shortWeekdays, that.shortWeekdays) && Utility.arrayEquals(shorterWeekdays, that.shorterWeekdays) && Utility.arrayEquals(narrowWeekdays, that.narrowWeekdays) && Utility.arrayEquals(standaloneWeekdays, that.standaloneWeekdays) && Utility.arrayEquals(standaloneShortWeekdays, that.standaloneShortWeekdays) && Utility.arrayEquals(standaloneShorterWeekdays, that.standaloneShorterWeekdays) && Utility.arrayEquals(standaloneNarrowWeekdays, that.standaloneNarrowWeekdays) && Utility.arrayEquals(ampms, that.ampms) && Utility.arrayEquals(ampmsNarrow, that.ampmsNarrow) && Utility.arrayEquals(abbreviatedDayPeriods, that.abbreviatedDayPeriods) && Utility.arrayEquals(wideDayPeriods, that.wideDayPeriods) && Utility.arrayEquals(narrowDayPeriods, that.narrowDayPeriods) && Utility.arrayEquals(standaloneAbbreviatedDayPeriods, that.standaloneAbbreviatedDayPeriods) && Utility.arrayEquals(standaloneWideDayPeriods, that.standaloneWideDayPeriods) && Utility.arrayEquals(standaloneNarrowDayPeriods, that.standaloneNarrowDayPeriods) && Utility.arrayEquals(timeSeparator, that.timeSeparator) && arrayOfArrayEquals(zoneStrings, that.zoneStrings) && // I thought canolicalize() would map the codes but .. alas! it doesn't.
    requestedLocale.getDisplayName().equals(that.requestedLocale.getDisplayName()) && Utility.arrayEquals(localPatternChars, that.localPatternChars));
}
#end_block

#method_before
/**
 * Initializes format symbols for the locale and calendar type
 * @param desiredLocale The locale whose symbols are desired.
 * @param type          The calendar type whose date format symbols are desired.
 */
// TODO: This protected seems to be marked as @stable accidentally.
protected void initializeData(ULocale desiredLocale, String type) {
    String key = desiredLocale.getBaseName() + "+" + type;
    String ns = desiredLocale.getKeywordValue("numbers");
    if (ns != null && ns.length() > 0) {
        key += "+" + ns;
    }
    DateFormatSymbols dfs = DFSCACHE.get(key);
    if (dfs == null) {
        // Initialize data from scratch put a clone of this instance into the cache
        CalendarData calData = new CalendarData(desiredLocale, type);
        initializeData(desiredLocale, calData);
        // Do not cache subclass instances
        if (this.getClass().getName().equals("android.icu.text.DateFormatSymbols")) {
            dfs = (DateFormatSymbols) this.clone();
            DFSCACHE.put(key, dfs);
        }
    } else {
        initializeData(dfs);
    }
}
#method_after
/**
 * Initializes format symbols for the locale and calendar type
 * @param desiredLocale The locale whose symbols are desired.
 * @param type          The calendar type whose date format symbols are desired.
 */
// TODO: This protected seems to be marked as @stable accidentally.
protected void initializeData(ULocale desiredLocale, String type) {
    String key = desiredLocale.getBaseName() + '+' + type;
    String ns = desiredLocale.getKeywordValue("numbers");
    if (ns != null && ns.length() > 0) {
        key += '+' + ns;
    }
    DateFormatSymbols dfs = DFSCACHE.getInstance(key, desiredLocale);
    initializeData(dfs);
}
#end_block

#method_before
@Deprecated
protected // This API was accidentally marked as @stable ICU 3.0 formerly.
void initializeData(ULocale desiredLocale, CalendarData calData) {
    // FIXME: cache only ResourceBundle. Hence every time, will do
    // getObject(). This won't be necessary if the Resource itself
    // is cached.
    eras = calData.getEras("abbreviated");
    eraNames = calData.getEras("wide");
    narrowEras = calData.getEras("narrow");
    months = calData.getStringArray("monthNames", "wide");
    shortMonths = calData.getStringArray("monthNames", "abbreviated");
    narrowMonths = calData.getStringArray("monthNames", "narrow");
    standaloneMonths = calData.getStringArray("monthNames", "stand-alone", "wide");
    standaloneShortMonths = calData.getStringArray("monthNames", "stand-alone", "abbreviated");
    standaloneNarrowMonths = calData.getStringArray("monthNames", "stand-alone", "narrow");
    String[] lWeekdays = calData.getStringArray("dayNames", "wide");
    weekdays = new String[8];
    // 1-based
    weekdays[0] = "";
    System.arraycopy(lWeekdays, 0, weekdays, 1, lWeekdays.length);
    String[] aWeekdays = calData.getStringArray("dayNames", "abbreviated");
    shortWeekdays = new String[8];
    // 1-based
    shortWeekdays[0] = "";
    System.arraycopy(aWeekdays, 0, shortWeekdays, 1, aWeekdays.length);
    String[] sWeekdays = calData.getStringArray("dayNames", "short");
    shorterWeekdays = new String[8];
    // 1-based
    shorterWeekdays[0] = "";
    System.arraycopy(sWeekdays, 0, shorterWeekdays, 1, sWeekdays.length);
    String[] nWeekdays = null;
    try {
        nWeekdays = calData.getStringArray("dayNames", "narrow");
    } catch (MissingResourceException e) {
        try {
            nWeekdays = calData.getStringArray("dayNames", "stand-alone", "narrow");
        } catch (MissingResourceException e1) {
            nWeekdays = calData.getStringArray("dayNames", "abbreviated");
        }
    }
    narrowWeekdays = new String[8];
    // 1-based
    narrowWeekdays[0] = "";
    System.arraycopy(nWeekdays, 0, narrowWeekdays, 1, nWeekdays.length);
    String[] swWeekdays = null;
    swWeekdays = calData.getStringArray("dayNames", "stand-alone", "wide");
    standaloneWeekdays = new String[8];
    // 1-based
    standaloneWeekdays[0] = "";
    System.arraycopy(swWeekdays, 0, standaloneWeekdays, 1, swWeekdays.length);
    String[] saWeekdays = null;
    saWeekdays = calData.getStringArray("dayNames", "stand-alone", "abbreviated");
    standaloneShortWeekdays = new String[8];
    // 1-based
    standaloneShortWeekdays[0] = "";
    System.arraycopy(saWeekdays, 0, standaloneShortWeekdays, 1, saWeekdays.length);
    String[] ssWeekdays = null;
    ssWeekdays = calData.getStringArray("dayNames", "stand-alone", "short");
    standaloneShorterWeekdays = new String[8];
    // 1-based
    standaloneShorterWeekdays[0] = "";
    System.arraycopy(ssWeekdays, 0, standaloneShorterWeekdays, 1, ssWeekdays.length);
    String[] snWeekdays = null;
    snWeekdays = calData.getStringArray("dayNames", "stand-alone", "narrow");
    standaloneNarrowWeekdays = new String[8];
    // 1-based
    standaloneNarrowWeekdays[0] = "";
    System.arraycopy(snWeekdays, 0, standaloneNarrowWeekdays, 1, snWeekdays.length);
    ampms = calData.getStringArray("AmPmMarkers");
    ampmsNarrow = calData.getStringArray("AmPmMarkersNarrow");
    quarters = calData.getStringArray("quarters", "wide");
    shortQuarters = calData.getStringArray("quarters", "abbreviated");
    standaloneQuarters = calData.getStringArray("quarters", "stand-alone", "wide");
    standaloneShortQuarters = calData.getStringArray("quarters", "stand-alone", "abbreviated");
    abbreviatedDayPeriods = loadDayPeriodStrings(calData, false, "abbreviated");
    wideDayPeriods = loadDayPeriodStrings(calData, false, "wide");
    narrowDayPeriods = loadDayPeriodStrings(calData, false, "narrow");
    standaloneAbbreviatedDayPeriods = loadDayPeriodStrings(calData, true, "abbreviated");
    standaloneWideDayPeriods = loadDayPeriodStrings(calData, true, "wide");
    standaloneNarrowDayPeriods = loadDayPeriodStrings(calData, true, "narrow");
    // The code for getting individual symbols in the leapMonthSymbols array is here
    // rather than in CalendarData because it depends on DateFormatSymbols constants...
    ICUResourceBundle monthPatternsBundle = null;
    try {
        monthPatternsBundle = calData.get("monthPatterns");
    } catch (MissingResourceException e) {
        // probably redundant
        monthPatternsBundle = null;
    }
    if (monthPatternsBundle != null) {
        leapMonthPatterns = new String[DT_MONTH_PATTERN_COUNT];
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_WIDE] = calData.get("monthPatterns", "wide").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_ABBREV] = calData.get("monthPatterns", "abbreviated").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_NARROW] = calData.get("monthPatterns", "narrow").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_WIDE] = calData.get("monthPatterns", "stand-alone", "wide").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_ABBREV] = calData.get("monthPatterns", "stand-alone", "abbreviated").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_NARROW] = calData.get("monthPatterns", "stand-alone", "narrow").get("leap").getString();
        leapMonthPatterns[DT_LEAP_MONTH_PATTERN_NUMERIC] = calData.get("monthPatterns", "numeric", "all").get("leap").getString();
    }
    ICUResourceBundle cyclicNameSetsBundle = null;
    try {
        cyclicNameSetsBundle = calData.get("cyclicNameSets");
    } catch (MissingResourceException e) {
        // probably redundant
        cyclicNameSetsBundle = null;
    }
    if (cyclicNameSetsBundle != null) {
        shortYearNames = calData.get("cyclicNameSets", "years", "format", "abbreviated").getStringArray();
        shortZodiacNames = calData.get("cyclicNameSets", "zodiacs", "format", "abbreviated").getStringArray();
    }
    requestedLocale = desiredLocale;
    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, desiredLocale);
    // Because localized date/time pattern characters will be obsolete in CLDR,
    // we decided not to maintain localized pattern characters in ICU any more.
    // We always use the base pattern characters by default. (ticket#5597)
    // localPatternChars = rb.getString("localPatternChars");
    localPatternChars = patternChars;
    // TODO: obtain correct actual/valid locale later
    ULocale uloc = rb.getULocale();
    setLocale(uloc, uloc);
    capitalization = new HashMap<CapitalizationContextUsage, boolean[]>();
    boolean[] noTransforms = new boolean[2];
    noTransforms[0] = false;
    noTransforms[1] = false;
    CapitalizationContextUsage[] allUsages = CapitalizationContextUsage.values();
    for (CapitalizationContextUsage usage : allUsages) {
        capitalization.put(usage, noTransforms);
    }
    UResourceBundle contextTransformsBundle = null;
    try {
        contextTransformsBundle = (UResourceBundle) rb.getWithFallback("contextTransforms");
    } catch (MissingResourceException e) {
        // probably redundant
        contextTransformsBundle = null;
    }
    if (contextTransformsBundle != null) {
        UResourceBundleIterator ctIterator = contextTransformsBundle.getIterator();
        while (ctIterator.hasNext()) {
            UResourceBundle contextTransformUsage = ctIterator.next();
            int[] intVector = contextTransformUsage.getIntVector();
            if (intVector.length >= 2) {
                String usageKey = contextTransformUsage.getKey();
                CapitalizationContextUsage usage = contextUsageTypeMap.get(usageKey);
                if (usage != null) {
                    boolean[] transforms = new boolean[2];
                    transforms[0] = (intVector[0] != 0);
                    transforms[1] = (intVector[1] != 0);
                    capitalization.put(usage, transforms);
                }
            }
        }
    }
    NumberingSystem ns = NumberingSystem.getInstance(desiredLocale);
    // Latin is default.
    String nsName = ns == null ? "latn" : ns.getName();
    String tsPath = "NumberElements/" + nsName + "/symbols/timeSeparator";
    try {
        setTimeSeparatorString(rb.getStringWithFallback(tsPath));
    } catch (MissingResourceException e) {
        setTimeSeparatorString(DEFAULT_TIME_SEPARATOR);
    }
}
#method_after
@Deprecated
protected // This API was accidentally marked as @stable ICU 3.0 formerly.
void initializeData(ULocale desiredLocale, ICUResourceBundle b, String calendarType) {
    // Create a CalendarSink to load this data and a resource bundle
    CalendarDataSink calendarSink = new CalendarDataSink();
    if (b == null) {
        b = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, desiredLocale);
    }
    // Iterate over the resource bundle data following the fallbacks through different calendar types
    while (calendarType != null) {
        // Enumerate this calendar type. If the calendar is not found fallback to gregorian.
        ICUResourceBundle dataForType = b.findWithFallback("calendar/" + calendarType);
        if (dataForType == null) {
            if (!"gregorian".equals(calendarType)) {
                calendarType = "gregorian";
                calendarSink.visitAllResources();
                continue;
            }
            throw new MissingResourceException("The 'gregorian' calendar type wasn't found for the locale: " + desiredLocale.getBaseName(), getClass().getName(), "gregorian");
        }
        calendarSink.preEnumerate(calendarType);
        dataForType.getAllItemsWithFallback("", calendarSink);
        // Stop loading when gregorian was loaded
        if (calendarType.equals("gregorian")) {
            break;
        }
        // Get the next calendar type to process from the sink
        calendarType = calendarSink.nextCalendarType;
        // Gregorian is always the last fallback
        if (calendarType == null) {
            calendarType = "gregorian";
            calendarSink.visitAllResources();
        }
    }
    Map<String, String[]> arrays = calendarSink.arrays;
    Map<String, Map<String, String>> maps = calendarSink.maps;
    eras = arrays.get("eras/abbreviated");
    eraNames = arrays.get("eras/wide");
    narrowEras = arrays.get("eras/narrow");
    months = arrays.get("monthNames/format/wide");
    shortMonths = arrays.get("monthNames/format/abbreviated");
    narrowMonths = arrays.get("monthNames/format/narrow");
    standaloneMonths = arrays.get("monthNames/stand-alone/wide");
    standaloneShortMonths = arrays.get("monthNames/stand-alone/abbreviated");
    standaloneNarrowMonths = arrays.get("monthNames/stand-alone/narrow");
    String[] lWeekdays = arrays.get("dayNames/format/wide");
    weekdays = new String[8];
    // 1-based
    weekdays[0] = "";
    System.arraycopy(lWeekdays, 0, weekdays, 1, lWeekdays.length);
    String[] aWeekdays = arrays.get("dayNames/format/abbreviated");
    shortWeekdays = new String[8];
    // 1-based
    shortWeekdays[0] = "";
    System.arraycopy(aWeekdays, 0, shortWeekdays, 1, aWeekdays.length);
    String[] sWeekdays = arrays.get("dayNames/format/short");
    shorterWeekdays = new String[8];
    // 1-based
    shorterWeekdays[0] = "";
    System.arraycopy(sWeekdays, 0, shorterWeekdays, 1, sWeekdays.length);
    String[] nWeekdays = arrays.get("dayNames/format/narrow");
    if (nWeekdays == null) {
        nWeekdays = arrays.get("dayNames/stand-alone/narrow");
        if (nWeekdays == null) {
            nWeekdays = arrays.get("dayNames/format/abbreviated");
            if (nWeekdays == null) {
                throw new MissingResourceException("Resource not found", getClass().getName(), "dayNames/format/abbreviated");
            }
        }
    }
    narrowWeekdays = new String[8];
    // 1-based
    narrowWeekdays[0] = "";
    System.arraycopy(nWeekdays, 0, narrowWeekdays, 1, nWeekdays.length);
    String[] swWeekdays = null;
    swWeekdays = arrays.get("dayNames/stand-alone/wide");
    standaloneWeekdays = new String[8];
    // 1-based
    standaloneWeekdays[0] = "";
    System.arraycopy(swWeekdays, 0, standaloneWeekdays, 1, swWeekdays.length);
    String[] saWeekdays = null;
    saWeekdays = arrays.get("dayNames/stand-alone/abbreviated");
    standaloneShortWeekdays = new String[8];
    // 1-based
    standaloneShortWeekdays[0] = "";
    System.arraycopy(saWeekdays, 0, standaloneShortWeekdays, 1, saWeekdays.length);
    String[] ssWeekdays = null;
    ssWeekdays = arrays.get("dayNames/stand-alone/short");
    standaloneShorterWeekdays = new String[8];
    // 1-based
    standaloneShorterWeekdays[0] = "";
    System.arraycopy(ssWeekdays, 0, standaloneShorterWeekdays, 1, ssWeekdays.length);
    String[] snWeekdays = null;
    snWeekdays = arrays.get("dayNames/stand-alone/narrow");
    standaloneNarrowWeekdays = new String[8];
    // 1-based
    standaloneNarrowWeekdays[0] = "";
    System.arraycopy(snWeekdays, 0, standaloneNarrowWeekdays, 1, snWeekdays.length);
    ampms = arrays.get("AmPmMarkers");
    ampmsNarrow = arrays.get("AmPmMarkersNarrow");
    quarters = arrays.get("quarters/format/wide");
    shortQuarters = arrays.get("quarters/format/abbreviated");
    standaloneQuarters = arrays.get("quarters/stand-alone/wide");
    standaloneShortQuarters = arrays.get("quarters/stand-alone/abbreviated");
    abbreviatedDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/abbreviated"));
    wideDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/wide"));
    narrowDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/narrow"));
    standaloneAbbreviatedDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/abbreviated"));
    standaloneWideDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/wide"));
    standaloneNarrowDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/narrow"));
    for (int i = 0; i < DT_MONTH_PATTERN_COUNT; i++) {
        String monthPatternPath = LEAP_MONTH_PATTERNS_PATHS[i];
        if (monthPatternPath != null) {
            Map<String, String> monthPatternMap = maps.get(monthPatternPath);
            if (monthPatternMap != null) {
                String leapMonthPattern = monthPatternMap.get("leap");
                if (leapMonthPattern != null) {
                    if (leapMonthPatterns == null) {
                        leapMonthPatterns = new String[DT_MONTH_PATTERN_COUNT];
                    }
                    leapMonthPatterns[i] = leapMonthPattern;
                }
            }
        }
    }
    shortYearNames = arrays.get("cyclicNameSets/years/format/abbreviated");
    shortZodiacNames = arrays.get("cyclicNameSets/zodiacs/format/abbreviated");
    requestedLocale = desiredLocale;
    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, desiredLocale);
    localPatternChars = patternChars;
    // TODO: obtain correct actual/valid locale later
    ULocale uloc = rb.getULocale();
    setLocale(uloc, uloc);
    capitalization = new HashMap<CapitalizationContextUsage, boolean[]>();
    boolean[] noTransforms = new boolean[2];
    noTransforms[0] = false;
    noTransforms[1] = false;
    CapitalizationContextUsage[] allUsages = CapitalizationContextUsage.values();
    for (CapitalizationContextUsage usage : allUsages) {
        capitalization.put(usage, noTransforms);
    }
    UResourceBundle contextTransformsBundle = null;
    try {
        contextTransformsBundle = rb.getWithFallback("contextTransforms");
    } catch (MissingResourceException e) {
        // probably redundant
        contextTransformsBundle = null;
    }
    if (contextTransformsBundle != null) {
        UResourceBundleIterator ctIterator = contextTransformsBundle.getIterator();
        while (ctIterator.hasNext()) {
            UResourceBundle contextTransformUsage = ctIterator.next();
            int[] intVector = contextTransformUsage.getIntVector();
            if (intVector.length >= 2) {
                String usageKey = contextTransformUsage.getKey();
                CapitalizationContextUsage usage = contextUsageTypeMap.get(usageKey);
                if (usage != null) {
                    boolean[] transforms = new boolean[2];
                    transforms[0] = (intVector[0] != 0);
                    transforms[1] = (intVector[1] != 0);
                    capitalization.put(usage, transforms);
                }
            }
        }
    }
    NumberingSystem ns = NumberingSystem.getInstance(desiredLocale);
    // Latin is default.
    String nsName = ns == null ? "latn" : ns.getName();
    String tsPath = "NumberElements/" + nsName + "/symbols/timeSeparator";
    try {
        setTimeSeparatorString(rb.getStringWithFallback(tsPath));
    } catch (MissingResourceException e) {
        setTimeSeparatorString(DEFAULT_TIME_SEPARATOR);
    }
}
#end_block

#method_before
private String[] loadDayPeriodStrings(CalendarData calData, boolean standalone, String width) {
    String[] dayPeriodKeys = { "midnight", "noon", "morning1", "afternoon1", "evening1", "night1", "morning2", "afternoon2", "evening2", "night2" };
    ICUResourceBundle b;
    String[] strings = new String[10];
    try {
        if (standalone) {
            b = calData.get("dayPeriod", "standalone", width);
        } else {
            b = calData.get("dayPeriod", "format", width);
        }
    } catch (MissingResourceException e) {
        // Array of null's.
        return strings;
    }
    for (int i = 0; i < 10; ++i) {
        // Null if string doesn't exist.
        strings[i] = b.findStringWithFallback(dayPeriodKeys[i]);
    }
    return strings;
}
#method_after
private String[] loadDayPeriodStrings(Map<String, String> resourceMap) {
    String[] strings = new String[DAY_PERIOD_KEYS.length];
    if (resourceMap != null) {
        for (int i = 0; i < DAY_PERIOD_KEYS.length; ++i) {
            // Null if string doesn't exist.
            strings[i] = resourceMap.get(DAY_PERIOD_KEYS[i]);
        }
    }
    return strings;
}
#end_block

#method_before
private Notification.Builder createNotificationBuilder(WifiConfiguration config, Bitmap badge) {
    CharSequence title = mContext.getText(R.string.wifi_available);
    PendingIntent deleteIntent = PendingIntent.getBroadcast(mContext, 0, new Intent(WifiNotificationController.ACTION_NOTIFICATION_DELETED), FLAG_UPDATE_CURRENT);
    return new Notification.Builder(mContext).setDeleteIntent(deleteIntent).setSmallIcon(com.android.internal.R.drawable.stat_notify_wifi_in_range).setLargeIcon(badge).setAutoCancel(true).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setTicker(title).setContentTitle(title).setContentText(config.getPrintableSsid()).addExtras(getSystemLabelExtras());
}
#method_after
private Notification.Builder createNotificationBuilder(WifiConfiguration config, Bitmap badge) {
    CharSequence title = mContext.getText(R.string.wifi_available);
    PendingIntent deleteIntent = PendingIntent.getBroadcast(mContext, 0, new Intent(WifiNotificationController.ACTION_NOTIFICATION_DELETED), FLAG_UPDATE_CURRENT);
    return new Notification.Builder(mContext).setDeleteIntent(deleteIntent).setSmallIcon(R.drawable.stat_notify_wifi_in_range).setLargeIcon(badge).setAutoCancel(true).setTicker(title).setContentTitle(title).setContentText(WifiConfigurationUtil.getPrintableSsid(config)).addExtras(getSystemLabelExtras());
}
#end_block

#method_before
private Bundle getSystemLabelExtras() {
    Bundle extras = new Bundle();
    extras.putString(Notification.EXTRA_SUBSTITUTE_APP_NAME, mContext.getString(com.android.internal.R.string.android_system_label));
    return extras;
}
#method_after
private Bundle getSystemLabelExtras() {
    Bundle extras = new Bundle();
    extras.putString(Notification.EXTRA_SUBSTITUTE_APP_NAME, mContext.getString(R.string.android_system_label));
    return extras;
}
#end_block

#method_before
private int getWifiBadgeResourceForEnum(int badgeEnum) {
    switch(badgeEnum) {
        case ScoredNetwork.BADGING_NONE:
            return 0;
        case ScoredNetwork.BADGING_SD:
            return com.android.internal.R.drawable.ic_signal_wifi_badged_sd;
        case ScoredNetwork.BADGING_HD:
            return com.android.internal.R.drawable.ic_signal_wifi_badged_hd;
        case ScoredNetwork.BADGING_4K:
            return com.android.internal.R.drawable.ic_signal_wifi_badged_4k;
        default:
            throw new IllegalArgumentException("No badge resource for enum :" + badgeEnum);
    }
}
#method_after
private int getWifiBadgeResourceForEnum(int badgeEnum) {
    switch(badgeEnum) {
        case ScoredNetwork.BADGING_NONE:
            return 0;
        case ScoredNetwork.BADGING_SD:
            return R.drawable.ic_signal_wifi_badged_sd;
        case ScoredNetwork.BADGING_HD:
            return R.drawable.ic_signal_wifi_badged_hd;
        case ScoredNetwork.BADGING_4K:
            return R.drawable.ic_signal_wifi_badged_4k;
        default:
            throw new IllegalArgumentException("No badge resource for enum :" + badgeEnum);
    }
}
#end_block

#method_before
private ScanResult findMatchingScanResult(List<ScanResult> scanResults, WifiConfiguration wifiConfiguration) {
    String ssid = WifiInfo.removeDoubleQuotes(wifiConfiguration.SSID);
    String bssid = wifiConfiguration.BSSID;
    for (ScanResult scanResult : scanResults) {
        if (ssid.equals(scanResult.SSID) && bssid.equals(scanResult.BSSID)) {
            return scanResult;
        }
    }
    return null;
}
#method_after
private ScanResult findMatchingScanResult(List<ScanResult> scanResults, WifiConfiguration wifiConfiguration) {
    String ssid = WifiConfigurationUtil.removeDoubleQuotes(wifiConfiguration);
    String bssid = wifiConfiguration.BSSID;
    for (ScanResult scanResult : scanResults) {
        if (ssid.equals(scanResult.SSID) && bssid.equals(scanResult.BSSID)) {
            return scanResult;
        }
    }
    return null;
}
#end_block

#method_before
@Override
public /**
 * Recommend the wireless network with the highest RSSI.
 */
RecommendationResult requestRecommendation(RecommendationRequest request) {
    ScanResult recommendedScanResult = null;
    int recommendedScore = Integer.MIN_VALUE;
    ScanResult[] results = request.getScanResults();
    if (results != null) {
        for (int i = 0; i < results.length; i++) {
            final ScanResult scanResult = results[i];
            if (VERBOSE)
                Log.v(TAG, "Scan: " + scanResult + " " + i);
            // a future CL.
            if (!"[ESS]".equals(scanResult.capabilities)) {
                if (VERBOSE)
                    Log.v(TAG, "Discarding closed network: " + scanResult);
                continue;
            }
            final NetworkKey networkKey = new NetworkKey(new WifiKey(quoteSsid(scanResult), scanResult.BSSID));
            if (VERBOSE)
                Log.v(TAG, "Evaluating network: " + networkKey);
            // We will only score networks we know about.
            final ScoredNetwork network = mStorage.get(networkKey);
            if (network == null) {
                if (VERBOSE)
                    Log.v(TAG, "Discarding unscored network: " + scanResult);
                continue;
            }
            final int score = network.rssiCurve.lookupScore(scanResult.level);
            if (VERBOSE)
                Log.d(TAG, "Scored " + scanResult + ": " + score);
            if (score > recommendedScore) {
                recommendedScanResult = scanResult;
                recommendedScore = score;
                if (VERBOSE)
                    Log.d(TAG, "New recommended network: " + scanResult);
                continue;
            }
        }
    } else {
        Log.w(TAG, "Received null scan results in request.");
    }
    // If we ended up without a recommendation, recommend the provided configuration
    // instead. If we wanted the platform to avoid this network, too, we could send back an
    // empty recommendation.
    RecommendationResult recommendationResult;
    if (recommendedScanResult == null) {
        if (request.getCurrentSelectedConfig() != null) {
            recommendationResult = RecommendationResult.createConnectRecommendation(request.getCurrentSelectedConfig());
        } else {
            recommendationResult = RecommendationResult.createDoNotConnectRecommendation();
        }
    } else {
        // Build a configuration based on the scan.
        WifiConfiguration recommendedConfig = new WifiConfiguration();
        recommendedConfig.SSID = quoteSsid(recommendedScanResult);
        recommendedConfig.BSSID = recommendedScanResult.BSSID;
        recommendedConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        recommendationResult = RecommendationResult.createConnectRecommendation(recommendedConfig);
    }
    synchronized (mStatsLock) {
        mLastRecommended = recommendationResult.getWifiConfiguration();
        mRecommendationCounter++;
        if (DEBUG)
            Log.d(TAG, "Recommending network: " + configToString(mLastRecommended));
    }
    return recommendationResult;
}
#method_after
@Override
public /**
 * Recommend the wireless network with the highest RSSI.
 */
RecommendationResult requestRecommendation(RecommendationRequest request) {
    ScanResult recommendedScanResult = null;
    int recommendedScore = Integer.MIN_VALUE;
    ScanResult[] results = request.getScanResults();
    if (results != null) {
        for (int i = 0; i < results.length; i++) {
            final ScanResult scanResult = results[i];
            if (VERBOSE)
                Log.v(TAG, "Scan: " + scanResult + " " + i);
            // a future CL.
            if (!"[ESS]".equals(scanResult.capabilities)) {
                if (VERBOSE)
                    Log.v(TAG, "Discarding closed network: " + scanResult);
                continue;
            }
            final NetworkKey networkKey = new NetworkKey(new WifiKey(ScanResultUtil.createQuotedSSID(scanResult.SSID), scanResult.BSSID));
            if (VERBOSE)
                Log.v(TAG, "Evaluating network: " + networkKey);
            // We will only score networks we know about.
            final ScoredNetwork network = mStorage.get(networkKey);
            if (network == null) {
                if (VERBOSE)
                    Log.v(TAG, "Discarding unscored network: " + scanResult);
                continue;
            }
            final int score = network.rssiCurve.lookupScore(scanResult.level);
            if (VERBOSE)
                Log.d(TAG, "Scored " + scanResult + ": " + score);
            if (score > recommendedScore) {
                recommendedScanResult = scanResult;
                recommendedScore = score;
                if (VERBOSE)
                    Log.d(TAG, "New recommended network: " + scanResult);
                continue;
            }
        }
    } else {
        Log.w(TAG, "Received null scan results in request.");
    }
    // If we ended up without a recommendation, recommend the provided configuration
    // instead. If we wanted the platform to avoid this network, too, we could send back an
    // empty recommendation.
    RecommendationResult recommendationResult;
    if (recommendedScanResult == null) {
        if (request.getCurrentSelectedConfig() != null) {
            recommendationResult = RecommendationResult.createConnectRecommendation(request.getCurrentSelectedConfig());
        } else {
            recommendationResult = RecommendationResult.createDoNotConnectRecommendation();
        }
    } else {
        // Build a configuration based on the scan.
        WifiConfiguration recommendedConfig = new WifiConfiguration();
        recommendedConfig.SSID = ScanResultUtil.createQuotedSSID(recommendedScanResult.SSID);
        recommendedConfig.BSSID = recommendedScanResult.BSSID;
        recommendedConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
        recommendationResult = RecommendationResult.createConnectRecommendation(recommendedConfig);
    }
    synchronized (mStatsLock) {
        mLastRecommended = recommendationResult.getWifiConfiguration();
        mRecommendationCounter++;
        if (DEBUG)
            Log.d(TAG, "Recommending network: " + configToString(mLastRecommended));
    }
    return recommendationResult;
}
#end_block

#method_before
private static ScoredNetwork parseScore(String score) {
    String[] splitScore = score.split("\\|");
    String[] splitWifiKey = splitScore[0].split(",");
    NetworkKey networkKey = new NetworkKey(new WifiKey(splitWifiKey[0], splitWifiKey[1]));
    String[] splitRssiCurve = splitScore[1].split(",");
    int start = Integer.parseInt(splitRssiCurve[0]);
    int bucketWidth = Integer.parseInt(splitRssiCurve[1]);
    byte[] rssiBuckets = new byte[splitRssiCurve.length - 2];
    for (int i = 2; i < splitRssiCurve.length; i++) {
        rssiBuckets[i - 2] = Integer.valueOf(splitRssiCurve[i]).byteValue();
    }
    boolean meteredHint = "1".equals(splitScore[2]);
    Bundle attributes = new Bundle();
    if (!TextUtils.isEmpty(splitScore[3])) {
        attributes.putBoolean(ScoredNetwork.ATTRIBUTES_KEY_HAS_CAPTIVE_PORTAL, "1".equals(splitScore[3]));
    }
    if (splitScore.length > 4) {
        String badge = splitScore[4].toUpperCase();
        if ("SD".equals(badge)) {
            attributes.putParcelable(ScoredNetwork.ATTRIBUTES_KEY_BADGING_CURVE, BADGE_CURVE_SD);
        } else if ("HD".equals(badge)) {
            attributes.putParcelable(ScoredNetwork.ATTRIBUTES_KEY_BADGING_CURVE, BADGE_CURVE_HD);
        } else if ("4K".equals(badge)) {
            attributes.putParcelable(ScoredNetwork.ATTRIBUTES_KEY_BADGING_CURVE, BADGE_CURVE_4K);
        }
    }
    RssiCurve rssiCurve = new RssiCurve(start, bucketWidth, rssiBuckets, 0);
    return new ScoredNetwork(networkKey, rssiCurve, meteredHint, attributes);
}
#method_after
private static ScoredNetwork parseScore(String score) {
    String[] splitScore = score.split("\\|");
    String[] splitWifiKey = splitScore[0].split(",");
    NetworkKey networkKey = new NetworkKey(new WifiKey(splitWifiKey[0], splitWifiKey[1]));
    String[] splitRssiCurve = splitScore[1].split(",");
    int bucketWidth = Integer.parseInt(splitRssiCurve[0]);
    byte[] rssiBuckets = new byte[splitRssiCurve.length - 1];
    for (int i = 1; i < splitRssiCurve.length; i++) {
        rssiBuckets[i - 1] = Integer.valueOf(splitRssiCurve[i]).byteValue();
    }
    boolean meteredHint = "1".equals(splitScore[2]);
    Bundle attributes = new Bundle();
    if (!TextUtils.isEmpty(splitScore[3])) {
        attributes.putBoolean(ScoredNetwork.ATTRIBUTES_KEY_HAS_CAPTIVE_PORTAL, "1".equals(splitScore[3]));
    }
    if (splitScore.length > 4) {
        String badge = splitScore[4].toUpperCase();
        if ("SD".equals(badge)) {
            attributes.putParcelable(ScoredNetwork.ATTRIBUTES_KEY_BADGING_CURVE, BADGE_CURVE_SD);
        } else if ("HD".equals(badge)) {
            attributes.putParcelable(ScoredNetwork.ATTRIBUTES_KEY_BADGING_CURVE, BADGE_CURVE_HD);
        } else if ("4K".equals(badge)) {
            attributes.putParcelable(ScoredNetwork.ATTRIBUTES_KEY_BADGING_CURVE, BADGE_CURVE_4K);
        }
    }
    RssiCurve rssiCurve = new RssiCurve(CONSTANT_CURVE_START, bucketWidth, rssiBuckets, 0);
    return new ScoredNetwork(networkKey, rssiCurve, meteredHint, attributes);
}
#end_block

#method_before
private static String configToString(WifiConfiguration config) {
    if (config == null) {
        return null;
    }
    StringBuilder sb = new StringBuilder().append("ID=").append(config.networkId).append(",SSID=").append(config.SSID).append(",useExternalScores=").append(config.useExternalScores).append(",meteredHint=").append(config.meteredHint).append(",meteredOverride=").append(config.meteredOverride);
    return sb.toString();
}
#method_after
private static String configToString(WifiConfiguration config) {
    if (config == null) {
        return null;
    }
    StringBuilder sb = new StringBuilder().append("ID=").append(config.networkId).append(",SSID=").append(config.SSID).append(",useExternalScores=").append(config.useExternalScores).append(",meteredHint=").append(config.meteredHint);
    return sb.toString();
}
#end_block

#method_before
private void checkAndSetNotification(NetworkInfo networkInfo, List<ScanResult> scanResults) {
    // don't bother doing any of the following
    if (!mNotificationEnabled)
        return;
    if (mWifiState != WifiManager.WIFI_STATE_ENABLED)
        return;
    if (scanResults == null || scanResults.isEmpty())
        return;
    NetworkInfo.State state = NetworkInfo.State.DISCONNECTED;
    if (networkInfo != null) {
        state = networkInfo.getState();
    }
    Log.i(TAG, "Checking state before requesting recommendations");
    if (state == NetworkInfo.State.DISCONNECTED || state == NetworkInfo.State.UNKNOWN) {
        RecommendationResult result = getOpenNetworkRecommendation(scanResults);
        if (result != null && result.getWifiConfiguration() != null) {
            Log.i(TAG, "Recommendations Received");
            mRecommendedNetwork = result.getWifiConfiguration();
            mNotificationBadgeBitmap = mWifiNotificationHelper.createNotificationBadgeBitmap(mRecommendedNetwork, scanResults);
            if (++mNumScansSinceNetworkStateChange >= NUM_SCANS_BEFORE_ACTUALLY_SCANNING && mNotificationBadgeBitmap != null) {
                /*
                     * We have scanned continuously at least
                     * NUM_SCANS_BEFORE_NOTIFICATION times. The user
                     * probably does not have a remembered network in range,
                     * since otherwise supplicant would have tried to
                     * associate and thus resetting this counter.
                     */
                displayNotification();
            }
            return;
        }
    }
    // No open networks in range, remove the notification
    removeNotification();
}
#method_after
private void checkAndSetNotification(NetworkInfo networkInfo, List<ScanResult> scanResults) {
    // don't bother doing any of the following
    if (!mNotificationEnabled)
        return;
    if (mWifiState != WifiManager.WIFI_STATE_ENABLED)
        return;
    if (scanResults == null || scanResults.isEmpty())
        return;
    NetworkInfo.State state = NetworkInfo.State.DISCONNECTED;
    if (networkInfo != null) {
        state = networkInfo.getState();
    }
    if (state == NetworkInfo.State.DISCONNECTED || state == NetworkInfo.State.UNKNOWN) {
        RecommendationResult result = getOpenNetworkRecommendation(scanResults);
        if (result != null && result.getWifiConfiguration() != null) {
            mRecommendedNetwork = result.getWifiConfiguration();
            mNotificationBadgeBitmap = mWifiNotificationHelper.createNotificationBadgeBitmap(mRecommendedNetwork, scanResults);
            if (++mNumScansSinceNetworkStateChange >= NUM_SCANS_BEFORE_ACTUALLY_SCANNING && mNotificationBadgeBitmap != null) {
                /*
                     * We have scanned continuously at least
                     * NUM_SCANS_BEFORE_NOTIFICATION times. The user
                     * probably does not have a remembered network in range,
                     * since otherwise supplicant would have tried to
                     * associate and thus resetting this counter.
                     */
                displayNotification();
            }
            return;
        }
    }
    // No open networks in range, remove the notification
    removeNotification();
}
#end_block

#method_before
@Nullable
private RecommendationResult getOpenNetworkRecommendation(List<ScanResult> scanResults) {
    if (scanResults == null || scanResults.isEmpty()) {
        return null;
    }
    ArrayList<ScanResult> openNetworks = new ArrayList<>();
    for (ScanResult scanResult : scanResults) {
        // that is available for an STA to connect
        if ("[ESS]".equals(scanResult.capabilities)) {
            openNetworks.add(scanResult);
        }
    }
    RecommendationRequest request = new RecommendationRequest.Builder().setScanResults(openNetworks.toArray(new ScanResult[openNetworks.size()])).build();
    Log.i(TAG, "About to request Recommendations");
    return mNetworkRecommendationProvider.requestRecommendation(request);
}
#method_after
@Nullable
private RecommendationResult getOpenNetworkRecommendation(List<ScanResult> scanResults) {
    if (scanResults == null || scanResults.isEmpty()) {
        return null;
    }
    ArrayList<ScanResult> openNetworks = new ArrayList<>();
    for (ScanResult scanResult : scanResults) {
        // that is available for an STA to connect
        if ("[ESS]".equals(scanResult.capabilities)) {
            openNetworks.add(scanResult);
        }
    }
    RecommendationRequest request = new RecommendationRequest.Builder().setScanResults(openNetworks.toArray(new ScanResult[openNetworks.size()])).build();
    return mNetworkRecommendationProvider.requestRecommendation(request);
}
#end_block

#method_before
private void postNotification(Notification notification) {
    mNotificationManager.notifyAsUser(null, /* tag */
    ICON_NETWORKS_AVAILABLE, notification, UserHandle.ALL);
}
#method_after
private void postNotification(Notification notification) {
    mNotificationManager.notify(null, /* tag */
    ICON_NETWORKS_AVAILABLE, notification);
}
#end_block

#method_before
private void removeNotification() {
    mNotificationManager.cancelAsUser(null, /* tag */
    ICON_NETWORKS_AVAILABLE, UserHandle.ALL);
    mNotificationShown = false;
}
#method_after
private void removeNotification() {
    mNotificationManager.cancel(null, /* tag */
    ICON_NETWORKS_AVAILABLE);
    mNotificationShown = false;
}
#end_block

#method_before
@Test
@MediumTest
public void testOnRestrictedStateChanged() throws Exception {
    ServiceStateTracker spySst = spy(sst);
    doReturn(true).when(mPhone).isPhoneTypeGsm();
    doReturn(IccCardApplicationStatus.AppState.APPSTATE_READY).when(mUiccCardApplication3gpp).getState();
    spySst.updatePhoneType();
    int notifyCount = 0;
    // cs not restricted -> cs emergency/normal restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, RILConstants.RIL_RESTRICTED_STATE_CS_ALL, ServiceStateTracker.CS_ENABLED);
    // cs emergency/normal restricted -> cs normal restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL, ServiceStateTracker.CS_NORMAL_ENABLED);
    // cs normal restricted -> cs emergency restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY, ServiceStateTracker.CS_EMERGENCY_ENABLED);
    // cs emergency restricted -> cs not restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, RILConstants.RIL_RESTRICTED_STATE_NONE, ServiceStateTracker.CS_DISABLED);
    // ps not restricted -> ps restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, RILConstants.RIL_RESTRICTED_STATE_PS_ALL, ServiceStateTracker.PS_ENABLED);
    // ps restricted -> ps not restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, RILConstants.RIL_RESTRICTED_STATE_NONE, ServiceStateTracker.PS_DISABLED);
}
#method_after
@Test
@MediumTest
public void testOnRestrictedStateChanged() throws Exception {
    ServiceStateTracker spySst = spy(sst);
    doReturn(true).when(mPhone).isPhoneTypeGsm();
    doReturn(IccCardApplicationStatus.AppState.APPSTATE_READY).when(mUiccCardApplication3gpp).getState();
    spySst.updatePhoneType();
    // Combination of restricted state and expected notification type.
    final int[] CS_ALL = { RILConstants.RIL_RESTRICTED_STATE_CS_ALL, ServiceStateTracker.CS_ENABLED };
    final int[] CS_NOR = { RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL, ServiceStateTracker.CS_NORMAL_ENABLED };
    final int[] CS_EME = { RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY, ServiceStateTracker.CS_EMERGENCY_ENABLED };
    final int[] CS_NON = { RILConstants.RIL_RESTRICTED_STATE_NONE, ServiceStateTracker.CS_DISABLED };
    final int[] PS_ALL = { RILConstants.RIL_RESTRICTED_STATE_PS_ALL, ServiceStateTracker.PS_ENABLED };
    final int[] PS_NON = { RILConstants.RIL_RESTRICTED_STATE_NONE, ServiceStateTracker.PS_DISABLED };
    int notifyCount = 0;
    // cs not restricted -> cs emergency/normal restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_ALL);
    // cs emergency/normal restricted -> cs normal restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_NOR);
    // cs normal restricted -> cs emergency restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_EME);
    // cs emergency restricted -> cs not restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_NON);
    // cs not restricted -> cs normal restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_NOR);
    // cs normal restricted -> cs emergency/normal restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_ALL);
    // cs emergency/normal restricted -> cs emergency restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_EME);
    // cs emergency restricted -> cs emergency/normal restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_ALL);
    // cs emergency/normal restricted -> cs not restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_NON);
    // cs not restricted -> cs emergency restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_EME);
    // cs emergency restricted -> cs normal restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_NOR);
    // cs normal restricted -> cs not restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, CS_NON);
    // ps not restricted -> ps restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, PS_ALL);
    // ps restricted -> ps not restricted
    internalCheckForRestrictedStateChange(spySst, ++notifyCount, PS_NON);
}
#end_block

#method_before
private void internalCheckForRestrictedStateChange(ServiceStateTracker serviceStateTracker, int times, int restrictedState, int notifyType) {
    mSimulatedCommands.triggerRestrictedStateChanged(restrictedState);
    waitForMs(200);
    ArgumentCaptor<Integer> intArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
    verify(serviceStateTracker, times(times)).setNotification(intArgumentCaptor.capture());
    assertEquals(intArgumentCaptor.getValue().intValue(), notifyType);
}
#method_after
private void internalCheckForRestrictedStateChange(ServiceStateTracker serviceStateTracker, int times, int[] restrictedState) {
    mSimulatedCommands.triggerRestrictedStateChanged(restrictedState[0]);
    waitForMs(100);
    ArgumentCaptor<Integer> intArgumentCaptor = ArgumentCaptor.forClass(Integer.class);
    verify(serviceStateTracker, times(times)).setNotification(intArgumentCaptor.capture());
    assertEquals(intArgumentCaptor.getValue().intValue(), restrictedState[1]);
}
#end_block

#method_before
@VisibleForTesting
public void updatePhoneType() {
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mRestrictedState = new RestrictedState();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
        mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
    } else {
        // clear GSM regsitrations first
        mCi.unregisterForAvailable(this);
        mCi.unSetOnRestrictedStateChanged(this);
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
}
#method_after
@VisibleForTesting
public void updatePhoneType() {
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mRestrictedState = new RestrictedState();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
        mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
    } else {
        // clear GSM regsitrations first
        mCi.unregisterForAvailable(this);
        mCi.unSetOnRestrictedStateChanged(this);
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that we've thrown away state and are starting over with
    // empty, detached ServiceStates.
    mVoiceRoamingOffRegistrants.notifyRegistrants();
    mDataRoamingOffRegistrants.notifyRegistrants();
    mDetachedRegistrants.notifyRegistrants();
    notifyDataRegStateRilRadioTechnologyChanged();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        // GSM
        case EVENT_RADIO_AVAILABLE:
            // setPowerStateToDesired();
            break;
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            pollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                String[] states = (String[]) ar.result;
                if (mPhone.isPhoneTypeGsm()) {
                    int lac = -1;
                    int cid = -1;
                    if (states.length >= 3) {
                        try {
                            if (states[1] != null && states[1].length() > 0) {
                                lac = (int) Long.parseLong(states[1], 16);
                            }
                            if (states[2] != null && states[2].length() > 0) {
                                cid = (int) Long.parseLong(states[2], 16);
                            }
                        } catch (NumberFormatException ex) {
                            Rlog.w(LOG_TAG, "error parsing location: " + ex);
                        }
                    }
                    ((GsmCellLocation) mCellLoc).setLacAndCid(lac, cid);
                } else {
                    int baseStationId = -1;
                    int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                    int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                    int systemId = -1;
                    int networkId = -1;
                    if (states.length > 9) {
                        try {
                            if (states[4] != null) {
                                baseStationId = Integer.parseInt(states[4]);
                            }
                            if (states[5] != null) {
                                baseStationLatitude = Integer.parseInt(states[5]);
                            }
                            if (states[6] != null) {
                                baseStationLongitude = Integer.parseInt(states[6]);
                            }
                            // Some carriers only return lat-lngs of 0,0
                            if (baseStationLatitude == 0 && baseStationLongitude == 0) {
                                baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                                baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                            }
                            if (states[8] != null) {
                                systemId = Integer.parseInt(states[8]);
                            }
                            if (states[9] != null) {
                                networkId = Integer.parseInt(states[9]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing cell location data: " + ex);
                        }
                    }
                    ((CdmaCellLocation) mCellLoc).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
                }
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        // GSM
        case EVENT_RADIO_AVAILABLE:
            // setPowerStateToDesired();
            break;
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                String[] states = (String[]) ar.result;
                if (mPhone.isPhoneTypeGsm()) {
                    int lac = -1;
                    int cid = -1;
                    if (states.length >= 3) {
                        try {
                            if (states[1] != null && states[1].length() > 0) {
                                lac = (int) Long.parseLong(states[1], 16);
                            }
                            if (states[2] != null && states[2].length() > 0) {
                                cid = (int) Long.parseLong(states[2], 16);
                            }
                        } catch (NumberFormatException ex) {
                            Rlog.w(LOG_TAG, "error parsing location: " + ex);
                        }
                    }
                    ((GsmCellLocation) mCellLoc).setLacAndCid(lac, cid);
                } else {
                    int baseStationId = -1;
                    int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                    int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                    int systemId = -1;
                    int networkId = -1;
                    if (states.length > 9) {
                        try {
                            if (states[4] != null) {
                                baseStationId = Integer.parseInt(states[4]);
                            }
                            if (states[5] != null) {
                                baseStationLatitude = Integer.parseInt(states[5]);
                            }
                            if (states[6] != null) {
                                baseStationLongitude = Integer.parseInt(states[6]);
                            }
                            // Some carriers only return lat-lngs of 0,0
                            if (baseStationLatitude == 0 && baseStationLongitude == 0) {
                                baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                                baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                            }
                            if (states[8] != null) {
                                systemId = Integer.parseInt(states[8]);
                            }
                            if (states[9] != null) {
                                networkId = Integer.parseInt(states[9]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing cell location data: " + ex);
                        }
                    }
                    ((CdmaCellLocation) mCellLoc).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
                }
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                mNewSS.setVoiceRoaming(isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS));
            }
            // For CDMA, voice and data should have the same roaming status
            final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
            final int dataRegType = mNewSS.getRilDataRadioTechnology();
            if (isVoiceInService && ServiceState.isCdma(dataRegType)) {
                mNewSS.setDataRoaming(mNewSS.getVoiceRoaming());
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#method_after
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                mNewSS.setVoiceRoaming(isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS));
            }
            // For CDMA, voice and data should have the same roaming status
            final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
            final int dataRegType = mNewSS.getRilDataRadioTechnology();
            if (isVoiceInService && ServiceState.isCdma(dataRegType)) {
                mNewSS.setDataRoaming(mNewSS.getVoiceRoaming());
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    String[] states;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    states = (String[]) ar.result;
                    int lac = -1;
                    int cid = -1;
                    int type = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    int reasonRegStateDenied = -1;
                    int psc = -1;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            if (states.length >= 3) {
                                if (states[1] != null && states[1].length() > 0) {
                                    lac = (int) Long.parseLong(states[1], 16);
                                }
                                if (states[2] != null && states[2].length() > 0) {
                                    cid = (int) Long.parseLong(states[2], 16);
                                }
                                // states[3] (if present) is the current radio technology
                                if (states.length >= 4 && states[3] != null) {
                                    type = Integer.parseInt(states[3]);
                                }
                            }
                            if (states.length > 14) {
                                if (states[14] != null && states[14].length() > 0) {
                                    psc = (int) Long.parseLong(states[14], 16);
                                }
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing RegistrationState: " + ex);
                        }
                    }
                    mGsmRoaming = regCodeIsRoaming(regState);
                    mNewSS.setVoiceRegState(regCodeToServiceState(regState));
                    mNewSS.setRilVoiceRadioTechnology(type);
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                    // LAC and CID are -1 if not avail
                    ((GsmCellLocation) mNewCellLoc).setLacAndCid(lac, cid);
                    ((GsmCellLocation) mNewCellLoc).setPsc(psc);
                } else {
                    states = (String[]) ar.result;
                    // [0] registrationState
                    int registrationState = 4;
                    // [3] radioTechnology
                    int radioTechnology = -1;
                    // [4] baseStationId
                    int baseStationId = -1;
                    // [5] baseStationLatitude
                    int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                    // [6] baseStationLongitude
                    int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                    // [7] init with 0, because it is treated as a boolean
                    int cssIndicator = 0;
                    // [8] systemId
                    int systemId = 0;
                    // [9] networkId
                    int networkId = 0;
                    // [10] Roaming indicator
                    int roamingIndicator = -1;
                    // [11] Indicates if current system is in PRL
                    int systemIsInPrl = 0;
                    // [12] Is default roaming indicator from PRL
                    int defaultRoamingIndicator = 0;
                    // [13] Denial reason if registrationState = 3
                    int reasonForDenial = 0;
                    if (states.length >= 14) {
                        try {
                            if (states[0] != null) {
                                registrationState = Integer.parseInt(states[0]);
                            }
                            if (states[3] != null) {
                                radioTechnology = Integer.parseInt(states[3]);
                            }
                            if (states[4] != null) {
                                baseStationId = Integer.parseInt(states[4]);
                            }
                            if (states[5] != null) {
                                baseStationLatitude = Integer.parseInt(states[5]);
                            }
                            if (states[6] != null) {
                                baseStationLongitude = Integer.parseInt(states[6]);
                            }
                            // Some carriers only return lat-lngs of 0,0
                            if (baseStationLatitude == 0 && baseStationLongitude == 0) {
                                baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                                baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                            }
                            if (states[7] != null) {
                                cssIndicator = Integer.parseInt(states[7]);
                            }
                            if (states[8] != null) {
                                systemId = Integer.parseInt(states[8]);
                            }
                            if (states[9] != null) {
                                networkId = Integer.parseInt(states[9]);
                            }
                            if (states[10] != null) {
                                roamingIndicator = Integer.parseInt(states[10]);
                            }
                            if (states[11] != null) {
                                systemIsInPrl = Integer.parseInt(states[11]);
                            }
                            if (states[12] != null) {
                                defaultRoamingIndicator = Integer.parseInt(states[12]);
                            }
                            if (states[13] != null) {
                                reasonForDenial = Integer.parseInt(states[13]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("EVENT_POLL_STATE_REGISTRATION_CDMA: error parsing: " + ex);
                        }
                    } else {
                        throw new RuntimeException("Warning! Wrong number of parameters returned from " + "RIL_REQUEST_REGISTRATION_STATE: expected 14 or more " + "strings and got " + states.length + " strings");
                    }
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                    mNewSS.setRilVoiceRadioTechnology(radioTechnology);
                    mNewSS.setCssIndicator(cssIndicator);
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    // Values are -1 if not available.
                    ((CdmaCellLocation) mNewCellLoc).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    states = (String[]) ar.result;
                    int type = 0;
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    mNewReasonDataDenied = -1;
                    mNewMaxDataCalls = 1;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                type = Integer.parseInt(states[3]);
                            }
                            if ((states.length >= 5) && (regState == ServiceState.RIL_REG_STATE_DENIED)) {
                                mNewReasonDataDenied = Integer.parseInt(states[4]);
                            }
                            if (states.length >= 6) {
                                mNewMaxDataCalls = Integer.parseInt(states[5]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    mDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setRilDataRadioTechnology(type);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + type);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    states = (String[]) ar.result;
                    if (DBG) {
                        log("handlePollStateResultMessage: EVENT_POLL_STATE_GPRS states.length=" + states.length + " states=" + states);
                    }
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    int dataRadioTechnology = 0;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                dataRadioTechnology = Integer.parseInt(states[3]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("handlePollStateResultMessage: error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    mNewSS.setRilDataRadioTechnology(dataRadioTechnology);
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + dataRadioTechnology);
                    }
                } else {
                    states = (String[]) ar.result;
                    if (DBG) {
                        log("handlePollStateResultMessage: EVENT_POLL_STATE_GPRS states.length=" + states.length + " states=" + states);
                    }
                    int newDataRAT = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
                    int regState = -1;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                newDataRAT = Integer.parseInt(states[3]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("handlePollStateResultMessage: error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    // If the unsolicited signal strength comes just before data RAT family changes (i.e.
                    // from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might display
                    // the wrong information until the next unsolicited signal strength information coming
                    // from the modem, which might take a long time to come or even not come at all.
                    // In order to provide the best user experience, we query the latest signal
                    // information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if ((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && newDataRAT != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) || (ServiceState.isCdma(oldDataRAT) && newDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) || (oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_LTE && ServiceState.isCdma(newDataRAT))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    mNewSS.setRilDataRadioTechnology(newDataRAT);
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRAT);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    String[] states;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    states = (String[]) ar.result;
                    int lac = -1;
                    int cid = -1;
                    int type = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    int reasonRegStateDenied = -1;
                    int psc = -1;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            if (states.length >= 3) {
                                if (states[1] != null && states[1].length() > 0) {
                                    lac = (int) Long.parseLong(states[1], 16);
                                }
                                if (states[2] != null && states[2].length() > 0) {
                                    cid = (int) Long.parseLong(states[2], 16);
                                }
                                // states[3] (if present) is the current radio technology
                                if (states.length >= 4 && states[3] != null) {
                                    type = Integer.parseInt(states[3]);
                                }
                            }
                            if (states.length > 14) {
                                if (states[14] != null && states[14].length() > 0) {
                                    psc = (int) Long.parseLong(states[14], 16);
                                }
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing RegistrationState: " + ex);
                        }
                    }
                    mGsmRoaming = regCodeIsRoaming(regState);
                    mNewSS.setVoiceRegState(regCodeToServiceState(regState));
                    mNewSS.setRilVoiceRadioTechnology(type);
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                    // LAC and CID are -1 if not avail
                    ((GsmCellLocation) mNewCellLoc).setLacAndCid(lac, cid);
                    ((GsmCellLocation) mNewCellLoc).setPsc(psc);
                } else {
                    states = (String[]) ar.result;
                    // [0] registrationState
                    int registrationState = 4;
                    // [3] radioTechnology
                    int radioTechnology = -1;
                    // [4] baseStationId
                    int baseStationId = -1;
                    // [5] baseStationLatitude
                    int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                    // [6] baseStationLongitude
                    int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                    // [7] init with 0, because it is treated as a boolean
                    int cssIndicator = 0;
                    // [8] systemId
                    int systemId = 0;
                    // [9] networkId
                    int networkId = 0;
                    // [10] Roaming indicator
                    int roamingIndicator = -1;
                    // [11] Indicates if current system is in PRL
                    int systemIsInPrl = 0;
                    // [12] Is default roaming indicator from PRL
                    int defaultRoamingIndicator = 0;
                    // [13] Denial reason if registrationState = 3
                    int reasonForDenial = 0;
                    if (states.length >= 14) {
                        try {
                            if (states[0] != null) {
                                registrationState = Integer.parseInt(states[0]);
                            }
                            if (states[3] != null) {
                                radioTechnology = Integer.parseInt(states[3]);
                            }
                            if (states[4] != null) {
                                baseStationId = Integer.parseInt(states[4]);
                            }
                            if (states[5] != null) {
                                baseStationLatitude = Integer.parseInt(states[5]);
                            }
                            if (states[6] != null) {
                                baseStationLongitude = Integer.parseInt(states[6]);
                            }
                            // Some carriers only return lat-lngs of 0,0
                            if (baseStationLatitude == 0 && baseStationLongitude == 0) {
                                baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                                baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                            }
                            if (states[7] != null) {
                                cssIndicator = Integer.parseInt(states[7]);
                            }
                            if (states[8] != null) {
                                systemId = Integer.parseInt(states[8]);
                            }
                            if (states[9] != null) {
                                networkId = Integer.parseInt(states[9]);
                            }
                            if (states[10] != null) {
                                roamingIndicator = Integer.parseInt(states[10]);
                            }
                            if (states[11] != null) {
                                systemIsInPrl = Integer.parseInt(states[11]);
                            }
                            if (states[12] != null) {
                                defaultRoamingIndicator = Integer.parseInt(states[12]);
                            }
                            if (states[13] != null) {
                                reasonForDenial = Integer.parseInt(states[13]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("EVENT_POLL_STATE_REGISTRATION_CDMA: error parsing: " + ex);
                        }
                    } else {
                        throw new RuntimeException("Warning! Wrong number of parameters returned from " + "RIL_REQUEST_REGISTRATION_STATE: expected 14 or more " + "strings and got " + states.length + " strings");
                    }
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                    mNewSS.setRilVoiceRadioTechnology(radioTechnology);
                    mNewSS.setCssIndicator(cssIndicator);
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    // Values are -1 if not available.
                    ((CdmaCellLocation) mNewCellLoc).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    states = (String[]) ar.result;
                    int type = 0;
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    mNewReasonDataDenied = -1;
                    mNewMaxDataCalls = 1;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                type = Integer.parseInt(states[3]);
                            }
                            if ((states.length >= 5) && (regState == ServiceState.RIL_REG_STATE_DENIED)) {
                                mNewReasonDataDenied = Integer.parseInt(states[4]);
                            }
                            if (states.length >= 6) {
                                mNewMaxDataCalls = Integer.parseInt(states[5]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    mDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setRilDataRadioTechnology(type);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + type);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    states = (String[]) ar.result;
                    if (DBG) {
                        log("handlePollStateResultMessage: EVENT_POLL_STATE_GPRS states.length=" + states.length + " states=" + states);
                    }
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    int dataRadioTechnology = 0;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                dataRadioTechnology = Integer.parseInt(states[3]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("handlePollStateResultMessage: error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    mNewSS.setRilDataRadioTechnology(dataRadioTechnology);
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + dataRadioTechnology);
                    }
                } else {
                    states = (String[]) ar.result;
                    if (DBG) {
                        log("handlePollStateResultMessage: EVENT_POLL_STATE_GPRS states.length=" + states.length + " states=" + states);
                    }
                    int newDataRAT = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
                    int regState = -1;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                newDataRAT = Integer.parseInt(states[3]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("handlePollStateResultMessage: error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if ((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && newDataRAT != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRAT)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRAT))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    mNewSS.setRilDataRadioTechnology(newDataRAT);
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRAT);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
protected void updateSpnDisplay() {
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (mSS.getVoiceRegState() == ServiceState.STATE_OUT_OF_SERVICE || mSS.getVoiceRegState() == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            if (mEmergencyOnly) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlphaLong();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
            // In Wi-Fi Calling mode show SPN+WiFi
            final String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
            int voiceIdx = 0;
            int dataIdx = 0;
            CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            if (configLoader != null) {
                try {
                    PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                    if (b != null) {
                        voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                        dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                    }
                } catch (Exception e) {
                    loge("updateSpnDisplay: carrier config error: " + e);
                }
            }
            String formatVoice = wfcSpnFormats[voiceIdx];
            String formatData = wfcSpnFormats[dataIdx];
            String originalSpn = spn.trim();
            spn = String.format(formatVoice, originalSpn);
            dataSpn = String.format(formatData, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed" + " sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlphaLong contains the ERI text
        String plmn = mSS.getOperatorAlphaLong();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (mSS.getVoiceRegState() == ServiceState.STATE_OUT_OF_SERVICE || mSS.getVoiceRegState() == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            if (mEmergencyOnly) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlphaLong contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
protected void setPowerStateToDesired() {
    if (DBG) {
        log("mDeviceShuttingDown=" + mDeviceShuttingDown + ", mDesiredPowerState=" + mDesiredPowerState + ", getRadioState=" + mCi.getRadioState() + ", mPowerOffDelayNeed=" + mPowerOffDelayNeed + ", mAlarmSwitch=" + mAlarmSwitch);
    }
    if (mPhone.isPhoneTypeGsm() && mAlarmSwitch) {
        if (DBG)
            log("mAlarmSwitch == true");
        Context context = mPhone.getContext();
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        am.cancel(mRadioOffIntent);
        mAlarmSwitch = false;
    }
    // If we want it on and it's off, turn it on
    if (mDesiredPowerState && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
        mCi.setRadioPower(true, null);
    } else if (!mDesiredPowerState && mCi.getRadioState().isOn()) {
        // If it's on and available and we want it off gracefully
        if (mPhone.isPhoneTypeGsm() && mPowerOffDelayNeed) {
            if (mImsRegistrationOnOff && !mAlarmSwitch) {
                if (DBG)
                    log("mImsRegistrationOnOff == true");
                Context context = mPhone.getContext();
                AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
                Intent intent = new Intent(ACTION_RADIO_OFF);
                mRadioOffIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
                mAlarmSwitch = true;
                if (DBG)
                    log("Alarm setting");
                am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 3000, mRadioOffIntent);
            } else {
                DcTracker dcTracker = mPhone.mDcTracker;
                powerOffRadioSafely(dcTracker);
            }
        } else {
            DcTracker dcTracker = mPhone.mDcTracker;
            powerOffRadioSafely(dcTracker);
        }
    } else if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
        mCi.requestShutdown(null);
    }
}
#method_after
protected void setPowerStateToDesired() {
    if (DBG) {
        log("mDeviceShuttingDown=" + mDeviceShuttingDown + ", mDesiredPowerState=" + mDesiredPowerState + ", getRadioState=" + mCi.getRadioState() + ", mPowerOffDelayNeed=" + mPowerOffDelayNeed + ", mAlarmSwitch=" + mAlarmSwitch + ", mRadioDisabledByCarrier=" + mRadioDisabledByCarrier);
    }
    if (mPhone.isPhoneTypeGsm() && mAlarmSwitch) {
        if (DBG)
            log("mAlarmSwitch == true");
        Context context = mPhone.getContext();
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        am.cancel(mRadioOffIntent);
        mAlarmSwitch = false;
    }
    // If we want it on and it's off, turn it on
    if (mDesiredPowerState && !mRadioDisabledByCarrier && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
        mCi.setRadioPower(true, null);
    } else if ((!mDesiredPowerState || mRadioDisabledByCarrier) && mCi.getRadioState().isOn()) {
        // If it's on and available and we want it off gracefully
        if (mPhone.isPhoneTypeGsm() && mPowerOffDelayNeed) {
            if (mImsRegistrationOnOff && !mAlarmSwitch) {
                if (DBG)
                    log("mImsRegistrationOnOff == true");
                Context context = mPhone.getContext();
                AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
                Intent intent = new Intent(ACTION_RADIO_OFF);
                mRadioOffIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
                mAlarmSwitch = true;
                if (DBG)
                    log("Alarm setting");
                am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 3000, mRadioOffIntent);
            } else {
                DcTracker dcTracker = mPhone.mDcTracker;
                powerOffRadioSafely(dcTracker);
            }
        } else {
            DcTracker dcTracker = mPhone.mDcTracker;
            powerOffRadioSafely(dcTracker);
        }
    } else if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
        mCi.requestShutdown(null);
    }
}
#end_block

#method_before
public void onImsCapabilityChanged() {
    if (mPhone.isPhoneTypeGsm()) {
        sendMessage(obtainMessage(EVENT_IMS_CAPABILITY_CHANGED));
    }
}
#method_after
public void onImsCapabilityChanged() {
    sendMessage(obtainMessage(EVENT_IMS_CAPABILITY_CHANGED));
}
#end_block

#method_before
private void pollStateDoneGsm() {
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasGprsAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasGprsDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(EventLogTags.GSM_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    // i.e. check preferred network setting, only switch to 2G, etc
    if (hasRilVoiceRadioTechnologyChanged) {
        int cid = -1;
        GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
        if (loc != null)
            cid = loc.getCid();
        // NOTE: this code was previously located after mSS and mNewSS are swapped, so
        // existing logs were incorrectly using the new state for "network_from"
        // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
        // to record the correct states.
        EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
        if (DBG) {
            log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
        }
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    GsmCellLocation tcl = (GsmCellLocation) mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    mReasonDataDenied = mNewReasonDataDenied;
    mMaxDataCalls = mNewMaxDataCalls;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        String operatorNumeric;
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        operatorNumeric = mSS.getOperatorNumeric();
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (operatorNumeric == null) {
            if (DBG)
                log("operatorNumeric is null");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            } catch (StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            TimeZone zone = null;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mSS.getVoiceRoaming());
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
        mEventLog.writeServiceStateChanged(mSS);
    }
    if (hasGprsAttached) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasGprsDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
        if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
            mStartedGprsRegCheck = true;
            int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
            sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
        }
    } else {
        mReportedGprsNoReg = false;
    }
}
#method_after
private void pollStateDoneGsm() {
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasGprsAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasGprsDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (hasLocationChanged == false) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(EventLogTags.GSM_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    // i.e. check preferred network setting, only switch to 2G, etc
    if (hasRilVoiceRadioTechnologyChanged) {
        int cid = -1;
        GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
        if (loc != null)
            cid = loc.getCid();
        // NOTE: this code was previously located after mSS and mNewSS are swapped, so
        // existing logs were incorrectly using the new state for "network_from"
        // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
        // to record the correct states.
        EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
        if (DBG) {
            log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
        }
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    GsmCellLocation tcl = (GsmCellLocation) mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    mReasonDataDenied = mNewReasonDataDenied;
    mMaxDataCalls = mNewMaxDataCalls;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        String operatorNumeric;
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        operatorNumeric = mSS.getOperatorNumeric();
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (operatorNumeric == null) {
            if (DBG)
                log("operatorNumeric is null");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            } catch (StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            TimeZone zone = null;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mSS.getVoiceRoaming());
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasGprsAttached || hasGprsDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasGprsAttached) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasGprsDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
        if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
            mStartedGprsRegCheck = true;
            int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
            sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
        }
    } else {
        mReportedGprsNoReg = false;
    }
}
#end_block

#method_before
protected void pollStateDoneCdma() {
    updateRoamingState();
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG)
        log("pollStateDone: cdma oldSS=[" + mSS + "] newSS=[" + mNewSS + "]");
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    // Add an event log when connection state changes
    if (mSS.getVoiceRegState() != mNewSS.getVoiceRegState() || mSS.getDataRegState() != mNewSS.getDataRegState()) {
        EventLog.writeEvent(EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    ServiceState tss;
    tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    CdmaCellLocation tcl = (CdmaCellLocation) mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
    }
    if (hasChanged) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        String operatorNumeric;
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        operatorNumeric = mSS.getOperatorNumeric();
        // try to fix the invalid Operator Numeric
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            int sid = mSS.getSystemId();
            operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + "is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
        } else {
            String isoCountryCode = "";
            String mcc = operatorNumeric.substring(0, 3);
            try {
                isoCountryCode = MccTable.countryCodeForMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
            } catch (NumberFormatException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            } catch (StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), isoCountryCode);
            mGotCountryCode = true;
            setOperatorIdd(operatorNumeric);
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(isoCountryCode);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        updateSpnDisplay();
        // set roaming type
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
    }
    if (hasCdmaDataConnectionAttached) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasCdmaDataConnectionDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasCdmaDataConnectionChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
// TODO: Add CdmaCellIdenity updating, see CdmaLteServiceStateTracker.
}
#method_after
protected void pollStateDoneCdma() {
    updateRoamingState();
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG)
        log("pollStateDone: cdma oldSS=[" + mSS + "] newSS=[" + mNewSS + "]");
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (hasLocationChanged == false) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    // Add an event log when connection state changes
    if (mSS.getVoiceRegState() != mNewSS.getVoiceRegState() || mSS.getDataRegState() != mNewSS.getDataRegState()) {
        EventLog.writeEvent(EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    ServiceState tss;
    tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    CdmaCellLocation tcl = (CdmaCellLocation) mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
    }
    if (hasChanged) {
        updateSpnDisplay();
        String operatorNumeric;
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        operatorNumeric = mSS.getOperatorNumeric();
        // try to fix the invalid Operator Numeric
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            int sid = mSS.getSystemId();
            operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + "is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
        } else {
            String isoCountryCode = "";
            String mcc = operatorNumeric.substring(0, 3);
            try {
                isoCountryCode = MccTable.countryCodeForMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
            } catch (NumberFormatException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            } catch (StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), isoCountryCode);
            mGotCountryCode = true;
            setOperatorIdd(operatorNumeric);
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(isoCountryCode);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        // set roaming type
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
    }
    if (hasCdmaDataConnectionAttached || hasCdmaDataConnectionDetached || hasRegistered) {
        logAttachChange();
    }
    if (hasCdmaDataConnectionAttached) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasCdmaDataConnectionDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasCdmaDataConnectionChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
// TODO: Add CdmaCellIdenity updating, see CdmaLteServiceStateTracker.
}
#end_block

#method_before
protected void pollStateDoneCdmaLte() {
    updateRoamingState();
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    log("pollStateDone: lte 1 ss=[" + mSS + "] newSS=[" + mNewSS + "]");
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    boolean has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && (((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE)));
    boolean hasMultiApnSupport = (((mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && ((mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_LTE) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
    boolean hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeegistered=" + hasDeregistered + " hasCdmaDataConnectionAttached=" + hasCdmaDataConnectionAttached + " hasCdmaDataConnectionDetached=" + hasCdmaDataConnectionDetached + " hasCdmaDataConnectionChanged=" + hasCdmaDataConnectionChanged + " hasVoiceRadioTechnologyChanged= " + hasVoiceRadioTechnologyChanged + " hasDataRadioTechnologyChanged=" + hasDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (mSS.getVoiceRegState() != mNewSS.getVoiceRegState() || mSS.getDataRegState() != mNewSS.getDataRegState()) {
        EventLog.writeEvent(EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    ServiceState tss;
    tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    CdmaCellLocation tcl = (CdmaCellLocation) mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    if (hasVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    if (hasDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
    }
    if (hasChanged) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) == null ? false : (mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null);
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (mSS.getRilVoiceRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_LTE || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name))) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlphaLong();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) && mSS.getRilVoiceRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_LTE) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
        String operatorNumeric;
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        operatorNumeric = mSS.getOperatorNumeric();
        // try to fix the invalid Operator Numeric
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            int sid = mSS.getSystemId();
            operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric is null");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
        } else {
            String isoCountryCode = "";
            String mcc = operatorNumeric.substring(0, 3);
            try {
                isoCountryCode = MccTable.countryCodeForMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
            } catch (NumberFormatException ex) {
                loge("countryCodeForMcc error" + ex);
            } catch (StringIndexOutOfBoundsException ex) {
                loge("countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), isoCountryCode);
            mGotCountryCode = true;
            setOperatorIdd(operatorNumeric);
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(isoCountryCode);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        updateSpnDisplay();
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
    }
    if (hasCdmaDataConnectionAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasCdmaDataConnectionDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if ((hasCdmaDataConnectionChanged || hasDataRadioTechnologyChanged)) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
}
#method_after
protected void pollStateDoneCdmaLte() {
    updateRoamingState();
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    log("pollStateDone: lte 1 ss=[" + mSS + "] newSS=[" + mNewSS + "]");
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasCdmaDataConnectionChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (hasLocationChanged == false) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
    boolean hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
    boolean hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeegistered=" + hasDeregistered + " hasCdmaDataConnectionAttached=" + hasCdmaDataConnectionAttached + " hasCdmaDataConnectionDetached=" + hasCdmaDataConnectionDetached + " hasCdmaDataConnectionChanged=" + hasCdmaDataConnectionChanged + " hasVoiceRadioTechnologyChanged= " + hasVoiceRadioTechnologyChanged + " hasDataRadioTechnologyChanged=" + hasDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (mSS.getVoiceRegState() != mNewSS.getVoiceRegState() || mSS.getDataRegState() != mNewSS.getDataRegState()) {
        EventLog.writeEvent(EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    ServiceState tss;
    tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    CdmaCellLocation tcl = (CdmaCellLocation) mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    if (hasVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    if (hasDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
    }
    if (hasChanged) {
        updateSpnDisplay();
        String operatorNumeric;
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlphaLong());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        operatorNumeric = mSS.getOperatorNumeric();
        // try to fix the invalid Operator Numeric
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            int sid = mSS.getSystemId();
            operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric is null");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
        } else {
            String isoCountryCode = "";
            String mcc = operatorNumeric.substring(0, 3);
            try {
                isoCountryCode = MccTable.countryCodeForMcc(Integer.parseInt(operatorNumeric.substring(0, 3)));
            } catch (NumberFormatException ex) {
                loge("countryCodeForMcc error" + ex);
            } catch (StringIndexOutOfBoundsException ex) {
                loge("countryCodeForMcc error" + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), isoCountryCode);
            mGotCountryCode = true;
            setOperatorIdd(operatorNumeric);
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(isoCountryCode);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        mPhone.notifyServiceStateChanged(mSS);
    }
    if (hasCdmaDataConnectionAttached || has4gHandoff || hasCdmaDataConnectionDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasCdmaDataConnectionAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasCdmaDataConnectionDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasDataRadioTechnologyChanged || hasVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if ((hasCdmaDataConnectionChanged || hasDataRadioTechnologyChanged)) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
}
#end_block

#method_before
private void onRestrictedStateChanged(AsyncResult ar) {
    RestrictedState newRs = new RestrictedState();
    if (DBG)
        log("onRestrictedStateChanged: E rs " + mRestrictedState);
    if (ar.exception == null) {
        int[] ints = (int[]) ar.result;
        int state = ints[0];
        newRs.setCsEmergencyRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
        // ignore the normal call and data restricted state before SIM READY
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY) {
            newRs.setCsNormalRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
            newRs.setPsRestricted((state & RILConstants.RIL_RESTRICTED_STATE_PS_ALL) != 0);
        }
        if (DBG)
            log("onRestrictedStateChanged: new rs " + newRs);
        if (!mRestrictedState.isPsRestricted() && newRs.isPsRestricted()) {
            mPsRestrictEnabledRegistrants.notifyRegistrants();
            setNotification(PS_ENABLED);
        } else if (mRestrictedState.isPsRestricted() && !newRs.isPsRestricted()) {
            mPsRestrictDisabledRegistrants.notifyRegistrants();
            setNotification(PS_DISABLED);
        }
        /**
         * There are two kind of cs restriction, normal and emergency. So
         * there are 4 x 4 combinations in current and new restricted states
         * and we only need to notify when state is changed.
         */
        if (mRestrictedState.isCsRestricted()) {
            if (!newRs.isCsNormalRestricted() && !newRs.isCsEmergencyRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (!newRs.isCsNormalRestricted()) {
                // remove normal restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (!newRs.isCsEmergencyRestricted()) {
                // remove emergency restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (mRestrictedState.isCsEmergencyRestricted() && !mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isCsNormalRestricted() && !newRs.isCsEmergencyRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // remove emergency restriction and enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (!mRestrictedState.isCsEmergencyRestricted() && mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isCsNormalRestricted() && !newRs.isCsEmergencyRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // remove normal restriction and enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            }
        } else {
            if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        }
        mRestrictedState = newRs;
    }
    log("onRestrictedStateChanged: X rs " + mRestrictedState);
}
#method_after
private void onRestrictedStateChanged(AsyncResult ar) {
    RestrictedState newRs = new RestrictedState();
    if (DBG)
        log("onRestrictedStateChanged: E rs " + mRestrictedState);
    if (ar.exception == null) {
        int[] ints = (int[]) ar.result;
        int state = ints[0];
        newRs.setCsEmergencyRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
        // ignore the normal call and data restricted state before SIM READY
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY) {
            newRs.setCsNormalRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
            newRs.setPsRestricted((state & RILConstants.RIL_RESTRICTED_STATE_PS_ALL) != 0);
        }
        if (DBG)
            log("onRestrictedStateChanged: new rs " + newRs);
        if (!mRestrictedState.isPsRestricted() && newRs.isPsRestricted()) {
            mPsRestrictEnabledRegistrants.notifyRegistrants();
            setNotification(PS_ENABLED);
        } else if (mRestrictedState.isPsRestricted() && !newRs.isPsRestricted()) {
            mPsRestrictDisabledRegistrants.notifyRegistrants();
            setNotification(PS_DISABLED);
        }
        /**
         * There are two kind of cs restriction, normal and emergency. So
         * there are 4 x 4 combinations in current and new restricted states
         * and we only need to notify when state is changed.
         */
        if (mRestrictedState.isCsRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (!newRs.isCsNormalRestricted()) {
                // remove normal restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (!newRs.isCsEmergencyRestricted()) {
                // remove emergency restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (mRestrictedState.isCsEmergencyRestricted() && !mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // remove emergency restriction and enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (!mRestrictedState.isCsEmergencyRestricted() && mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // remove normal restriction and enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            }
        } else {
            if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        }
        mRestrictedState = newRs;
    }
    log("onRestrictedStateChanged: X rs " + mRestrictedState);
}
#end_block

#method_before
private void setAndBroadcastNetworkSetTime(long time) {
    if (DBG)
        log("setAndBroadcastNetworkSetTime: time=" + time + "ms");
    SystemClock.setCurrentTimeMillis(time);
    Intent intent = new Intent(TelephonyIntents.ACTION_NETWORK_SET_TIME);
    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    intent.putExtra("time", time);
    mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
}
#method_after
private void setAndBroadcastNetworkSetTime(long time) {
    if (DBG)
        log("setAndBroadcastNetworkSetTime: time=" + time + "ms");
    SystemClock.setCurrentTimeMillis(time);
    Intent intent = new Intent(TelephonyIntents.ACTION_NETWORK_SET_TIME);
    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    intent.putExtra("time", time);
    mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    TelephonyMetrics.getInstance().writeNITZEvent(mPhone.getPhoneId(), time);
}
#end_block

#method_before
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    // override isGsm for CDMA LTE
    if (mPhone.isPhoneTypeGsm() || (mPhone.isPhoneTypeCdmaLte() && mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE)) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#method_after
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    // override isGsm for CDMA LTE
    if (mPhone.isPhoneTypeGsm() || (mPhone.isPhoneTypeCdmaLte() && ServiceState.isLte(mSS.getRilDataRadioTechnology()))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + mCellLoc);
    pw.println(" mNewCellLoc=" + mNewCellLoc);
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + mCellLoc);
    pw.println(" mNewCellLoc=" + mNewCellLoc);
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#end_block

#method_before
protected void resetServiceStateInIwlanMode() {
    if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
        boolean resetIwlanRatVal = false;
        log("set service state as POWER_OFF");
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mNewSS.getRilDataRadioTechnology()) {
            log("pollStateDone: mNewSS = " + mNewSS);
            log("pollStateDone: reset iwlan RAT value");
            resetIwlanRatVal = true;
        }
        mNewSS.setStateOff();
        if (resetIwlanRatVal) {
            mNewSS.setRilDataRadioTechnology(ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN);
            mNewSS.setDataRegState(ServiceState.STATE_IN_SERVICE);
            log("pollStateDone: mNewSS = " + mNewSS);
        }
    }
}
#method_after
protected void resetServiceStateInIwlanMode() {
    if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
        boolean resetIwlanRatVal = false;
        log("set service state as POWER_OFF");
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mNewSS.getRilDataRadioTechnology()) {
            log("pollStateDone: mNewSS = " + mNewSS);
            log("pollStateDone: reset iwlan RAT value");
            resetIwlanRatVal = true;
        }
        // operator info should be kept in SS
        String operator = mNewSS.getOperatorAlphaLong();
        mNewSS.setStateOff();
        if (resetIwlanRatVal) {
            mNewSS.setRilDataRadioTechnology(ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN);
            mNewSS.setDataRegState(ServiceState.STATE_IN_SERVICE);
            mNewSS.setOperatorAlphaLong(operator);
            log("pollStateDone: mNewSS = " + mNewSS);
        }
    }
}
#end_block

#method_before
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException {
    Objects.requireNonNull(h);
    final Class<?>[] intfs = interfaces.clone();
    final SecurityManager sm = System.getSecurityManager();
    // Android-changed: sm is always null
    // if (sm != null) {
    // checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
    // }
    /*
         * Look up or generate the designated proxy class.
         */
    Class<?> cl = getProxyClass0(loader, intfs);
    /*
         * Invoke its constructor with the designated invocation handler.
         */
    try {
        // Android-changed: sm is always null
        // if (sm != null) {
        // checkNewProxyPermission(Reflection.getCallerClass(), cl);
        // }
        final Constructor<?> cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        if (!Modifier.isPublic(cl.getModifiers())) {
            AccessController.doPrivileged(new PrivilegedAction<Void>() {

                public Void run() {
                    cons.setAccessible(true);
                    return null;
                }
            });
        }
        return cons.newInstance(new Object[] { h });
    } catch (IllegalAccessException | InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    } catch (NoSuchMethodException e) {
        throw new InternalError(e.toString(), e);
    }
}
#method_after
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException {
    Objects.requireNonNull(h);
    final Class<?>[] intfs = interfaces.clone();
    // Android-changed: sm is always null
    // final SecurityManager sm = System.getSecurityManager();
    // if (sm != null) {
    // checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
    // }
    /*
         * Look up or generate the designated proxy class.
         */
    Class<?> cl = getProxyClass0(loader, intfs);
    /*
         * Invoke its constructor with the designated invocation handler.
         */
    try {
        // Android-changed: sm is always null
        // if (sm != null) {
        // checkNewProxyPermission(Reflection.getCallerClass(), cl);
        // }
        final Constructor<?> cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        if (!Modifier.isPublic(cl.getModifiers())) {
            // Android-changed: Removed AccessController.doPrivileged
            cons.setAccessible(true);
        }
        return cons.newInstance(new Object[] { h });
    } catch (IllegalAccessException | InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    } catch (NoSuchMethodException e) {
        throw new InternalError(e.toString(), e);
    }
}
#end_block

#method_before
public boolean needsUnlockedKeyStore() {
    for (WifiConfiguration config : getInternalConfiguredNetworks()) {
        if (config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) && config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) {
            if (mWifiKeyStore.needsSoftwareBackedKeyStore(config.enterpriseConfig)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean needsUnlockedKeyStore() {
    for (WifiConfiguration config : getInternalConfiguredNetworks()) {
        if (WifiConfigurationUtil.isConfigForEapNetwork(config)) {
            if (mWifiKeyStore.needsSoftwareBackedKeyStore(config.enterpriseConfig)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean saveToStore(boolean forceWrite) {
    ArrayList<WifiConfiguration> sharedConfigurations = new ArrayList<>();
    ArrayList<WifiConfiguration> userConfigurations = new ArrayList<>();
    for (WifiConfiguration config : mConfiguredNetworks.valuesForAllUsers()) {
        // Don't persist ephemeral networks to store.
        if (!config.ephemeral) {
            // user logs in.
            if (config.shared || !WifiConfigurationUtil.doesUidBelongToAnyProfile(config.creatorUid, mUserManager.getProfiles(mCurrentUserId))) {
                sharedConfigurations.add(config);
            } else {
                userConfigurations.add(config);
            }
        }
    }
    WifiConfigStoreData storeData = new WifiConfigStoreData(sharedConfigurations, userConfigurations, mDeletedEphemeralSSIDs);
    try {
        mWifiConfigStore.write(forceWrite, storeData);
    } catch (IOException e) {
        Log.wtf(TAG, "Writing to store failed. Saved networks maybe lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML serialization for store failed. Saved networks maybe lost!", e);
        return false;
    }
    return true;
}
#method_after
public boolean saveToStore(boolean forceWrite) {
    ArrayList<WifiConfiguration> sharedConfigurations = new ArrayList<>();
    ArrayList<WifiConfiguration> userConfigurations = new ArrayList<>();
    for (WifiConfiguration config : mConfiguredNetworks.valuesForAllUsers()) {
        // Don't persist ephemeral and passpoint networks to store.
        if (!config.ephemeral && !config.isPasspoint()) {
            // user logs in.
            if (config.shared || !WifiConfigurationUtil.doesUidBelongToAnyProfile(config.creatorUid, mUserManager.getProfiles(mCurrentUserId))) {
                sharedConfigurations.add(config);
            } else {
                userConfigurations.add(config);
            }
        }
    }
    WifiConfigStoreData storeData = new WifiConfigStoreData(sharedConfigurations, userConfigurations, mDeletedEphemeralSSIDs);
    try {
        mWifiConfigStore.write(forceWrite, storeData);
    } catch (IOException e) {
        Log.wtf(TAG, "Writing to store failed. Saved networks maybe lost!", e);
        return false;
    } catch (XmlPullParserException e) {
        Log.wtf(TAG, "XML serialization for store failed. Saved networks maybe lost!", e);
        return false;
    }
    return true;
}
#end_block

#method_before
public WifiConnectivityManager makeWifiConnectivityManager(WifiInfo wifiInfo, boolean hasConnectionRequests) {
    return new WifiConnectivityManager(mContext, mWifiStateMachine, getWifiScanner(), mWifiConfigManager, wifiInfo, mWifiNetworkSelector, mWifiLastResortWatchdog, mWifiMetrics, mWifiStateMachineHandlerThread.getLooper(), mClock, hasConnectionRequests, mFrameworkFacade, mSavedNetworkEvaluator, mExternalScoreEvaluator, mRecommendedNetworkEvaluator, new PasspointNetworkEvaluator(mPasspointManager, mWifiConfigManager, mWifiNetworkSelector.getLocalLog()));
}
#method_after
public WifiConnectivityManager makeWifiConnectivityManager(WifiInfo wifiInfo, boolean hasConnectionRequests) {
    return new WifiConnectivityManager(mContext, mWifiStateMachine, getWifiScanner(), mWifiConfigManager, wifiInfo, mWifiNetworkSelector, mWifiLastResortWatchdog, mWifiMetrics, mWifiStateMachineHandlerThread.getLooper(), mClock, hasConnectionRequests, mFrameworkFacade, mSavedNetworkEvaluator, mRecommendedNetworkEvaluator, mPasspointNetworkEvaluator);
}
#end_block

#method_before
@Override
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    // Go through each ScanDetail and match a best provider for each ScanDetail.
    List<Pair<ScanDetail, Pair<PasspointProvider, PasspointMatchInfo>>> providerList = new ArrayList<>();
    for (ScanDetail scanDetail : scanDetails) {
        // Skip non-Passpoint APs.
        if (!scanDetail.getNetworkDetail().isInterworking()) {
            continue;
        }
        List<Pair<PasspointProvider, PasspointMatch>> matchedProviders = mPasspointManager.matchProvider(scanDetail);
        // Find the best provider for this ScanDetail.
        Pair<PasspointProvider, PasspointMatchInfo> bestMatch = getBestMatch(scanDetail, matchedProviders);
        if (bestMatch != null) {
            providerList.add(Pair.create(scanDetail, bestMatch));
        }
    }
    // Find the best provider from all scan details.
    Pair<ScanDetail, Pair<PasspointProvider, PasspointMatchInfo>> bestMatch = null;
    for (Pair<ScanDetail, Pair<PasspointProvider, PasspointMatchInfo>> match : providerList) {
        if (bestMatch == null || bestMatch.second.second.compareTo(match.second.second) < 0) {
            bestMatch = match;
        }
    }
    // No matching provider found.
    if (bestMatch == null) {
        return null;
    }
    WifiConfiguration config = createWifiConfigForProvider(bestMatch.second.first, bestMatch.first);
    connectableNetworks.add(Pair.create(bestMatch.first, config));
    return config;
}
#method_after
@Override
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    // Go through each ScanDetail and find the best provider for each ScanDetail.
    List<Pair<ScanDetail, Pair<PasspointProvider, PasspointMatch>>> providerList = new ArrayList<>();
    for (ScanDetail scanDetail : scanDetails) {
        // Skip non-Passpoint APs.
        if (!scanDetail.getNetworkDetail().isInterworking()) {
            continue;
        }
        List<Pair<PasspointProvider, PasspointMatch>> matchedProviders = mPasspointManager.matchProvider(scanDetail);
        // Find the best provider for this ScanDetail.
        Pair<PasspointProvider, PasspointMatch> bestProvider = findBestProvider(matchedProviders);
        if (bestProvider != null) {
            providerList.add(Pair.create(scanDetail, bestProvider));
        }
    }
    // Done if no matching provider is found.
    if (providerList.isEmpty()) {
        return null;
    }
    // Find the best Passpoint network among all matches.
    Pair<PasspointProvider, ScanDetail> bestNetwork = findBestNetwork(providerList, currentNetwork == null ? null : currentNetwork.SSID);
    // Return the configuration for the current connected network if it is the best network.
    if (currentNetwork != null && TextUtils.equals(currentNetwork.SSID, ScanResultUtil.createQuotedSSID(bestNetwork.second.getSSID()))) {
        connectableNetworks.add(Pair.create(bestNetwork.second, currentNetwork));
        return currentNetwork;
    }
    WifiConfiguration config = createWifiConfigForProvider(bestNetwork.first, bestNetwork.second);
    connectableNetworks.add(Pair.create(bestNetwork.second, config));
    return config;
}
#end_block

#method_before
private WifiConfiguration createWifiConfigForProvider(PasspointProvider provider, ScanDetail scanDetail) {
    WifiConfiguration config = provider.getWifiConfig();
    config.ephemeral = true;
    config.SSID = "\"" + scanDetail.getSSID() + "\"";
    // Add the newly created WifiConfiguration to WifiConfigManager.
    NetworkUpdateResult result = mWifiConfigManager.addOrUpdateNetwork(config, Process.WIFI_UID);
    if (!result.isSuccess()) {
        localLog("Failed to add passpoint network");
        return null;
    }
    mWifiConfigManager.setNetworkCandidateScanResult(result.getNetworkId(), scanDetail.getScanResult(), 0);
    return mWifiConfigManager.getConfiguredNetwork(result.getNetworkId());
}
#method_after
private WifiConfiguration createWifiConfigForProvider(PasspointProvider provider, ScanDetail scanDetail) {
    WifiConfiguration config = provider.getWifiConfig();
    config.SSID = ScanResultUtil.createQuotedSSID(scanDetail.getSSID());
    // Add the newly created WifiConfiguration to WifiConfigManager.
    NetworkUpdateResult result = mWifiConfigManager.addOrUpdateNetwork(config, Process.WIFI_UID);
    if (!result.isSuccess()) {
        localLog("Failed to add passpoint network");
        return null;
    }
    mWifiConfigManager.setNetworkCandidateScanResult(result.getNetworkId(), scanDetail.getScanResult(), 0);
    return mWifiConfigManager.getConfiguredNetwork(result.getNetworkId());
}
#end_block

#method_before
WifiConnectivityManager createConnectivityManager() {
    return new WifiConnectivityManager(mContext, mWifiStateMachine, mWifiScanner, mWifiConfigManager, mWifiInfo, mWifiNS, mWifiLastResortWatchdog, mWifiMetrics, mLooper.getLooper(), mClock, true, mFrameworkFacade, null, null, null, null);
}
#method_after
WifiConnectivityManager createConnectivityManager() {
    return new WifiConnectivityManager(mContext, mWifiStateMachine, mWifiScanner, mWifiConfigManager, mWifiInfo, mWifiNS, mWifiLastResortWatchdog, mWifiMetrics, mLooper.getLooper(), mClock, true, mFrameworkFacade, null, null, null);
}
#end_block

#method_before
@Test
public void verifyNotificationDisplayedWhenNetworkRecommended() throws Exception {
    Util.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    Util.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.DISCONNECTED);
    setOpenAccessPoints(3);
    when(mScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createConnectRecommendation(createFakeConfig()));
    // The notification should not be displayed after only two scan results.
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mNotificationManager, never()).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // Changing to and from "SCANNING" state should not affect the counter.
    Util.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.SCANNING);
    Util.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.DISCONNECTED);
    verify(mNotificationManager, never()).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // The third scan result notification will trigger the notification.
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiNotificationHelper).createMainNotification(any(WifiConfiguration.class));
    verify(mNotificationManager).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    verify(mNotificationManager, never()).cancelAsUser(any(String.class), anyInt(), any(UserHandle.class));
}
#method_after
@Test
public void verifyNotificationDisplayedWhenNetworkRecommended() throws Exception {
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.DISCONNECTED);
    setOpenAccessPoints(3);
    when(mScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createConnectRecommendation(createFakeConfig()));
    // The notification should not be displayed after only two scan results.
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mNotificationManager, never()).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // Changing to and from "SCANNING" state should not affect the counter.
    TestUtil.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.SCANNING);
    TestUtil.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.DISCONNECTED);
    verify(mNotificationManager, never()).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // The third scan result notification will trigger the notification.
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiNotificationHelper).createMainNotification(any(WifiConfiguration.class), any(Bitmap.class));
    verify(mNotificationManager).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    verify(mNotificationManager, never()).cancelAsUser(any(String.class), anyInt(), any(UserHandle.class));
}
#end_block

#method_before
@Test
public void verifyNotificationNotDisplayedWhenNoNetworkRecommended() throws Exception {
    Util.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    Util.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.DISCONNECTED);
    setOpenAccessPoints(3);
    // Recommendation result with no WifiConfiguration returned.
    when(mScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createDoNotConnectRecommendation());
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mNotificationManager, never()).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // DoNotConnect Recommendation result.
    when(mScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createDoNotConnectRecommendation());
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mNotificationManager, never()).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
}
#method_after
@Test
public void verifyNotificationNotDisplayedWhenNoNetworkRecommended() throws Exception {
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.DISCONNECTED);
    setOpenAccessPoints(3);
    // Recommendation result with no WifiConfiguration returned.
    when(mScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createDoNotConnectRecommendation());
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mNotificationManager, never()).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // DoNotConnect Recommendation result.
    when(mScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createDoNotConnectRecommendation());
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mNotificationManager, never()).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
}
#end_block

#method_before
@Test
public void verifyNotificationsFlowOnConnectToNetwork() {
    Util.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    Util.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.DISCONNECTED);
    setOpenAccessPoints(3);
    when(mScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createConnectRecommendation(createFakeConfig()));
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    Util.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiNotificationHelper).createMainNotification(any(WifiConfiguration.class));
    verify(mNotificationManager).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // Send connect intent, should attempt to connect to Wi-Fi
    Intent intent = new Intent(WifiNotificationController.ACTION_CONNECT_TO_RECOMMENDED_NETWORK);
    mBroadcastReceiver.onReceive(mContext, intent);
    verify(mWifiManager).connect(any(WifiConfiguration.class), any(ActionListener.class));
    verify(mWifiNotificationHelper).createConnectingNotification(any(WifiConfiguration.class));
    // Show connecting notification.
    verify(mNotificationManager, times(2)).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // Verify callback to dismiss notification exists.
    assertTrue(mHandler.hasCallbacks(mWifiNotificationController.mDismissNotificationRunnable));
    // Verify show connected notification.
    Util.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.CONNECTED);
    verify(mWifiNotificationHelper).createConnectedNotification(any(WifiConfiguration.class));
    verify(mNotificationManager, times(3)).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // Verify callback to dismiss notification exists.
    assertTrue(mHandler.hasCallbacks(mWifiNotificationController.mDismissNotificationRunnable));
}
#method_after
@Test
public void verifyNotificationsFlowOnConnectToNetwork() {
    TestUtil.sendWifiStateChanged(mBroadcastReceiver, mContext, WifiManager.WIFI_STATE_ENABLED);
    TestUtil.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.DISCONNECTED);
    setOpenAccessPoints(3);
    when(mScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createConnectRecommendation(createFakeConfig()));
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    TestUtil.sendScanResultsAvailable(mBroadcastReceiver, mContext);
    verify(mWifiNotificationHelper).createMainNotification(any(WifiConfiguration.class), any(Bitmap.class));
    verify(mNotificationManager).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // Send connect intent, should attempt to connect to Wi-Fi
    Intent intent = new Intent(WifiNotificationController.ACTION_CONNECT_TO_RECOMMENDED_NETWORK);
    mBroadcastReceiver.onReceive(mContext, intent);
    verify(mWifiManager).connect(any(WifiConfiguration.class), any(ActionListener.class));
    verify(mWifiNotificationHelper).createConnectingNotification(any(WifiConfiguration.class), any(Bitmap.class));
    // Show connecting notification.
    verify(mNotificationManager, times(2)).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // Verify callback to dismiss connecting notification exists.
    assertTrue(mHandler.hasCallbacks(mWifiNotificationController.mShowFailedToConnectNotificationRunnable));
    // Verify show connected notification.
    TestUtil.sendNetworkStateChanged(mBroadcastReceiver, mContext, NetworkInfo.DetailedState.CONNECTED);
    verify(mWifiNotificationHelper).createConnectedNotification(any(WifiConfiguration.class), any(Bitmap.class));
    verify(mNotificationManager, times(3)).notifyAsUser(any(String.class), anyInt(), any(Notification.class), any(UserHandle.class));
    // Verify callback to dismiss connected notification exists.
    assertTrue(mHandler.hasCallbacks(mWifiNotificationController.mDismissNotificationRunnable));
}
#end_block

#method_before
@Override
public void onCreate() {
    mHandlerThread = new HandlerThread("RecommendationProvider");
    mHandlerThread.start();
    mHandler = new Handler(mHandlerThread.getLooper());
    mProvider = new DefaultNetworkRecommendationProvider(mHandler, (NetworkScoreManager) getSystemService(Context.NETWORK_SCORE_SERVICE), new DefaultNetworkRecommendationProvider.ScoreStorage());
    mWifiNotificationController = new WifiNotificationController(this, getContentResolver(), mHandler, getSystemService(NetworkScoreManager.class), getSystemService(WifiManager.class), getSystemService(NotificationManager.class));
    mWifiWakeupController = new WifiWakeupController(this, getContentResolver(), mHandlerThread.getLooper());
}
#method_after
@Override
public void onCreate() {
    mHandlerThread = new HandlerThread("RecommendationProvider");
    mHandlerThread.start();
    mHandler = new Handler(mHandlerThread.getLooper());
    NetworkScoreManager networkScoreManager = getSystemService(NetworkScoreManager.class);
    mProvider = new DefaultNetworkRecommendationProvider(mHandler, networkScoreManager, new DefaultNetworkRecommendationProvider.ScoreStorage());
    mWifiNotificationController = new WifiNotificationController(this, getContentResolver(), mHandler, networkScoreManager, getSystemService(WifiManager.class), getSystemService(NotificationManager.class), new WifiNotificationHelper(this, mProvider));
    mWifiWakeupController = new WifiWakeupController(this, getContentResolver(), mHandlerThread.getLooper(), getSystemService(WifiManager.class), new WifiWakeupNetworkSelector(getResources()));
}
#end_block

#method_before
private void checkAndSetNotification(NetworkInfo networkInfo, List<ScanResult> scanResults) {
    // don't bother doing any of the following
    if (!mNotificationEnabled)
        return;
    if (mWifiState != WifiManager.WIFI_STATE_ENABLED)
        return;
    NetworkInfo.State state = NetworkInfo.State.DISCONNECTED;
    if (networkInfo != null) {
        state = networkInfo.getState();
    }
    if (state == NetworkInfo.State.DISCONNECTED || state == NetworkInfo.State.UNKNOWN) {
        RecommendationResult result = getOpenNetworkRecommendation(scanResults);
        if (result != null && result.getWifiConfiguration() != null) {
            mRecommendedNetwork = result.getWifiConfiguration();
            if (++mNumScansSinceNetworkStateChange >= NUM_SCANS_BEFORE_ACTUALLY_SCANNING) {
                /*
                     * We have scanned continuously at least
                     * NUM_SCANS_BEFORE_NOTIFICATION times. The user
                     * probably does not have a remembered network in range,
                     * since otherwise supplicant would have tried to
                     * associate and thus resetting this counter.
                     */
                displayNotification();
            }
            return;
        }
    }
    // No open networks in range, remove the notification
    removeNotification();
}
#method_after
private void checkAndSetNotification(NetworkInfo networkInfo, List<ScanResult> scanResults) {
    // don't bother doing any of the following
    if (!mNotificationEnabled)
        return;
    if (mWifiState != WifiManager.WIFI_STATE_ENABLED)
        return;
    NetworkInfo.State state = NetworkInfo.State.DISCONNECTED;
    if (networkInfo != null) {
        state = networkInfo.getState();
    }
    if (state == NetworkInfo.State.DISCONNECTED || state == NetworkInfo.State.UNKNOWN) {
        RecommendationResult result = getOpenNetworkRecommendation(scanResults);
        if (result != null && result.getWifiConfiguration() != null) {
            mRecommendedNetwork = result.getWifiConfiguration();
            mNotificationBadgeBitmap = mWifiNotificationHelper.createNotificationBadgeBitmap(mRecommendedNetwork, scanResults);
            if (++mNumScansSinceNetworkStateChange >= NUM_SCANS_BEFORE_ACTUALLY_SCANNING && mNotificationBadgeBitmap != null) {
                /*
                     * We have scanned continuously at least
                     * NUM_SCANS_BEFORE_NOTIFICATION times. The user
                     * probably does not have a remembered network in range,
                     * since otherwise supplicant would have tried to
                     * associate and thus resetting this counter.
                     */
                displayNotification();
            }
            return;
        }
    }
    // No open networks in range, remove the notification
    removeNotification();
}
#end_block

#method_before
private void displayNotification() {
    if (System.currentTimeMillis() < mNotificationRepeatTime) {
        return;
    }
    Notification notification = mWifiNotificationHelper.createMainNotification(mRecommendedNetwork);
    mNotificationRepeatTime = System.currentTimeMillis() + mNotificationRepeatDelayMs;
    Log.i("WifiNotification", "Show Notification2");
    notify(notification);
    mNotificationShown = true;
}
#method_after
private void displayNotification() {
    if (System.currentTimeMillis() < mNotificationRepeatTime) {
        return;
    }
    Notification notification = mWifiNotificationHelper.createMainNotification(mRecommendedNetwork, mNotificationBadgeBitmap);
    mNotificationRepeatTime = System.currentTimeMillis() + mNotificationRepeatDelayMs;
    postNotification(notification);
    mNotificationShown = true;
}
#end_block

#method_before
private void connectToRecommendedNetwork() {
    if (mRecommendedNetwork == null) {
        return;
    }
    // Attempts to connect to recommended network.
    mWifiManager.connect(mRecommendedNetwork, null);
    // Update notification to connecting status.
    Notification notification = mWifiNotificationHelper.createConnectingNotification(mRecommendedNetwork);
    notify(notification);
    mHandler.postDelayed(mDismissNotificationRunnable, TIME_TO_SHOW_CONNECTING_MILLIS);
}
#method_after
private void connectToRecommendedNetwork() {
    if (mRecommendedNetwork == null) {
        return;
    }
    // Attempts to connect to recommended network.
    mWifiManager.connect(mRecommendedNetwork, null);
    // Update notification to connecting status.
    Notification notification = mWifiNotificationHelper.createConnectingNotification(mRecommendedNetwork, mNotificationBadgeBitmap);
    postNotification(notification);
    mHandler.postDelayed(mShowFailedToConnectNotificationRunnable, TIME_TO_SHOW_CONNECTING_MILLIS);
}
#end_block

#method_before
private void updateNotificationOnConnect() {
    if (!mNotificationShown) {
        return;
    }
    Notification notification = mWifiNotificationHelper.createConnectedNotification(mRecommendedNetwork);
    notify(notification);
    // Remove any previous reset notification callbacks.
    mHandler.removeCallbacks(mDismissNotificationRunnable);
    mHandler.postDelayed(mDismissNotificationRunnable, TIME_TO_SHOW_CONNECTED_MILLIS);
}
#method_after
private void updateNotificationOnConnect() {
    if (!mNotificationShown) {
        return;
    }
    Notification notification = mWifiNotificationHelper.createConnectedNotification(mRecommendedNetwork, mNotificationBadgeBitmap);
    postNotification(notification);
    // Remove any previous reset notification callbacks.
    mHandler.removeCallbacks(mShowFailedToConnectNotificationRunnable);
    mHandler.postDelayed(mDismissNotificationRunnable, TIME_TO_SHOW_CONNECTED_MILLIS);
}
#end_block

#method_before
private void handleNotificationDeleted() {
    mNotificationShown = false;
    mRecommendedNetwork = null;
}
#method_after
private void handleNotificationDeleted() {
    mNotificationShown = false;
    mRecommendedNetwork = null;
    mNotificationBadgeBitmap = null;
}
#end_block

#method_before
public Notification createMainNotification(WifiConfiguration config) {
    PendingIntent optionsIntent = PendingIntent.getActivity(mContext, 0, new Intent(WifiManager.ACTION_PICK_WIFI_NETWORK), FLAG_UPDATE_CURRENT);
    Action optionsAction = new Action.Builder(null, /* icon */
    mContext.getText(com.android.internal.R.string.wifi_available_options), optionsIntent).build();
    PendingIntent connectIntent = PendingIntent.getBroadcast(mContext, 0, new Intent(WifiNotificationController.ACTION_CONNECT_TO_RECOMMENDED_NETWORK), FLAG_UPDATE_CURRENT);
    Action connectAction = new Action.Builder(null, /* icon */
    mContext.getText(com.android.internal.R.string.wifi_available_connect), connectIntent).build();
    return createNotificationBuilder(config).addAction(connectAction).addAction(optionsAction).build();
}
#method_after
Notification createMainNotification(WifiConfiguration config, Bitmap badge) {
    PendingIntent optionsIntent = PendingIntent.getActivity(mContext, 0, new Intent(WifiManager.ACTION_PICK_WIFI_NETWORK), FLAG_UPDATE_CURRENT);
    Action optionsAction = new Action.Builder(null, /* icon */
    mContext.getText(R.string.wifi_available_options), optionsIntent).build();
    PendingIntent connectIntent = PendingIntent.getBroadcast(mContext, 0, new Intent(WifiNotificationController.ACTION_CONNECT_TO_RECOMMENDED_NETWORK), FLAG_UPDATE_CURRENT);
    Action connectAction = new Action.Builder(null, /* icon */
    mContext.getText(R.string.wifi_available_connect), connectIntent).build();
    return createNotificationBuilder(config, badge).addAction(connectAction).addAction(optionsAction).build();
}
#end_block

#method_before
public Notification createConnectingNotification(WifiConfiguration config) {
    Action connecting = new Action.Builder(null, /* icon */
    mContext.getText(com.android.internal.R.string.wifi_available_connecting), null).build();
    return createNotificationBuilder(config).addAction(connecting).setProgress(0, /* max */
    0, /* progress */
    true).build();
}
#method_after
Notification createConnectingNotification(WifiConfiguration config, Bitmap badge) {
    Action connecting = new Action.Builder(null, /* icon */
    mContext.getText(R.string.wifi_available_connecting), null).build();
    return createNotificationBuilder(config, badge).addAction(connecting).setProgress(0, /* max */
    0, /* progress */
    true).build();
}
#end_block

#method_before
public Notification createConnectedNotification(WifiConfiguration config) {
    Action connected = new Action.Builder(null, /* icon */
    mContext.getText(com.android.internal.R.string.wifi_available_connected), null).build();
    return createNotificationBuilder(config).addAction(connected).build();
}
#method_after
Notification createConnectedNotification(WifiConfiguration config, Bitmap badge) {
    Action connected = new Action.Builder(null, /* icon */
    mContext.getText(R.string.wifi_available_connected), null).build();
    return createNotificationBuilder(config, badge).addAction(connected).build();
}
#end_block

#method_before
private Notification.Builder createNotificationBuilder(WifiConfiguration config) {
    CharSequence title = mContext.getText(com.android.internal.R.string.wifi_available);
    PendingIntent deleteIntent = PendingIntent.getBroadcast(mContext, 0, new Intent(WifiNotificationController.ACTION_NOTIFICATION_DELETED), FLAG_UPDATE_CURRENT);
    final Bundle extras = new Bundle();
    extras.putString(Notification.EXTRA_SUBSTITUTE_APP_NAME, mContext.getString(com.android.internal.R.string.android_system_label));
    return new Notification.Builder(mContext).setDeleteIntent(deleteIntent).setSmallIcon(com.android.internal.R.drawable.stat_notify_wifi_in_range).setAutoCancel(true).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setTicker(title).setContentTitle(title).setContentText(config.getPrintableSsid()).addExtras(extras);
}
#method_after
private Notification.Builder createNotificationBuilder(WifiConfiguration config, Bitmap badge) {
    CharSequence title = mContext.getText(R.string.wifi_available);
    PendingIntent deleteIntent = PendingIntent.getBroadcast(mContext, 0, new Intent(WifiNotificationController.ACTION_NOTIFICATION_DELETED), FLAG_UPDATE_CURRENT);
    return new Notification.Builder(mContext).setDeleteIntent(deleteIntent).setSmallIcon(com.android.internal.R.drawable.stat_notify_wifi_in_range).setLargeIcon(badge).setAutoCancel(true).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setTicker(title).setContentTitle(title).setContentText(config.getPrintableSsid()).addExtras(getSystemLabelExtras());
}
#end_block

#method_before
@Override
public String getName() {
    return mNetworkRecommendationsEnabled ? TAG : mExternalScoreEvaluator.getName();
}
#method_after
@Override
public String getName() {
    if (mNetworkRecommendationsEnabled) {
        return TAG;
    }
    return TAG + "-" + mExternalScoreEvaluator.getName();
}
#end_block

#method_before
private static long readLong(String path) {
    try (final FileInputStream fis = new FileInputStream(path);
        final BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {
        return Long.parseLong(reader.readLine());
    } catch (FileNotFoundException e) {
        // This is expected since we are trying to parse from multiple paths.
        Slog.i(TAG, "readLong(): Path doesn't exist: " + path);
        return 0;
    } catch (NumberFormatException e) {
        Slog.w(TAG, "readLong(): Could not parse " + path + ": " + e);
        return 0;
    } catch (Exception e) {
        Slog.w(TAG, "readLong(): Unknown exception while opening " + path + ": " + e);
        return 0;
    }
}
#method_after
private static long readLong(String path) {
    try (final FileInputStream fis = new FileInputStream(path);
        final BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {
        return Long.parseLong(reader.readLine());
    } catch (FileNotFoundException e) {
        // This is expected since we are trying to parse multiple paths.
        Slog.i(TAG, "readLong(): Path doesn't exist: " + path + ": " + e);
        return 0;
    } catch (NumberFormatException e) {
        Slog.e(TAG, "readLong(): Could not parse " + path + ": " + e);
        return 0;
    } catch (Exception e) {
        Slog.e(TAG, "readLong(): Unknown exception while opening " + path + ": " + e);
        return 0;
    }
}
#end_block

#method_before
@Override
public synchronized boolean setWifiEnabled(String packageName, boolean enable) throws RemoteException {
    enforceChangePermission();
    Slog.d(TAG, "setWifiEnabled: " + enable + " pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
    /*
        * Caller might not have WRITE_SECURE_SETTINGS,
        * only CHANGE_WIFI_STATE is enforced
        */
    long ident = Binder.clearCallingIdentity();
    try {
        if (!mSettingsStore.handleWifiToggled(enable)) {
            // Nothing to do if wifi cannot be toggled
            return true;
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    if (mPermissionReviewRequired) {
        final int wiFiEnabledState = getWifiEnabledState();
        if (enable) {
            if (wiFiEnabledState == WifiManager.WIFI_STATE_DISABLING || wiFiEnabledState == WifiManager.WIFI_STATE_DISABLED) {
                if (startConsentUiIfNeeded(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_ENABLE)) {
                    return true;
                }
            }
        } else if (wiFiEnabledState == WifiManager.WIFI_STATE_ENABLING || wiFiEnabledState == WifiManager.WIFI_STATE_ENABLED) {
            if (startConsentUiIfNeeded(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_DISABLE)) {
                return true;
            }
        }
    }
    mWifiController.sendMessage(CMD_WIFI_TOGGLED);
    return true;
}
#method_after
@Override
public synchronized boolean setWifiEnabled(String packageName, boolean enable) throws RemoteException {
    enforceChangePermission();
    Slog.d(TAG, "setWifiEnabled: " + enable + " pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
    /*
        * Caller might not have WRITE_SECURE_SETTINGS,
        * only CHANGE_WIFI_STATE is enforced
        */
    long ident = Binder.clearCallingIdentity();
    try {
        if (!mSettingsStore.handleWifiToggled(enable)) {
            // Nothing to do if wifi cannot be toggled
            return true;
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    if (mPermissionReviewRequired) {
        final int wiFiEnabledState = getWifiEnabledState();
        if (enable) {
            if (wiFiEnabledState == WifiManager.WIFI_STATE_DISABLING || wiFiEnabledState == WifiManager.WIFI_STATE_DISABLED) {
                if (startConsentUi(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_ENABLE)) {
                    return true;
                }
            }
        } else if (wiFiEnabledState == WifiManager.WIFI_STATE_ENABLING || wiFiEnabledState == WifiManager.WIFI_STATE_ENABLED) {
            if (startConsentUi(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_DISABLE)) {
                return true;
            }
        }
    }
    mWifiController.sendMessage(CMD_WIFI_TOGGLED);
    return true;
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump WifiService from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (args.length > 0 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0])) {
        // WifiMetrics proto bytes were requested. Dump only these.
        mWifiStateMachine.updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
    } else if (args.length > 0 && IpManager.DUMP_ARG.equals(args[0])) {
        // IpManager dump was requested. Pass it along and take no further action.
        String[] ipManagerArgs = new String[args.length - 1];
        System.arraycopy(args, 1, ipManagerArgs, 0, ipManagerArgs.length);
        mWifiStateMachine.dumpIpManager(fd, pw, ipManagerArgs);
    } else if (args.length > 0 && DUMP_ARG_SET_IPREACH_DISCONNECT.equals(args[0])) {
        if (args.length > 1) {
            if (DUMP_ARG_SET_IPREACH_DISCONNECT_ENABLED.equals(args[1])) {
                mWifiStateMachine.setIpReachabilityDisconnectEnabled(true);
            } else if (DUMP_ARG_SET_IPREACH_DISCONNECT_DISABLED.equals(args[1])) {
                mWifiStateMachine.setIpReachabilityDisconnectEnabled(false);
            }
        }
        pw.println("IPREACH_DISCONNECT state is " + mWifiStateMachine.getIpReachabilityDisconnectEnabled());
        return;
    } else {
        pw.println("Wi-Fi is " + mWifiStateMachine.syncGetWifiStateByName());
        pw.println("Stay-awake conditions: " + Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0));
        pw.println("mInIdleMode " + mInIdleMode);
        pw.println("mScanPending " + mScanPending);
        mWifiController.dump(fd, pw, args);
        mSettingsStore.dump(fd, pw, args);
        mNotificationController.dump(fd, pw, args);
        mWifiWakeupController.dump(fd, pw, args);
        mTrafficPoller.dump(fd, pw, args);
        pw.println();
        pw.println("Locks held:");
        mWifiLockManager.dump(pw);
        pw.println();
        mWifiMulticastLockManager.dump(pw);
        pw.println();
        mWifiStateMachine.dump(fd, pw, args);
        pw.println();
        mWifiBackupRestore.dump(fd, pw, args);
        pw.println();
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump WifiService from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (args.length > 0 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0])) {
        // WifiMetrics proto bytes were requested. Dump only these.
        mWifiStateMachine.updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
    } else if (args.length > 0 && IpManager.DUMP_ARG.equals(args[0])) {
        // IpManager dump was requested. Pass it along and take no further action.
        String[] ipManagerArgs = new String[args.length - 1];
        System.arraycopy(args, 1, ipManagerArgs, 0, ipManagerArgs.length);
        mWifiStateMachine.dumpIpManager(fd, pw, ipManagerArgs);
    } else if (args.length > 0 && DUMP_ARG_SET_IPREACH_DISCONNECT.equals(args[0])) {
        if (args.length > 1) {
            if (DUMP_ARG_SET_IPREACH_DISCONNECT_ENABLED.equals(args[1])) {
                mWifiStateMachine.setIpReachabilityDisconnectEnabled(true);
            } else if (DUMP_ARG_SET_IPREACH_DISCONNECT_DISABLED.equals(args[1])) {
                mWifiStateMachine.setIpReachabilityDisconnectEnabled(false);
            }
        }
        pw.println("IPREACH_DISCONNECT state is " + mWifiStateMachine.getIpReachabilityDisconnectEnabled());
        return;
    } else {
        pw.println("Wi-Fi is " + mWifiStateMachine.syncGetWifiStateByName());
        pw.println("Stay-awake conditions: " + Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0));
        pw.println("mInIdleMode " + mInIdleMode);
        pw.println("mScanPending " + mScanPending);
        mWifiController.dump(fd, pw, args);
        mSettingsStore.dump(fd, pw, args);
        mTrafficPoller.dump(fd, pw, args);
        pw.println();
        pw.println("Locks held:");
        mWifiLockManager.dump(pw);
        pw.println();
        mWifiMulticastLockManager.dump(pw);
        pw.println();
        mWifiStateMachine.dump(fd, pw, args);
        pw.println();
        mWifiBackupRestore.dump(fd, pw, args);
        pw.println();
    }
}
#end_block

#method_before
private void enableVerboseLoggingInternal(int verbose) {
    mWifiStateMachine.enableVerboseLogging(verbose);
    mWifiLockManager.enableVerboseLogging(verbose);
    mWifiMulticastLockManager.enableVerboseLogging(verbose);
    mWifiInjector.getWifiLastResortWatchdog().enableVerboseLogging(verbose);
    mWifiInjector.getWifiBackupRestore().enableVerboseLogging(verbose);
}
#method_after
void enableVerboseLoggingInternal(int verbose) {
    mWifiStateMachine.enableVerboseLogging(verbose);
    mWifiLockManager.enableVerboseLogging(verbose);
    mWifiMulticastLockManager.enableVerboseLogging(verbose);
    mWifiInjector.getWifiLastResortWatchdog().enableVerboseLogging(verbose);
    mWifiInjector.getWifiBackupRestore().enableVerboseLogging(verbose);
    LogcatLog.enableVerboseLogging(verbose);
}
#end_block

#method_before
private void grantDefaultPermissionExceptions(int userId) {
    synchronized (mService.mPackages) {
        mHandler.removeMessages(MSG_READ_DEFAULT_PERMISSION_EXCEPTIONS);
        if (mGrantExceptions == null) {
            mGrantExceptions = readDefaultPermissionExceptionsLPw();
        }
        // mGrantExceptions is null only before the first read and then
        // it serves as a cache of the default grants that should be
        // performed for every user. If there is an entry then the app
        // is on the system image and supports runtime permissions.
        Set<String> permissions = null;
        final int exceptionCount = mGrantExceptions.size();
        for (int i = 0; i < exceptionCount; i++) {
            String packageName = mGrantExceptions.keyAt(i);
            PackageParser.Package pkg = getSystemPackageLPr(packageName);
            List<DefaultPermissionGrant> permissionGrants = mGrantExceptions.valueAt(i);
            final int permissionGrantCount = permissionGrants.size();
            for (int j = 0; j < permissionGrantCount; j++) {
                DefaultPermissionGrant permissionGrant = permissionGrants.get(j);
                if (permissions == null) {
                    permissions = new ArraySet<>();
                } else {
                    permissions.clear();
                }
                permissions.add(permissionGrant.name);
                grantRuntimePermissionsLPw(pkg, permissions, permissionGrant.fixed, false, userId);
            }
        }
    }
}
#method_after
private void grantDefaultPermissionExceptions(int userId) {
    synchronized (mService.mPackages) {
        mHandler.removeMessages(MSG_READ_DEFAULT_PERMISSION_EXCEPTIONS);
        if (mGrantExceptions == null) {
            mGrantExceptions = readDefaultPermissionExceptionsLPw();
        }
        // mGrantExceptions is null only before the first read and then
        // it serves as a cache of the default grants that should be
        // performed for every user. If there is an entry then the app
        // is on the system image and supports runtime permissions.
        Set<String> permissions = null;
        final int exceptionCount = mGrantExceptions.size();
        for (int i = 0; i < exceptionCount; i++) {
            String packageName = mGrantExceptions.keyAt(i);
            PackageParser.Package pkg = getSystemPackageLPr(packageName);
            List<DefaultPermissionGrant> permissionGrants = mGrantExceptions.valueAt(i);
            final int permissionGrantCount = permissionGrants.size();
            for (int j = 0; j < permissionGrantCount; j++) {
                DefaultPermissionGrant permissionGrant = permissionGrants.get(j);
                if (permissions == null) {
                    permissions = new ArraySet<>();
                } else {
                    permissions.clear();
                }
                permissions.add(permissionGrant.name);
                grantRuntimePermissionsLPw(pkg, permissions, permissionGrant.fixed, userId);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onCreate() {
    mHandlerThread = new HandlerThread("RecommendationProvider");
    mHandlerThread.start();
    mHandler = new Handler(mHandlerThread.getLooper());
    mProvider = new DefaultNetworkRecommendationProvider(mHandler, (NetworkScoreManager) getSystemService(Context.NETWORK_SCORE_SERVICE), new DefaultNetworkRecommendationProvider.ScoreStorage());
    mWifiWakeupController = new WifiWakeupController(this, getContentResolver(), mHandlerThread.getLooper());
}
#method_after
@Override
public void onCreate() {
    mHandlerThread = new HandlerThread("RecommendationProvider");
    mHandlerThread.start();
    mHandler = new Handler(mHandlerThread.getLooper());
    mProvider = new DefaultNetworkRecommendationProvider(mHandler, (NetworkScoreManager) getSystemService(Context.NETWORK_SCORE_SERVICE), new DefaultNetworkRecommendationProvider.ScoreStorage());
    mWifiNotificationController = new WifiNotificationController(this, mHandler.getLooper(), null);
    mWifiWakeupController = new WifiWakeupController(this, getContentResolver(), mHandlerThread.getLooper());
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mProvider.dump(fd, writer, args);
    mWifiWakeupController.dump(fd, writer, args);
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mProvider.dump(fd, writer, args);
    mWifiNotificationController.dump(fd, writer, args);
    mWifiWakeupController.dump(fd, writer, args);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mContentResolver = InstrumentationRegistry.getTargetContext().getContentResolver();
    mWifiWakeupEnabledOriginalValue = Settings.Global.getInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED);
    Settings.Global.putInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 1);
    mWifiWakeupController = new WifiWakeupController(mContext, mContentResolver, Looper.getMainLooper());
    mWifiWakeupController.start();
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mContentResolver = InstrumentationRegistry.getTargetContext().getContentResolver();
    mWifiWakeupEnabledOriginalValue = Settings.Global.getInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 0);
    Settings.Global.putInt(mContentResolver, Settings.Global.WIFI_WAKEUP_ENABLED, 1);
    mWifiWakeupController = new WifiWakeupController(mContext, mContentResolver, Looper.getMainLooper());
    mWifiWakeupController.start();
}
#end_block

#method_before
@Test
public void testEvaluateNetworks_recommendation_onlyTrustedNetworkAllowed() {
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(new RecommendationResult(TRUSTED_WIFI_CONFIGURATION));
    when(mWifiConfigManager.addOrUpdateNetwork(TRUSTED_WIFI_CONFIGURATION, Process.WIFI_UID)).thenReturn(new NetworkUpdateResult(TRUSTED_WIFI_CONFIGURATION.networkId));
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, false, /* untrustedNetworkAllowed */
    null);
    assertEquals(TRUSTED_WIFI_CONFIGURATION, result);
    verify(mNetworkScoreManager).requestRecommendation(mRecommendationRequestCaptor.capture());
    assertEquals(1, mRecommendationRequestCaptor.getValue().getScanResults().length);
    assertEquals(TRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[0]);
    verify(mWifiConfigManager).setNetworkCandidateScanResult(TRUSTED_WIFI_CONFIGURATION.networkId, TRUSTED_SCAN_DETAIL.getScanResult(), 0);
}
#method_after
@Test
public void testEvaluateNetworks_recommendation_onlyTrustedNetworkAllowed() {
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createConnectRecommendation(TRUSTED_WIFI_CONFIGURATION));
    when(mWifiConfigManager.addOrUpdateNetwork(TRUSTED_WIFI_CONFIGURATION, Process.WIFI_UID)).thenReturn(new NetworkUpdateResult(TRUSTED_WIFI_CONFIGURATION.networkId));
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, false, /* untrustedNetworkAllowed */
    null);
    assertEquals(TRUSTED_WIFI_CONFIGURATION, result);
    verify(mNetworkScoreManager).requestRecommendation(mRecommendationRequestCaptor.capture());
    assertEquals(1, mRecommendationRequestCaptor.getValue().getScanResults().length);
    assertEquals(TRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[0]);
    verify(mWifiConfigManager).setNetworkCandidateScanResult(TRUSTED_WIFI_CONFIGURATION.networkId, TRUSTED_SCAN_DETAIL.getScanResult(), 0);
}
#end_block

#method_before
@Test
public void testEvaluateNetworks_trustedRecommendation_untrustedNetworksAllowed() {
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(new RecommendationResult(TRUSTED_WIFI_CONFIGURATION));
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, true, /* untrustedNetworkAllowed */
    null);
    assertEquals(TRUSTED_WIFI_CONFIGURATION, result);
    verify(mNetworkScoreManager).requestRecommendation(mRecommendationRequestCaptor.capture());
    assertEquals(2, mRecommendationRequestCaptor.getValue().getScanResults().length);
    assertEquals(TRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[0]);
    assertEquals(UNTRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[1]);
    verify(mWifiConfigManager).setNetworkCandidateScanResult(TRUSTED_WIFI_CONFIGURATION.networkId, TRUSTED_SCAN_DETAIL.getScanResult(), 0);
}
#method_after
@Test
public void testEvaluateNetworks_trustedRecommendation_untrustedNetworksAllowed() {
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createConnectRecommendation(TRUSTED_WIFI_CONFIGURATION));
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, true, /* untrustedNetworkAllowed */
    null);
    assertEquals(TRUSTED_WIFI_CONFIGURATION, result);
    verify(mNetworkScoreManager).requestRecommendation(mRecommendationRequestCaptor.capture());
    assertEquals(2, mRecommendationRequestCaptor.getValue().getScanResults().length);
    assertEquals(TRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[0]);
    assertEquals(UNTRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[1]);
    verify(mWifiConfigManager).setNetworkCandidateScanResult(TRUSTED_WIFI_CONFIGURATION.networkId, TRUSTED_SCAN_DETAIL.getScanResult(), 0);
}
#end_block

#method_before
@Test
public void testEvaluateNetworks_untrustedRecommendation_untrustedNetworksAllowed() {
    NetworkUpdateResult networkUpdateResult = new NetworkUpdateResult(10);
    when(mWifiConfigManager.addOrUpdateNetwork(UNTRUSTED_WIFI_CONFIGURATION, Process.WIFI_UID)).thenReturn(networkUpdateResult);
    when(mWifiConfigManager.getConfiguredNetwork(networkUpdateResult.getNetworkId())).thenReturn(UNTRUSTED_WIFI_CONFIGURATION);
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(new RecommendationResult(UNTRUSTED_WIFI_CONFIGURATION));
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, true, /* untrustedNetworkAllowed */
    null);
    assertEquals(UNTRUSTED_WIFI_CONFIGURATION, result);
    verify(mNetworkScoreManager).requestRecommendation(mRecommendationRequestCaptor.capture());
    assertEquals(2, mRecommendationRequestCaptor.getValue().getScanResults().length);
    assertEquals(TRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[0]);
    assertEquals(UNTRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[1]);
    verify(mWifiConfigManager).setNetworkCandidateScanResult(networkUpdateResult.getNetworkId(), UNTRUSTED_SCAN_DETAIL.getScanResult(), 0);
}
#method_after
@Test
public void testEvaluateNetworks_untrustedRecommendation_untrustedNetworksAllowed() {
    NetworkUpdateResult networkUpdateResult = new NetworkUpdateResult(10);
    when(mWifiConfigManager.addOrUpdateNetwork(UNTRUSTED_WIFI_CONFIGURATION, Process.WIFI_UID)).thenReturn(networkUpdateResult);
    when(mWifiConfigManager.getConfiguredNetwork(networkUpdateResult.getNetworkId())).thenReturn(UNTRUSTED_WIFI_CONFIGURATION);
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createConnectRecommendation(UNTRUSTED_WIFI_CONFIGURATION));
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, true, /* untrustedNetworkAllowed */
    null);
    assertEquals(UNTRUSTED_WIFI_CONFIGURATION, result);
    verify(mNetworkScoreManager).requestRecommendation(mRecommendationRequestCaptor.capture());
    assertEquals(2, mRecommendationRequestCaptor.getValue().getScanResults().length);
    assertEquals(TRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[0]);
    assertEquals(UNTRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[1]);
    verify(mWifiConfigManager).setNetworkCandidateScanResult(networkUpdateResult.getNetworkId(), UNTRUSTED_SCAN_DETAIL.getScanResult(), 0);
}
#end_block

#method_before
@Test
public void testEvaluateNetworks_untrustedRecommendation_updateFailed() {
    NetworkUpdateResult networkUpdateResult = new NetworkUpdateResult(WifiConfiguration.INVALID_NETWORK_ID);
    when(mWifiConfigManager.addOrUpdateNetwork(UNTRUSTED_WIFI_CONFIGURATION, Process.WIFI_UID)).thenReturn(networkUpdateResult);
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(new RecommendationResult(UNTRUSTED_WIFI_CONFIGURATION));
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, true, /* untrustedNetworkAllowed */
    null);
    assertNull(result);
    verify(mNetworkScoreManager).requestRecommendation(mRecommendationRequestCaptor.capture());
    assertEquals(2, mRecommendationRequestCaptor.getValue().getScanResults().length);
    assertEquals(TRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[0]);
    assertEquals(UNTRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[1]);
    verify(mWifiConfigManager).setNetworkCandidateScanResult(UNTRUSTED_WIFI_CONFIGURATION.networkId, UNTRUSTED_SCAN_DETAIL.getScanResult(), 0);
}
#method_after
@Test
public void testEvaluateNetworks_untrustedRecommendation_updateFailed() {
    NetworkUpdateResult networkUpdateResult = new NetworkUpdateResult(WifiConfiguration.INVALID_NETWORK_ID);
    when(mWifiConfigManager.addOrUpdateNetwork(UNTRUSTED_WIFI_CONFIGURATION, Process.WIFI_UID)).thenReturn(networkUpdateResult);
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(RecommendationResult.createConnectRecommendation(UNTRUSTED_WIFI_CONFIGURATION));
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, true, /* untrustedNetworkAllowed */
    null);
    assertNull(result);
    verify(mNetworkScoreManager).requestRecommendation(mRecommendationRequestCaptor.capture());
    assertEquals(2, mRecommendationRequestCaptor.getValue().getScanResults().length);
    assertEquals(TRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[0]);
    assertEquals(UNTRUSTED_SCAN_DETAIL.getScanResult(), mRecommendationRequestCaptor.getValue().getScanResults()[1]);
    verify(mWifiConfigManager, never()).setNetworkCandidateScanResult(anyInt(), any(ScanResult.class), anyInt());
}
#end_block

#method_before
@Override
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    List<ScanResult> scanResults = new ArrayList<>();
    for (int i = 0; i < scanDetails.size(); i++) {
        ScanDetail scanDetail = scanDetails.get(i);
        ScanResult scanResult = scanDetail.getScanResult();
        if (mWifiConfigManager.wasEphemeralNetworkDeleted(ScanResultUtil.createQuotedSSID(scanResult.SSID))) {
            continue;
        }
        scanResult.untrusted = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail) == null;
        if (!untrustedNetworkAllowed && scanResult.untrusted) {
            continue;
        }
        scanResults.add(scanResult);
    }
    if (scanResults.isEmpty()) {
        return null;
    }
    ScanResult[] scanResultArray = scanResults.toArray(new ScanResult[scanResults.size()]);
    RecommendationRequest request = new RecommendationRequest.Builder().setScanResults(scanResultArray).build();
    RecommendationResult result = mNetworkScoreManager.requestRecommendation(request);
    if (result == null || result.getWifiConfiguration() == null) {
        return null;
    }
    WifiConfiguration wifiConfiguration = result.getWifiConfiguration();
    ScanResult scanResult = findMatchingScanResult(scanResultArray, wifiConfiguration);
    if (scanResult == null) {
        mLocalLog.log("Could not match WifiConfiguration to a ScanResult.");
        return null;
    }
    final int networkId = wifiConfiguration.networkId == WifiConfiguration.INVALID_NETWORK_ID ? addEphemeralNetwork(wifiConfiguration, scanResult) : wifiConfiguration.networkId;
    mWifiConfigManager.setNetworkCandidateScanResult(networkId, scanResult, 0);
    return mWifiConfigManager.getConfiguredNetwork(networkId);
}
#method_after
@Override
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    List<ScanResult> scanResults = new ArrayList<>();
    for (int i = 0; i < scanDetails.size(); i++) {
        ScanDetail scanDetail = scanDetails.get(i);
        ScanResult scanResult = scanDetail.getScanResult();
        if (mWifiConfigManager.wasEphemeralNetworkDeleted(ScanResultUtil.createQuotedSSID(scanResult.SSID))) {
            continue;
        }
        scanResult.untrusted = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail) == null;
        if (!untrustedNetworkAllowed && scanResult.untrusted) {
            continue;
        }
        scanResults.add(scanResult);
    }
    if (scanResults.isEmpty()) {
        return null;
    }
    ScanResult[] scanResultArray = scanResults.toArray(new ScanResult[scanResults.size()]);
    RecommendationRequest request = new RecommendationRequest.Builder().setScanResults(scanResultArray).build();
    RecommendationResult result = mNetworkScoreManager.requestRecommendation(request);
    if (result == null || result.getWifiConfiguration() == null) {
        return null;
    }
    WifiConfiguration wifiConfiguration = result.getWifiConfiguration();
    ScanResult scanResult = findMatchingScanResult(scanResultArray, wifiConfiguration);
    if (scanResult == null) {
        Slog.e(TAG, "Could not match WifiConfiguration to a ScanResult.");
        return null;
    }
    int networkId = wifiConfiguration.networkId;
    if (networkId == WifiConfiguration.INVALID_NETWORK_ID) {
        networkId = addEphemeralNetwork(wifiConfiguration, scanResult);
        if (networkId == WifiConfiguration.INVALID_NETWORK_ID) {
            return null;
        }
    }
    mWifiConfigManager.setNetworkCandidateScanResult(networkId, scanResult, 0);
    return mWifiConfigManager.getConfiguredNetwork(networkId);
}
#end_block

#method_before
private ScanResult findMatchingScanResult(ScanResult[] scanResults, WifiConfiguration wifiConfiguration) {
    String ssid = ScanResultUtil.getUnquotedSSID(wifiConfiguration);
    String bssid = wifiConfiguration.BSSID;
    for (int i = 0; i < scanResults.length; i++) {
        if (ssid.equals(scanResults[i].SSID) && bssid.equals(scanResults[i].BSSID)) {
            return scanResults[i];
        }
    }
    return null;
}
#method_after
private ScanResult findMatchingScanResult(ScanResult[] scanResults, WifiConfiguration wifiConfiguration) {
    String ssid = WifiInfo.removeDoubleQuotes(wifiConfiguration.SSID);
    String bssid = wifiConfiguration.BSSID;
    for (int i = 0; i < scanResults.length; i++) {
        if (ssid.equals(scanResults[i].SSID) && bssid.equals(scanResults[i].BSSID)) {
            return scanResults[i];
        }
    }
    return null;
}
#end_block

#method_before
@Override
public String getName() {
    return "RecommendedNetworkEvaluator";
}
#method_after
@Override
public String getName() {
    return TAG;
}
#end_block

#method_before
public static ZygoteProcess getProcess() {
    synchronized (sLock) {
        connectToZygoteIfNeeded();
        return sZygote;
    }
}
#method_after
public static ZygoteProcess getProcess() {
    synchronized (sLock) {
        connectToZygoteIfNeededLocked();
        return sZygote;
    }
}
#end_block

#method_before
public static void setMultiprocessEnabled(boolean enabled) {
    synchronized (sLock) {
        sMultiprocessEnabled = enabled;
        // When toggling between multi-process being on/off, start or stop the
        // service. If it is enabled and the zygote is not yet started, bring up the service.
        // Otherwise, bring down the service. The name may be null if the package
        // information has not yet been resolved.
        final String serviceName = getServiceName();
        if (serviceName == null)
            return;
        if (enabled && sZygote == null) {
            SystemService.start(serviceName);
        } else {
            SystemService.stop(serviceName);
            sZygote = null;
        }
    }
}
#method_after
public static void setMultiprocessEnabled(boolean enabled) {
    synchronized (sLock) {
        sMultiprocessEnabled = enabled;
        // When toggling between multi-process being on/off, start or stop the
        // service. If it is enabled and the zygote is not yet started, bring up the service.
        // Otherwise, bring down the service. The name may be null if the package
        // information has not yet been resolved.
        final String serviceName = getServiceNameLocked();
        if (serviceName == null)
            return;
        if (enabled && sZygote == null) {
            SystemService.start(serviceName);
        } else {
            SystemService.stop(serviceName);
            sZygote = null;
        }
    }
}
#end_block

#method_before
public static void onWebViewProviderChanged(PackageInfo packageInfo) {
    String serviceName;
    synchronized (sLock) {
        sPackage = packageInfo;
        // If multi-process is not enabled, then do not start the zygote service.
        if (!sMultiprocessEnabled) {
            return;
        }
        serviceName = getServiceName();
        sZygote = null;
    }
    // so connectToZygoteIfNeeded() may still fail.
    if (SystemService.isStopped(serviceName)) {
        SystemService.start(serviceName);
    } else {
        SystemService.restart(serviceName);
    }
    try {
        SystemService.waitForState(serviceName, SystemService.State.RUNNING, 5000);
    } catch (TimeoutException e) {
        Log.e(LOGTAG, "Timed out waiting for " + serviceName);
        return;
    }
    synchronized (sLock) {
        connectToZygoteIfNeeded();
    }
}
#method_after
public static void onWebViewProviderChanged(PackageInfo packageInfo) {
    String serviceName;
    synchronized (sLock) {
        sPackage = packageInfo;
        // If multi-process is not enabled, then do not start the zygote service.
        if (!sMultiprocessEnabled) {
            return;
        }
        serviceName = getServiceNameLocked();
        sZygote = null;
        // so connectToZygoteIfNeededLocked() may still fail.
        if (SystemService.isStopped(serviceName)) {
            SystemService.start(serviceName);
        } else {
            SystemService.restart(serviceName);
        }
        try {
            SystemService.waitForState(serviceName, SystemService.State.RUNNING, 5000);
        } catch (TimeoutException e) {
            Log.e(LOGTAG, "Timed out waiting for " + serviceName);
            return;
        }
        connectToZygoteIfNeededLocked();
    }
}
#end_block

