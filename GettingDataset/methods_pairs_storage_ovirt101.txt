499
#method_before
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    if (getEntity() != null) {
        StorageDomain storageDomain = (StorageDomain) getEntity();
        setIsNfs(storageDomain.getStorageType() == StorageType.NFS);
        setIsLocalS(storageDomain.getStorageType() == StorageType.LOCALFS);
        setIsPosix(storageDomain.getStorageType() == StorageType.POSIXFS);
        if (getIsNfs() || getIsLocalS() || getIsPosix()) {
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    StorageServerConnections connection = (StorageServerConnections) ReturnValue;
                    StorageGeneralModel generalModel = (StorageGeneralModel) model;
                    generalModel.setPath(connection == null ? null : connection.getconnection());
                    if (isNfs) {
                        EnumTranslator translator = EnumTranslator.getInstance();
                        generalModel.setNfsVersion(translator.translate(connection.getNfsVersion()));
                        generalModel.setRetransmissions(connection.getNfsRetrans());
                        generalModel.setTimeout(connection.getNfsTimeo());
                    }
                    if (isPosix) {
                        generalModel.setVfsType(connection.getVfsType());
                        generalModel.setMountOptions(connection.getMountOptions());
                    }
                }
            };
            AsyncDataProvider.getInstance().getStorageConnectionById(_asyncQuery, storageDomain.getStorage(), true);
        } else {
            setPath(null);
        }
    }
}
#method_after
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    if (getEntity() != null) {
        StorageDomain storageDomain = (StorageDomain) getEntity();
        setIsNfs(storageDomain.getStorageType() == StorageType.NFS);
        setIsLocalS(storageDomain.getStorageType() == StorageType.LOCALFS);
        setIsPosix(storageDomain.getStorageType() == StorageType.POSIXFS);
        if (getIsNfs() || getIsLocalS() || getIsPosix()) {
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    StorageServerConnections connection = (StorageServerConnections) returnValue;
                    StorageGeneralModel generalModel = (StorageGeneralModel) model;
                    if (connection != null) {
                        generalModel.setPath(connection.getConnection());
                        if (isNfs) {
                            EnumTranslator translator = EnumTranslator.getInstance();
                            generalModel.setNfsVersion(translator.translate(connection.getNfsVersion()));
                            generalModel.setRetransmissions(connection.getNfsRetrans());
                            generalModel.setTimeout(connection.getNfsTimeo());
                        }
                        if (isPosix) {
                            generalModel.setVfsType(connection.getVfsType());
                            generalModel.setMountOptions(connection.getMountOptions());
                        }
                    } else {
                        generalModel.setPath(null);
                    }
                }
            };
            AsyncDataProvider.getInstance().getStorageConnectionById(_asyncQuery, storageDomain.getStorage(), true);
        } else {
            setPath(null);
        }
    }
}
#end_block

#method_before
private List<VM> getMigratableVmsRunningOnVds(final VmDao vmDao, final Guid hostId) {
    List<VM> vmsFromDB = vmDao.getAllRunningForVds(hostId);
    return vmsFromDB.stream().filter(v -> v.getMigrationSupport() == MigrationSupport.MIGRATABLE && // must not be pinned to the host
    !v.getDedicatedVmForVdsList().contains(hostId)).collect(Collectors.toList());
}
#method_after
private List<VM> getMigratableVmsRunningOnVds(final VmDao vmDao, final Guid hostId) {
    List<VM> vmsFromDB = vmDao.getAllRunningForVds(hostId);
    return vmsFromDB.stream().filter(vm -> vm.getMigrationSupport() == MigrationSupport.MIGRATABLE && // must not be pinned to the host
    !vm.getDedicatedVmForVdsList().contains(hostId)).collect(Collectors.toList());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            // remove the server from resource manager and add it back
            initializeVds();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDao().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, getVdsId(), interfaceDao.getAllInterfacesForVds(getVdsId()), new CustomPropertiesForVdsNetworkInterface(), Collections.<NetworkAttachment>emptyList(), getTargetClusterNetworks());
    persister.persistNetworkAttachments();
    if (targetClusterSupportsSetupNetworks() && !VDSStatus.PendingApproval.equals(getVds().getStatus())) {
        configureNetworks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            // remove the server from resource manager and add it back
            initializeVds();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDao().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, getVdsId(), interfaceDao.getAllInterfacesForVds(getVdsId()), new CustomPropertiesForVdsNetworkInterface(), Collections.<NetworkAttachment>emptyList(), getTargetClusterNetworks());
    persister.persistNetworkAttachments();
    if (targetClusterSupportsSetupNetworks() && VDSStatus.PendingApproval != getVds().getStatus()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public SortedMap<String, List<DataCenterWithCluster>> getGroupedList(List<DataCenterWithCluster> acceptableValues) {
            SortedMap<String, List<DataCenterWithCluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterWithClusterComparator());
            String currentDataCenter = null;
            List<DataCenterWithCluster> currentClusterWithDcList = null;
            for (DataCenterWithCluster clusterWithDc : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(clusterWithDc.getDataCenter().getName())) {
                    currentClusterWithDcList = new ArrayList<>();
                    currentDataCenter = clusterWithDc.getDataCenter().getName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterWithDcList);
                    }
                }
                if (currentClusterWithDcList != null) {
                    currentClusterWithDcList.add(clusterWithDc);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    EnableableFormLabel label = new EnableableFormLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<ConsoleDisconnectAction>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    defaultHostEditor.asListBox().setVisibleItemCount(3);
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<NumaTuneMode>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    providersEditor.setLabel(constants.providerLabel());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public SortedMap<String, List<DataCenterWithCluster>> getGroupedList(List<DataCenterWithCluster> acceptableValues) {
            SortedMap<String, List<DataCenterWithCluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterWithClusterComparator());
            String currentDataCenter = null;
            List<DataCenterWithCluster> currentClusterWithDcList = null;
            for (DataCenterWithCluster clusterWithDc : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(clusterWithDc.getDataCenter().getName())) {
                    currentClusterWithDcList = new ArrayList<>();
                    currentDataCenter = clusterWithDc.getDataCenter().getName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterWithDcList);
                    }
                }
                if (currentClusterWithDcList != null) {
                    currentClusterWithDcList.add(clusterWithDc);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    threadsPerCoreEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    threadsPerCoreEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(threadsPerCoreEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    EnableableFormLabel label = new EnableableFormLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    defaultHostEditor.asListBox().setVisibleItemCount(3);
    migrationModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    providersEditor.setLabel(constants.providerLabel());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getCompatibilityVersion() != null) {
                boolean enabled = AsyncDataProvider.getInstance().isSerialNumberPolicySupported(vdsGroup.getCompatibilityVersion().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getCompatibilityVersion() != null) {
                boolean enabled = AsyncDataProvider.getInstance().isSerialNumberPolicySupported(vdsGroup.getCompatibilityVersion().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        }
    });
}
#end_block

#method_before
private ArrayList<String> getDisksAliasesByImageStatus(List<DiskModel> disks, ImageStatus status) {
    ArrayList<String> disksAliases = new ArrayList<String>();
    if (disks == null) {
        return disksAliases;
    }
    for (DiskModel diskModel : disks) {
        Disk disk = diskModel.getDisk();
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == status) {
            disksAliases.add(disk.getDiskAlias());
        }
    }
    return disksAliases;
}
#method_after
private ArrayList<String> getDisksAliasesByImageStatus(List<DiskModel> disks, ImageStatus status) {
    ArrayList<String> disksAliases = new ArrayList<>();
    if (disks == null) {
        return disksAliases;
    }
    for (DiskModel diskModel : disks) {
        Disk disk = diskModel.getDisk();
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == status) {
            disksAliases.add(disk.getDiskAlias());
        }
    }
    return disksAliases;
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
protected List<Widget> consoleTabWidgets() {
    return Arrays.<Widget>asList(displayTypeEditor, graphicsTypeEditor, usbSupportEditor, consoleDisconnectActionEditor, isSmartcardEnabledEditor, nativeUsbWarningMessage, expander, numOfMonitorsEditor, vncKeyboardLayoutEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent);
}
#method_after
protected List<Widget> consoleTabWidgets() {
    return Arrays.asList(displayTypeEditor, graphicsTypeEditor, usbSupportEditor, consoleDisconnectActionEditor, isSmartcardEnabledEditor, nativeUsbWarningMessage, expander, numOfMonitorsEditor, vncKeyboardLayoutEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent);
}
#end_block

#method_before
protected List<Widget> poolSpecificFields() {
    return Arrays.<Widget>asList(numOfVmsEditor, newPoolEditVmsPanel, editPoolEditVmsPanel, editPoolIncraseNumOfVmsPanel, poolTab, prestartedVmsEditor, poolNameIcon, newPoolEditMaxAssignedVmsPerUserPanel, editPoolEditMaxAssignedVmsPerUserPanel, spiceProxyEditor, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyOverrideEnabledEditor);
}
#method_after
protected List<Widget> poolSpecificFields() {
    return Arrays.asList(numOfVmsEditor, newPoolEditVmsPanel, editPoolEditVmsPanel, editPoolIncraseNumOfVmsPanel, poolTab, prestartedVmsEditor, poolNameIcon, newPoolEditMaxAssignedVmsPerUserPanel, editPoolEditMaxAssignedVmsPerUserPanel, spiceProxyEditor, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyOverrideEnabledEditor);
}
#end_block

#method_before
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, ioThreadsLabel, detachableMemSizeEditor, detachableInstanceTypesEditor, overrideMigrationDowntimeEditorWithDetachable);
}
#method_after
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, threadsPerCoreEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, ioThreadsLabel, detachableMemSizeEditor, detachableInstanceTypesEditor, overrideMigrationDowntimeEditorWithDetachable);
}
#end_block

#method_before
protected List<Widget> adminOnlyWidgets() {
    return Arrays.<Widget>asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, consoleDisconnectActionEditor, monitors, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#method_after
protected List<Widget> adminOnlyWidgets() {
    return Arrays.asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, consoleDisconnectActionEditor, monitors, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#end_block

#method_before
public List<HasValidation> getInvalidWidgets() {
    List<HasValidation> hasValidations = new ArrayList<HasValidation>();
    for (DialogTab dialogTab : allDialogTabs()) {
        hasValidations.addAll(dialogTab.getInvalidWidgets());
    }
    return hasValidations;
}
#method_after
public List<HasValidation> getInvalidWidgets() {
    List<HasValidation> hasValidations = new ArrayList<>();
    for (DialogTab dialogTab : allDialogTabs()) {
        hasValidations.addAll(dialogTab.getInvalidWidgets());
    }
    return hasValidations;
}
#end_block

#method_before
protected VDS selectBestProxy(FenceProxySourceType fenceProxySource, Guid excludedHostId) {
    return getDbFacade().getVdsDao().getAll().stream().filter(vds -> !vds.getId().equals(fencedHost.getId()) && !isHostExcluded(vds, excludedHostId) && isHostFromSelectedSource(vds, fenceProxySource) && areAgentsVersionCompatible(vds) && isFencingPolicySupported(vds, getMinSupportedVersionForFencingPolicy()) && !isHostNetworkUnreachable(vds)).sorted((x, y) -> (x.getStatus() == VDSStatus.Up ? -1 : y.getStatus() == VDSStatus.Up ? 1 : 0)).findFirst().orElse(null);
}
#method_after
protected VDS selectBestProxy(FenceProxySourceType fenceProxySource, Guid excludedHostId) {
    return getDbFacade().getVdsDao().getAll().stream().peek(vds -> log.debug("Evaluating host '{}'", vds.getHostName())).filter(vds -> !Objects.equals(vds.getId(), fencedHost.getId())).filter(vds -> !isHostExcluded(vds, excludedHostId)).filter(vds -> isHostFromSelectedSource(vds, fenceProxySource)).filter(this::areAgentsVersionCompatible).filter(vds -> isFencingPolicySupported(vds, getMinSupportedVersionForFencingPolicy())).filter(vds -> !isHostNetworkUnreachable(vds)).sorted(Comparator.comparingInt(vds -> vds.getStatus() == VDSStatus.Up ? -1 : 1)).findFirst().orElse(null);
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (shouldOverrideSoundDevice()) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (shouldOverrideSoundDevice()) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#end_block

#method_before
protected void setDefaultMigrationPolicy() {
    if (getVdsGroup() != null) {
        boolean isMigrationSupported = FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion());
        MigrationSupport migrationSupport = isMigrationSupported ? MigrationSupport.MIGRATABLE : MigrationSupport.PINNED_TO_HOST;
        getParameters().getVmStaticData().setMigrationSupport(migrationSupport);
    }
}
#method_after
protected void setDefaultMigrationPolicy() {
    if (getVdsGroup() != null) {
        boolean isMigrationSupported = FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getEffectiveCompatibilityVersion());
        MigrationSupport migrationSupport = isMigrationSupported ? MigrationSupport.MIGRATABLE : MigrationSupport.PINNED_TO_HOST;
        getParameters().getVmStaticData().setMigrationSupport(migrationSupport);
    }
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getVdsGroup().getCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci()) {
        return true;
    }
    return (VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion()));
}
#method_after
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci()) {
        return true;
    }
    return (VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion()));
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, int threadsPerCpu, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket * threadsPerCpu) > Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && threadsPerCpu > Config.<Integer>getValue(ConfigValues.MaxNumOfThreadsPerCpu, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && threadsPerCpu < 1) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_THREADS_PER_CPU.toString());
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isExternalVM() && getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getParameters().getVmStaticData().getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    ArrayList<String> errorMessages = new ArrayList<>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmNumaNodes();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    addGraphicsDevice();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.error("Failed to add vm . The reasons are: {}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    ArrayList<String> errorMessages = new ArrayList<>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmNumaNodes();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                addVmRngDevice();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    addGraphicsDevice();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.error("Failed to add vm . The reasons are: {}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    setIconIds(vmStatic);
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVdsGroup().getCompatibilityVersion(), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    setIconIds(vmStatic);
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getEffectiveCompatibilityVersion(), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getVdsGroup().getCompatibilityVersion(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion()) && isOsSupportedForVirtIoScsi;
}
#method_after
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion()) && isOsSupportedForVirtIoScsi;
}
#end_block

#method_before
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion());
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion());
}
#end_block

#method_before
protected void autoSelectGraphicsDevice() {
    if (// if not set by user in params
    getParameters().getGraphicsDevices().isEmpty() && getVdsGroup() != null) {
        // and VdsGroup is known
        DisplayType defaultDisplayType = getParameters().getVmStaticData().getDefaultDisplayType();
        int osId = getParameters().getVmStaticData().getOsId();
        Version clusterVersion = getVdsGroup().getCompatibilityVersion();
        List<GraphicsType> templateGraphics = VmDeviceUtils.getGraphicsTypesOfEntity(vmDevicesSourceId);
        // otherwise choose the first supported graphics device
        if (!VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, templateGraphics, defaultDisplayType)) {
            GraphicsType defaultGraphicsType = null;
            List<Pair<GraphicsType, DisplayType>> pairs = osRepository.getGraphicsAndDisplays(osId, clusterVersion);
            for (Pair<GraphicsType, DisplayType> pair : pairs) {
                if (pair.getSecond().equals(defaultDisplayType)) {
                    defaultGraphicsType = pair.getFirst();
                    break;
                }
            }
            if (defaultGraphicsType != null) {
                for (GraphicsType graphicsType : GraphicsType.values()) {
                    // reset graphics devices
                    getParameters().getGraphicsDevices().put(graphicsType, null);
                }
                VmDeviceType vmDisplayType = defaultGraphicsType.getCorrespondingDeviceType();
                GraphicsDevice defaultGraphicsDevice = new GraphicsDevice(vmDisplayType);
                getParameters().getGraphicsDevices().put(defaultGraphicsType, defaultGraphicsDevice);
            }
        }
    }
}
#method_after
protected void autoSelectGraphicsDevice() {
    if (// if not set by user in params
    getParameters().getGraphicsDevices().isEmpty() && getVdsGroup() != null) {
        // and VdsGroup is known
        DisplayType defaultDisplayType = getParameters().getVmStaticData().getDefaultDisplayType();
        int osId = getParameters().getVmStaticData().getOsId();
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        List<GraphicsType> templateGraphics = VmDeviceUtils.getGraphicsTypesOfEntity(vmDevicesSourceId);
        // otherwise choose the first supported graphics device
        if (!VmValidationUtils.isGraphicsAndDisplaySupported(osId, compatibilityVersion, templateGraphics, defaultDisplayType)) {
            GraphicsType defaultGraphicsType = null;
            List<Pair<GraphicsType, DisplayType>> pairs = osRepository.getGraphicsAndDisplays(osId, compatibilityVersion);
            for (Pair<GraphicsType, DisplayType> pair : pairs) {
                if (pair.getSecond().equals(defaultDisplayType)) {
                    defaultGraphicsType = pair.getFirst();
                    break;
                }
            }
            if (defaultGraphicsType != null) {
                for (GraphicsType graphicsType : GraphicsType.values()) {
                    // reset graphics devices
                    getParameters().getGraphicsDevices().put(graphicsType, null);
                }
                VmDeviceType vmDisplayType = defaultGraphicsType.getCorrespondingDeviceType();
                GraphicsDevice defaultGraphicsDevice = new GraphicsDevice(vmDisplayType);
                getParameters().getGraphicsDevices().put(defaultGraphicsType, defaultGraphicsDevice);
            }
        }
    }
}
#end_block

#method_before
public ValidationResult vmNotHavingPciPassthroughDevices() {
    for (VM vm : vms) {
        if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES, String.format("$VmName %s", vm.getName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vmNotHavingPciPassthroughDevices() {
    for (VM vm : vms) {
        if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public void generate(Model model) {
    for (Type type : model.getTypes()) {
        // StatisticUnit, ValueType.
        if (type instanceof EnumType && !SchemaGenerator.isSchemaEnum(type)) {
            EnumType enumType = (EnumType) type;
            generateEnum(enumType);
        }
    }
}
#method_after
public void generate(Model model) {
    for (Type type : model.getTypes()) {
        // StatisticUnit, ValueType.
        if (type instanceof EnumType && !schemaNames.isSchemaEnum(type)) {
            EnumType enumType = (EnumType) type;
            generateEnum(enumType);
        }
    }
}
#end_block

#method_before
private void writeSchema(XMLStreamWriter writer) throws XMLStreamException {
    // Header:
    writer.writeStartElement(XS_URI, "schema");
    writer.writeAttribute("version", "1.0");
    // Generate the action types:
    writeActionTypes(writer);
    // Find the struct and enum types:
    List<StructType> structTypes = new ArrayList<>();
    List<EnumType> enumTypes = new ArrayList<>();
    for (Type type : model.getTypes()) {
        if (type instanceof StructType && type != identifiedType) {
            structTypes.add((StructType) type);
        }
        if (type instanceof EnumType && isSchemaEnum(type)) {
            enumTypes.add((EnumType) type);
        }
    }
    // Write the XML schema group of elements that are used by the capabilities resource to list the possible
    // values of the enum types. Eventually the complete capabilities elements will be generated, but for now
    // it is written manually and int includes this group.
    writeEnumValues(writer, enumTypes);
    // Write the XML schema for the enum types:
    for (EnumType enumType : enumTypes) {
        writeEnumType(writer, enumType);
    }
    // Write the XML schema for the struct types:
    for (StructType structType : structTypes) {
        writeStructType(writer, structType);
    }
    // Footer:
    writer.writeEndElement();
}
#method_after
private void writeSchema(XMLStreamWriter writer) throws XMLStreamException {
    // Header:
    writer.writeStartElement(XS_URI, "schema");
    writer.writeAttribute("version", "1.0");
    // Generate the action types:
    writeActionTypes(writer);
    // Find the struct and enum types:
    List<StructType> structTypes = new ArrayList<>();
    List<EnumType> enumTypes = new ArrayList<>();
    for (Type type : model.getTypes()) {
        if (type instanceof StructType && type != identifiedType) {
            structTypes.add((StructType) type);
        }
        if (type instanceof EnumType && schemaNames.isSchemaEnum(type)) {
            enumTypes.add((EnumType) type);
        }
    }
    // Write the XML schema group of elements that are used by the capabilities resource to list the possible
    // values of the enum types. Eventually the complete capabilities elements will be generated, but for now
    // it is written manually and int includes this group.
    writeEnumValues(writer, enumTypes);
    // Write the XML schema for the enum types:
    for (EnumType enumType : enumTypes) {
        writeEnumType(writer, enumType);
    }
    // Write the XML schema for the struct types:
    for (StructType structType : structTypes) {
        writeStructType(writer, structType);
    }
    // Footer:
    writer.writeEndElement();
}
#end_block

#method_before
private void writeStructType(XMLStreamWriter writer, StructType type) throws XMLStreamException {
    // Get the name of the type, and its plural:
    Name typeName = type.getName();
    Name typePlural = names.getPlural(typeName);
    // Check if this type is an identified type, one that can appear as the root of a valid XML document, as in that
    // case the complex types must extend "BaseResource" and "BaseResources":
    boolean isRoot = type.isExtension(identifiedType);
    // Tag for the entity:
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", schemaNames.getSchemaTagName(typeName));
    writer.writeAttribute("type", getSchemaTypeName(type));
    writer.writeEndElement();
    writeLine(writer);
    // Determine if the complex type is an extension of other complex type:
    String baseComplexTypeName = null;
    Type baseType = type.getBase();
    if (baseType != null && baseType != identifiedType) {
        baseComplexTypeName = getSchemaTypeName(baseType);
    } else {
        if (isRoot) {
            baseComplexTypeName = "BaseResource";
        }
    }
    // Complex type for the entity:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", getSchemaTypeName(type));
    if (baseComplexTypeName != null) {
        writer.writeStartElement(XS_URI, "complexContent");
        writer.writeStartElement(XS_URI, "extension");
        writer.writeAttribute("base", baseComplexTypeName);
    }
    writeStructMembers(writer, type);
    if (baseComplexTypeName != null) {
        writer.writeEndElement();
        writer.writeEndElement();
    }
    writer.writeEndElement();
    writeLine(writer);
    // Tag for the collection:
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", schemaNames.getSchemaTagName(typePlural));
    writer.writeAttribute("type", schemaNames.getSchemaTypeName(typePlural));
    writer.writeEndElement();
    writeLine(writer);
    // Complex type for the collection:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", schemaNames.getSchemaTypeName(typePlural));
    if (isRoot) {
        writer.writeStartElement(XS_URI, "complexContent");
        writer.writeStartElement(XS_URI, "extension");
        writer.writeAttribute("base", "BaseResources");
    }
    writer.writeStartElement(XS_URI, "sequence");
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("ref", schemaNames.getSchemaTagName(typeName));
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "unbounded");
    writeJaxbProperty(writer, schemaNames.getSchemaTypeName(typePlural));
    writer.writeEndElement();
    writer.writeEndElement();
    if (isRoot) {
        writer.writeEndElement();
        writer.writeEndElement();
    }
    writer.writeEndElement();
    writeLine(writer);
}
#method_after
private void writeStructType(XMLStreamWriter writer, StructType type) throws XMLStreamException {
    // Get the name of the type, and its plural:
    Name typeName = type.getName();
    Name typePlural = names.getPlural(typeName);
    // Check if this type is an identified type, one that can appear as the root of a valid XML document, as in that
    // case the complex types must extend "BaseResource" and "BaseResources":
    boolean isRoot = type.isExtension(identifiedType);
    // Tag for the entity:
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", schemaNames.getSchemaTagName(typeName));
    writer.writeAttribute("type", schemaNames.getSchemaTypeName(type));
    writer.writeEndElement();
    writeLine(writer);
    // Determine if the complex type is an extension of other complex type:
    String baseComplexTypeName = null;
    Type baseType = type.getBase();
    if (baseType != null && baseType != identifiedType) {
        baseComplexTypeName = schemaNames.getSchemaTypeName(baseType);
    } else {
        if (isRoot) {
            baseComplexTypeName = "BaseResource";
        }
    }
    // Complex type for the entity:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", schemaNames.getSchemaTypeName(type));
    if (baseComplexTypeName != null) {
        writer.writeStartElement(XS_URI, "complexContent");
        writer.writeStartElement(XS_URI, "extension");
        writer.writeAttribute("base", baseComplexTypeName);
    }
    writeStructMembers(writer, type);
    if (baseComplexTypeName != null) {
        writer.writeEndElement();
        writer.writeEndElement();
    }
    writer.writeEndElement();
    writeLine(writer);
    // Tag for the collection:
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", schemaNames.getSchemaTagName(typePlural));
    writer.writeAttribute("type", schemaNames.getSchemaTypeName(typePlural));
    writer.writeEndElement();
    writeLine(writer);
    // Complex type for the collection:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", schemaNames.getSchemaTypeName(typePlural));
    if (isRoot) {
        writer.writeStartElement(XS_URI, "complexContent");
        writer.writeStartElement(XS_URI, "extension");
        writer.writeAttribute("base", "BaseResources");
    }
    writer.writeStartElement(XS_URI, "sequence");
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("ref", schemaNames.getSchemaTagName(typeName));
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "unbounded");
    writeJaxbProperty(writer, schemaNames.getSchemaTypeName(typePlural));
    writer.writeEndElement();
    writer.writeEndElement();
    if (isRoot) {
        writer.writeEndElement();
        writer.writeEndElement();
    }
    writer.writeEndElement();
    writeLine(writer);
}
#end_block

#method_before
private void writeEnumType(XMLStreamWriter writer, EnumType type) throws XMLStreamException {
    // Get the enum values and sort them by name:
    List<EnumValue> values = new ArrayList<>(type.getValues());
    values.sort(comparing(Concept::getName));
    // Generate the XML schema enumerated type that will for attributes whose value is of this enum type:
    writer.writeStartElement(XS_URI, "simpleType");
    writer.writeAttribute("name", getSchemaTypeName(type));
    writer.writeStartElement(XS_URI, "restriction");
    writer.writeAttribute("base", "xs:string");
    for (EnumValue value : values) {
        writer.writeStartElement(XS_URI, "enumeration");
        writer.writeAttribute("value", getSchemaEnumValueName(value));
        writeJaxbProperty(writer, getJavaEnumValueName(value));
        writer.writeEndElement();
    }
    writer.writeEndElement();
    writer.writeEndElement();
    writeLine(writer);
}
#method_after
private void writeEnumType(XMLStreamWriter writer, EnumType type) throws XMLStreamException {
    // Get the enum values and sort them by name:
    List<EnumValue> values = new ArrayList<>(type.getValues());
    values.sort(comparing(Concept::getName));
    // Generate the XML schema enumerated type that will for attributes whose value is of this enum type:
    writer.writeStartElement(XS_URI, "simpleType");
    writer.writeAttribute("name", schemaNames.getSchemaTypeName(type));
    writer.writeStartElement(XS_URI, "restriction");
    writer.writeAttribute("base", "xs:string");
    for (EnumValue value : values) {
        writer.writeStartElement(XS_URI, "enumeration");
        writer.writeAttribute("value", getSchemaEnumValueName(value));
        writeJaxbProperty(writer, getJavaEnumValueName(value));
        writer.writeEndElement();
    }
    writer.writeEndElement();
    writer.writeEndElement();
    writeLine(writer);
}
#end_block

#method_before
private void writeActionTypes(XMLStreamWriter writer) throws XMLStreamException {
    // Write the "GracePeriod" complex type:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", "GracePeriod");
    writer.writeStartElement(XS_URI, "sequence");
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", "expiry");
    writer.writeAttribute("type", "xs:long");
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writeLine(writer);
    // Write the "Action" element:
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", "action");
    writer.writeAttribute("type", "Action");
    writer.writeEndElement();
    writeLine(writer);
    // Write the "Action" complex type:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", "Action");
    writer.writeStartElement(XS_URI, "complexContent");
    writer.writeStartElement(XS_URI, "extension");
    writer.writeAttribute("base", "BaseResource");
    writer.writeStartElement(XS_URI, "sequence");
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", "async");
    writer.writeAttribute("type", "xs:boolean");
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "1");
    writer.writeEndElement();
    writer.writeStartElement(XS_URI, "group");
    writer.writeAttribute("ref", "ActionParameterGroup");
    writer.writeEndElement();
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("ref", "status");
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "1");
    writer.writeEndElement();
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("ref", "fault");
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "1");
    writer.writeEndElement();
    writer.writeStartElement(XS_URI, "group");
    writer.writeAttribute("ref", "ActionResponseGroup");
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writeLine(writer);
    // Write the "Actions" complex type:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", "Actions");
    writer.writeStartElement(XS_URI, "sequence");
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("ref", "link");
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "unbounded");
    writeJaxbCustomization(writer, "property", "name", "Links");
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writeLine(writer);
    // Write the parameter groups:
    writeActionParameterGroup(writer);
    writeActionResponseGroup(writer);
}
#method_after
private void writeActionTypes(XMLStreamWriter writer) throws XMLStreamException {
    // Write the "GracePeriod" complex type:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", "GracePeriod");
    writer.writeStartElement(XS_URI, "sequence");
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", "expiry");
    writer.writeAttribute("type", "xs:long");
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writeLine(writer);
    // Write the "Action" element:
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", "action");
    writer.writeAttribute("type", "Action");
    writer.writeEndElement();
    writeLine(writer);
    // Write the "Action" complex type:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", "Action");
    writer.writeStartElement(XS_URI, "complexContent");
    writer.writeStartElement(XS_URI, "extension");
    writer.writeAttribute("base", "BaseResource");
    writer.writeStartElement(XS_URI, "sequence");
    writer.writeStartElement(XS_URI, "group");
    writer.writeAttribute("ref", "ActionParameterGroup");
    writer.writeEndElement();
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("ref", "status");
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "1");
    writer.writeEndElement();
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("ref", "fault");
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "1");
    writer.writeEndElement();
    writer.writeStartElement(XS_URI, "group");
    writer.writeAttribute("ref", "ActionResponseGroup");
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writeLine(writer);
    // Write the "Actions" complex type:
    writer.writeStartElement(XS_URI, "complexType");
    writer.writeAttribute("name", "Actions");
    writer.writeStartElement(XS_URI, "sequence");
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("ref", "link");
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "unbounded");
    writeJaxbCustomization(writer, "property", "name", "Links");
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
    writeLine(writer);
    // Write the parameter groups:
    writeActionParameterGroup(writer);
    writeActionResponseGroup(writer);
}
#end_block

#method_before
private void writeActionParameter(XMLStreamWriter writer, Parameter parameter) throws XMLStreamException {
    Name name = parameter.getName();
    Type type = parameter.getType();
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", schemaNames.getSchemaTagName(name));
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "1");
    if (type instanceof ListType) {
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        String elementTypeName = getSchemaTypeName(elementType);
        if (elementTypeName.startsWith("xs:")) {
            writer.writeStartElement(XS_URI, "complexType");
            writeJaxbClass(writer, schemaNames.getSchemaTypeName(name) + "List");
            writer.writeStartElement(XS_URI, "sequence");
            writer.writeStartElement(XS_URI, "element");
            writer.writeAttribute("name", schemaNames.getSchemaTagName(names.getSingular(name)));
            writer.writeAttribute("type", elementTypeName);
            writer.writeAttribute("minOccurs", "0");
            writer.writeAttribute("maxOccurs", "unbounded");
            writeJaxbProperty(writer, schemaNames.getSchemaTypeName(name));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
        } else {
            writer.writeAttribute("name", schemaNames.getSchemaTagName(name));
            writer.writeAttribute("type", schemaNames.getSchemaTypeName(names.getPlural(elementType.getName())));
            writer.writeAttribute("minOccurs", "0");
            writer.writeAttribute("maxOccurs", "1");
        }
    } else {
        writer.writeAttribute("name", schemaNames.getSchemaTagName(name));
        writer.writeAttribute("type", getSchemaTypeName(type));
        writer.writeAttribute("minOccurs", "0");
        writer.writeAttribute("maxOccurs", "1");
    }
    writer.writeEndElement();
}
#method_after
private void writeActionParameter(XMLStreamWriter writer, Parameter parameter) throws XMLStreamException {
    Name name = parameter.getName();
    Type type = parameter.getType();
    writer.writeStartElement(XS_URI, "element");
    writer.writeAttribute("name", schemaNames.getSchemaTagName(name));
    writer.writeAttribute("minOccurs", "0");
    writer.writeAttribute("maxOccurs", "1");
    if (type instanceof ListType) {
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        String elementTypeName = schemaNames.getSchemaTypeName(elementType);
        if (elementTypeName.startsWith("xs:")) {
            writer.writeStartElement(XS_URI, "complexType");
            writeJaxbClass(writer, schemaNames.getSchemaTypeName(name) + "List");
            writer.writeStartElement(XS_URI, "sequence");
            writer.writeStartElement(XS_URI, "element");
            writer.writeAttribute("name", schemaNames.getSchemaTagName(names.getSingular(name)));
            writer.writeAttribute("type", elementTypeName);
            writer.writeAttribute("minOccurs", "0");
            writer.writeAttribute("maxOccurs", "unbounded");
            writeJaxbProperty(writer, schemaNames.getSchemaTypeName(name));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
        } else {
            writer.writeAttribute("name", schemaNames.getSchemaTagName(name));
            writer.writeAttribute("type", schemaNames.getSchemaTypeName(names.getPlural(elementType.getName())));
            writer.writeAttribute("minOccurs", "0");
            writer.writeAttribute("maxOccurs", "1");
        }
    } else {
        writer.writeAttribute("name", schemaNames.getSchemaTagName(name));
        writer.writeAttribute("type", schemaNames.getSchemaTypeName(type));
        writer.writeAttribute("minOccurs", "0");
        writer.writeAttribute("maxOccurs", "1");
    }
    writer.writeEndElement();
}
#end_block

#method_before
private String getMemberSchemaTypeName(Type declaringType, Type memberType, Name memberName) {
    String exception = getMemberSchemaTypeNameException(declaringType.getName(), memberName);
    if (exception != null) {
        return exception;
    }
    return getSchemaTypeName(memberType);
}
#method_after
private String getMemberSchemaTypeName(Type declaringType, Type memberType, Name memberName) {
    String exception = getMemberSchemaTypeNameException(declaringType.getName(), memberName);
    if (exception != null) {
        return exception;
    }
    return schemaNames.getSchemaTypeName(memberType);
}
#end_block

#method_before
public void run(String[] args) throws Exception {
    // Create the command line options:
    Options options = new Options();
    // Options for the locations of files and directories:
    options.addOption(Option.builder().longOpt(MODEL_OPTION).desc("The directory or .jar file containing the source model files.").type(File.class).required(true).hasArg(true).argName("DIRECTORY|JAR").build());
    options.addOption(Option.builder().longOpt(IN_SCHEMA_OPTION).desc("The XML schema input file.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(OUT_SCHEMA_OPTION).desc("The XML schema output file.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(JAVA_OPTION).desc("The directory where the generated Java source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    // Options for the names of generated Java sources:
    options.addOption(Option.builder().longOpt(JAXRS_PACKAGE_OPTION).desc("The name of the Java package for JAX-RS interfaces.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(XJC_PACKAGE_OPTION).desc("The name of the Java package for classes generated by the XJC compiler.").required(false).hasArg(true).argName("PACKAGE").build());
    // Parse the command line:
    CommandLineParser parser = new DefaultParser();
    CommandLine line = null;
    try {
        line = parser.parse(options, args);
    } catch (ParseException exception) {
        HelpFormatter formatter = new HelpFormatter();
        formatter.setSyntaxPrefix("Usage: ");
        formatter.printHelp("metamodel-tool [OPTIONS]", options);
        System.exit(1);
    }
    // Extract the locations of files and directories from the command line:
    File modelFile = (File) line.getParsedOptionValue(MODEL_OPTION);
    File inSchemaFile = (File) line.getParsedOptionValue(IN_SCHEMA_OPTION);
    File outSchemaFile = (File) line.getParsedOptionValue(OUT_SCHEMA_OPTION);
    File javaDir = (File) line.getParsedOptionValue(JAVA_OPTION);
    // Extract the names of the Java packages from the command line and copy them to the object that manages them:
    String[] jaxrsPackages = line.getOptionValues(JAXRS_PACKAGE_OPTION);
    if (jaxrsPackages != null) {
        for (String jaxrsPackage : jaxrsPackages) {
            javaPackages.addJaxrsRule(jaxrsPackage);
        }
    }
    String xjcPackage = line.getOptionValue(XJC_PACKAGE_OPTION);
    if (xjcPackage != null) {
        javaPackages.setXjcPackageName(xjcPackage);
    }
    // Analyze the model files:
    Model model = new Model();
    ModelAnalyzer modelAnalyzer = new ModelAnalyzer();
    modelAnalyzer.setModel(model);
    modelAnalyzer.analyzeSource(modelFile);
    // Generate the XML schema:
    if (inSchemaFile != null && outSchemaFile != null) {
        schemaGenerator.setInFile(inSchemaFile);
        schemaGenerator.setOutFile(outSchemaFile);
        schemaGenerator.generate(model);
    }
    // Generate the Java code:
    if (javaDir != null) {
        FileUtils.forceMkdir(javaDir);
        jaxrsGenerator.setOutDir(javaDir);
        jaxrsGenerator.generate(model);
    }
    // Generate the enums
    if (javaDir != null) {
        // TODO: revisit!!!
        enumGenerator.setOutDir(javaDir);
        enumGenerator.generate(model);
    }
}
#method_after
public void run(String[] args) throws Exception {
    // Create the command line options:
    Options options = new Options();
    // Options for the locations of files and directories:
    options.addOption(Option.builder().longOpt(MODEL_OPTION).desc("The directory or .jar file containing the source model files.").type(File.class).required(true).hasArg(true).argName("DIRECTORY|JAR").build());
    // Options for the location of the generated XML and JSON model representations:
    options.addOption(Option.builder().longOpt(XML_OPTION).desc("The location of the generated XML description of the model. If not specified then the XML " + "description isn't generated.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(JSON_OPTION).desc("The location of the generated JSON description of the model. If not specified then the JSON " + "description isn't generated.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    // Options for the location of the input and output XML schemas:
    options.addOption(Option.builder().longOpt(IN_SCHEMA_OPTION).desc("The XML schema input file.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(OUT_SCHEMA_OPTION).desc("The XML schema output file.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    // Options for the names of generated Java sources:
    options.addOption(Option.builder().longOpt(JAVA_OPTION).desc("The directory where the generated Java source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    options.addOption(Option.builder().longOpt(JAXRS_PACKAGE_OPTION).desc("The name of the Java package for JAX-RS interfaces.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(XJC_PACKAGE_OPTION).desc("The name of the Java package for classes generated by the XJC compiler.").required(false).hasArg(true).argName("PACKAGE").build());
    // Parse the command line:
    CommandLineParser parser = new DefaultParser();
    CommandLine line = null;
    try {
        line = parser.parse(options, args);
    } catch (ParseException exception) {
        HelpFormatter formatter = new HelpFormatter();
        formatter.setSyntaxPrefix("Usage: ");
        formatter.printHelp("metamodel-tool [OPTIONS]", options);
        System.exit(1);
    }
    // Extract the locations of files and directories from the command line:
    File modelFile = (File) line.getParsedOptionValue(MODEL_OPTION);
    File xmlFile = (File) line.getParsedOptionValue(XML_OPTION);
    File jsonFile = (File) line.getParsedOptionValue(JSON_OPTION);
    File inSchemaFile = (File) line.getParsedOptionValue(IN_SCHEMA_OPTION);
    File outSchemaFile = (File) line.getParsedOptionValue(OUT_SCHEMA_OPTION);
    File javaDir = (File) line.getParsedOptionValue(JAVA_OPTION);
    // Analyze the model files:
    Model model = new Model();
    ModelAnalyzer modelAnalyzer = new ModelAnalyzer();
    modelAnalyzer.setModel(model);
    modelAnalyzer.analyzeSource(modelFile);
    // Generate the XML representation of the model:
    if (xmlFile != null) {
        File xmlDir = xmlFile.getParentFile();
        FileUtils.forceMkdir(xmlDir);
        xmlDescriptionGenerator.generate(model, xmlFile);
    }
    // Generate the JSON representation of the model:
    if (jsonFile != null) {
        File jsonDir = jsonFile.getParentFile();
        FileUtils.forceMkdir(jsonDir);
        jsonDescriptionGenerator.generate(model, jsonFile);
    }
    // Extract the names of the Java packages from the command line and copy them to the object that manages them:
    String[] jaxrsPackages = line.getOptionValues(JAXRS_PACKAGE_OPTION);
    if (jaxrsPackages != null) {
        for (String jaxrsPackage : jaxrsPackages) {
            javaPackages.addJaxrsRule(jaxrsPackage);
        }
    }
    String xjcPackage = line.getOptionValue(XJC_PACKAGE_OPTION);
    if (xjcPackage != null) {
        javaPackages.setXjcPackageName(xjcPackage);
    }
    // Generate the XML schema:
    if (inSchemaFile != null && outSchemaFile != null) {
        schemaGenerator.setInFile(inSchemaFile);
        schemaGenerator.setOutFile(outSchemaFile);
        schemaGenerator.generate(model);
    }
    // Generate the Java code:
    if (javaDir != null) {
        FileUtils.forceMkdir(javaDir);
        jaxrsGenerator.setOutDir(javaDir);
        jaxrsGenerator.generate(model);
        // Generate the enums
        enumGenerator.setOutDir(javaDir);
        enumGenerator.generate(model);
    }
}
#end_block

#method_before
public static Map<String, LUNs> buildVmLunDisksData(Map<String, Object> xmlRpcStruct) {
    Map<String, Object> disks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_disks);
    Map<String, LUNs> lunsMap = new HashMap<>();
    if (disks != null) {
        for (Object diskAsObj : disks.values()) {
            Map<String, Object> disk = (Map<String, Object>) diskAsObj;
            String lunGuidString = assignStringValue(disk, VdsProperties.lun_guid);
            if (!StringUtils.isEmpty(lunGuidString)) {
                LUNs lun = new LUNs();
                lun.setLUN_id(lunGuidString);
                if (disk.containsKey(VdsProperties.disk_true_size)) {
                    long sizeInBytes = assignLongValue(disk, VdsProperties.disk_true_size);
                    int sizeInGB = SizeConverter.convert(sizeInBytes, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue();
                    lun.setDeviceSize(sizeInGB);
                }
                lunsMap.put(lunGuidString, lun);
            }
        }
    }
    return lunsMap;
}
#method_after
public static Map<String, LUNs> buildVmLunDisksData(Map<String, Object> xmlRpcStruct) {
    Map<String, Object> disks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_disks);
    Map<String, LUNs> lunsMap = new HashMap<>();
    if (disks != null) {
        for (Object diskAsObj : disks.values()) {
            Map<String, Object> disk = (Map<String, Object>) diskAsObj;
            String lunGuidString = assignStringValue(disk, VdsProperties.lun_guid);
            if (!StringUtils.isEmpty(lunGuidString)) {
                LUNs lun = new LUNs();
                lun.setLUNId(lunGuidString);
                if (disk.containsKey(VdsProperties.disk_true_size)) {
                    long sizeInBytes = assignLongValue(disk, VdsProperties.disk_true_size);
                    int sizeInGB = SizeConverter.convert(sizeInBytes, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue();
                    lun.setDeviceSize(sizeInGB);
                }
                lunsMap.put(lunGuidString, lun);
            }
        }
    }
    return lunsMap;
}
#end_block

#method_before
private static void initDisks(Map<String, Object> vmStruct, VmDynamic vm) {
    Map<String, Object> disks = (Map<String, Object>) vmStruct.get(VdsProperties.vm_disks);
    ArrayList<DiskImageDynamic> disksData = new ArrayList<>();
    for (Object diskAsObj : disks.values()) {
        Map<String, Object> disk = (Map<String, Object>) diskAsObj;
        DiskImageDynamic diskData = new DiskImageDynamic();
        String imageGroupIdString = assignStringValue(disk, VdsProperties.image_group_id);
        if (!StringUtils.isEmpty(imageGroupIdString)) {
            Guid imageGroupIdGuid = new Guid(imageGroupIdString);
            diskData.setId(imageGroupIdGuid);
            diskData.setread_rate(assignIntValue(disk, VdsProperties.vm_disk_read_rate));
            diskData.setwrite_rate(assignIntValue(disk, VdsProperties.vm_disk_write_rate));
            if (disk.containsKey(VdsProperties.disk_actual_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_actual_size);
                diskData.setactual_size(size != null ? size * 512 : 0);
            } else if (disk.containsKey(VdsProperties.disk_true_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_true_size);
                diskData.setactual_size(size != null ? size : 0);
            }
            if (disk.containsKey(VdsProperties.vm_disk_read_latency)) {
                diskData.setReadLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_read_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_write_latency)) {
                diskData.setWriteLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_write_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_flush_latency)) {
                diskData.setFlushLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_flush_latency) / NANO_SECONDS);
            }
            disksData.add(diskData);
        }
    }
    vm.setDisks(disksData);
}
#method_after
private static void initDisks(Map<String, Object> vmStruct, VmDynamic vm) {
    Map<String, Object> disks = (Map<String, Object>) vmStruct.get(VdsProperties.vm_disks);
    ArrayList<DiskImageDynamic> disksData = new ArrayList<>();
    for (Object diskAsObj : disks.values()) {
        Map<String, Object> disk = (Map<String, Object>) diskAsObj;
        DiskImageDynamic diskData = new DiskImageDynamic();
        String imageGroupIdString = assignStringValue(disk, VdsProperties.image_group_id);
        if (!StringUtils.isEmpty(imageGroupIdString)) {
            Guid imageGroupIdGuid = new Guid(imageGroupIdString);
            diskData.setId(imageGroupIdGuid);
            diskData.setReadRate(assignIntValue(disk, VdsProperties.vm_disk_read_rate));
            diskData.setWriteRate(assignIntValue(disk, VdsProperties.vm_disk_write_rate));
            if (disk.containsKey(VdsProperties.disk_actual_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_actual_size);
                diskData.setActualSize(size != null ? size * 512 : 0);
            } else if (disk.containsKey(VdsProperties.disk_true_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_true_size);
                diskData.setActualSize(size != null ? size : 0);
            }
            if (disk.containsKey(VdsProperties.vm_disk_read_latency)) {
                diskData.setReadLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_read_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_write_latency)) {
                diskData.setWriteLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_write_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_flush_latency)) {
                diskData.setFlushLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_flush_latency) / NANO_SECONDS);
            }
            disksData.add(diskData);
        }
    }
    vm.setDisks(disksData);
}
#end_block

#method_before
private static VdsNetworkInterface resolveActiveNic(VDS host, String hostIp) {
    if (hostIp == null) {
        return null;
    }
    final String managementAddress = hostIp;
    VdsNetworkInterface activeIface = LinqUtils.firstOrNull(host.getInterfaces(), new InterfaceByAddressPredicate(managementAddress));
    return activeIface;
}
#method_after
private static VdsNetworkInterface resolveActiveNic(VDS host, String hostIp) {
    if (hostIp == null) {
        return null;
    }
    final String managementAddress = hostIp;
    VdsNetworkInterface activeIface = host.getInterfaces().stream().filter(new InterfaceByAddressPredicate(managementAddress)).findFirst().orElse(null);
    return activeIface;
}
#end_block

#method_before
private static String normalizeBondOptions(String bondOptions) {
    Matcher matcher = Pattern.compile("mode=([\\w-\\.]+)").matcher(bondOptions);
    if (!matcher.find()) {
        return bondOptions;
    }
    String bondModeValue = BondMode.toNumeric(matcher.group(1));
    if (bondModeValue != null) {
        return matcher.replaceAll("mode=" + bondModeValue);
    }
    return bondOptions;
}
#method_after
private static String normalizeBondOptions(String bondOptions) {
    Matcher matcher = Pattern.compile("mode=([\\w-\\.]+)").matcher(bondOptions);
    if (!matcher.find()) {
        return bondOptions;
    }
    BondMode bondMode = BondMode.getBondMode(matcher.group(1));
    if (bondMode != null) {
        return matcher.replaceAll("mode=" + bondMode.getValue());
    }
    return bondOptions;
}
#end_block

#method_before
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(assignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.parseInt(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = assignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            Map<Integer, Integer> distanceMap = new HashMap<>();
            if (numaNodeDistanceMap != null) {
                // Save the received NUMA node distances
                List<Integer> distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
                for (int i = 0; i < distances.size(); i++) {
                    distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
                }
            } else {
                // Save faked distances
                for (VdsNumaNode otherNumaNode : newNumaNodeList) {
                    // There is no distance if the node is the same one
                    if (otherNumaNode.getIndex() == vdsNumaNode.getIndex()) {
                        continue;
                    }
                    distanceMap.put(otherNumaNode.getIndex(), 0);
                }
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#method_after
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(assignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.parseInt(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = assignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            Map<Integer, Integer> distanceMap = new HashMap<>();
            List<Integer> distances = Collections.emptyList();
            if (numaNodeDistanceMap != null) {
                // Save the received NUMA node distances
                distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
                for (int i = 0; i < distances.size(); i++) {
                    distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
                }
            }
            if (distances.isEmpty()) {
                // Save faked distances
                for (VdsNumaNode otherNumaNode : newNumaNodeList) {
                    // There is no distance if the node is the same one
                    if (otherNumaNode.getIndex() == vdsNumaNode.getIndex()) {
                        continue;
                    }
                    distanceMap.put(otherNumaNode.getIndex(), 0);
                }
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#end_block

#method_before
private static List<Integer> extractIntegerList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return null;
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return null;
    }
    List<Integer> list = new ArrayList<>();
    for (Object item : items) {
        list.add((Integer) item);
    }
    return list;
}
#method_after
private static List<Integer> extractIntegerList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return Collections.emptyList();
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return Collections.emptyList();
    }
    List<Integer> list = new ArrayList<>();
    for (Object item : items) {
        list.add((Integer) item);
    }
    return list;
}
#end_block

#method_before
@Test
public void testGetBondMode() {
    for (BondMode bondMode : BondMode.values()) {
        assertEquals(bondMode, BondMode.getBondMode("mode=" + bondMode.getValue()));
        assertEquals(bondMode, BondMode.getBondMode("mode=" + bondMode.getStringValue()));
        assertEquals(bondMode, BondMode.getBondMode("  mode=" + bondMode.getValue() + "   "));
        assertEquals(bondMode, BondMode.getBondMode("prefix=0 mode=" + bondMode.getValue() + " suffix=0"));
        assertEquals(bondMode, BondMode.getBondMode(" othermode=7 mode=" + bondMode.getValue() + "   othermode=7"));
    }
    assertEquals(null, BondMode.getBondMode(" othermode=7 mode  =   4   othermode=7"));
    assertEquals(null, BondMode.getBondMode("  mode  =   4   "));
    assertEquals(null, BondMode.getBondMode("no bond mode"));
    assertEquals(null, BondMode.getBondMode("prefixmode=4"));
    assertEquals(null, BondMode.getBondMode("mode=4suffix"));
    assertEquals(null, BondMode.getBondMode("mode=nomode"));
    assertEquals(null, BondMode.getBondMode("mode=17"));
    assertEquals(null, BondMode.getBondMode("mode="));
    assertEquals(null, BondMode.getBondMode("mode= "));
    assertEquals(null, BondMode.getBondMode("mode17"));
}
#method_after
@Test
public void testGetBondMode() {
    for (BondMode bondMode : BondMode.values()) {
        assertEquals(bondMode, BondMode.getBondMode(bondMode.getValue()));
        assertEquals(bondMode, BondMode.getBondMode(bondMode.getStringValue()));
        assertEquals(null, BondMode.getBondMode("mode=" + bondMode.getValue()));
        assertEquals(null, BondMode.getBondMode("mode=" + bondMode.getStringValue()));
    }
}
#end_block

#method_before
private void loadPolicyUnits() {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        if (policyUnit.isInternal()) {
            policyUnits.put(policyUnit.getId(), PolicyUnitImpl.getPolicyUnitImpl(policyUnit, getPendingResourceManager()));
        } else {
            policyUnits.put(policyUnit.getId(), new PolicyUnitImpl(policyUnit, getPendingResourceManager()));
        }
    }
}
#method_after
private void loadPolicyUnits() {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        if (policyUnit.isInternal()) {
            policyUnits.put(policyUnit.getId(), Injector.injectMembers(PolicyUnitImpl.getPolicyUnitImpl(policyUnit, getPendingResourceManager())));
        } else {
            policyUnits.put(policyUnit.getId(), new PolicyUnitImpl(policyUnit, getPendingResourceManager()));
        }
    }
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    filters = new ArrayList<>(filters);
    sortFilters(filters, filterPositionMap);
    for (Guid filter : filters) {
        PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
        if (filterPolicyUnit.getPolicyUnit().isInternal()) {
            internalFilters.add(filterPolicyUnit);
        } else {
            if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                externalFilters.add(filterPolicyUnit);
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && hostList != null && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    filters = (filters != null) ? new ArrayList<>(filters) : new ArrayList<>();
    sortFilters(filters, filterPositionMap);
    for (Guid filter : filters) {
        PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
        if (filterPolicyUnit.getPolicyUnit().isInternal()) {
            internalFilters.add(filterPolicyUnit);
        } else {
            if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                externalFilters.add(filterPolicyUnit);
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && hostList != null && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling(getPendingResourceManager());
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION, auditLogDirector);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN, auditLogDirector);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling(getPendingResourceManager());
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION, auditLogDirector);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN, auditLogDirector);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
private Pair<List<Guid>, Guid> internalRunBalance(PolicyUnitImpl policyUnit, VDSGroup cluster, List<VDS> hosts) {
    return policyUnit.balance(cluster, hosts, cluster.getClusterPolicyProperties(), new ArrayList<String>());
}
#method_after
private Pair<List<Guid>, Guid> internalRunBalance(PolicyUnitImpl policyUnit, VDSGroup cluster, List<VDS> hosts) {
    return policyUnit.balance(cluster, hosts, cluster.getClusterPolicyProperties(), new ArrayList<>());
}
#end_block

#method_before
// private void handleAgentAlerts(Entry<FenceAgent, Boolean> entry, Guid hostId) {
// Guid agentId = entry.getKey().getId();
// boolean agentHealthy = entry.getValue();
// if (agentHealthy) {
// removeAlert(agentId, hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FENCE_AGENT_NON_RESPONSIVE);
// } else {
// addAlert(agentId, hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_FENCE_AGENT_NON_RESPONSIVE);
// }
// 
// }
// private void addAlert(Guid agentId, Guid hostId, AuditLogType auditMessage) {
// AuditLogableBase alert = new AuditLogableBase();
// alert.addCustomValue(AGENT_ID, agentId.toString());
// AlertDirector.AddVdsAlert(hostId, auditMessage, alert);
// }
// 
// private void removeAlert(Guid agentId, Guid hostId, AuditLogType auditMessage) {
// AuditLogableBase alert = new AuditLogableBase();
// alert.addCustomValue(AGENT_ID, agentId.toString());
// AlertDirector.RemoveVdsAlert(hostId, auditMessage, alert);
// }
private void handleStartAlerts(PmHealth healthStatus, Guid hostId) {
    if (healthStatus.isStartShouldWork()) {
        removeAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    } else {
        addAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    }
}
#method_after
private void handleStartAlerts(PmHealth healthStatus, Guid hostId) {
    if (healthStatus.isStartShouldWork()) {
        removeAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    } else {
        addAlert(hostId, AuditLogType.VDS_ALERT_PM_HEALTH_CHECK_START_MIGHT_FAIL);
    }
}
#end_block

#method_before
private void startHostsWithPMInReboot(List<VDS> hosts) {
    final List<VDS> hostsWithPMInReboot = hosts.stream().filter(host -> host.isPmEnabled() && host.getStatus() == VDSStatus.Reboot).collect(Collectors.toList());
    if (hostsWithPMInReboot.size() > 0) {
        Runnable task = () -> {
            waitUntilFencingAllowed();
            startHosts(hostsWithPMInReboot);
        };
        ThreadPoolUtil.execute(task);
    }
}
#method_after
private void startHostsWithPMInReboot(List<VDS> hosts) {
    final List<VDS> hostsWithPMInReboot = hosts.stream().filter(host -> host.isPmEnabled()).filter(host -> host.getStatus() == VDSStatus.Reboot).collect(Collectors.toList());
    if (hostsWithPMInReboot.size() > 0) {
        ThreadPoolUtil.execute(() -> {
            waitUntilFencingAllowed();
            startHosts(hostsWithPMInReboot);
        });
    }
}
#end_block

#method_before
private void recoverKdumpingHosts(List<VDS> hosts) {
    final List<VDS> kdumpingHosts = new ArrayList<>();
    for (VDS host : hosts) {
        if (host.getStatus() == VDSStatus.Kdumping) {
            kdumpingHosts.add(host);
        }
    }
    if (!kdumpingHosts.isEmpty()) {
        Runnable task = () -> {
            waitUntilFencingAllowed();
            executeNotRespondingTreatment(kdumpingHosts);
        };
        ThreadPoolUtil.execute(task);
    }
}
#method_after
private void recoverKdumpingHosts(List<VDS> hosts) {
    final List<VDS> kdumpingHosts = hosts.stream().filter(host -> host.getStatus() == VDSStatus.Kdumping).collect(Collectors.toList());
    if (!kdumpingHosts.isEmpty()) {
        ThreadPoolUtil.execute(() -> {
            waitUntilFencingAllowed();
            executeNotRespondingTreatment(kdumpingHosts);
        });
    }
}
#end_block

#method_before
private void executeNotRespondingTreatment(List<VDS> hosts) {
    for (VDS host : hosts) {
        final FenceVdsActionParameters params = new FenceVdsActionParameters(host.getId());
        Runnable task = () -> {
            Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, params, ExecutionHandler.createInternalJobContext());
        };
        ThreadPoolUtil.execute(task);
    }
}
#method_after
private void executeNotRespondingTreatment(List<VDS> hosts) {
    for (VDS host : hosts) {
        ThreadPoolUtil.execute(() -> {
            Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(host.getId()), ExecutionHandler.createInternalJobContext());
        });
    }
}
#end_block

#method_before
public static Map<String, LUNs> buildVmLunDisksData(Map<String, Object> xmlRpcStruct) {
    Map<String, Object> disks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_disks);
    Map<String, LUNs> lunsMap = new HashMap<>();
    if (disks != null) {
        for (Object diskAsObj : disks.values()) {
            Map<String, Object> disk = (Map<String, Object>) diskAsObj;
            String lunGuidString = assignStringValue(disk, VdsProperties.lun_guid);
            if (!StringUtils.isEmpty(lunGuidString)) {
                LUNs lun = new LUNs();
                lun.setLUN_id(lunGuidString);
                if (disk.containsKey(VdsProperties.disk_true_size)) {
                    long sizeInBytes = assignLongValue(disk, VdsProperties.disk_true_size);
                    int sizeInGB = SizeConverter.convert(sizeInBytes, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue();
                    lun.setDeviceSize(sizeInGB);
                }
                lunsMap.put(lunGuidString, lun);
            }
        }
    }
    return lunsMap;
}
#method_after
public static Map<String, LUNs> buildVmLunDisksData(Map<String, Object> xmlRpcStruct) {
    Map<String, Object> disks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_disks);
    Map<String, LUNs> lunsMap = new HashMap<>();
    if (disks != null) {
        for (Object diskAsObj : disks.values()) {
            Map<String, Object> disk = (Map<String, Object>) diskAsObj;
            String lunGuidString = assignStringValue(disk, VdsProperties.lun_guid);
            if (!StringUtils.isEmpty(lunGuidString)) {
                LUNs lun = new LUNs();
                lun.setLUNId(lunGuidString);
                if (disk.containsKey(VdsProperties.disk_true_size)) {
                    long sizeInBytes = assignLongValue(disk, VdsProperties.disk_true_size);
                    int sizeInGB = SizeConverter.convert(sizeInBytes, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue();
                    lun.setDeviceSize(sizeInGB);
                }
                lunsMap.put(lunGuidString, lun);
            }
        }
    }
    return lunsMap;
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(assignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(assignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(assignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(assignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
private static List<VmJob> getVmJobs(Guid vmId, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vmJobs)) {
        return null;
    }
    List<VmJob> vmJobs = new ArrayList<VmJob>();
    for (Object jobMap : ((Map<String, Object>) xmlRpcStruct.get(VdsProperties.vmJobs)).values()) {
        VmJob job = buildVmJobData(vmId, (Map<String, Object>) jobMap);
        vmJobs.add(job);
    }
    return vmJobs;
}
#method_after
private static List<VmJob> getVmJobs(Guid vmId, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vmJobs)) {
        return null;
    }
    List<VmJob> vmJobs = new ArrayList<>();
    for (Object jobMap : ((Map<String, Object>) xmlRpcStruct.get(VdsProperties.vmJobs)).values()) {
        VmJob job = buildVmJobData(vmId, (Map<String, Object>) jobMap);
        vmJobs.add(job);
    }
    return vmJobs;
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#end_block

#method_before
private static void initDisksUsage(Map<String, Object> vmStruct, VmStatistics vm) {
    Object[] vmDisksUsage = (Object[]) vmStruct.get(VdsProperties.VM_DISKS_USAGE);
    if (vmDisksUsage != null) {
        ArrayList<Object> disksUsageList = new ArrayList<Object>(Arrays.asList(vmDisksUsage));
        vm.setDisksUsage(SerializationFactory.getSerializer().serializeUnformattedJson(disksUsageList));
    }
}
#method_after
private static void initDisksUsage(Map<String, Object> vmStruct, VmStatistics vm) {
    Object[] vmDisksUsage = (Object[]) vmStruct.get(VdsProperties.VM_DISKS_USAGE);
    if (vmDisksUsage != null) {
        ArrayList<Object> disksUsageList = new ArrayList<>(Arrays.asList(vmDisksUsage));
        vm.setDisksUsage(SerializationFactory.getSerializer().serializeUnformattedJson(disksUsageList));
    }
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.parseInt(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(assignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.parseInt(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(assignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<String, Long>();
        vds.setLocalDisksUsage(diskStats);
        for (Entry<String, Object> entry : diskStatsStruct.entrySet()) {
            Map<String, Object> pathStatsStruct = (Map<String, Object>) entry.getValue();
            diskStats.put(entry.getKey(), assignLongValue(pathStatsStruct, VdsProperties.DISK_STATS_FREE));
        }
    }
}
#method_after
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        vds.setLocalDisksUsage(diskStats);
        for (Entry<String, Object> entry : diskStatsStruct.entrySet()) {
            Map<String, Object> pathStatsStruct = (Map<String, Object>) entry.getValue();
            diskStats.put(entry.getKey(), assignLongValue(pathStatsStruct, VdsProperties.DISK_STATS_FREE));
        }
    }
}
#end_block

#method_before
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                Boolean actual = Boolean.TRUE;
                if (internalValue.containsKey(VdsProperties.actual)) {
                    actual = (Boolean) internalValue.get(VdsProperties.actual);
                }
                data.setActual(actual);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#method_after
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                Boolean actual = Boolean.TRUE;
                if (internalValue.containsKey(VdsProperties.actual)) {
                    actual = (Boolean) internalValue.get(VdsProperties.actual);
                }
                data.setActual(actual);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#end_block

#method_before
private static void initDisks(Map<String, Object> vmStruct, VmDynamic vm) {
    Map<String, Object> disks = (Map<String, Object>) vmStruct.get(VdsProperties.vm_disks);
    ArrayList<DiskImageDynamic> disksData = new ArrayList<DiskImageDynamic>();
    for (Object diskAsObj : disks.values()) {
        Map<String, Object> disk = (Map<String, Object>) diskAsObj;
        DiskImageDynamic diskData = new DiskImageDynamic();
        String imageGroupIdString = assignStringValue(disk, VdsProperties.image_group_id);
        if (!StringUtils.isEmpty(imageGroupIdString)) {
            Guid imageGroupIdGuid = new Guid(imageGroupIdString);
            diskData.setId(imageGroupIdGuid);
            diskData.setread_rate(assignIntValue(disk, VdsProperties.vm_disk_read_rate));
            diskData.setwrite_rate(assignIntValue(disk, VdsProperties.vm_disk_write_rate));
            if (disk.containsKey(VdsProperties.disk_actual_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_actual_size);
                diskData.setactual_size(size != null ? size * 512 : 0);
            } else if (disk.containsKey(VdsProperties.disk_true_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_true_size);
                diskData.setactual_size(size != null ? size : 0);
            }
            if (disk.containsKey(VdsProperties.vm_disk_read_latency)) {
                diskData.setReadLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_read_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_write_latency)) {
                diskData.setWriteLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_write_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_flush_latency)) {
                diskData.setFlushLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_flush_latency) / NANO_SECONDS);
            }
            disksData.add(diskData);
        }
    }
    vm.setDisks(disksData);
}
#method_after
private static void initDisks(Map<String, Object> vmStruct, VmDynamic vm) {
    Map<String, Object> disks = (Map<String, Object>) vmStruct.get(VdsProperties.vm_disks);
    ArrayList<DiskImageDynamic> disksData = new ArrayList<>();
    for (Object diskAsObj : disks.values()) {
        Map<String, Object> disk = (Map<String, Object>) diskAsObj;
        DiskImageDynamic diskData = new DiskImageDynamic();
        String imageGroupIdString = assignStringValue(disk, VdsProperties.image_group_id);
        if (!StringUtils.isEmpty(imageGroupIdString)) {
            Guid imageGroupIdGuid = new Guid(imageGroupIdString);
            diskData.setId(imageGroupIdGuid);
            diskData.setReadRate(assignIntValue(disk, VdsProperties.vm_disk_read_rate));
            diskData.setWriteRate(assignIntValue(disk, VdsProperties.vm_disk_write_rate));
            if (disk.containsKey(VdsProperties.disk_actual_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_actual_size);
                diskData.setActualSize(size != null ? size * 512 : 0);
            } else if (disk.containsKey(VdsProperties.disk_true_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_true_size);
                diskData.setActualSize(size != null ? size : 0);
            }
            if (disk.containsKey(VdsProperties.vm_disk_read_latency)) {
                diskData.setReadLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_read_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_write_latency)) {
                diskData.setWriteLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_write_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_flush_latency)) {
                diskData.setFlushLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_flush_latency) / NANO_SECONDS);
            }
            disksData.add(diskData);
        }
    }
    vm.setDisks(disksData);
}
#end_block

#method_before
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, String interfaceName, Map<String, Object> bridgeProperties) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface iface = vdsInterfaces.get(interfaceName);
    if (iface == null) {
        if (bridgeProperties != null) {
            interfaces.addAll(findBridgedNetworkInterfaces(bridgeProperties, vdsInterfaces));
        }
    } else {
        interfaces.add(iface);
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, String interfaceName, Map<String, Object> bridgeProperties) {
    List<VdsNetworkInterface> interfaces = new ArrayList<>();
    VdsNetworkInterface iface = vdsInterfaces.get(interfaceName);
    if (iface == null) {
        if (bridgeProperties != null) {
            interfaces.addAll(findBridgedNetworkInterfaces(bridgeProperties, vdsInterfaces));
        }
    } else {
        interfaces.add(iface);
    }
    return interfaces;
}
#end_block

#method_before
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        for (Object port : ports) {
            if (vdsInterfaces.containsKey(port.toString())) {
                interfaces.add(vdsInterfaces.get(port.toString()));
            }
        }
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findBridgedNetworkInterfaces(Map<String, Object> bridge, Map<String, VdsNetworkInterface> vdsInterfaces) {
    List<VdsNetworkInterface> interfaces = new ArrayList<>();
    Object[] ports = (Object[]) bridge.get("ports");
    if (ports != null) {
        for (Object port : ports) {
            if (vdsInterfaces.containsKey(port.toString())) {
                interfaces.add(vdsInterfaces.get(port.toString()));
            }
        }
    }
    return interfaces;
}
#end_block

#method_before
public static List<VmGuestAgentInterface> buildVmGuestAgentInterfacesData(Guid vmId, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK_INTERFACES)) {
        return null;
    }
    List<VmGuestAgentInterface> interfaces = new ArrayList<VmGuestAgentInterface>();
    for (Object ifaceStruct : (Object[]) xmlRpcStruct.get(VdsProperties.VM_NETWORK_INTERFACES)) {
        VmGuestAgentInterface nic = new VmGuestAgentInterface();
        Map ifaceMap = (Map) ifaceStruct;
        nic.setInterfaceName(assignStringValue(ifaceMap, VdsProperties.VM_INTERFACE_NAME));
        nic.setMacAddress(getMacAddress(ifaceMap));
        nic.setIpv4Addresses(extracStringtList(ifaceMap, VdsProperties.VM_IPV4_ADDRESSES));
        nic.setIpv6Addresses(extracStringtList(ifaceMap, VdsProperties.VM_IPV6_ADDRESSES));
        nic.setVmId(vmId);
        interfaces.add(nic);
    }
    return interfaces;
}
#method_after
public static List<VmGuestAgentInterface> buildVmGuestAgentInterfacesData(Guid vmId, Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK_INTERFACES)) {
        return null;
    }
    List<VmGuestAgentInterface> interfaces = new ArrayList<>();
    for (Object ifaceStruct : (Object[]) xmlRpcStruct.get(VdsProperties.VM_NETWORK_INTERFACES)) {
        VmGuestAgentInterface nic = new VmGuestAgentInterface();
        Map ifaceMap = (Map) ifaceStruct;
        nic.setInterfaceName(assignStringValue(ifaceMap, VdsProperties.VM_INTERFACE_NAME));
        nic.setMacAddress(getMacAddress(ifaceMap));
        nic.setIpv4Addresses(extracStringtList(ifaceMap, VdsProperties.VM_IPV4_ADDRESSES));
        nic.setIpv6Addresses(extracStringtList(ifaceMap, VdsProperties.VM_IPV6_ADDRESSES));
        nic.setVmId(vmId);
        interfaces.add(nic);
    }
    return interfaces;
}
#end_block

#method_before
private static List<String> extracStringtList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return null;
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return null;
    }
    List<String> list = new ArrayList<String>();
    for (Object item : items) {
        list.add((String) item);
    }
    return list;
}
#method_after
private static List<String> extracStringtList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return null;
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return null;
    }
    List<String> list = new ArrayList<>();
    for (Object item : items) {
        list.add((String) item);
    }
    return list;
}
#end_block

#method_before
private static List<Integer> extractIntegerList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return Collections.emptyList();
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return Collections.emptyList();
    }
    List<Integer> list = new ArrayList<Integer>();
    for (Object item : items) {
        list.add((Integer) item);
    }
    return list;
}
#method_after
private static List<Integer> extractIntegerList(Map<String, Object> xmlRpcStruct, String propertyName) {
    if (!xmlRpcStruct.containsKey(propertyName)) {
        return Collections.emptyList();
    }
    Object[] items = (Object[]) xmlRpcStruct.get(propertyName);
    if (items.length == 0) {
        return Collections.emptyList();
    }
    List<Integer> list = new ArrayList<>();
    for (Object item : items) {
        list.add((Integer) item);
    }
    return list;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final VDSGroup oldCluster = backend.runQuery(VdcQueryType.GetVdsGroupById, getParameters()).getReturnValue();
    VDSGroup newCluster = getParameters().getNewCluster();
    List<ClusterEditWarnings.Warning> hostWarnings = getProblematicEntities(oldCluster, newCluster, hostCheckers, new ClusterEntityResolver<VDS>() {

        @Override
        public List<VDS> getClusterEntities(VDSGroup cluster) {
            return vdsDao.getAllForVdsGroup(cluster.getId());
        }
    });
    final List<ClusterEditWarnings.Warning> vmWarnings = oldCluster.supportsVirtService() && newCluster.supportsVirtService() ? getProblematicEntities(oldCluster, newCluster, vmCheckers, new ClusterEntityResolver<VM>() {

        @Override
        public List<VM> getClusterEntities(VDSGroup cluster) {
            return vmDao.getAllForVdsGroup(cluster.getId());
        }
    }) : Collections.<ClusterEditWarnings.Warning>emptyList();
    setReturnValue(new ClusterEditWarnings(hostWarnings, vmWarnings));
}
#method_after
@Override
protected void executeQueryCommand() {
    final VDSGroup oldCluster = backend.runQuery(VdcQueryType.GetVdsGroupById, getParameters()).getReturnValue();
    VDSGroup newCluster = getParameters().getNewCluster();
    List<ClusterEditWarnings.Warning> hostWarnings = getProblematicEntities(oldCluster, newCluster, hostCheckers, new ClusterEntityResolver<VDS>() {

        @Override
        public List<VDS> getClusterEntities(VDSGroup cluster) {
            return vdsDao.getAllForVdsGroup(cluster.getId());
        }
    });
    List<ClusterEditWarnings.Warning> vmWarnings = new ArrayList<>();
    if (oldCluster.supportsVirtService() && newCluster.supportsVirtService()) {
        vmWarnings = getProblematicEntities(oldCluster, newCluster, vmCheckers, new ClusterEntityResolver<VM>() {

            @Override
            public List<VM> getClusterEntities(VDSGroup cluster) {
                return vmDao.getAllForVdsGroup(cluster.getId());
            }
        });
    }
    setReturnValue(new ClusterEditWarnings(hostWarnings, vmWarnings));
}
#end_block

#method_before
protected void unlockVm() {
    // make VM property to null in order to refresh it from db
    setVm(null);
    if (getVm() != null) {
        if (getVm().getStatus() == VMStatus.ImageLocked) {
            VmHandler.unlockVm(getVm(), getCompensationContext());
        }
    } else {
        setLoggingForCommand();
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing endAction on Vm");
    }
}
#method_after
protected void unlockVm() {
    // Set VM property to null in order to refresh it from db
    setVm(null);
    if (getVm() != null) {
        if (getVm().getStatus() == VMStatus.ImageLocked) {
            VmHandler.unlockVm(getVm(), getCompensationContext());
        }
    } else {
        setLoggingForCommand();
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing endAction on Vm");
    }
}
#end_block

#method_before
static StorageServerConnections setUpEntityExpectations(StorageServerConnections entity, int index) {
    expect(entity.geIid()).andReturn(GUIDS[index].toString()).anyTimes();
    expect(entity.getStorageType()).andReturn(STORAGE_TYPES_MAPPED[index]).anyTimes();
    if (STORAGE_TYPES_MAPPED[index].equals(StorageType.ISCSI)) {
        expect(entity.getPort()).andReturn("3260").anyTimes();
        expect(entity.getConnection()).andReturn("1.122.10.125").anyTimes();
    }
    if (STORAGE_TYPES_MAPPED[index].equals(StorageType.NFS)) {
        expect(entity.getConnection()).andReturn("1.122.10.125:/data1").anyTimes();
    }
    return entity;
}
#method_after
static StorageServerConnections setUpEntityExpectations(StorageServerConnections entity, int index) {
    expect(entity.getId()).andReturn(GUIDS[index].toString()).anyTimes();
    expect(entity.getStorageType()).andReturn(STORAGE_TYPES_MAPPED[index]).anyTimes();
    if (STORAGE_TYPES_MAPPED[index].equals(StorageType.ISCSI)) {
        expect(entity.getPort()).andReturn("3260").anyTimes();
        expect(entity.getConnection()).andReturn("1.122.10.125").anyTimes();
    }
    if (STORAGE_TYPES_MAPPED[index].equals(StorageType.NFS)) {
        expect(entity.getConnection()).andReturn("1.122.10.125:/data1").anyTimes();
    }
    return entity;
}
#end_block

#method_before
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    if (Guid.isNullOrEmpty(storagePoolId) || !FeatureSupported.refreshLunSupported(DbFacade.getInstance().getStoragePoolDao().get(storagePoolId).getCompatibilityVersion())) {
        return new Pair<>(true, null);
    }
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, storagePoolId, StorageType.FCP, Arrays.asList(getFCPConnection())));
    boolean isSuccess = returnValue.getSucceeded();
    EngineFault engineFault = null;
    if (!isSuccess && returnValue.getVdsError() != null) {
        engineFault = new EngineFault();
        engineFault.setError(returnValue.getVdsError().getCode());
    }
    return new Pair<>(isSuccess, engineFault);
}
#method_after
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    if (Guid.isNullOrEmpty(storagePoolId) || !FeatureSupported.refreshLunSupported(DbFacade.getInstance().getStoragePoolDao().get(storagePoolId).getCompatibilityVersion())) {
        return new Pair<>(true, null);
    }
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, storagePoolId, StorageType.FCP, Arrays.asList(getFCPConnection())));
    boolean isSuccess = returnValue.getSucceeded();
    EngineFault engineFault = null;
    if (!isSuccess && returnValue.getVdsError() != null) {
        engineFault = new EngineFault();
        engineFault.setError(returnValue.getVdsError().getCode());
    }
    return new Pair<>(isSuccess, engineFault);
}
#end_block

#method_before
protected void runningFailed() {
    try {
        decreasePendingVm();
        getVdsBroker().removeAsyncRunningCommand(getVmId());
        setCommandShouldBeLogged(false);
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmOnDown();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#method_after
protected void runningFailed() {
    try {
        decreasePendingVm();
        getVdsBroker().RemoveAsyncRunningCommand(getVmId());
        setCommandShouldBeLogged(false);
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmOnDown();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#end_block

#method_before
public boolean isConnectionForISCSIDomainAttached(StorageDomain storageDomain) {
    List<StorageServerConnections> connectionsForDomain = getAllConnectionsForDomain(storageDomain.getId());
    for (StorageServerConnections connectionForDomain : connectionsForDomain) {
        if (connectionForDomain.geIid().equals(connection.geIid())) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean isConnectionForISCSIDomainAttached(StorageDomain storageDomain) {
    List<StorageServerConnections> connectionsForDomain = getAllConnectionsForDomain(storageDomain.getId());
    for (StorageServerConnections connectionForDomain : connectionsForDomain) {
        if (connectionForDomain.getId().equals(connection.getId())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    lun.setvolume_group_id(volumeGroupId);
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().update(lun);
    }
    if (storageType == StorageType.FCP) {
        // No need to handle connections (FCP storage doesn't utilize connections).
        return;
    }
    for (StorageServerConnections connection : lun.getLunConnections()) {
        StorageServerConnections dbConnection = ISCSIStorageHelper.findConnectionWithSameDetails(connection);
        if (dbConnection == null) {
            connection.setId(Guid.newGuid().toString());
            connection.setStorageType(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setId(dbConnection.geIid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUNStorageServerConnectionMapId(lun.getLUN_id(), connection.geIid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUNStorageServerConnectionMap(lun.getLUN_id(), connection.geIid()));
        }
    }
}
#method_after
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    lun.setvolume_group_id(volumeGroupId);
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().update(lun);
    }
    if (storageType == StorageType.FCP) {
        // No need to handle connections (FCP storage doesn't utilize connections).
        return;
    }
    for (StorageServerConnections connection : lun.getLunConnections()) {
        StorageServerConnections dbConnection = ISCSIStorageHelper.findConnectionWithSameDetails(connection);
        if (dbConnection == null) {
            connection.setId(Guid.newGuid().toString());
            connection.setStorageType(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setId(dbConnection.getId());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUNStorageServerConnectionMapId(lun.getLUN_id(), connection.getId())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUNStorageServerConnectionMap(lun.getLUN_id(), connection.getId()));
        }
    }
}
#end_block

#method_before
private void cleanConnection(StorageServerConnections connection, Guid hostId) {
    // then the id of connection will be empty, and there's nothing to delete.
    if (connection.geIid() != null && !connection.geIid().equals("")) {
        // $NON-NLS-1$
        Frontend.getInstance().runAction(VdcActionType.RemoveStorageServerConnection, new StorageServerConnectionParametersBase(connection, hostId), null, this);
    }
}
#method_after
private void cleanConnection(StorageServerConnections connection, Guid hostId) {
    // then the id of connection will be empty, and there's nothing to delete.
    if (connection.getId() != null && !connection.getId().equals("")) {
        // $NON-NLS-1$
        Frontend.getInstance().runAction(VdcActionType.RemoveStorageServerConnection, new StorageServerConnectionParametersBase(connection, hostId), null, this);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    boolean returnValue = super.equals(obj);
    if (!returnValue && obj != null && obj instanceof StorageServerConnections) {
        returnValue = (geIid() != null && !geIid().isEmpty() && geIid().equals(((StorageServerConnections) obj).geIid()));
    }
    return returnValue;
}
#method_after
@Override
public boolean equals(Object obj) {
    boolean returnValue = super.equals(obj);
    if (!returnValue && obj != null && obj instanceof StorageServerConnections) {
        returnValue = (getId() != null && !getId().isEmpty() && getId().equals(((StorageServerConnections) obj).getId()));
    }
    return returnValue;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((geIid() == null) ? 0 : geIid().hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((getId() == null) ? 0 : getId().hashCode());
    return result;
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", geIid()).append("connection", getConnection()).append("iqn", getIqn()).append("vfsType", getVfsType()).append("mountOptions", getMountOptions()).append("nfsVersion", getNfsVersion()).append("nfsRetrans", getNfsRetrans()).append("nfsTimeo", getNfsTimeo()).append("iface", getIface()).append("netIfaceName", getNetIfaceName()).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("connection", getConnection()).append("iqn", getIqn()).append("vfsType", getVfsType()).append("mountOptions", getMountOptions()).append("nfsVersion", getNfsVersion()).append("nfsRetrans", getNfsRetrans()).append("nfsTimeo", getNfsTimeo()).append("iface", getIface()).append("netIfaceName", getNetIfaceName()).build();
}
#end_block

#method_before
static StorageServerConnections setUpEntityExpectations(StorageServerConnections entity, int index) {
    expect(entity.geIid()).andReturn(GUIDS[index].toString()).anyTimes();
    expect(entity.getStorageType()).andReturn(STORAGE_TYPES_MAPPED[index]).anyTimes();
    expect(entity.getConnection()).andReturn("/data1").anyTimes();
    if (STORAGE_TYPES_MAPPED[index].equals(StorageType.ISCSI)) {
        expect(entity.getPort()).andReturn("3260").anyTimes();
    }
    return entity;
}
#method_after
static StorageServerConnections setUpEntityExpectations(StorageServerConnections entity, int index) {
    expect(entity.getId()).andReturn(GUIDS[index].toString()).anyTimes();
    expect(entity.getStorageType()).andReturn(STORAGE_TYPES_MAPPED[index]).anyTimes();
    expect(entity.getConnection()).andReturn("/data1").anyTimes();
    if (STORAGE_TYPES_MAPPED[index].equals(StorageType.ISCSI)) {
        expect(entity.getPort()).andReturn("3260").anyTimes();
    }
    return entity;
}
#end_block

#method_before
protected boolean isConnWithSameDetailsExists(StorageServerConnections connection, Guid storagePoolId) {
    List<StorageServerConnections> connections = null;
    if (connection.getStorageType() == StorageType.LOCALFS) {
        List<StorageServerConnections> connectionsForPool = storagePoolId == null ? Collections.<StorageServerConnections>emptyList() : getStorageConnDao().getAllConnectableStorageSeverConnection(storagePoolId);
        List<StorageServerConnections> connectionsForPath = getStorageConnDao().getAllForStorage(connection.getConnection());
        connections = (List<StorageServerConnections>) CollectionUtils.intersection(connectionsForPool, connectionsForPath);
    } else if (connection.getStorageType().isFileDomain()) {
        String connectionField = connection.getConnection();
        connections = getStorageConnDao().getAllForStorage(connectionField);
    } else {
        StorageServerConnections sameConnection = findConnectionWithSameDetails(connection);
        connections = sameConnection != null ? Arrays.asList(sameConnection) : Collections.<StorageServerConnections>emptyList();
    }
    boolean isDuplicateConnExists = (connections.size() > 1 || (connections.size() == 1 && !connections.get(0).geIid().equalsIgnoreCase(connection.geIid())));
    return isDuplicateConnExists;
}
#method_after
protected boolean isConnWithSameDetailsExists(StorageServerConnections connection, Guid storagePoolId) {
    List<StorageServerConnections> connections = null;
    if (connection.getStorageType() == StorageType.LOCALFS) {
        List<StorageServerConnections> connectionsForPool = storagePoolId == null ? Collections.<StorageServerConnections>emptyList() : getStorageConnDao().getAllConnectableStorageSeverConnection(storagePoolId);
        List<StorageServerConnections> connectionsForPath = getStorageConnDao().getAllForStorage(connection.getConnection());
        connections = (List<StorageServerConnections>) CollectionUtils.intersection(connectionsForPool, connectionsForPath);
    } else if (connection.getStorageType().isFileDomain()) {
        String connectionField = connection.getConnection();
        connections = getStorageConnDao().getAllForStorage(connectionField);
    } else {
        StorageServerConnections sameConnection = findConnectionWithSameDetails(connection);
        connections = sameConnection != null ? Arrays.asList(sameConnection) : Collections.<StorageServerConnections>emptyList();
    }
    boolean isDuplicateConnExists = (connections.size() > 1 || (connections.size() == 1 && !connections.get(0).getId().equalsIgnoreCase(connection.getId())));
    return isDuplicateConnExists;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Create a dummy lun
    LUNs dummyLun = createDummyLun();
    // Create storage server connection mapping
    LUNStorageServerConnectionMap connectionMapRecord = new LUNStorageServerConnectionMap(dummyLun.getLUN_id(), getParameters().getStorageConnectionId());
    List<StorageServerConnections> connectionsForDomain;
    if (getLunDao().get(dummyLun.getLUN_id()) == null) {
        getLunDao().save(dummyLun);
        // Save connection maps when creating the dummy lun for the first time
        connectionsForDomain = getStorageServerConnectionDao().getAllForDomain(getStorageDomainId());
        for (StorageServerConnections connection : connectionsForDomain) {
            saveConnection(new LUNStorageServerConnectionMap(dummyLun.getLUN_id(), connection.geIid()));
        }
    }
    // Save new connection map
    saveConnection(connectionMapRecord);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Create a dummy lun
    LUNs dummyLun = createDummyLun();
    // Create storage server connection mapping
    LUNStorageServerConnectionMap connectionMapRecord = new LUNStorageServerConnectionMap(dummyLun.getLUN_id(), getParameters().getStorageConnectionId());
    List<StorageServerConnections> connectionsForDomain;
    if (getLunDao().get(dummyLun.getLUN_id()) == null) {
        getLunDao().save(dummyLun);
        // Save connection maps when creating the dummy lun for the first time
        connectionsForDomain = getStorageServerConnectionDao().getAllForDomain(getStorageDomainId());
        for (StorageServerConnections connection : connectionsForDomain) {
            saveConnection(new LUNStorageServerConnectionMap(dummyLun.getLUN_id(), connection.getId()));
        }
    }
    // Save new connection map
    saveConnection(connectionMapRecord);
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void executeCommandNotFirstDummyLun() {
    LUNs dummyLun = new LUNs();
    dummyLun.setLUN_id(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX + domain.getId());
    when(lunDao.get(dummyLun.getLUN_id())).thenReturn(dummyLun);
    List<StorageServerConnections> connectionsForDomain = new ArrayList<>();
    StorageServerConnections connection = new StorageServerConnections();
    connection.setId(Guid.newGuid().toString());
    connection.setStorageType(StorageType.ISCSI);
    connection.setIqn("iqn.1.2.3.4.com");
    connection.setConnection("123.345.266.255");
    connectionsForDomain.add(connection);
    when(connectionDao.getAllForDomain(domain.getId())).thenReturn(connectionsForDomain);
    LUNStorageServerConnectionMapId map_id = new LUNStorageServerConnectionMapId(dummyLun.getLUN_id(), connection.geIid());
    when(lunMapDao.get(map_id)).thenReturn(null);
    // dummy lun already exists, thus no need to save
    verify(lunDao, never()).save(dummyLun);
    verify(lunMapDao, never()).save(new LUNStorageServerConnectionMap());
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void executeCommandNotFirstDummyLun() {
    LUNs dummyLun = new LUNs();
    dummyLun.setLUN_id(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX + domain.getId());
    when(lunDao.get(dummyLun.getLUN_id())).thenReturn(dummyLun);
    List<StorageServerConnections> connectionsForDomain = new ArrayList<>();
    StorageServerConnections connection = new StorageServerConnections();
    connection.setId(Guid.newGuid().toString());
    connection.setStorageType(StorageType.ISCSI);
    connection.setIqn("iqn.1.2.3.4.com");
    connection.setConnection("123.345.266.255");
    connectionsForDomain.add(connection);
    when(connectionDao.getAllForDomain(domain.getId())).thenReturn(connectionsForDomain);
    LUNStorageServerConnectionMapId map_id = new LUNStorageServerConnectionMapId(dummyLun.getLUN_id(), connection.getId());
    when(lunMapDao.get(map_id)).thenReturn(null);
    // dummy lun already exists, thus no need to save
    verify(lunDao, never()).save(dummyLun);
    verify(lunMapDao, never()).save(new LUNStorageServerConnectionMap());
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@Test
public void executeCommandFirstDummyLun() {
    LUNs dummyLun = new LUNs();
    dummyLun.setLUN_id(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX + domain.getId());
    when(lunDao.get(dummyLun.getLUN_id())).thenReturn(null);
    doNothing().when(lunDao).save(dummyLun);
    List<StorageServerConnections> connectionsForDomain = new ArrayList<>();
    StorageServerConnections connection = new StorageServerConnections();
    connection.setId(Guid.newGuid().toString());
    connection.setStorageType(StorageType.ISCSI);
    connection.setIqn("iqn.1.2.3.4.com");
    connection.setConnection("123.345.266.255");
    connectionsForDomain.add(connection);
    when(connectionDao.getAllForDomain(domain.getId())).thenReturn(connectionsForDomain);
    LUNStorageServerConnectionMapId map_id = new LUNStorageServerConnectionMapId(dummyLun.getLUN_id(), connection.geIid());
    when(lunMapDao.get(map_id)).thenReturn(null);
    LUNStorageServerConnectionMap map = new LUNStorageServerConnectionMap();
    doNothing().when(lunMapDao).save(map);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void executeCommandFirstDummyLun() {
    LUNs dummyLun = new LUNs();
    dummyLun.setLUN_id(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX + domain.getId());
    when(lunDao.get(dummyLun.getLUN_id())).thenReturn(null);
    doNothing().when(lunDao).save(dummyLun);
    List<StorageServerConnections> connectionsForDomain = new ArrayList<>();
    StorageServerConnections connection = new StorageServerConnections();
    connection.setId(Guid.newGuid().toString());
    connection.setStorageType(StorageType.ISCSI);
    connection.setIqn("iqn.1.2.3.4.com");
    connection.setConnection("123.345.266.255");
    connectionsForDomain.add(connection);
    when(connectionDao.getAllForDomain(domain.getId())).thenReturn(connectionsForDomain);
    LUNStorageServerConnectionMapId map_id = new LUNStorageServerConnectionMapId(dummyLun.getLUN_id(), connection.getId());
    when(lunMapDao.get(map_id)).thenReturn(null);
    LUNStorageServerConnectionMap map = new LUNStorageServerConnectionMap();
    doNothing().when(lunMapDao).save(map);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    VDSReturnValue returnValue = null;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateIfaces(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        returnValue = Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
        }
    }
    EngineFault engineFault = null;
    if (!isSuccess && returnValue.getVdsError() != null) {
        engineFault = new EngineFault();
        engineFault.setError(returnValue.getVdsError().getCode());
    }
    return new Pair<>(isSuccess, engineFault);
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    VDSReturnValue returnValue = null;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateIfaces(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
        }
    }
    EngineFault engineFault = null;
    if (!isSuccess && returnValue.getVdsError() != null) {
        engineFault = new EngineFault();
        engineFault.setError(returnValue.getVdsError().getCode());
    }
    return new Pair<>(isSuccess, engineFault);
}
#end_block

#method_before
public static List<StorageServerConnections> updateIfaces(List<StorageServerConnections> conns, Guid vdsId) {
    List<StorageServerConnections> res = new ArrayList<>(conns);
    for (StorageServerConnections conn : conns) {
        // Get list of endpoints (nics or vlans) that will initiate iscsi sessions.
        // Targets are represented by StorageServerConnections object (connection, iqn, port, portal).
        List<VdsNetworkInterface> ifaces = DbFacade.getInstance().getInterfaceDao().getIscsiIfacesByHostIdAndStorageTargetId(vdsId, conn.geIid());
        if (!ifaces.isEmpty()) {
            VdsNetworkInterface removedInterface = ifaces.remove(0);
            setInterfaceProperties(conn, removedInterface);
            // from more than one endpoint(initiator) we have to clone this connection per endpoint.
            for (VdsNetworkInterface iface : ifaces) {
                StorageServerConnections newConn = StorageServerConnections.copyOf(conn);
                newConn.setId(Guid.newGuid().toString());
                setInterfaceProperties(newConn, iface);
                res.add(newConn);
            }
        }
    }
    return res;
}
#method_after
public static List<StorageServerConnections> updateIfaces(List<StorageServerConnections> conns, Guid vdsId) {
    List<StorageServerConnections> res = new ArrayList<>(conns);
    for (StorageServerConnections conn : conns) {
        // Get list of endpoints (nics or vlans) that will initiate iscsi sessions.
        // Targets are represented by StorageServerConnections object (connection, iqn, port, portal).
        List<VdsNetworkInterface> ifaces = DbFacade.getInstance().getInterfaceDao().getIscsiIfacesByHostIdAndStorageTargetId(vdsId, conn.getId());
        if (!ifaces.isEmpty()) {
            VdsNetworkInterface removedInterface = ifaces.remove(0);
            setInterfaceProperties(conn, removedInterface);
            // from more than one endpoint(initiator) we have to clone this connection per endpoint.
            for (VdsNetworkInterface iface : ifaces) {
                StorageServerConnections newConn = StorageServerConnections.copyOf(conn);
                newConn.setId(Guid.newGuid().toString());
                setInterfaceProperties(newConn, iface);
                res.add(newConn);
            }
        }
    }
    return res;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected List<StorageServerConnections> filterConnectionsUsedByOthers(List<StorageServerConnections> connections, String vgId, final String lunId) {
    // if we have lun id then filter by this lun
    // else get vg's luns from db
    List<String> lunsByVg = lunId.isEmpty() ? DbFacade.getInstance().getLunDao().getAllForVolumeGroup(vgId).stream().map(LUNs::getLUN_id).collect(Collectors.toList()) : null;
    // if a luns were retrieved by vgId, they can belongs not only to storage but also to disks
    // at that case they should left at db
    List<String> lunsByVgWithNoDisks = new ArrayList<>();
    if (lunId.isEmpty()) {
        for (String lunIdByVg : lunsByVg) {
            if (DbFacade.getInstance().getDiskLunMapDao().getDiskIdByLunId(lunIdByVg) == null) {
                lunsByVgWithNoDisks.add(lunIdByVg);
            }
        }
    } else {
        lunsByVgWithNoDisks.add(lunId);
    }
    List<StorageServerConnections> toRemove = new ArrayList<>();
    for (StorageServerConnections connection : connections) {
        fillConnectionDetailsIfNeeded(connection);
        if (connection.geIid() != null) {
            List<String> list = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(connection.geIid()).stream().map(LUNs::getLUN_id).collect(Collectors.toList());
            if (0 < CollectionUtils.subtract(list, lunsByVgWithNoDisks).size()) {
                toRemove.add(connection);
            }
        }
    }
    return (List<StorageServerConnections>) CollectionUtils.subtract(connections, toRemove);
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected List<StorageServerConnections> filterConnectionsUsedByOthers(List<StorageServerConnections> connections, String vgId, final String lunId) {
    // if we have lun id then filter by this lun
    // else get vg's luns from db
    List<String> lunsByVg = lunId.isEmpty() ? DbFacade.getInstance().getLunDao().getAllForVolumeGroup(vgId).stream().map(LUNs::getLUN_id).collect(Collectors.toList()) : null;
    // if a luns were retrieved by vgId, they can belongs not only to storage but also to disks
    // at that case they should left at db
    List<String> lunsByVgWithNoDisks = new ArrayList<>();
    if (lunId.isEmpty()) {
        for (String lunIdByVg : lunsByVg) {
            if (DbFacade.getInstance().getDiskLunMapDao().getDiskIdByLunId(lunIdByVg) == null) {
                lunsByVgWithNoDisks.add(lunIdByVg);
            }
        }
    } else {
        lunsByVgWithNoDisks.add(lunId);
    }
    List<StorageServerConnections> toRemove = new ArrayList<>();
    for (StorageServerConnections connection : connections) {
        fillConnectionDetailsIfNeeded(connection);
        if (connection.getId() != null) {
            List<String> list = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(connection.getId()).stream().map(LUNs::getLUN_id).collect(Collectors.toList());
            if (0 < CollectionUtils.subtract(list, lunsByVgWithNoDisks).size()) {
                toRemove.add(connection);
            }
        }
    }
    return (List<StorageServerConnections>) CollectionUtils.subtract(connections, toRemove);
}
#end_block

#method_before
private void fillConnectionDetailsIfNeeded(StorageServerConnections connection) {
    // it from the db by its details.
    if (connection.geIid() == null) {
        StorageServerConnections dbConnection = findConnectionWithSameDetails(connection);
        if (dbConnection != null) {
            connection.setId(dbConnection.geIid());
        }
    }
}
#method_after
private void fillConnectionDetailsIfNeeded(StorageServerConnections connection) {
    // it from the db by its details.
    if (connection.getId() == null) {
        StorageServerConnections dbConnection = findConnectionWithSameDetails(connection);
        if (dbConnection != null) {
            connection.setId(dbConnection.getId());
        }
    }
}
#end_block

#method_before
@Override
public boolean storageDomainRemoved(StorageDomainStatic storageDomain) {
    List<StorageServerConnections> list = DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage());
    for (StorageServerConnections connection : filterConnectionsUsedByOthers(list, storageDomain.getStorage(), "")) {
        DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.geIid());
    }
    // There is no need to remove entries from lun_storage_server_connection_map,
    // as the foreign key from the luns table is defined as ON DELETE CASCADE.
    removeStorageDomainLuns(storageDomain);
    return true;
}
#method_after
@Override
public boolean storageDomainRemoved(StorageDomainStatic storageDomain) {
    List<StorageServerConnections> list = DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage());
    for (StorageServerConnections connection : filterConnectionsUsedByOthers(list, storageDomain.getStorage(), "")) {
        DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getId());
    }
    // There is no need to remove entries from lun_storage_server_connection_map,
    // as the foreign key from the luns table is defined as ON DELETE CASCADE.
    removeStorageDomainLuns(storageDomain);
    return true;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageServerConnections.class, to = org.ovirt.engine.api.model.StorageConnection.class)
public static StorageConnection map(StorageServerConnections entity, StorageConnection template) {
    StorageConnection model = template != null ? template : new StorageConnection();
    model.setId(entity.geIid());
    model.setType(map(entity.getStorageType(), null));
    if (entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI) {
        model.setAddress(entity.getConnection());
        model.setPort(Integer.parseInt(entity.getPort()));
        model.setUsername(entity.getUserName());
        model.setTarget(entity.getIqn());
    }
    if (entity.getStorageType().isFileDomain()) {
        setPath(entity, model);
    }
    if (entity.getStorageType().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.NFS)) {
        if (entity.getNfsVersion() != null) {
            model.setNfsVersion(entity.getNfsVersion().toString());
        }
        if (entity.getNfsRetrans() != null) {
            model.setNfsRetrans(entity.getNfsRetrans().intValue());
        }
        if (entity.getNfsTimeo() != null) {
            model.setNfsTimeo(entity.getNfsTimeo().intValue());
        }
        if (entity.getMountOptions() != null) {
            model.setMountOptions(entity.getMountOptions());
        }
    } else if (entity.getStorageType().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.POSIXFS) || entity.getStorageType().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.GLUSTERFS)) {
        model.setMountOptions(entity.getMountOptions());
        model.setVfsType(entity.getVfsType());
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageServerConnections.class, to = org.ovirt.engine.api.model.StorageConnection.class)
public static StorageConnection map(StorageServerConnections entity, StorageConnection template) {
    StorageConnection model = template != null ? template : new StorageConnection();
    model.setId(entity.getId());
    model.setType(map(entity.getStorageType(), null));
    if (entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI) {
        model.setAddress(entity.getConnection());
        model.setPort(Integer.parseInt(entity.getPort()));
        model.setUsername(entity.getUserName());
        model.setTarget(entity.getIqn());
    }
    if (entity.getStorageType().isFileDomain()) {
        setPath(entity, model);
    }
    if (entity.getStorageType().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.NFS)) {
        if (entity.getNfsVersion() != null) {
            model.setNfsVersion(entity.getNfsVersion().toString());
        }
        if (entity.getNfsRetrans() != null) {
            model.setNfsRetrans(entity.getNfsRetrans().intValue());
        }
        if (entity.getNfsTimeo() != null) {
            model.setNfsTimeo(entity.getNfsTimeo().intValue());
        }
        if (entity.getMountOptions() != null) {
            model.setMountOptions(entity.getMountOptions());
        }
    } else if (entity.getStorageType().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.POSIXFS) || entity.getStorageType().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.GLUSTERFS)) {
        model.setMountOptions(entity.getMountOptions());
        model.setVfsType(entity.getVfsType());
    }
    return model;
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getTagDao();
    existingTag = dao.get(EXISTING_TAG_ID);
    existingTag = dao.get(new Guid("d3ec3e01-ca89-48e1-8b43-a9b38f873b0c"));
    parent = new Guid("6d849ebf-755f-4552-ad09-9a090cda105d");
    user = new Guid("9bf7c640-b620-456f-a550-0348f366544a");
    vm = new Guid("77296e00-0cad-4e5a-9299-008a7b6f4355");
    template = new Guid("77296e00-0cad-4e5a-9299-008a7b6f4355");
    vmPool = new Guid("103cfd1d-18b1-4790-8a0c-1e52621b0076");
    newTag = new Tags();
    newTag.setTagName("newtagname");
    newTag.setIsReadonly(true);
    newTag.setDescription("newtagdescription");
    newTag.setParentId(parent);
    existingUserGroupTag = dao.getTagUserGroupByGroupIdAndByTagId(EXISTING_TAG_ID, EXISTING_GROUP_ID);
    existingUserTag = dao.getTagUserByTagIdAndByuserId(EXISTING_TAG_ID, EXISTING_USER_ID);
    existingVdsTag = dao.getTagVdsByTagIdAndByVdsId(EXISTING_TAG_ID, EXISTING_VDS_ID);
    newVdsTag = new TagsVdsMap(EXISTING_TAG_ID, FREE_VDS_ID);
    existingVmTag = dao.getTagVmByTagIdAndByVmId(EXISTING_TAG_ID, EXISTING_VM_ID);
    existingTemplateTag = dao.getTagTemplateByTagIdAndByTemplateId(EXISTING_TAG_ID, EXISTING_TEMPLATE_ID);
    newVmTag = new TagsVmMap(EXISTING_TAG_ID, FREE_VM_ID);
    newTemplateTag = new TagsTemplateMap(EXISTING_TAG_ID, FREE_TEMPLATE_ID);
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getTagDao();
    existingTag = dao.get(EXISTING_TAG_ID);
    existingTag = dao.get(new Guid("d3ec3e01-ca89-48e1-8b43-a9b38f873b0c"));
    parent = new Guid("6d849ebf-755f-4552-ad09-9a090cda105d");
    user = new Guid("9bf7c640-b620-456f-a550-0348f366544a");
    vm = new Guid("77296e00-0cad-4e5a-9299-008a7b6f4355");
    template = new Guid("77296e00-0cad-4e5a-9299-008a7b6f4355");
    vmPool = new Guid("103cfd1d-18b1-4790-8a0c-1e52621b0076");
    newTag = new Tags();
    newTag.settag_name("newtagname");
    newTag.setIsReadonly(true);
    newTag.setdescription("newtagdescription");
    newTag.setparent_id(parent);
    existingUserGroupTag = dao.getTagUserGroupByGroupIdAndByTagId(EXISTING_TAG_ID, EXISTING_GROUP_ID);
    existingUserTag = dao.getTagUserByTagIdAndByuserId(EXISTING_TAG_ID, EXISTING_USER_ID);
    existingVdsTag = dao.getTagVdsByTagIdAndByVdsId(EXISTING_TAG_ID, EXISTING_VDS_ID);
    newVdsTag = new TagsVdsMap(EXISTING_TAG_ID, FREE_VDS_ID);
    existingVmTag = dao.getTagVmByTagIdAndByVmId(EXISTING_TAG_ID, EXISTING_VM_ID);
    existingTemplateTag = dao.getTagTemplateByTagIdAndByTemplateId(EXISTING_TAG_ID, EXISTING_TEMPLATE_ID);
    newVmTag = new TagsVmMap(EXISTING_TAG_ID, FREE_VM_ID);
    newTemplateTag = new TagsTemplateMap(EXISTING_TAG_ID, FREE_TEMPLATE_ID);
}
#end_block

#method_before
@Test
public void testGet() {
    Tags result = dao.get(existingTag.getTagId());
    assertNotNull(result);
    assertEquals(existingTag, result);
}
#method_after
@Test
public void testGet() {
    Tags result = dao.get(existingTag.gettag_id());
    assertNotNull(result);
    assertEquals(existingTag, result);
}
#end_block

#method_before
@Test
public void testGetByName() {
    Tags result = dao.getByName(existingTag.getTagName());
    assertNotNull(result);
    assertEquals(existingTag, result);
}
#method_after
@Test
public void testGetByName() {
    Tags result = dao.getByName(existingTag.gettag_name());
    assertNotNull(result);
    assertEquals(existingTag, result);
}
#end_block

#method_before
@Test
public void testGetAllForParent() {
    List<Tags> result = dao.getAllForParent(parent);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (Tags tag : result) {
        assertEquals(parent, tag.getParentId());
    }
}
#method_after
@Test
public void testGetAllForParent() {
    List<Tags> result = dao.getAllForParent(parent);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (Tags tag : result) {
        assertEquals(parent, tag.getparent_id());
    }
}
#end_block

#method_before
@Test
public void testGetAllForUserGroup() {
    List<Tags> result = dao.getAllForUserGroups("b399944a-81ab-4ec5-8266-e19ba7c3c9d1");
    assertNotNull(result);
    assertFalse(result.isEmpty());
// FIXME: Fix this test - userGroup is not set
/*

        Guid userGroupId = new Guid("b399944a-81ab-4ec5-8266-e19ba7c3c9d1");

        for (tags tag : result) {
            assertEquals(userGroupId, tag.getUserGroup().geIid());
        }*/
}
#method_after
@Test
public void testGetAllForUserGroup() {
    List<Tags> result = dao.getAllForUserGroups("b399944a-81ab-4ec5-8266-e19ba7c3c9d1");
    assertNotNull(result);
    assertFalse(result.isEmpty());
// FIXME: Fix this test - userGroup is not set
/*

        Guid userGroupId = new Guid("b399944a-81ab-4ec5-8266-e19ba7c3c9d1");

        for (tags tag : result) {
            assertEquals(userGroupId, tag.getUserGroup().getId());
        }*/
}
#end_block

#method_before
@Test
public void testGetAllVmTagsWithIds() {
    List<Tags> result = dao.getAllVmTagsWithIds(existingTag.getTagId().toString());
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#method_after
@Test
public void testGetAllVmTagsWithIds() {
    List<Tags> result = dao.getAllVmTagsWithIds(existingTag.gettag_id().toString());
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#end_block

#method_before
@Test
public void testSave() {
    dao.save(newTag);
    Tags result = dao.get(newTag.getTagId());
    assertNotNull(result);
    assertEquals(newTag, result);
}
#method_after
@Test
public void testSave() {
    dao.save(newTag);
    Tags result = dao.get(newTag.gettag_id());
    assertNotNull(result);
    assertEquals(newTag, result);
}
#end_block

#method_before
@Test
public void testUpdate() {
    existingTag.setDescription("this is the updated description!");
    dao.update(existingTag);
    Tags result = dao.get(existingTag.getTagId());
    assertEquals(existingTag, result);
}
#method_after
@Test
public void testUpdate() {
    existingTag.setdescription("this is the updated description!");
    dao.update(existingTag);
    Tags result = dao.get(existingTag.gettag_id());
    assertEquals(existingTag, result);
}
#end_block

#method_before
@Test
public void testRemove() {
    dao.remove(existingTag.getTagId());
    Tags result = dao.get(existingTag.getTagId());
    assertNull(result);
}
#method_after
@Test
public void testRemove() {
    dao.remove(existingTag.gettag_id());
    Tags result = dao.get(existingTag.gettag_id());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetTagUserGroupByGroupIdAndTagId() {
    TagsUserGroupMap result = dao.getTagUserGroupByGroupIdAndByTagId(existingUserGroupTag.getTagId(), existingUserGroupTag.getGroupId());
    assertNotNull(result);
    assertEqualsTagUserGroupMap(existingUserGroupTag, result);
}
#method_after
@Test
public void testGetTagUserGroupByGroupIdAndTagId() {
    TagsUserGroupMap result = dao.getTagUserGroupByGroupIdAndByTagId(existingUserGroupTag.gettag_id(), existingUserGroupTag.getgroup_id());
    assertNotNull(result);
    assertEqualsTagUserGroupMap(existingUserGroupTag, result);
}
#end_block

#method_before
private void assertEqualsTagUserGroupMap(TagsUserGroupMap existing, TagsUserGroupMap result) {
    assertEquals("Group IDs not equal", existing.getGroupId(), result.getGroupId());
    assertEquals("Tag IDs not equal", existing.getTagId(), result.getTagId());
    assertEquals("Object equation", existing, result);
}
#method_after
private void assertEqualsTagUserGroupMap(TagsUserGroupMap existing, TagsUserGroupMap result) {
    assertEquals("Group IDs not equal", existing.getgroup_id(), result.getgroup_id());
    assertEquals("Tag IDs not equal", existing.gettag_id(), result.gettag_id());
    assertEquals("Object equation", existing, result);
}
#end_block

#method_before
@Test
public void testDetachUserGroupFromTag() {
    dao.detachUserGroupFromTag(existingUserGroupTag.getTagId(), existingUserGroupTag.getGroupId());
    TagsUserGroupMap result = dao.getTagUserGroupByGroupIdAndByTagId(existingUserGroupTag.getTagId(), existingUserGroupTag.getGroupId());
    assertNull(result);
}
#method_after
@Test
public void testDetachUserGroupFromTag() {
    dao.detachUserGroupFromTag(existingUserGroupTag.gettag_id(), existingUserGroupTag.getgroup_id());
    TagsUserGroupMap result = dao.getTagUserGroupByGroupIdAndByTagId(existingUserGroupTag.gettag_id(), existingUserGroupTag.getgroup_id());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetUserTag() {
    TagsUserMap result = dao.getTagUserByTagIdAndByuserId(existingUserTag.getTagId(), existingUserTag.getUserId());
    assertNotNull(result);
    assertEqualsTagUserMap(existingUserTag, result);
}
#method_after
@Test
public void testGetUserTag() {
    TagsUserMap result = dao.getTagUserByTagIdAndByuserId(existingUserTag.gettag_id(), existingUserTag.getuser_id());
    assertNotNull(result);
    assertEqualsTagUserMap(existingUserTag, result);
}
#end_block

#method_before
private void assertEqualsTagUserMap(TagsUserMap existing, TagsUserMap result) {
    assertEquals("Tag ID is not equal", existing.getTagId(), result.getTagId());
    assertEquals("USER ID is not equal", existing.getUserId(), result.getUserId());
    assertEquals("Object equation", existing, result);
}
#method_after
private void assertEqualsTagUserMap(TagsUserMap existing, TagsUserMap result) {
    assertEquals("Tag ID is not equal", existing.gettag_id(), result.gettag_id());
    assertEquals("USER ID is not equal", existing.getuser_id(), result.getuser_id());
    assertEquals("Object equation", existing, result);
}
#end_block

#method_before
@Test
public void testGetTagVdsMap() {
    TagsVdsMap result = dao.getTagVdsByTagIdAndByVdsId(existingVdsTag.getTagId(), existingVdsTag.getVdsId());
    assertNotNull(result);
    assertEqualsTagsVdsMap(existingVdsTag, result);
}
#method_after
@Test
public void testGetTagVdsMap() {
    TagsVdsMap result = dao.getTagVdsByTagIdAndByVdsId(existingVdsTag.gettag_id(), existingVdsTag.getvds_id());
    assertNotNull(result);
    assertEqualsTagsVdsMap(existingVdsTag, result);
}
#end_block

#method_before
private void assertEqualsTagsVdsMap(TagsVdsMap existing, TagsVdsMap result) {
    assertEquals("Tag ID is not equal", existing.getTagId(), result.getTagId());
    assertEquals("VDS ID is not equal", existing.getVdsId(), result.getVdsId());
    assertEquals("Object equation", existing, result);
}
#method_after
private void assertEqualsTagsVdsMap(TagsVdsMap existing, TagsVdsMap result) {
    assertEquals("Tag ID is not equal", existing.gettag_id(), result.gettag_id());
    assertEquals("VDS ID is not equal", existing.getvds_id(), result.getvds_id());
    assertEquals("Object equation", existing, result);
}
#end_block

#method_before
@Test
public void testAttachVdsToTag() {
    dao.attachVdsToTag(newVdsTag);
    TagsVdsMap result = dao.getTagVdsByTagIdAndByVdsId(newVdsTag.getTagId(), newVdsTag.getVdsId());
    assertNotNull(result);
    assertEqualsTagsVdsMap(newVdsTag, result);
}
#method_after
@Test
public void testAttachVdsToTag() {
    dao.attachVdsToTag(newVdsTag);
    TagsVdsMap result = dao.getTagVdsByTagIdAndByVdsId(newVdsTag.gettag_id(), newVdsTag.getvds_id());
    assertNotNull(result);
    assertEqualsTagsVdsMap(newVdsTag, result);
}
#end_block

#method_before
@Test
public void testDetachVdsFromTag() {
    dao.detachVdsFromTag(existingVdsTag.getTagId(), existingVdsTag.getVdsId());
    TagsVdsMap result = dao.getTagVdsByTagIdAndByVdsId(existingVdsTag.getTagId(), existingVdsTag.getVdsId());
    assertNull(result);
}
#method_after
@Test
public void testDetachVdsFromTag() {
    dao.detachVdsFromTag(existingVdsTag.gettag_id(), existingVdsTag.getvds_id());
    TagsVdsMap result = dao.getTagVdsByTagIdAndByVdsId(existingVdsTag.gettag_id(), existingVdsTag.getvds_id());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetTagVmMapByTag() {
    TagsVmMap result = dao.getTagVmByTagIdAndByVmId(existingVmTag.getTagId(), existingVmTag.getVmId());
    assertNotNull(result);
    assertEqualsTagsVmMap(existingVmTag, result);
}
#method_after
@Test
public void testGetTagVmMapByTag() {
    TagsVmMap result = dao.getTagVmByTagIdAndByVmId(existingVmTag.gettag_id(), existingVmTag.getvm_id());
    assertNotNull(result);
    assertEqualsTagsVmMap(existingVmTag, result);
}
#end_block

#method_before
@Test
public void testGetTagTemplateMapByTag() {
    TagsTemplateMap result = dao.getTagTemplateByTagIdAndByTemplateId(existingTemplateTag.getTagId(), existingTemplateTag.getTemplateId());
    assertNotNull(result);
    assertEqualsTagsTemplateMap(existingTemplateTag, result);
}
#method_after
@Test
public void testGetTagTemplateMapByTag() {
    TagsTemplateMap result = dao.getTagTemplateByTagIdAndByTemplateId(existingTemplateTag.gettag_id(), existingTemplateTag.gettemplate_id());
    assertNotNull(result);
    assertEqualsTagsTemplateMap(existingTemplateTag, result);
}
#end_block

#method_before
private void assertEqualsTagsVmMap(TagsVmMap existing, TagsVmMap result) {
    assertEquals("TG is not equal", existing.getTagId(), result.getTagId());
    assertEquals("VM id not equal ", existing.getVmId(), result.getVmId());
    assertEquals("Object equation", existing, result);
}
#method_after
private void assertEqualsTagsVmMap(TagsVmMap existing, TagsVmMap result) {
    assertEquals("TG is not equal", existing.gettag_id(), result.gettag_id());
    assertEquals("VM id not equal ", existing.getvm_id(), result.getvm_id());
    assertEquals("Object equation", existing, result);
}
#end_block

#method_before
private void assertEqualsTagsTemplateMap(TagsTemplateMap existing, TagsTemplateMap result) {
    assertEquals("TG is not equal", existing.getTagId(), result.getTagId());
    assertEquals("Template id not equal ", existing.getTemplateId(), result.getTemplateId());
    assertEquals("Object equation", existing, result);
}
#method_after
private void assertEqualsTagsTemplateMap(TagsTemplateMap existing, TagsTemplateMap result) {
    assertEquals("TG is not equal", existing.gettag_id(), result.gettag_id());
    assertEquals("Template id not equal ", existing.gettemplate_id(), result.gettemplate_id());
    assertEquals("Object equation", existing, result);
}
#end_block

#method_before
@Test
public void testAttachVmToTag() {
    dao.attachVmToTag(newVmTag);
    TagsVmMap result = dao.getTagVmByTagIdAndByVmId(newVmTag.getTagId(), newVmTag.getVmId());
    assertNotNull(result);
    assertEqualsTagsVmMap(newVmTag, result);
}
#method_after
@Test
public void testAttachVmToTag() {
    dao.attachVmToTag(newVmTag);
    TagsVmMap result = dao.getTagVmByTagIdAndByVmId(newVmTag.gettag_id(), newVmTag.getvm_id());
    assertNotNull(result);
    assertEqualsTagsVmMap(newVmTag, result);
}
#end_block

#method_before
@Test
public void testAttachTemplateToTag() {
    dao.attachTemplateToTag(newTemplateTag);
    TagsTemplateMap result = dao.getTagTemplateByTagIdAndByTemplateId(newTemplateTag.getTagId(), newTemplateTag.getTemplateId());
    assertNotNull(result);
    assertEqualsTagsTemplateMap(newTemplateTag, result);
}
#method_after
@Test
public void testAttachTemplateToTag() {
    dao.attachTemplateToTag(newTemplateTag);
    TagsTemplateMap result = dao.getTagTemplateByTagIdAndByTemplateId(newTemplateTag.gettag_id(), newTemplateTag.gettemplate_id());
    assertNotNull(result);
    assertEqualsTagsTemplateMap(newTemplateTag, result);
}
#end_block

#method_before
@Test
public void updateVmTag() {
    existingVmTag.setDefaultDisplayType(existingVmTag.getDefaultDisplayType() + 1);
    dao.updateDefaultDisplayForVmTag(existingVmTag);
    TagsVmMap result = dao.getTagVmByTagIdAndByVmId(existingVmTag.getTagId(), existingVmTag.getVmId());
    assertNotNull(result);
    assertEqualsTagsVmMap(existingVmTag, result);
}
#method_after
@Test
public void updateVmTag() {
    existingVmTag.setDefaultDisplayType(existingVmTag.getDefaultDisplayType() + 1);
    dao.updateDefaultDisplayForVmTag(existingVmTag);
    TagsVmMap result = dao.getTagVmByTagIdAndByVmId(existingVmTag.gettag_id(), existingVmTag.getvm_id());
    assertNotNull(result);
    assertEqualsTagsVmMap(existingVmTag, result);
}
#end_block

#method_before
@Test
public void testDetachVmFromTag() {
    dao.detachVmFromTag(existingVmTag.getTagId(), existingVmTag.getVmId());
    TagsVmMap result = dao.getTagVmByTagIdAndByVmId(existingVmTag.getTagId(), existingVmTag.getVmId());
    assertNull(result);
}
#method_after
@Test
public void testDetachVmFromTag() {
    dao.detachVmFromTag(existingVmTag.gettag_id(), existingVmTag.getvm_id());
    TagsVmMap result = dao.getTagVmByTagIdAndByVmId(existingVmTag.gettag_id(), existingVmTag.getvm_id());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testDetachTemplateFromTag() {
    dao.detachTemplateFromTag(existingTemplateTag.getTagId(), existingTemplateTag.getTemplateId());
    TagsTemplateMap result = dao.getTagTemplateByTagIdAndByTemplateId(existingTemplateTag.getTagId(), existingTemplateTag.getTemplateId());
    assertNull(result);
}
#method_after
@Test
public void testDetachTemplateFromTag() {
    dao.detachTemplateFromTag(existingTemplateTag.gettag_id(), existingTemplateTag.gettemplate_id());
    TagsTemplateMap result = dao.getTagTemplateByTagIdAndByTemplateId(existingTemplateTag.gettag_id(), existingTemplateTag.gettemplate_id());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetTagVmMapByByVmIdAndDefaultTag() {
    List<TagsVmMap> result = dao.getTagVmMapByVmIdAndDefaultTag(EXISTING_VM_ID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (TagsVmMap mapping : result) {
        assertEquals(EXISTING_VM_ID, mapping.getVmId());
    }
}
#method_after
@Test
public void testGetTagVmMapByByVmIdAndDefaultTag() {
    List<TagsVmMap> result = dao.getTagVmMapByVmIdAndDefaultTag(EXISTING_VM_ID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (TagsVmMap mapping : result) {
        assertEquals(EXISTING_VM_ID, mapping.getvm_id());
    }
}
#end_block

#method_before
public Map<String, String> createStructFromConnection(final StorageServerConnections connection, final StoragePool storagePool, final Guid vdsId) {
    Pair<String, String> credentials = getStorageConnectionCredentialsForhost(vdsId, connection);
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.geIid(), Guid.Empty.toString());
    con.put("connection", connection.getConnection(), "");
    con.putIfNotEmpty("tpgt", connection.getPortal());
    con.put("port", connection.getPort(), "");
    con.put("iqn", connection.getIqn(), "");
    con.put("user", credentials.getFirst(), "");
    con.put("password", credentials.getSecond(), "");
    con.putIfNotEmpty("ifaceName", connection.getIface());
    con.putIfNotEmpty("netIfaceName", connection.getNetIfaceName());
    // through vds which has no storage pool
    if (storagePool == null || Config.<Boolean>getValue(ConfigValues.AdvancedNFSOptionsEnabled, storagePool.getCompatibilityVersion().getValue())) {
        // For mnt_options, vfs_type, and protocol_version - if they are null
        // or empty we should not send a key with an empty value
        con.putIfNotEmpty("mnt_options", connection.getMountOptions());
        con.putIfNotEmpty("vfs_type", connection.getVfsType());
        if (connection.getNfsVersion() != null) {
            con.put("protocol_version", connection.getNfsVersion().getValue());
        }
        con.putIfNotEmpty("timeout", connection.getNfsTimeo());
        con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    }
    return con;
}
#method_after
public Map<String, String> createStructFromConnection(final StorageServerConnections connection, final StoragePool storagePool, final Guid vdsId) {
    Pair<String, String> credentials = getStorageConnectionCredentialsForhost(vdsId, connection);
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getId(), Guid.Empty.toString());
    con.put("connection", connection.getConnection(), "");
    con.putIfNotEmpty("tpgt", connection.getPortal());
    con.put("port", connection.getPort(), "");
    con.put("iqn", connection.getIqn(), "");
    con.put("user", credentials.getFirst(), "");
    con.put("password", credentials.getSecond(), "");
    con.putIfNotEmpty("ifaceName", connection.getIface());
    con.putIfNotEmpty("netIfaceName", connection.getNetIfaceName());
    // through vds which has no storage pool
    if (storagePool == null || Config.<Boolean>getValue(ConfigValues.AdvancedNFSOptionsEnabled, storagePool.getCompatibilityVersion().getValue())) {
        // For mnt_options, vfs_type, and protocol_version - if they are null
        // or empty we should not send a key with an empty value
        con.putIfNotEmpty("mnt_options", connection.getMountOptions());
        con.putIfNotEmpty("vfs_type", connection.getVfsType());
        if (connection.getNfsVersion() != null) {
            con.put("protocol_version", connection.getNfsVersion().getValue());
        }
        con.putIfNotEmpty("timeout", connection.getNfsTimeo());
        con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    }
    return con;
}
#end_block

#method_before
private List<String> getStorageConnectionsMissingInDataCenter(Collection<String> storageConnections, Guid dataCenterId) {
    Set<String> existingConnIds = new HashSet<>();
    List<String> res = new LinkedList<>();
    List<StorageServerConnections> dcStorageConnections = getDBFacade().getStorageServerConnectionDao().getConnectableStorageConnectionsByStorageType(dataCenterId, StorageType.ISCSI);
    for (StorageServerConnections conn : dcStorageConnections) {
        existingConnIds.add(conn.geIid());
    }
    for (String id : storageConnections) {
        if (!existingConnIds.contains(id)) {
            res.add(id);
        }
    }
    return res;
}
#method_after
private List<String> getStorageConnectionsMissingInDataCenter(Collection<String> storageConnections, Guid dataCenterId) {
    Set<String> existingConnIds = new HashSet<>();
    List<String> res = new LinkedList<>();
    List<StorageServerConnections> dcStorageConnections = getDBFacade().getStorageServerConnectionDao().getConnectableStorageConnectionsByStorageType(dataCenterId, StorageType.ISCSI);
    for (StorageServerConnections conn : dcStorageConnections) {
        existingConnIds.add(conn.getId());
    }
    for (String id : storageConnections) {
        if (!existingConnIds.contains(id)) {
            res.add(id);
        }
    }
    return res;
}
#end_block

#method_before
@Test
public void checkRemoveNotExistingConnection() {
    parameters.setStorageServerConnection(NFSConnection);
    when(storageServerConnectionDao.get(NFSConnection.geIid())).thenReturn(null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
}
#method_after
@Test
public void checkRemoveNotExistingConnection() {
    parameters.setStorageServerConnection(NFSConnection);
    when(storageServerConnectionDao.get(NFSConnection.getId())).thenReturn(null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
}
#end_block

#method_before
@Test
public void checkRemoveNFSConnectionDomainsExist() {
    parameters.setStorageServerConnection(NFSConnection);
    when(storageServerConnectionDao.get(NFSConnection.geIid())).thenReturn(NFSConnection);
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(NFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageName("domain1");
    StorageDomain domain2 = new StorageDomain();
    domain2.setStorage(NFSConnection.getConnection());
    domain2.setStatus(StorageDomainStatus.Maintenance);
    domain2.setStorageName("domain2");
    domains.add(domain1);
    domains.add(domain2);
    doReturn(domains).when(command).getStorageDomainsByConnId(NFSConnection.geIid());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
}
#method_after
@Test
public void checkRemoveNFSConnectionDomainsExist() {
    parameters.setStorageServerConnection(NFSConnection);
    when(storageServerConnectionDao.get(NFSConnection.getId())).thenReturn(NFSConnection);
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(NFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageName("domain1");
    StorageDomain domain2 = new StorageDomain();
    domain2.setStorage(NFSConnection.getConnection());
    domain2.setStatus(StorageDomainStatus.Maintenance);
    domain2.setStorageName("domain2");
    domains.add(domain1);
    domains.add(domain2);
    doReturn(domains).when(command).getStorageDomainsByConnId(NFSConnection.getId());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
}
#end_block

#method_before
@Test
public void checkRemoveNFSConnectionNoDomain() {
    parameters.setStorageServerConnection(NFSConnection);
    when(storageServerConnectionDao.get(NFSConnection.geIid())).thenReturn(NFSConnection);
    List<StorageDomain> domains = new ArrayList<>();
    doReturn(domains).when(command).getStorageDomainsByConnId(NFSConnection.geIid());
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void checkRemoveNFSConnectionNoDomain() {
    parameters.setStorageServerConnection(NFSConnection);
    when(storageServerConnectionDao.get(NFSConnection.getId())).thenReturn(NFSConnection);
    List<StorageDomain> domains = new ArrayList<>();
    doReturn(domains).when(command).getStorageDomainsByConnId(NFSConnection.getId());
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void checkRemoveIscsiConnectionDomainsExist() {
    parameters.setStorageServerConnection(iSCSIConnection);
    when(storageServerConnectionDao.get(iSCSIConnection.geIid())).thenReturn(iSCSIConnection);
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain1");
    lun1.setvolume_group_id("G95OWd-Wvck-vftu-pMq9-9SAC-NF3E-ulDPsQ");
    luns.add(lun1);
    when(lunDao.getAllForStorageServerConnection(iSCSIConnection.geIid())).thenReturn(luns);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
}
#method_after
@Test
public void checkRemoveIscsiConnectionDomainsExist() {
    parameters.setStorageServerConnection(iSCSIConnection);
    when(storageServerConnectionDao.get(iSCSIConnection.getId())).thenReturn(iSCSIConnection);
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain1");
    lun1.setvolume_group_id("G95OWd-Wvck-vftu-pMq9-9SAC-NF3E-ulDPsQ");
    luns.add(lun1);
    when(lunDao.getAllForStorageServerConnection(iSCSIConnection.getId())).thenReturn(luns);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
}
#end_block

#method_before
@Test
public void checkRemoveIscsiConnectionDomainsAndDisksExist() {
    parameters.setStorageServerConnection(iSCSIConnection);
    when(storageServerConnectionDao.get(iSCSIConnection.geIid())).thenReturn(iSCSIConnection);
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain1");
    lun1.setvolume_group_id("G95OWd-Wvck-vftu-pMq9-9SAC-NF3E-ulDPsQ");
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setStorageDomainName("");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    luns.add(lun2);
    when(lunDao.getAllForStorageServerConnection(iSCSIConnection.geIid())).thenReturn(luns);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS_AND_DISKS);
}
#method_after
@Test
public void checkRemoveIscsiConnectionDomainsAndDisksExist() {
    parameters.setStorageServerConnection(iSCSIConnection);
    when(storageServerConnectionDao.get(iSCSIConnection.getId())).thenReturn(iSCSIConnection);
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain1");
    lun1.setvolume_group_id("G95OWd-Wvck-vftu-pMq9-9SAC-NF3E-ulDPsQ");
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setStorageDomainName("");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    luns.add(lun2);
    when(lunDao.getAllForStorageServerConnection(iSCSIConnection.getId())).thenReturn(luns);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS_AND_DISKS);
}
#end_block

#method_before
@Test
public void checkRemoveIscsiConnectionDisksExist() {
    parameters.setStorageServerConnection(iSCSIConnection);
    when(storageServerConnectionDao.get(iSCSIConnection.geIid())).thenReturn(iSCSIConnection);
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain1");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setStorageDomainName("storagedomain4");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    luns.add(lun2);
    when(lunDao.getAllForStorageServerConnection(iSCSIConnection.geIid())).thenReturn(luns);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_DISKS);
}
#method_after
@Test
public void checkRemoveIscsiConnectionDisksExist() {
    parameters.setStorageServerConnection(iSCSIConnection);
    when(storageServerConnectionDao.get(iSCSIConnection.getId())).thenReturn(iSCSIConnection);
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain1");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setStorageDomainName("storagedomain4");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    luns.add(lun2);
    when(lunDao.getAllForStorageServerConnection(iSCSIConnection.getId())).thenReturn(luns);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_DISKS);
}
#end_block

#method_before
@Test
public void checkExecuteCommandWithVdsId() {
    parameters.setStorageServerConnection(NFSConnection);
    doNothing().when(storageServerConnectionDao).remove(NFSConnection.geIid());
    doReturn(true).when(command).disconnectStorage();
    command.executeCommand();
}
#method_after
@Test
public void checkExecuteCommandWithVdsId() {
    parameters.setStorageServerConnection(NFSConnection);
    doNothing().when(storageServerConnectionDao).remove(NFSConnection.getId());
    doReturn(true).when(command).disconnectStorage();
    command.executeCommand();
}
#end_block

#method_before
@Test
public void checkExecuteCommandWithEmptyVdsId() {
    parameters.setStorageServerConnection(NFSConnection);
    parameters.setVdsId(Guid.Empty);
    doNothing().when(storageServerConnectionDao).remove(NFSConnection.geIid());
    // Test will fail if we try to disconnect
    command.executeCommand();
    verify(command, never()).disconnectStorage();
}
#method_after
@Test
public void checkExecuteCommandWithEmptyVdsId() {
    parameters.setStorageServerConnection(NFSConnection);
    parameters.setVdsId(Guid.Empty);
    doNothing().when(storageServerConnectionDao).remove(NFSConnection.getId());
    // Test will fail if we try to disconnect
    command.executeCommand();
    verify(command, never()).disconnectStorage();
}
#end_block

#method_before
@Test
public void checkExecuteCommandWithNullVdsId() {
    parameters.setStorageServerConnection(NFSConnection);
    parameters.setVdsId(null);
    doNothing().when(storageServerConnectionDao).remove(NFSConnection.geIid());
    // Test will fail if we try to disconnect
    command.executeCommand();
    verify(command, never()).disconnectStorage();
}
#method_after
@Test
public void checkExecuteCommandWithNullVdsId() {
    parameters.setStorageServerConnection(NFSConnection);
    parameters.setVdsId(null);
    doNothing().when(storageServerConnectionDao).remove(NFSConnection.getId());
    // Test will fail if we try to disconnect
    command.executeCommand();
    verify(command, never()).disconnectStorage();
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(final StorageServerConnections connection) {
    return getIdParameterSource(connection.geIid()).addValue("connection", connection.getConnection()).addValue("iqn", connection.getIqn()).addValue("port", connection.getPort()).addValue("portal", connection.getPortal()).addValue("password", DbFacadeUtils.encryptPassword(connection.getPassword())).addValue("storage_type", connection.getStorageType()).addValue("user_name", connection.getUserName()).addValue("mount_options", connection.getMountOptions()).addValue("vfs_type", connection.getVfsType()).addValue("nfs_version", (connection.getNfsVersion() != null) ? connection.getNfsVersion().getValue() : null).addValue("nfs_timeo", connection.getNfsTimeo()).addValue("nfs_retrans", connection.getNfsRetrans());
}
#method_after
private MapSqlParameterSource getFullParameterSource(final StorageServerConnections connection) {
    return getIdParameterSource(connection.getId()).addValue("connection", connection.getConnection()).addValue("iqn", connection.getIqn()).addValue("port", connection.getPort()).addValue("portal", connection.getPortal()).addValue("password", DbFacadeUtils.encryptPassword(connection.getPassword())).addValue("storage_type", connection.getStorageType()).addValue("user_name", connection.getUserName()).addValue("mount_options", connection.getMountOptions()).addValue("vfs_type", connection.getVfsType()).addValue("nfs_version", (connection.getNfsVersion() != null) ? connection.getNfsVersion().getValue() : null).addValue("nfs_timeo", connection.getNfsTimeo()).addValue("nfs_retrans", connection.getNfsRetrans());
}
#end_block

#method_before
@Test
public void testConnectionWithValidMountOptionsSucceeds() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.NFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(ValidationResult.VALID).when(getCommand()).validateMountOptions();
    when(getCommand().getStorageConnDao().get(newPosixConnection.geIid())).thenReturn(newPosixConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(getCommand());
}
#method_after
@Test
public void testConnectionWithValidMountOptionsSucceeds() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.NFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(ValidationResult.VALID).when(getCommand()).validateMountOptions();
    when(getCommand().getStorageConnDao().get(newPosixConnection.getId())).thenReturn(newPosixConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(getCommand());
}
#end_block

#method_before
public Map<String, String> createVdsDeployParams(String hostname, String heAgentGateway) {
    if (hostedEngineVm == null) {
        return Collections.emptyMap();
    }
    HashMap params = new HashMap<>();
    params.put("fqdn", EngineLocalConfig.getInstance().getHost());
    params.put("vmid", hostedEngineVm.getId().toString());
    params.put("storage", sd.getConnection());
    params.put("conf", getBackupConfPath());
    params.put("host_id", offerHostId(hostedEngineVm.getVdsGroupId()));
    params.put("domainType", getStorageType());
    params.put("spUUID", hostedEngineVm.getStoragePoolId().toString());
    params.put("sdUUID", getStorageDomainStatic().getId().toString());
    params.put("connectionUUID", sdConnection.geIid().toString());
    params.put("iqn", sdConnection.getIqn());
    params.put("portal", sdConnection.getPort());
    params.put("user", sdConnection.getUserName());
    params.put("password", sdConnection.getPassword());
    params.put("port", sdConnection.getPort());
    params.put("ca_cert", getCaCertPath());
    params.put("ca_subject", hostname);
    params.put("vdsm_use_ssl", Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication).toString());
    params.put("gateway", heAgentGateway);
    if (hostedEngineVm.getDiskList() != null) {
        for (int i = 0; i < hostedEngineVm.getDiskList().size(); i++) {
            params.put("vm_disk_id[" + i + "]", hostedEngineVm.getDiskList().get(i).getImageId().toString());
            params.put("vm_disk_vol_id[" + i + "]", hostedEngineVm.getDiskList().get(i).getImage().getDiskId().toString());
        }
    }
    return params;
}
#method_after
public Map<String, String> createVdsDeployParams(String hostname, String heAgentGateway) {
    if (hostedEngineVm == null) {
        return Collections.emptyMap();
    }
    HashMap params = new HashMap<>();
    params.put("fqdn", EngineLocalConfig.getInstance().getHost());
    params.put("vmid", hostedEngineVm.getId().toString());
    params.put("storage", sd.getConnection());
    params.put("conf", getBackupConfPath());
    params.put("host_id", offerHostId(hostedEngineVm.getVdsGroupId()));
    params.put("domainType", getStorageType());
    params.put("spUUID", hostedEngineVm.getStoragePoolId().toString());
    params.put("sdUUID", getStorageDomainStatic().getId().toString());
    params.put("connectionUUID", sdConnection.getId().toString());
    params.put("iqn", sdConnection.getIqn());
    params.put("portal", sdConnection.getPort());
    params.put("user", sdConnection.getUserName());
    params.put("password", sdConnection.getPassword());
    params.put("port", sdConnection.getPort());
    params.put("ca_cert", getCaCertPath());
    params.put("ca_subject", hostname);
    params.put("vdsm_use_ssl", Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication).toString());
    params.put("gateway", heAgentGateway);
    if (hostedEngineVm.getDiskList() != null) {
        for (int i = 0; i < hostedEngineVm.getDiskList().size(); i++) {
            params.put("vm_disk_id[" + i + "]", hostedEngineVm.getDiskList().get(i).getImageId().toString());
            params.put("vm_disk_vol_id[" + i + "]", hostedEngineVm.getDiskList().get(i).getImage().getDiskId().toString());
        }
    }
    return params;
}
#end_block

#method_before
@Test
public void checkPosixStorageConnectionsMappingsToBll() {
    StorageServerConnections connection = new StorageServerConnections();
    Guid connId = Guid.newGuid();
    connection.setId(connId.toString());
    connection.setStorageType(org.ovirt.engine.core.common.businessentities.storage.StorageType.POSIXFS);
    connection.setConnection("1.2.135.255:/myshare/data");
    connection.setVfsType("nfs");
    connection.setMountOptions("timeo=30");
    StorageConnection RESTConnection = new StorageConnection();
    RESTConnection.setId(connId.toString());
    RESTConnection.setType(StorageType.POSIXFS.toString().toLowerCase());
    RESTConnection.setAddress("1.2.135.255");
    RESTConnection.setPath("/myshare/data");
    RESTConnection.setVfsType("nfs");
    RESTConnection.setMountOptions("timeo=30");
    StorageServerConnections mappedResult = StorageDomainMapper.map(RESTConnection, null);
    assertEquals(connection.geIid(), mappedResult.geIid());
    assertEquals(connection.getStorageType(), mappedResult.getStorageType());
    assertEquals(connection.getConnection(), mappedResult.getConnection());
    assertEquals(connection.getVfsType(), mappedResult.getVfsType());
    assertEquals(connection.getMountOptions(), mappedResult.getMountOptions());
}
#method_after
@Test
public void checkPosixStorageConnectionsMappingsToBll() {
    StorageServerConnections connection = new StorageServerConnections();
    Guid connId = Guid.newGuid();
    connection.setId(connId.toString());
    connection.setStorageType(org.ovirt.engine.core.common.businessentities.storage.StorageType.POSIXFS);
    connection.setConnection("1.2.135.255:/myshare/data");
    connection.setVfsType("nfs");
    connection.setMountOptions("timeo=30");
    StorageConnection RESTConnection = new StorageConnection();
    RESTConnection.setId(connId.toString());
    RESTConnection.setType(StorageType.POSIXFS.toString().toLowerCase());
    RESTConnection.setAddress("1.2.135.255");
    RESTConnection.setPath("/myshare/data");
    RESTConnection.setVfsType("nfs");
    RESTConnection.setMountOptions("timeo=30");
    StorageServerConnections mappedResult = StorageDomainMapper.map(RESTConnection, null);
    assertEquals(connection.getId(), mappedResult.getId());
    assertEquals(connection.getStorageType(), mappedResult.getStorageType());
    assertEquals(connection.getConnection(), mappedResult.getConnection());
    assertEquals(connection.getVfsType(), mappedResult.getVfsType());
    assertEquals(connection.getMountOptions(), mappedResult.getMountOptions());
}
#end_block

#method_before
@Test
public void checkNFSStorageConnectionsMappingsToBll() {
    StorageServerConnections connection = new StorageServerConnections();
    Guid connId = Guid.newGuid();
    connection.setId(connId.toString());
    connection.setStorageType(org.ovirt.engine.core.common.businessentities.storage.StorageType.NFS);
    connection.setConnection("1.2.135.255:/myshare/data");
    connection.setNfsRetrans((short) 200);
    connection.setNfsTimeo((short) 400);
    connection.setNfsVersion(org.ovirt.engine.core.common.businessentities.NfsVersion.V3);
    connection.setMountOptions("tcp");
    StorageConnection RESTConnection = new StorageConnection();
    RESTConnection.setId(connId.toString());
    RESTConnection.setType(StorageType.NFS.toString().toLowerCase());
    RESTConnection.setAddress("1.2.135.255");
    RESTConnection.setPath("/myshare/data");
    RESTConnection.setNfsRetrans(200);
    RESTConnection.setNfsTimeo(400);
    RESTConnection.setNfsVersion(NfsVersion.V3.toString());
    RESTConnection.setMountOptions("tcp");
    StorageServerConnections mappedResult = StorageDomainMapper.map(RESTConnection, null);
    assertEquals(connection.geIid(), mappedResult.geIid());
    assertEquals(connection.getStorageType(), mappedResult.getStorageType());
    assertEquals(connection.getConnection(), mappedResult.getConnection());
    assertEquals(connection.getNfsRetrans(), mappedResult.getNfsRetrans());
    assertEquals(connection.getNfsTimeo(), mappedResult.getNfsTimeo());
    assertEquals(connection.getNfsVersion(), mappedResult.getNfsVersion());
    assertEquals(connection.getMountOptions(), mappedResult.getMountOptions());
}
#method_after
@Test
public void checkNFSStorageConnectionsMappingsToBll() {
    StorageServerConnections connection = new StorageServerConnections();
    Guid connId = Guid.newGuid();
    connection.setId(connId.toString());
    connection.setStorageType(org.ovirt.engine.core.common.businessentities.storage.StorageType.NFS);
    connection.setConnection("1.2.135.255:/myshare/data");
    connection.setNfsRetrans((short) 200);
    connection.setNfsTimeo((short) 400);
    connection.setNfsVersion(org.ovirt.engine.core.common.businessentities.NfsVersion.V3);
    connection.setMountOptions("tcp");
    StorageConnection RESTConnection = new StorageConnection();
    RESTConnection.setId(connId.toString());
    RESTConnection.setType(StorageType.NFS.toString().toLowerCase());
    RESTConnection.setAddress("1.2.135.255");
    RESTConnection.setPath("/myshare/data");
    RESTConnection.setNfsRetrans(200);
    RESTConnection.setNfsTimeo(400);
    RESTConnection.setNfsVersion(NfsVersion.V3.toString());
    RESTConnection.setMountOptions("tcp");
    StorageServerConnections mappedResult = StorageDomainMapper.map(RESTConnection, null);
    assertEquals(connection.getId(), mappedResult.getId());
    assertEquals(connection.getStorageType(), mappedResult.getStorageType());
    assertEquals(connection.getConnection(), mappedResult.getConnection());
    assertEquals(connection.getNfsRetrans(), mappedResult.getNfsRetrans());
    assertEquals(connection.getNfsTimeo(), mappedResult.getNfsTimeo());
    assertEquals(connection.getNfsVersion(), mappedResult.getNfsVersion());
    assertEquals(connection.getMountOptions(), mappedResult.getMountOptions());
}
#end_block

#method_before
@Test
public void checkISCSISStorageConnectionsMappingsToBll() {
    StorageServerConnections connection = new StorageServerConnections();
    Guid connId = Guid.newGuid();
    connection.setId(connId.toString());
    connection.setIqn("iqn.my.target1");
    connection.setPort("3260");
    connection.setStorageType(org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI);
    connection.setConnection("1.2.135.255");
    connection.setUserName("myuser1");
    connection.setPassword("123");
    StorageConnection RESTConnection = new StorageConnection();
    RESTConnection.setId(connId.toString());
    RESTConnection.setType(StorageType.ISCSI.toString().toLowerCase());
    RESTConnection.setPort(3260);
    RESTConnection.setTarget("iqn.my.target1");
    RESTConnection.setAddress("1.2.135.255");
    RESTConnection.setUsername("myuser1");
    RESTConnection.setPassword("123");
    StorageServerConnections mappedResult = StorageDomainMapper.map(RESTConnection, null);
    assertEquals(mappedResult.geIid(), mappedResult.geIid());
    assertEquals(mappedResult.getStorageType(), mappedResult.getStorageType());
    assertEquals(mappedResult.getConnection(), mappedResult.getConnection());
    assertEquals(mappedResult.getIqn(), mappedResult.getIqn());
    assertEquals(mappedResult.getUserName(), mappedResult.getUserName());
    assertEquals(mappedResult.getPassword(), mappedResult.getPassword());
    assertEquals(mappedResult.getPort(), mappedResult.getPort());
}
#method_after
@Test
public void checkISCSISStorageConnectionsMappingsToBll() {
    StorageServerConnections connection = new StorageServerConnections();
    Guid connId = Guid.newGuid();
    connection.setId(connId.toString());
    connection.setIqn("iqn.my.target1");
    connection.setPort("3260");
    connection.setStorageType(org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI);
    connection.setConnection("1.2.135.255");
    connection.setUserName("myuser1");
    connection.setPassword("123");
    StorageConnection RESTConnection = new StorageConnection();
    RESTConnection.setId(connId.toString());
    RESTConnection.setType(StorageType.ISCSI.toString().toLowerCase());
    RESTConnection.setPort(3260);
    RESTConnection.setTarget("iqn.my.target1");
    RESTConnection.setAddress("1.2.135.255");
    RESTConnection.setUsername("myuser1");
    RESTConnection.setPassword("123");
    StorageServerConnections mappedResult = StorageDomainMapper.map(RESTConnection, null);
    assertEquals(mappedResult.getId(), mappedResult.getId());
    assertEquals(mappedResult.getStorageType(), mappedResult.getStorageType());
    assertEquals(mappedResult.getConnection(), mappedResult.getConnection());
    assertEquals(mappedResult.getIqn(), mappedResult.getIqn());
    assertEquals(mappedResult.getUserName(), mappedResult.getUserName());
    assertEquals(mappedResult.getPassword(), mappedResult.getPassword());
    assertEquals(mappedResult.getPort(), mappedResult.getPort());
}
#end_block

#method_before
@Test
public void addNewConnectionWithVds() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setId("");
    parameters.setStorageServerConnection(newPosixConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    Pair<Boolean, Integer> connectResult = new Pair(true, 0);
    doReturn(connectResult).when(command).connectHostToStorage();
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.geIid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void addNewConnectionWithVds() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setId("");
    parameters.setStorageServerConnection(newPosixConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    Pair<Boolean, Integer> connectResult = new Pair(true, 0);
    doReturn(connectResult).when(command).connectHostToStorage();
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getId());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@Test
public void addNewConnectionEmptyVdsId() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setId("");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.geIid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void addNewConnectionEmptyVdsId() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setId("");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(Guid.Empty);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getId());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@Test
public void addNewConnectionNullVdsId() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setId("");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(null);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.geIid());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void addNewConnectionNullVdsId() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    newPosixConnection.setId("");
    parameters.setStorageServerConnection(newPosixConnection);
    parameters.setVdsId(null);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    doReturn(null).when(command).getConnectionFromDbById(newPosixConnection.getId());
    doNothing().when(command).saveConnection(newPosixConnection);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@Override
public void removeLun(LUNs lun) {
    if (lun.getvolume_group_id().isEmpty()) {
        DbFacade.getInstance().getLunDao().remove(lun.getLUN_id());
        for (StorageServerConnections connection : filterConnectionsUsedByOthers(lun.getLunConnections(), "", lun.getLUN_id())) {
            DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.geIid());
        }
    }
}
#method_after
@Override
public void removeLun(LUNs lun) {
    if (lun.getvolume_group_id().isEmpty()) {
        DbFacade.getInstance().getLunDao().remove(lun.getLUN_id());
        for (StorageServerConnections connection : filterConnectionsUsedByOthers(lun.getLunConnections(), "", lun.getLUN_id())) {
            DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getId());
        }
    }
}
#end_block

#method_before
private String getConnectionDescription(List<StorageServerConnections> connections, String connectionId) {
    // Using Guid in order to handle nulls. This can happened when we trying
    // to import an existing domain
    Guid connectionIdGuid = Guid.createGuidFromStringDefaultEmpty(connectionId);
    for (StorageServerConnections connection : connections) {
        Guid connectionGuid = Guid.createGuidFromStringDefaultEmpty(connection.geIid());
        if (connectionGuid.equals(connectionIdGuid)) {
            String desc = connection.getConnection();
            if (connection.getIqn() != null) {
                desc += " " + connection.getIqn();
            }
            return desc;
        }
    }
    return "";
}
#method_after
private String getConnectionDescription(List<StorageServerConnections> connections, String connectionId) {
    // Using Guid in order to handle nulls. This can happened when we trying
    // to import an existing domain
    Guid connectionIdGuid = Guid.createGuidFromStringDefaultEmpty(connectionId);
    for (StorageServerConnections connection : connections) {
        Guid connectionGuid = Guid.createGuidFromStringDefaultEmpty(connection.getId());
        if (connectionGuid.equals(connectionIdGuid)) {
            String desc = connection.getConnection();
            if (connection.getIqn() != null) {
                desc += " " + connection.getIqn();
            }
            return desc;
        }
    }
    return "";
}
#end_block

#method_before
@Test
public void checkNoHost() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    parameters.setVdsId(null);
    parameters.setStorageServerConnection(newNFSConnection);
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(oldNFSConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void checkNoHost() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    parameters.setVdsId(null);
    parameters.setStorageServerConnection(newNFSConnection);
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(oldNFSConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void checkEmptyIdHost() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    parameters.setVdsId(Guid.Empty);
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(oldNFSConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void checkEmptyIdHost() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    parameters.setVdsId(Guid.Empty);
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(oldNFSConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void updateChangeConnectionType() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.geIid())).thenReturn(oldNFSConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_CHANGE_STORAGE_TYPE);
}
#method_after
@Test
public void updateChangeConnectionType() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getId())).thenReturn(oldNFSConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_CHANGE_STORAGE_TYPE);
}
#end_block

#method_before
@Test
public void updateNonExistingConnection() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(null);
    parameters.setStorageServerConnection(newNFSConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
}
#method_after
@Test
public void updateNonExistingConnection() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(null);
    parameters.setStorageServerConnection(newNFSConnection);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
}
#end_block

#method_before
@Test
public void updateSeveralConnectionsWithSamePath() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    List<StorageServerConnections> connections = new ArrayList<>();
    StorageServerConnections conn1 = new StorageServerConnections();
    conn1.setConnection(newNFSConnection.getConnection());
    conn1.setId(newNFSConnection.geIid());
    StorageServerConnections conn2 = new StorageServerConnections();
    conn2.setConnection(newNFSConnection.getConnection());
    conn2.setId(Guid.newGuid().toString());
    connections.add(conn1);
    connections.add(conn2);
    when(storageConnDao.getAllForStorage(newNFSConnection.getConnection())).thenReturn(connections);
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(oldNFSConnection);
    doReturn(true).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
}
#method_after
@Test
public void updateSeveralConnectionsWithSamePath() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    List<StorageServerConnections> connections = new ArrayList<>();
    StorageServerConnections conn1 = new StorageServerConnections();
    conn1.setConnection(newNFSConnection.getConnection());
    conn1.setId(newNFSConnection.getId());
    StorageServerConnections conn2 = new StorageServerConnections();
    conn2.setConnection(newNFSConnection.getConnection());
    conn2.setId(Guid.newGuid().toString());
    connections.add(conn1);
    connections.add(conn2);
    when(storageConnDao.getAllForStorage(newNFSConnection.getConnection())).thenReturn(connections);
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(oldNFSConnection);
    doReturn(true).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
}
#end_block

#method_before
@Test
public void updateConnectionOfSeveralDomains() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newNFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageName("domain1");
    StorageDomain domain2 = new StorageDomain();
    domain2.setStorage(newNFSConnection.getConnection());
    domain2.setStatus(StorageDomainStatus.Maintenance);
    domain2.setStorageName("domain2");
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(oldNFSConnection);
    initDomainListForConnection(newNFSConnection.geIid(), domain1, domain2);
    doReturn(false).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
    assertTrue(messages.contains("$domainNames domain1,domain2"));
}
#method_after
@Test
public void updateConnectionOfSeveralDomains() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newNFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageName("domain1");
    StorageDomain domain2 = new StorageDomain();
    domain2.setStorage(newNFSConnection.getConnection());
    domain2.setStatus(StorageDomainStatus.Maintenance);
    domain2.setStorageName("domain2");
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(oldNFSConnection);
    initDomainListForConnection(newNFSConnection.getId(), domain1, domain2);
    doReturn(false).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
    assertTrue(messages.contains("$domainNames domain1,domain2"));
}
#end_block

#method_before
@Test
public void updateConnectionOfActiveDomain() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newNFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    initDomainListForConnection(newNFSConnection.geIid(), domain1);
    parameters.setStorageServerConnection(newNFSConnection);
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(oldNFSConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
}
#method_after
@Test
public void updateConnectionOfActiveDomain() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newNFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    initDomainListForConnection(newNFSConnection.getId(), domain1);
    parameters.setStorageServerConnection(newNFSConnection);
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(oldNFSConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
}
#end_block

#method_before
@Test
public void updateConnectionOfDomainsAndLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    LUNs lun3 = new LUNs();
    lun3.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun3.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun3.setStorageDomainId(storageDomainId);
    lun3.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun3);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Down);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDao.getForDisk(diskId1, true)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.geIid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    when(storageDomainDao.get(storageDomainId)).thenReturn(domain1);
    when(storagePoolIsoMapDao.getAllForStorage(storageDomainId)).thenReturn(Collections.singletonList(new StoragePoolIsoMap(storageDomainId, Guid.newGuid(), StorageDomainStatus.Active)));
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
    assertTrue(messages.contains("$vmNames vm1"));
    assertTrue(messages.contains("$domainNames storagedomain4"));
}
#method_after
@Test
public void updateConnectionOfDomainsAndLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    LUNs lun3 = new LUNs();
    lun3.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun3.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun3.setStorageDomainId(storageDomainId);
    lun3.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun3);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Down);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDao.getForDisk(diskId1, true)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getId())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    when(storageDomainDao.get(storageDomainId)).thenReturn(domain1);
    when(storagePoolIsoMapDao.getAllForStorage(storageDomainId)).thenReturn(Collections.singletonList(new StoragePoolIsoMap(storageDomainId, Guid.newGuid(), StorageDomainStatus.Active)));
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
    assertTrue(messages.contains("$vmNames vm1"));
    assertTrue(messages.contains("$domainNames storagedomain4"));
}
#end_block

#method_before
@Test
public void updateConnectionOfLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Paused);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDao.getForDisk(diskId1, true)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.geIid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
    assertTrue(messages.contains("$vmNames vm1,vm2"));
}
#method_after
@Test
public void updateConnectionOfLunDisks() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setvolume_group_id("");
    lun1.setDiskAlias("disk1");
    Guid diskId1 = Guid.newGuid();
    lun1.setDiskId(diskId1);
    luns.add(lun1);
    LUNs lun2 = new LUNs();
    lun2.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun2.setvolume_group_id("");
    lun2.setDiskAlias("disk2");
    Guid diskId2 = Guid.newGuid();
    lun2.setDiskId(diskId2);
    luns.add(lun2);
    Map<Boolean, List<VM>> vmsMap = new HashMap<>();
    VM vm1 = new VM();
    vm1.setName("vm1");
    vm1.setStatus(VMStatus.Up);
    VM vm2 = new VM();
    vm2.setName("vm2");
    vm2.setStatus(VMStatus.Paused);
    VM vm3 = new VM();
    vm3.setName("vm3");
    vm3.setStatus(VMStatus.Up);
    List<VM> pluggedVms = new ArrayList<>();
    pluggedVms.add(vm1);
    pluggedVms.add(vm2);
    List<VM> unPluggedVms = new ArrayList<>();
    unPluggedVms.add(vm3);
    vmsMap.put(Boolean.FALSE, unPluggedVms);
    vmsMap.put(Boolean.TRUE, pluggedVms);
    when(vmDao.getForDisk(diskId1, true)).thenReturn(vmsMap);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getId())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
    assertTrue(messages.contains("$vmNames vm1,vm2"));
}
#end_block

#method_before
@Test
public void updateConnectionOfDomains() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun1.setStorageDomainId(storageDomainId);
    lun1.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun1);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.geIid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    domains.add(domain1);
    when(storageDomainDao.get(storageDomainId)).thenReturn(domain1);
    when(storagePoolIsoMapDao.getAllForStorage(storageDomainId)).thenReturn(Collections.singletonList(new StoragePoolIsoMap(storageDomainId, Guid.newGuid(), StorageDomainStatus.Active)));
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
    assertTrue(messages.contains("$domainNames storagedomain4"));
}
#method_after
@Test
public void updateConnectionOfDomains() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun1.setStorageDomainId(storageDomainId);
    lun1.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun1);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getId())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Active);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    domains.add(domain1);
    when(storageDomainDao.get(storageDomainId)).thenReturn(domain1);
    when(storagePoolIsoMapDao.getAllForStorage(storageDomainId)).thenReturn(Collections.singletonList(new StoragePoolIsoMap(storageDomainId, Guid.newGuid(), StorageDomainStatus.Active)));
    List<String> messages = CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
    assertTrue(messages.contains("$domainNames storagedomain4"));
}
#end_block

#method_before
@Test
public void updateConnectionOfUnattachedBlockDomain() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun1.setStorageDomainId(storageDomainId);
    lun1.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun1);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.geIid())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Unknown);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Unattached);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    domains.add(domain1);
    when(storageDomainDao.get(storageDomainId)).thenReturn(domain1);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void updateConnectionOfUnattachedBlockDomain() {
    StorageServerConnections iscsiConnection = createISCSIConnection("10.35.16.25", StorageType.ISCSI, "iqn.2013-04.myhat.com:aaa-target1", "3260", "user1", "mypassword123");
    List<LUNs> luns = new ArrayList<>();
    LUNs lun1 = new LUNs();
    lun1.setLUN_id("3600144f09dbd05000000517e730b1212");
    lun1.setStorageDomainName("storagedomain4");
    Guid storageDomainId = Guid.newGuid();
    lun1.setStorageDomainId(storageDomainId);
    lun1.setvolume_group_id(Guid.newGuid().toString());
    luns.add(lun1);
    parameters.setStorageServerConnection(iscsiConnection);
    when(storageConnDao.get(iscsiConnection.getId())).thenReturn(iscsiConnection);
    doReturn(luns).when(command).getLuns();
    List<StorageDomain> domains = new ArrayList<>();
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(iscsiConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Unknown);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Unattached);
    domain1.setId(storageDomainId);
    domain1.setStorageName("storagedomain4");
    domains.add(domain1);
    when(storageDomainDao.get(storageDomainId)).thenReturn(domain1);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void updateConnectionOfUnattachedFileDomain() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newNFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Unknown);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Unattached);
    initDomainListForConnection(newNFSConnection.geIid(), domain1);
    parameters.setStorageServerConnection(newNFSConnection);
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(oldNFSConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void updateConnectionOfUnattachedFileDomain() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newNFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Unknown);
    domain1.setStorageDomainSharedStatus(StorageDomainSharedStatus.Unattached);
    initDomainListForConnection(newNFSConnection.getId(), domain1);
    parameters.setStorageServerConnection(newNFSConnection);
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(oldNFSConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void updateConnectionNoDomain() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    List<StorageDomain> domains = new ArrayList<>();
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(oldNFSConnection);
    doReturn(domains).when(command).getStorageDomainsByConnId(newNFSConnection.geIid());
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void updateConnectionNoDomain() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    List<StorageDomain> domains = new ArrayList<>();
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(oldNFSConnection);
    doReturn(domains).when(command).getStorageDomainsByConnId(newNFSConnection.getId());
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void succeedCanDoActionNFS() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newNFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Maintenance);
    initDomainListForConnection(newNFSConnection.geIid(), domain1);
    when(storageConnDao.get(newNFSConnection.geIid())).thenReturn(oldNFSConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void succeedCanDoActionNFS() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newNFSConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Maintenance);
    initDomainListForConnection(newNFSConnection.getId(), domain1);
    when(storageConnDao.get(newNFSConnection.getId())).thenReturn(oldNFSConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newNFSConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void succeedCanDoActionPosix() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newPosixConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Maintenance);
    initDomainListForConnection(newPosixConnection.geIid(), domain1);
    parameters.setStorageServerConnection(newPosixConnection);
    when(storageConnDao.get(newPosixConnection.geIid())).thenReturn(oldPosixConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void succeedCanDoActionPosix() {
    StorageServerConnections newPosixConnection = createPosixConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data1", StorageType.POSIXFS, "nfs", "timeo=30");
    parameters.setStorageServerConnection(newPosixConnection);
    StorageDomain domain1 = new StorageDomain();
    domain1.setStorage(newPosixConnection.getConnection());
    domain1.setStatus(StorageDomainStatus.Maintenance);
    initDomainListForConnection(newPosixConnection.getId(), domain1);
    parameters.setStorageServerConnection(newPosixConnection);
    when(storageConnDao.get(newPosixConnection.getId())).thenReturn(oldPosixConnection);
    doReturn(false).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void succeedUpdateNFSCommandWithDomain() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    VDSReturnValue returnValueConnectSuccess = new VDSReturnValue();
    StoragePoolIsoMap map = new StoragePoolIsoMap();
    returnValueConnectSuccess.setSucceeded(true);
    StorageDomainDynamic domainDynamic = new StorageDomainDynamic();
    StorageDomain domain = createDomain(domainDynamic);
    doReturn(Collections.singletonList(map)).when(command).getStoragePoolIsoMap(domain);
    returnValueConnectSuccess.setReturnValue(domain);
    doReturn(returnValueConnectSuccess).when(command).getStatsForDomain(domain);
    doReturn(true).when(command).connectToStorage();
    doNothing().when(storageConnDao).update(newNFSConnection);
    doNothing().when(storageDomainDynamicDao).update(domainDynamic);
    List<StorageDomain> domains = new ArrayList<>();
    domains.add(domain);
    doReturn(domains).when(command).getStorageDomainsByConnId(newNFSConnection.geIid());
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Locked);
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Maintenance);
    doNothing().when(command).disconnectFromStorage();
    doNothing().when(command).updateStorageDomain(domains);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#method_after
@Test
public void succeedUpdateNFSCommandWithDomain() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    VDSReturnValue returnValueConnectSuccess = new VDSReturnValue();
    StoragePoolIsoMap map = new StoragePoolIsoMap();
    returnValueConnectSuccess.setSucceeded(true);
    StorageDomainDynamic domainDynamic = new StorageDomainDynamic();
    StorageDomain domain = createDomain(domainDynamic);
    doReturn(Collections.singletonList(map)).when(command).getStoragePoolIsoMap(domain);
    returnValueConnectSuccess.setReturnValue(domain);
    doReturn(returnValueConnectSuccess).when(command).getStatsForDomain(domain);
    doReturn(true).when(command).connectToStorage();
    doNothing().when(storageConnDao).update(newNFSConnection);
    doNothing().when(storageDomainDynamicDao).update(domainDynamic);
    List<StorageDomain> domains = new ArrayList<>();
    domains.add(domain);
    doReturn(domains).when(command).getStorageDomainsByConnId(newNFSConnection.getId());
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Locked);
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Maintenance);
    doNothing().when(command).disconnectFromStorage();
    doNothing().when(command).updateStorageDomain(domains);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
}
#end_block

#method_before
@Test
public void failUpdateStats() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    VDSReturnValue returnValueUpdate = new VDSReturnValue();
    returnValueUpdate.setSucceeded(false);
    StorageDomain domain = createDomain(new StorageDomainDynamic());
    initDomainListForConnection(newNFSConnection.geIid(), domain);
    StorageDomainDynamic domainDynamic = new StorageDomainDynamic();
    StoragePoolIsoMap map = new StoragePoolIsoMap();
    doReturn(Collections.singletonList(map)).when(command).getStoragePoolIsoMap(domain);
    doReturn(returnValueUpdate).when(command).getStatsForDomain(domain);
    doReturn(true).when(command).connectToStorage();
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Locked);
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Maintenance);
    doNothing().when(command).disconnectFromStorage();
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
    verify(storageDomainDynamicDao, never()).update(domainDynamic);
}
#method_after
@Test
public void failUpdateStats() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    VDSReturnValue returnValueUpdate = new VDSReturnValue();
    returnValueUpdate.setSucceeded(false);
    StorageDomain domain = createDomain(new StorageDomainDynamic());
    initDomainListForConnection(newNFSConnection.getId(), domain);
    StorageDomainDynamic domainDynamic = new StorageDomainDynamic();
    StoragePoolIsoMap map = new StoragePoolIsoMap();
    doReturn(Collections.singletonList(map)).when(command).getStoragePoolIsoMap(domain);
    doReturn(returnValueUpdate).when(command).getStatsForDomain(domain);
    doReturn(true).when(command).connectToStorage();
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Locked);
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Maintenance);
    doNothing().when(command).disconnectFromStorage();
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
    verify(storageDomainDynamicDao, never()).update(domainDynamic);
}
#end_block

#method_before
@Test
public void failUpdateConnectToStorage() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    doReturn(false).when(command).connectToStorage();
    VDSReturnValue returnValueUpdate = new VDSReturnValue();
    returnValueUpdate.setSucceeded(true);
    StorageDomainDynamic domainDynamic = new StorageDomainDynamic();
    StorageDomain domain = createDomain(domainDynamic);
    initDomainListForConnection(newNFSConnection.geIid(), domain);
    StoragePoolIsoMap map = new StoragePoolIsoMap();
    doReturn(Collections.singletonList(map)).when(command).getStoragePoolIsoMap(domain);
    doReturn(returnValueUpdate).when(command).getStatsForDomain(domain);
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Locked);
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Maintenance);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
    verify(storageDomainDynamicDao, never()).update(domainDynamic);
    verify(command, never()).disconnectFromStorage();
}
#method_after
@Test
public void failUpdateConnectToStorage() {
    StorageServerConnections newNFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    parameters.setStorageServerConnection(newNFSConnection);
    doReturn(false).when(command).connectToStorage();
    VDSReturnValue returnValueUpdate = new VDSReturnValue();
    returnValueUpdate.setSucceeded(true);
    StorageDomainDynamic domainDynamic = new StorageDomainDynamic();
    StorageDomain domain = createDomain(domainDynamic);
    initDomainListForConnection(newNFSConnection.getId(), domain);
    StoragePoolIsoMap map = new StoragePoolIsoMap();
    doReturn(Collections.singletonList(map)).when(command).getStoragePoolIsoMap(domain);
    doReturn(returnValueUpdate).when(command).getStatsForDomain(domain);
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Locked);
    doNothing().when(command).changeStorageDomainStatusInTransaction(StorageDomainStatus.Maintenance);
    command.executeCommand();
    CommandAssertUtils.checkSucceeded(command, true);
    verify(storageDomainDynamicDao, never()).update(domainDynamic);
    verify(command, never()).disconnectFromStorage();
}
#end_block

#method_before
@Test
public void failDomainIsActive() {
    StorageServerConnections NFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    when(command.getConnection()).thenReturn(NFSConnection);
    doReturn(oldNFSConnection).when(storageConnDao).get(any(String.class));
    // Create an active domain.
    StorageDomain domain = new StorageDomain();
    domain.setStatus(StorageDomainStatus.Active);
    domain.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    doReturn(domain).when(storageDomainDao).get(any(Guid.class));
    initDomainListForConnection(NFSConnection.geIid(), domain);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
}
#method_after
@Test
public void failDomainIsActive() {
    StorageServerConnections NFSConnection = createNFSConnection("multipass.my.domain.tlv.company.com:/export/allstorage/data2", StorageType.NFS, NfsVersion.V4, 300, 0);
    when(command.getConnection()).thenReturn(NFSConnection);
    doReturn(oldNFSConnection).when(storageConnDao).get(any(String.class));
    // Create an active domain.
    StorageDomain domain = new StorageDomain();
    domain.setStatus(StorageDomainStatus.Active);
    domain.setStorageDomainSharedStatus(StorageDomainSharedStatus.Active);
    doReturn(domain).when(storageDomainDao).get(any(Guid.class));
    initDomainListForConnection(NFSConnection.getId(), domain);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    String connectionId = getConnection().geIid();
    List<StorageDomain> domains = null;
    if (StringUtils.isEmpty(connectionId)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_EMPTY);
    }
    StorageServerConnections connection = getStorageServerConnectionDao().get(connectionId);
    if (connection == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    // if user passed only the connection id for removal, vdsm still needs few more details in order to disconnect, so
    // bringing them from db and repopulating them in the connection object received in input parameters
    populateMissingFields(connection);
    StorageType storageType = connection.getStorageType();
    if (storageType.isFileDomain()) {
        // go to storage domain static, get all storage domains where storage field  = storage connection id
        domains = getStorageDomainsByConnId(connectionId);
        if (domains.size() > 0) {
            String domainNames = createDomainNamesListFromStorageDomains(domains);
            return prepareFailureMessageForDomains(domainNames);
        }
    } else if (storageType.equals(StorageType.ISCSI)) {
        List<String> domainNames = new ArrayList<>();
        List<String> diskNames = new ArrayList<>();
        // go to luns to storage connections map table, get it from there
        List<LUNs> luns = getLunDao().getAllForStorageServerConnection(connectionId);
        if (!luns.isEmpty()) {
            String volumeGroupId = null;
            for (LUNs lun : luns) {
                volumeGroupId = lun.getvolume_group_id();
                if (StringUtils.isNotEmpty(volumeGroupId)) {
                    // non empty vg id indicates there's a storage domain using the lun
                    String domainName = lun.getStorageDomainName();
                    domainNames.add(domainName);
                } else {
                    // empty vg id indicates there's a lun disk using the lun
                    String lunDiskName = lun.getDiskAlias();
                    diskNames.add(lunDiskName);
                }
            }
            String domainNamesForMessage = null;
            if (!domainNames.isEmpty()) {
                // Build domain names list to display in the error
                domainNamesForMessage = prepareEntityNamesForMessage(domainNames);
                if (diskNames.isEmpty()) {
                    return prepareFailureMessageForDomains(domainNamesForMessage);
                } else {
                    String diskNamesForMessage = prepareEntityNamesForMessage(diskNames);
                    return prepareFailureMessageForDomainsAndDisks(domainNamesForMessage, diskNamesForMessage);
                }
            } else if (!diskNames.isEmpty()) {
                String diskNamesForMessage = prepareEntityNamesForMessage(diskNames);
                return prepareFailureMessageForDisks(diskNamesForMessage);
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    String connectionId = getConnection().getId();
    List<StorageDomain> domains = null;
    if (StringUtils.isEmpty(connectionId)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_EMPTY);
    }
    StorageServerConnections connection = getStorageServerConnectionDao().get(connectionId);
    if (connection == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    // if user passed only the connection id for removal, vdsm still needs few more details in order to disconnect, so
    // bringing them from db and repopulating them in the connection object received in input parameters
    populateMissingFields(connection);
    StorageType storageType = connection.getStorageType();
    if (storageType.isFileDomain()) {
        // go to storage domain static, get all storage domains where storage field  = storage connection id
        domains = getStorageDomainsByConnId(connectionId);
        if (domains.size() > 0) {
            String domainNames = createDomainNamesListFromStorageDomains(domains);
            return prepareFailureMessageForDomains(domainNames);
        }
    } else if (storageType.equals(StorageType.ISCSI)) {
        List<String> domainNames = new ArrayList<>();
        List<String> diskNames = new ArrayList<>();
        // go to luns to storage connections map table, get it from there
        List<LUNs> luns = getLunDao().getAllForStorageServerConnection(connectionId);
        if (!luns.isEmpty()) {
            String volumeGroupId = null;
            for (LUNs lun : luns) {
                volumeGroupId = lun.getvolume_group_id();
                if (StringUtils.isNotEmpty(volumeGroupId)) {
                    // non empty vg id indicates there's a storage domain using the lun
                    String domainName = lun.getStorageDomainName();
                    domainNames.add(domainName);
                } else {
                    // empty vg id indicates there's a lun disk using the lun
                    String lunDiskName = lun.getDiskAlias();
                    diskNames.add(lunDiskName);
                }
            }
            String domainNamesForMessage = null;
            if (!domainNames.isEmpty()) {
                // Build domain names list to display in the error
                domainNamesForMessage = prepareEntityNamesForMessage(domainNames);
                if (diskNames.isEmpty()) {
                    return prepareFailureMessageForDomains(domainNamesForMessage);
                } else {
                    String diskNamesForMessage = prepareEntityNamesForMessage(diskNames);
                    return prepareFailureMessageForDomainsAndDisks(domainNamesForMessage, diskNamesForMessage);
                }
            } else if (!diskNames.isEmpty()) {
                String diskNamesForMessage = prepareEntityNamesForMessage(diskNames);
                return prepareFailureMessageForDisks(diskNamesForMessage);
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String connectionId = getConnection().geIid();
    getStorageServerConnectionDao().remove(connectionId);
    log.info("Removing connection '{}' from database ", connectionId);
    if (Guid.isNullOrEmpty(getParameters().getVdsId())) {
        log.info("No vdsId passed - hosts will not be disconnected.");
    } else {
        // disconnect the connection from vdsm
        disconnectStorage();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    String connectionId = getConnection().getId();
    getStorageServerConnectionDao().remove(connectionId);
    log.info("Removing connection '{}' from database ", connectionId);
    if (Guid.isNullOrEmpty(getParameters().getVdsId())) {
        log.info("No vdsId passed - hosts will not be disconnected.");
    } else {
        // disconnect the connection from vdsm
        disconnectStorage();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getConnection().getConnection(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    // lock connection's id to avoid editing or removing this connection at the same time
    // by another user
    locks.put(getConnection().geIid(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getConnection().getConnection(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    // lock connection's id to avoid editing or removing this connection at the same time
    // by another user
    locks.put(getConnection().getId(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    return locks;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // If not, just save the connection to the database
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        Pair<Boolean, Integer> result = connectHostToStorage();
        boolean isValidConnection = result.getFirst();
        // Process failure
        if (!isValidConnection) {
            throw new EngineException(EngineError.forValue(result.getSecond()));
        }
    }
    StorageServerConnections connection = getConnection();
    connection.setId(Guid.newGuid().toString());
    saveConnection(connection);
    getReturnValue().setActionReturnValue(connection.geIid());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // If not, just save the connection to the database
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        Pair<Boolean, Integer> result = connectHostToStorage();
        boolean isValidConnection = result.getFirst();
        // Process failure
        if (!isValidConnection) {
            throw new EngineException(EngineError.forValue(result.getSecond()));
        }
    }
    StorageServerConnections connection = getConnection();
    connection.setId(Guid.newGuid().toString());
    saveConnection(connection);
    getReturnValue().setActionReturnValue(connection.getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    StorageServerConnections paramConnection = getConnection();
    // if an id was sent - it's not ok since only the backend should allocate ids
    if (StringUtils.isNotEmpty(paramConnection.geIid())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
    if (!isValidConnection(paramConnection)) {
        return false;
    }
    Guid storagePoolId = Guid.isNullOrEmpty(getParameters().getVdsId()) ? null : getVds().getStoragePoolId();
    if (isConnWithSameDetailsExists(paramConnection, storagePoolId)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    // validate that it's a valid VDS ID and that the VDS is up.
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        if (getVds() == null) {
            return failCanDoAction(EngineMessage.VDS_INVALID_SERVER_ID);
        }
        if (getVds().getStatus() != VDSStatus.Up) {
            return failCanDoAction(EngineMessage.VDS_ADD_STORAGE_SERVER_STATUS_MUST_BE_UP);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    StorageServerConnections paramConnection = getConnection();
    // if an id was sent - it's not ok since only the backend should allocate ids
    if (StringUtils.isNotEmpty(paramConnection.getId())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
    if (!isValidConnection(paramConnection)) {
        return false;
    }
    Guid storagePoolId = Guid.isNullOrEmpty(getParameters().getVdsId()) ? null : getVds().getStoragePoolId();
    if (isConnWithSameDetailsExists(paramConnection, storagePoolId)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    // validate that it's a valid VDS ID and that the VDS is up.
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        if (getVds() == null) {
            return failCanDoAction(EngineMessage.VDS_INVALID_SERVER_ID);
        }
        if (getVds().getStatus() != VDSStatus.Up) {
            return failCanDoAction(EngineMessage.VDS_ADD_STORAGE_SERVER_STATUS_MUST_BE_UP);
        }
    }
    return true;
}
#end_block

#method_before
static StorageServerConnections setUpEntityExpectations(StorageServerConnections entity, int index) {
    expect(entity.geIid()).andReturn(GUIDS[index].toString()).anyTimes();
    expect(entity.getStorageType()).andReturn(STORAGE_TYPES_MAPPED[index]).anyTimes();
    expect(entity.getConnection()).andReturn("1.1.1.255").anyTimes();
    if (STORAGE_TYPES_MAPPED[index].equals(StorageType.ISCSI)) {
        expect(entity.getPort()).andReturn("3260").anyTimes();
    }
    return entity;
}
#method_after
static StorageServerConnections setUpEntityExpectations(StorageServerConnections entity, int index) {
    expect(entity.getId()).andReturn(GUIDS[index].toString()).anyTimes();
    expect(entity.getStorageType()).andReturn(STORAGE_TYPES_MAPPED[index]).anyTimes();
    expect(entity.getConnection()).andReturn("1.1.1.255").anyTimes();
    if (STORAGE_TYPES_MAPPED[index].equals(StorageType.ISCSI)) {
        expect(entity.getPort()).andReturn("3260").anyTimes();
    }
    return entity;
}
#end_block

#method_before
@Override
public Response add(StorageConnection conn) {
    StorageServerConnections entity = StorageDomainMapper.map(conn, null);
    IscsiBond iscsiBond = getIscsiBond();
    iscsiBond.getStorageConnectionIds().add(entity.geIid());
    return performAction(VdcActionType.EditIscsiBond, new EditIscsiBondParameters(iscsiBond));
}
#method_after
@Override
public Response add(StorageConnection conn) {
    StorageServerConnections entity = StorageDomainMapper.map(conn, null);
    IscsiBond iscsiBond = getIscsiBond();
    iscsiBond.getStorageConnectionIds().add(entity.getId());
    return performAction(VdcActionType.EditIscsiBond, new EditIscsiBondParameters(iscsiBond));
}
#end_block

#method_before
protected boolean checkStorageConnection(String storageDomainConnection) {
    List<StorageDomain> domains = null;
    StorageServerConnections connection = getStorageServerConnectionDao().get(storageDomainConnection);
    if (connection == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    if (connection.getStorageType().isFileDomain()) {
        domains = getStorageDomainsByConnId(connection.geIid());
        if (domains.size() > 0) {
            String domainNames = createDomainNamesListFromStorageDomains(domains);
            return prepareFailureMessageForDomains(domainNames);
        }
    }
    return true;
}
#method_after
protected boolean checkStorageConnection(String storageDomainConnection) {
    List<StorageDomain> domains = null;
    StorageServerConnections connection = getStorageServerConnectionDao().get(storageDomainConnection);
    if (connection == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    if (connection.getStorageType().isFileDomain()) {
        domains = getStorageDomainsByConnId(connection.getId());
        if (domains.size() > 0) {
            String domainNames = createDomainNamesListFromStorageDomains(domains);
            return prepareFailureMessageForDomains(domainNames);
        }
    }
    return true;
}
#end_block

#method_before
private void initializeStorageTargetsList() {
    AsyncDataProvider.getInstance().getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<StorageServerConnections> selected = new ArrayList<>();
            ArrayList<StorageServerConnections> conns = (ArrayList<StorageServerConnections>) returnValue;
            Set<String> iscsiBonded = isBondExist() ? new HashSet<>(getIscsiBond().getStorageConnectionIds()) : Collections.<String>emptySet();
            for (StorageServerConnections conn : conns) {
                if (iscsiBonded.contains(conn.geIid())) {
                    selected.add(conn);
                }
            }
            IscsiBondModel model = (IscsiBondModel) target;
            model.getStorageTargets().setItems(conns);
            model.getStorageTargets().setSelectedItems(selected);
        }
    }), getStoragePool().getId(), StorageType.ISCSI);
}
#method_after
private void initializeStorageTargetsList() {
    AsyncDataProvider.getInstance().getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<StorageServerConnections> selected = new ArrayList<>();
            ArrayList<StorageServerConnections> conns = (ArrayList<StorageServerConnections>) returnValue;
            Set<String> iscsiBonded = isBondExist() ? new HashSet<>(getIscsiBond().getStorageConnectionIds()) : Collections.<String>emptySet();
            for (StorageServerConnections conn : conns) {
                if (iscsiBonded.contains(conn.getId())) {
                    selected.add(conn);
                }
            }
            IscsiBondModel model = (IscsiBondModel) target;
            model.getStorageTargets().setItems(conns);
            model.getStorageTargets().setSelectedItems(selected);
        }
    }), getStoragePool().getId(), StorageType.ISCSI);
}
#end_block

#method_before
private List<String> getSelectedConnections() {
    List<String> selectedConnections = new ArrayList<>();
    for (StorageServerConnections conn : getStorageTargets().getSelectedItems()) {
        selectedConnections.add(conn.geIid());
    }
    return selectedConnections;
}
#method_after
private List<String> getSelectedConnections() {
    List<String> selectedConnections = new ArrayList<>();
    for (StorageServerConnections conn : getStorageTargets().getSelectedItems()) {
        selectedConnections.add(conn.getId());
    }
    return selectedConnections;
}
#end_block

#method_before
@Override
public boolean storageDomainRemoved(StorageDomainStatic storageDomain) {
    StorageServerConnections connection = DbFacade.getInstance().getStorageServerConnectionDao().get(storageDomain.getStorage());
    if (connection != null) {
        DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.geIid());
    }
    return true;
}
#method_after
@Override
public boolean storageDomainRemoved(StorageDomainStatic storageDomain) {
    StorageServerConnections connection = DbFacade.getInstance().getStorageServerConnectionDao().get(storageDomain.getStorage());
    if (connection != null) {
        DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getId());
    }
    return true;
}
#end_block

#method_before
@Test
public void successfullyAddedStorageConnections() {
    IscsiBond iscsiBond = createIscsiBond("First", Guid.newGuid());
    List<StorageServerConnections> conns = new ArrayList<>();
    conns.add(createStorageConnection());
    conns.add(createStorageConnection());
    doReturn(conns).when(storageServerConnectionDao).getConnectableStorageConnectionsByStorageType(iscsiBond.getStoragePoolId(), StorageType.ISCSI);
    iscsiBond.getStorageConnectionIds().add(conns.get(0).geIid());
    iscsiBond.getStorageConnectionIds().add(conns.get(1).geIid());
    assertEquals(ValidationResult.VALID, validator.validateAddedStorageConnections(iscsiBond));
}
#method_after
@Test
public void successfullyAddedStorageConnections() {
    IscsiBond iscsiBond = createIscsiBond("First", Guid.newGuid());
    List<StorageServerConnections> conns = new ArrayList<>();
    conns.add(createStorageConnection());
    conns.add(createStorageConnection());
    doReturn(conns).when(storageServerConnectionDao).getConnectableStorageConnectionsByStorageType(iscsiBond.getStoragePoolId(), StorageType.ISCSI);
    iscsiBond.getStorageConnectionIds().add(conns.get(0).getId());
    iscsiBond.getStorageConnectionIds().add(conns.get(1).getId());
    assertEquals(ValidationResult.VALID, validator.validateAddedStorageConnections(iscsiBond));
}
#end_block

#method_before
@Test
public void someAddedStorageConnectionsAreNotAnIscsi() {
    IscsiBond iscsiBond = createIscsiBond("First", Guid.newGuid());
    List<StorageServerConnections> conns = new ArrayList<>();
    conns.add(createStorageConnection());
    doReturn(conns).when(storageServerConnectionDao).getConnectableStorageConnectionsByStorageType(iscsiBond.getStoragePoolId(), StorageType.ISCSI);
    iscsiBond.getStorageConnectionIds().add(conns.get(0).geIid());
    iscsiBond.getStorageConnectionIds().add(Guid.newGuid().toString());
    ValidationResult res = validator.validateAddedStorageConnections(iscsiBond);
    assertEquals(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTIONS_CANNOT_BE_ADDED_TO_ISCSI_BOND, res.getMessage());
    assertEquals(1, res.getVariableReplacements().size());
    assertEquals("$connectionIds " + iscsiBond.getStorageConnectionIds().get(1).toString(), res.getVariableReplacements().get(0));
}
#method_after
@Test
public void someAddedStorageConnectionsAreNotAnIscsi() {
    IscsiBond iscsiBond = createIscsiBond("First", Guid.newGuid());
    List<StorageServerConnections> conns = new ArrayList<>();
    conns.add(createStorageConnection());
    doReturn(conns).when(storageServerConnectionDao).getConnectableStorageConnectionsByStorageType(iscsiBond.getStoragePoolId(), StorageType.ISCSI);
    iscsiBond.getStorageConnectionIds().add(conns.get(0).getId());
    iscsiBond.getStorageConnectionIds().add(Guid.newGuid().toString());
    ValidationResult res = validator.validateAddedStorageConnections(iscsiBond);
    assertEquals(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTIONS_CANNOT_BE_ADDED_TO_ISCSI_BOND, res.getMessage());
    assertEquals(1, res.getVariableReplacements().size());
    assertEquals("$connectionIds " + iscsiBond.getStorageConnectionIds().get(1).toString(), res.getVariableReplacements().get(0));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    StorageServerConnections newConnectionDetails = getConnection();
    StorageType storageType = newConnectionDetails.getStorageType();
    if (!storageType.isFileDomain() && !storageType.equals(StorageType.ISCSI)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_STORAGE_TYPE);
    }
    if (!isValidConnection(newConnectionDetails)) {
        return false;
    }
    // Check if connection exists by id, otherwise there's nothing to update
    String connectionId = newConnectionDetails.geIid();
    StorageServerConnections oldConnection = getStorageConnDao().get(connectionId);
    if (oldConnection == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    if (!newConnectionDetails.getStorageType().equals(oldConnection.getStorageType())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_CHANGE_STORAGE_TYPE);
    }
    Guid storagePoolId = getStoragePoolIdByFileConnectionId(oldConnection.geIid());
    if (isConnWithSameDetailsExists(newConnectionDetails, storagePoolId)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    if (doDomainsUseConnection(newConnectionDetails) || doLunsUseConnection()) {
        if (storageType.isFileDomain() && domains.size() > 1) {
            String domainNames = createDomainNamesList(domains);
            addCanDoActionMessageVariable("domainNames", domainNames);
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
        }
        // Check that the storage domain is in proper state to be edited
        if (!isConnectionEditable(newConnectionDetails)) {
            return false;
        }
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    StorageServerConnections newConnectionDetails = getConnection();
    StorageType storageType = newConnectionDetails.getStorageType();
    if (!storageType.isFileDomain() && !storageType.equals(StorageType.ISCSI)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_STORAGE_TYPE);
    }
    if (!isValidConnection(newConnectionDetails)) {
        return false;
    }
    // Check if connection exists by id, otherwise there's nothing to update
    String connectionId = newConnectionDetails.getId();
    StorageServerConnections oldConnection = getStorageConnDao().get(connectionId);
    if (oldConnection == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    if (!newConnectionDetails.getStorageType().equals(oldConnection.getStorageType())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_CHANGE_STORAGE_TYPE);
    }
    Guid storagePoolId = getStoragePoolIdByFileConnectionId(oldConnection.getId());
    if (isConnWithSameDetailsExists(newConnectionDetails, storagePoolId)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    if (doDomainsUseConnection(newConnectionDetails) || doLunsUseConnection()) {
        if (storageType.isFileDomain() && domains.size() > 1) {
            String domainNames = createDomainNamesList(domains);
            addCanDoActionMessageVariable("domainNames", domainNames);
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
        }
        // Check that the storage domain is in proper state to be edited
        if (!isConnectionEditable(newConnectionDetails)) {
            return false;
        }
    }
    return super.canDoAction();
}
#end_block

#method_before
protected List<LUNs> getLuns() {
    if (luns.isEmpty()) {
        luns = getLunDao().getAllForStorageServerConnection(getConnection().geIid());
    }
    return luns;
}
#method_after
protected List<LUNs> getLuns() {
    if (luns.isEmpty()) {
        luns = getLunDao().getAllForStorageServerConnection(getConnection().getId());
    }
    return luns;
}
#end_block

#method_before
protected boolean doDomainsUseConnection(StorageServerConnections connection) {
    if (domains == null || domains.isEmpty()) {
        domains = getStorageDomainsByConnId(connection.geIid());
    }
    return domains != null && !domains.isEmpty();
}
#method_after
protected boolean doDomainsUseConnection(StorageServerConnections connection) {
    if (domains == null || domains.isEmpty()) {
        domains = getStorageDomainsByConnId(connection.getId());
    }
    return domains != null && !domains.isEmpty();
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    domains = getStorageDomainsByConnId(getConnection().geIid());
    if (!domains.isEmpty()) {
        for (StorageDomain domain : domains) {
            locks.put(domain.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
        }
    }
    if (getConnection().getStorageType().isFileDomain()) {
        // lock the path to avoid at the same time if some other user tries to
        // add new storage connection to same path or edit another storage server connection to point to same path
        locks.put(getConnection().getConnection(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    } else {
        // for block domains, locking the target details
        locks.put(getConnection().getConnection() + ";" + getConnection().getIqn() + ";" + getConnection().getPort() + ";" + getConnection().getUserName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
        // lock lun disks and domains, not VMs , no need to load from db.
        if (getLuns() != null) {
            for (LUNs lun : getLuns()) {
                Guid diskId = lun.getDiskId();
                Guid storageDomainId = lun.getStorageDomainId();
                if (diskId != null) {
                    locks.put(diskId.toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
                }
                if (storageDomainId != null) {
                    locks.put(storageDomainId.toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
                }
            }
        }
    }
    // lock connection's id to avoid editing or removing this connection at the same time
    // by another user
    locks.put(getConnection().geIid(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    domains = getStorageDomainsByConnId(getConnection().getId());
    if (!domains.isEmpty()) {
        for (StorageDomain domain : domains) {
            locks.put(domain.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
        }
    }
    if (getConnection().getStorageType().isFileDomain()) {
        // lock the path to avoid at the same time if some other user tries to
        // add new storage connection to same path or edit another storage server connection to point to same path
        locks.put(getConnection().getConnection(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    } else {
        // for block domains, locking the target details
        locks.put(getConnection().getConnection() + ";" + getConnection().getIqn() + ";" + getConnection().getPort() + ";" + getConnection().getUserName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
        // lock lun disks and domains, not VMs , no need to load from db.
        if (getLuns() != null) {
            for (LUNs lun : getLuns()) {
                Guid diskId = lun.getDiskId();
                Guid storageDomainId = lun.getStorageDomainId();
                if (diskId != null) {
                    locks.put(diskId.toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
                }
                if (storageDomainId != null) {
                    locks.put(storageDomainId.toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
                }
            }
        }
    }
    // lock connection's id to avoid editing or removing this connection at the same time
    // by another user
    locks.put(getConnection().getId(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE_CONNECTION, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    return locks;
}
#end_block

#method_before
private Response addDomain(VdcActionType action, StorageDomain model, StorageDomainStatic entity, Guid hostId, StorageServerConnections connection) {
    Response response = null;
    boolean isConnNew = false;
    if (connection.getStorageType().isFileDomain() && StringUtils.isEmpty(connection.geIid())) {
        isConnNew = true;
        connection.setId(addStorageServerConnection(connection, hostId));
    }
    entity.setStorage(connection.geIid());
    if (action == VdcActionType.AddNFSStorageDomain || action == VdcActionType.AddPosixFsStorageDomain || action == VdcActionType.AddGlusterFsStorageDomain) {
        org.ovirt.engine.core.common.businessentities.StorageDomain existing = getExistingStorageDomain(hostId, entity.getStorageType(), entity.getStorageDomainType(), connection);
        if (existing != null) {
            StorageDomainMapper.map(model, existing.getStorageStaticData());
            entity = existing.getStorageStaticData();
            action = VdcActionType.AddExistingFileStorageDomain;
        }
    }
    try {
        if (action != VdcActionType.AddExistingFileStorageDomain) {
            validateParameters(model, 2, "name");
        }
        response = performCreate(action, getAddParams(entity, hostId), ID_RESOLVER);
    } catch (WebApplicationException e) {
        // cleanup of created connection
        if (isConnNew) {
            removeStorageServerConnection(connection, hostId);
        }
        throw e;
    }
    return response;
}
#method_after
private Response addDomain(VdcActionType action, StorageDomain model, StorageDomainStatic entity, Guid hostId, StorageServerConnections connection) {
    Response response = null;
    boolean isConnNew = false;
    if (connection.getStorageType().isFileDomain() && StringUtils.isEmpty(connection.getId())) {
        isConnNew = true;
        connection.setId(addStorageServerConnection(connection, hostId));
    }
    entity.setStorage(connection.getId());
    if (action == VdcActionType.AddNFSStorageDomain || action == VdcActionType.AddPosixFsStorageDomain || action == VdcActionType.AddGlusterFsStorageDomain) {
        org.ovirt.engine.core.common.businessentities.StorageDomain existing = getExistingStorageDomain(hostId, entity.getStorageType(), entity.getStorageDomainType(), connection);
        if (existing != null) {
            StorageDomainMapper.map(model, existing.getStorageStaticData());
            entity = existing.getStorageStaticData();
            action = VdcActionType.AddExistingFileStorageDomain;
        }
    }
    try {
        if (action != VdcActionType.AddExistingFileStorageDomain) {
            validateParameters(model, 2, "name");
        }
        response = performCreate(action, getAddParams(entity, hostId), ID_RESOLVER);
    } catch (WebApplicationException e) {
        // cleanup of created connection
        if (isConnNew) {
            removeStorageServerConnection(connection, hostId);
        }
        throw e;
    }
    return response;
}
#end_block

#method_before
private static Pair<StorageDomainStatic, Guid> BuildStorageStaticFromXmlRpcStruct(Map<String, Object> xmlRpcStruct) {
    Pair<StorageDomainStatic, Guid> returnValue = new Pair<>();
    StorageDomainStatic sdStatic = new StorageDomainStatic();
    if (xmlRpcStruct.containsKey("name")) {
        sdStatic.setStorageName(xmlRpcStruct.get("name").toString());
    }
    if (xmlRpcStruct.containsKey("type")) {
        sdStatic.setStorageType(EnumUtils.valueOf(StorageType.class, xmlRpcStruct.get("type").toString(), true));
    }
    if (xmlRpcStruct.containsKey("class")) {
        String domainType = xmlRpcStruct.get("class").toString();
        if ("backup".equalsIgnoreCase(domainType)) {
            sdStatic.setStorageDomainType(StorageDomainType.ImportExport);
        } else {
            sdStatic.setStorageDomainType(EnumUtils.valueOf(StorageDomainType.class, domainType, true));
        }
    }
    if (xmlRpcStruct.containsKey("version")) {
        sdStatic.setStorageFormat(StorageFormatType.forValue(xmlRpcStruct.get("version").toString()));
    }
    if (sdStatic.getStorageType() != StorageType.UNKNOWN) {
        if (sdStatic.getStorageType().isFileDomain() && xmlRpcStruct.containsKey("remotePath")) {
            String path = xmlRpcStruct.get("remotePath").toString();
            List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForStorage(path);
            if (connections.isEmpty()) {
                sdStatic.setConnection(new StorageServerConnections());
                sdStatic.getConnection().setConnection(path);
                sdStatic.getConnection().setStorageType(sdStatic.getStorageType());
            } else {
                sdStatic.setStorage(connections.get(0).geIid());
                sdStatic.setConnection(connections.get(0));
            }
        } else if (sdStatic.getStorageType() != StorageType.NFS && (xmlRpcStruct.containsKey("vguuid"))) {
            sdStatic.setStorage(xmlRpcStruct.get("vguuid").toString());
        }
    }
    if (xmlRpcStruct.containsKey("state")) {
        sdStatic.setSanState(EnumUtils.valueOf(SANState.class, xmlRpcStruct.get("state").toString().toUpperCase(), false));
    }
    returnValue.setFirst(sdStatic);
    Object[] poolUUIDs = (Object[]) xmlRpcStruct.get("pool");
    if (poolUUIDs.length != 0) {
        returnValue.setSecond(Guid.createGuidFromString(poolUUIDs[0].toString()));
    }
    return returnValue;
}
#method_after
private static Pair<StorageDomainStatic, Guid> BuildStorageStaticFromXmlRpcStruct(Map<String, Object> xmlRpcStruct) {
    Pair<StorageDomainStatic, Guid> returnValue = new Pair<>();
    StorageDomainStatic sdStatic = new StorageDomainStatic();
    if (xmlRpcStruct.containsKey("name")) {
        sdStatic.setStorageName(xmlRpcStruct.get("name").toString());
    }
    if (xmlRpcStruct.containsKey("type")) {
        sdStatic.setStorageType(EnumUtils.valueOf(StorageType.class, xmlRpcStruct.get("type").toString(), true));
    }
    if (xmlRpcStruct.containsKey("class")) {
        String domainType = xmlRpcStruct.get("class").toString();
        if ("backup".equalsIgnoreCase(domainType)) {
            sdStatic.setStorageDomainType(StorageDomainType.ImportExport);
        } else {
            sdStatic.setStorageDomainType(EnumUtils.valueOf(StorageDomainType.class, domainType, true));
        }
    }
    if (xmlRpcStruct.containsKey("version")) {
        sdStatic.setStorageFormat(StorageFormatType.forValue(xmlRpcStruct.get("version").toString()));
    }
    if (sdStatic.getStorageType() != StorageType.UNKNOWN) {
        if (sdStatic.getStorageType().isFileDomain() && xmlRpcStruct.containsKey("remotePath")) {
            String path = xmlRpcStruct.get("remotePath").toString();
            List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForStorage(path);
            if (connections.isEmpty()) {
                sdStatic.setConnection(new StorageServerConnections());
                sdStatic.getConnection().setConnection(path);
                sdStatic.getConnection().setStorageType(sdStatic.getStorageType());
            } else {
                sdStatic.setStorage(connections.get(0).getId());
                sdStatic.setConnection(connections.get(0));
            }
        } else if (sdStatic.getStorageType() != StorageType.NFS && (xmlRpcStruct.containsKey("vguuid"))) {
            sdStatic.setStorage(xmlRpcStruct.get("vguuid").toString());
        }
    }
    if (xmlRpcStruct.containsKey("state")) {
        sdStatic.setSanState(EnumUtils.valueOf(SANState.class, xmlRpcStruct.get("state").toString().toUpperCase(), false));
    }
    returnValue.setFirst(sdStatic);
    Object[] poolUUIDs = (Object[]) xmlRpcStruct.get("pool");
    if (poolUUIDs.length != 0) {
        returnValue.setSecond(Guid.createGuidFromString(poolUUIDs[0].toString()));
    }
    return returnValue;
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStorageServerConnectionLunMapDao();
    StorageServerConnectionDao storageServerConnectionDao = dbFacade.getStorageServerConnectionDao();
    StorageServerConnections existingConnection = storageServerConnectionDao.get("0cc146e8-e5ed-482c-8814-270bc48c297e");
    existingLUNStorageMap = dao.get(new LUNStorageServerConnectionMapId("1IET_00180001", existingConnection.geIid()));
    newLUNStorageMap = new LUNStorageServerConnectionMap(FREE_LUN_ID, existingConnection.geIid());
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStorageServerConnectionLunMapDao();
    StorageServerConnectionDao storageServerConnectionDao = dbFacade.getStorageServerConnectionDao();
    StorageServerConnections existingConnection = storageServerConnectionDao.get("0cc146e8-e5ed-482c-8814-270bc48c297e");
    existingLUNStorageMap = dao.get(new LUNStorageServerConnectionMapId("1IET_00180001", existingConnection.getId()));
    newLUNStorageMap = new LUNStorageServerConnectionMap(FREE_LUN_ID, existingConnection.getId());
}
#end_block

#method_before
@Test
public void testGetServerConnection() {
    StorageServerConnections result = dao.get(existingConnection.geIid());
    assertNotNull(result);
    assertEquals(existingConnection, result);
}
#method_after
@Test
public void testGetServerConnection() {
    StorageServerConnections result = dao.get(existingConnection.getId());
    assertNotNull(result);
    assertEquals(existingConnection, result);
}
#end_block

#method_before
@Test
public void testgetAllForVolumeGroup() {
    Set<String> lunConns1 = getLunConnections(dbFacade.getStorageServerConnectionLunMapDao().getAll(FixturesTool.LUN_ID1));
    Set<String> lunConns2 = getLunConnections(dbFacade.getStorageServerConnectionLunMapDao().getAll(FixturesTool.LUN_ID2));
    assertTrue("Both LUNs should have at least one mutual connection", CollectionUtils.containsAny(lunConns1, lunConns2));
    List<StorageServerConnections> result = dao.getAllForVolumeGroup(EXISTING_DOMAIN_STORAGE_NAME);
    assertFalse(result.isEmpty());
    Set<String> connections = new HashSet<>();
    for (StorageServerConnections connection : result) {
        assertFalse(connections.contains(connection.geIid()));
        connections.add(connection.geIid());
    }
}
#method_after
@Test
public void testgetAllForVolumeGroup() {
    Set<String> lunConns1 = getLunConnections(dbFacade.getStorageServerConnectionLunMapDao().getAll(FixturesTool.LUN_ID1));
    Set<String> lunConns2 = getLunConnections(dbFacade.getStorageServerConnectionLunMapDao().getAll(FixturesTool.LUN_ID2));
    assertTrue("Both LUNs should have at least one mutual connection", CollectionUtils.containsAny(lunConns1, lunConns2));
    List<StorageServerConnections> result = dao.getAllForVolumeGroup(EXISTING_DOMAIN_STORAGE_NAME);
    assertFalse(result.isEmpty());
    Set<String> connections = new HashSet<>();
    for (StorageServerConnections connection : result) {
        assertFalse(connections.contains(connection.getId()));
        connections.add(connection.getId());
    }
}
#end_block

#method_before
@Test
public void getAllForForConnection() {
    StorageServerConnections conn = dao.get(existingConnection.geIid());
    conn.setId("copy");
    dao.save(conn);
    assertGetAllForConnectionResult(Arrays.asList(existingConnection, conn), existingConnection);
}
#method_after
@Test
public void getAllForForConnection() {
    StorageServerConnections conn = dao.get(existingConnection.getId());
    conn.setId("copy");
    dao.save(conn);
    assertGetAllForConnectionResult(Arrays.asList(existingConnection, conn), existingConnection);
}
#end_block

#method_before
@Test
public void testSaveServerConnection() {
    StorageServerConnections conn = dao.get(newServerConnection.geIid());
    assertNull(conn);
    dao.save(newServerConnection);
    conn = dao.get(newServerConnection.geIid());
    assertEquals(newServerConnection, conn);
}
#method_after
@Test
public void testSaveServerConnection() {
    StorageServerConnections conn = dao.get(newServerConnection.getId());
    assertNull(conn);
    dao.save(newServerConnection);
    conn = dao.get(newServerConnection.getId());
    assertEquals(newServerConnection, conn);
}
#end_block

#method_before
@Test
public void testUpdateIscsiServerConnection() {
    existingConnection.setIqn("1.2.3.4");
    dao.update(existingConnection);
    StorageServerConnections result = dao.get(existingConnection.geIid());
    assertEquals(existingConnection, result);
}
#method_after
@Test
public void testUpdateIscsiServerConnection() {
    existingConnection.setIqn("1.2.3.4");
    dao.update(existingConnection);
    StorageServerConnections result = dao.get(existingConnection.getId());
    assertEquals(existingConnection, result);
}
#end_block

#method_before
@Test
public void testUpdateNfsServerConnection() {
    // create a new connection
    StorageServerConnections newNFSServerConnection = new StorageServerConnections();
    newNFSServerConnection.setId("0cb136e8-e5ed-472b-8914-260bc48c2987");
    newNFSServerConnection.setStorageType(StorageType.NFS);
    newNFSServerConnection.setConnection("host/lib/data");
    newNFSServerConnection.setNfsVersion(NfsVersion.V4);
    newNFSServerConnection.setNfsRetrans((short) 0);
    dao.save(newNFSServerConnection);
    // get it from db
    StorageServerConnections newNFSServerConnectionFromDB = dao.get("0cb136e8-e5ed-472b-8914-260bc48c2987");
    // update its properties and save back to db (update)
    newNFSServerConnectionFromDB.setConnection("/host2/lib/data");
    newNFSServerConnectionFromDB.setNfsRetrans((short) 3);
    newNFSServerConnectionFromDB.setNfsTimeo((short) 100);
    dao.update(newNFSServerConnectionFromDB);
    // get it again after the update
    StorageServerConnections updatedNFSServerConnectionFromDB = dao.get("0cb136e8-e5ed-472b-8914-260bc48c2987");
    assertEquals(updatedNFSServerConnectionFromDB.getConnection(), newNFSServerConnectionFromDB.getConnection());
    assertEquals(updatedNFSServerConnectionFromDB.geIid(), newNFSServerConnectionFromDB.geIid());
    assertEquals(updatedNFSServerConnectionFromDB.getNfsRetrans(), newNFSServerConnectionFromDB.getNfsRetrans());
    assertEquals(updatedNFSServerConnectionFromDB.getNfsTimeo(), newNFSServerConnectionFromDB.getNfsTimeo());
    assertNotSame(newNFSServerConnection.getConnection(), updatedNFSServerConnectionFromDB.getConnection());
    // cleanup...
    dao.remove("0cb136e8-e5ed-472b-8914-260bc48c2987");
}
#method_after
@Test
public void testUpdateNfsServerConnection() {
    // create a new connection
    StorageServerConnections newNFSServerConnection = new StorageServerConnections();
    newNFSServerConnection.setId("0cb136e8-e5ed-472b-8914-260bc48c2987");
    newNFSServerConnection.setStorageType(StorageType.NFS);
    newNFSServerConnection.setConnection("host/lib/data");
    newNFSServerConnection.setNfsVersion(NfsVersion.V4);
    newNFSServerConnection.setNfsRetrans((short) 0);
    dao.save(newNFSServerConnection);
    // get it from db
    StorageServerConnections newNFSServerConnectionFromDB = dao.get("0cb136e8-e5ed-472b-8914-260bc48c2987");
    // update its properties and save back to db (update)
    newNFSServerConnectionFromDB.setConnection("/host2/lib/data");
    newNFSServerConnectionFromDB.setNfsRetrans((short) 3);
    newNFSServerConnectionFromDB.setNfsTimeo((short) 100);
    dao.update(newNFSServerConnectionFromDB);
    // get it again after the update
    StorageServerConnections updatedNFSServerConnectionFromDB = dao.get("0cb136e8-e5ed-472b-8914-260bc48c2987");
    assertEquals(updatedNFSServerConnectionFromDB.getConnection(), newNFSServerConnectionFromDB.getConnection());
    assertEquals(updatedNFSServerConnectionFromDB.getId(), newNFSServerConnectionFromDB.getId());
    assertEquals(updatedNFSServerConnectionFromDB.getNfsRetrans(), newNFSServerConnectionFromDB.getNfsRetrans());
    assertEquals(updatedNFSServerConnectionFromDB.getNfsTimeo(), newNFSServerConnectionFromDB.getNfsTimeo());
    assertNotSame(newNFSServerConnection.getConnection(), updatedNFSServerConnectionFromDB.getConnection());
    // cleanup...
    dao.remove("0cb136e8-e5ed-472b-8914-260bc48c2987");
}
#end_block

#method_before
@Test
public void testRemoveServerConnection() {
    dao.remove(existingConnection.geIid());
    StorageServerConnections result = dao.get(existingConnection.geIid());
    assertNull(result);
}
#method_after
@Test
public void testRemoveServerConnection() {
    dao.remove(existingConnection.getId());
    StorageServerConnections result = dao.get(existingConnection.getId());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testNfsOptions() {
    newServerConnection.setNfsVersion(NfsVersion.V4);
    newServerConnection.setNfsRetrans((short) 5);
    dao.save(newServerConnection);
    StorageServerConnections result = dao.get(newServerConnection.geIid());
    assertEquals(result.getNfsVersion(), NfsVersion.V4);
    assertTrue(result.getNfsRetrans() == 5);
    assertNull(result.getNfsTimeo());
    result = dao.get(existingNfsAutoConnection.geIid());
    assertEquals(result.getNfsVersion(), NfsVersion.AUTO);
    assertTrue(result.getNfsRetrans() == 7);
    assertTrue(result.getNfsTimeo() == 42);
    result = dao.get(existingConnection.geIid());
    assertNull(result.getNfsVersion());
    assertNull(result.getNfsRetrans());
    assertNull(result.getNfsTimeo());
}
#method_after
@Test
public void testNfsOptions() {
    newServerConnection.setNfsVersion(NfsVersion.V4);
    newServerConnection.setNfsRetrans((short) 5);
    dao.save(newServerConnection);
    StorageServerConnections result = dao.get(newServerConnection.getId());
    assertEquals(result.getNfsVersion(), NfsVersion.V4);
    assertTrue(result.getNfsRetrans() == 5);
    assertNull(result.getNfsTimeo());
    result = dao.get(existingNfsAutoConnection.getId());
    assertEquals(result.getNfsVersion(), NfsVersion.AUTO);
    assertTrue(result.getNfsRetrans() == 7);
    assertTrue(result.getNfsTimeo() == 42);
    result = dao.get(existingConnection.getId());
    assertNull(result.getNfsVersion());
    assertNull(result.getNfsRetrans());
    assertNull(result.getNfsTimeo());
}
#end_block

#method_before
@Test
public void testGetAllConnectionsOfNfsDomain() {
    List<StorageServerConnections> connections = dao.getAllForDomain(Guid.createGuidFromString("d9ede37f-e6c3-4bf9-a984-19174070aa31"));
    assertEquals(connections.size(), 1);
    assertEquals(connections.get(0).geIid(), "0cc146e8-e5ed-482c-8814-270bc48c2981");
}
#method_after
@Test
public void testGetAllConnectionsOfNfsDomain() {
    List<StorageServerConnections> connections = dao.getAllForDomain(Guid.createGuidFromString("d9ede37f-e6c3-4bf9-a984-19174070aa31"));
    assertEquals(connections.size(), 1);
    assertEquals(connections.get(0).getId(), "0cc146e8-e5ed-482c-8814-270bc48c2981");
}
#end_block

#method_before
@Test
public void testGetAllConnectionsOfIscsiDomain() {
    List<StorageServerConnections> connections = dao.getAllForDomain(Guid.createGuidFromString("72e3a666-89e1-4005-a7ca-f7548004a9ab"));
    assertEquals(connections.size(), 2);
    assertTrue((connections.get(0).geIid().equals("fDMzhE-wx3s-zo3q-Qcxd-T0li-yoYU-QvVePk")) || (connections.get(0).geIid().equals("0cc146e8-e5ed-482c-8814-270bc48c297e")));
}
#method_after
@Test
public void testGetAllConnectionsOfIscsiDomain() {
    List<StorageServerConnections> connections = dao.getAllForDomain(Guid.createGuidFromString("72e3a666-89e1-4005-a7ca-f7548004a9ab"));
    assertEquals(connections.size(), 2);
    assertTrue((connections.get(0).getId().equals("fDMzhE-wx3s-zo3q-Qcxd-T0li-yoYU-QvVePk")) || (connections.get(0).getId().equals("0cc146e8-e5ed-482c-8814-270bc48c297e")));
}
#end_block

#method_before
@Override
protected void perform() {
    if (isColdReboot()) {
        CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.ShutdownVm, withRootCommandInfo(new ShutdownVmParameters(getVmId(), false)), cloneContextAndDetachFromParent());
        setSucceeded(true);
    } else {
        final VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RebootVm, new VdsAndVmIDVDSParametersBase(getVdsId(), getVmId()));
        setActionReturnValue(returnValue.getReturnValue());
        setSucceeded(returnValue.getSucceeded());
    }
}
#method_after
@Override
protected void perform() {
    if (isColdReboot()) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ShutdownVm, new ShutdownVmParameters(getVmId(), false));
        setReturnValue(returnValue);
        setSucceeded(returnValue.getSucceeded());
        if (getSucceeded()) {
            resourceManager.getVmManager(getVmId()).setColdReboot(true);
        }
    } else {
        final VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RebootVm, new VdsAndVmIDVDSParametersBase(getVdsId(), getVmId()));
        setActionReturnValue(returnValue.getReturnValue());
        setSucceeded(returnValue.getSucceeded());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.Up && getVm().getStatus() != VMStatus.PoweringUp) {
        return failVmStatusIllegal();
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.Up && getVm().getStatus() != VMStatus.PoweringUp) {
        return failVmStatusIllegal();
    }
    return true;
}
#end_block

#method_before
@Before
public void InitTest() {
    mockCpuFlagsManagerHandler();
    mockOsRepository();
    SimpleDependecyInjector.getInstance().bind(DbFacade.class, dbFacade);
}
#method_after
@Before
public void InitTest() {
    mockCpuFlagsManagerHandler();
    mockOsRepository();
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
}
#end_block

#method_before
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockVdsGroupDaoReturnVdsGroup();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockOsRepository();
    mockOsRepositoryGraphics(0, Version.v3_3, new Pair<GraphicsType, DisplayType>(GraphicsType.SPICE, DisplayType.qxl));
    mockGraphicsDevices(vm.getId());
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockVdsGroupDaoReturnVdsGroup();
    mockVmTemplateDaoReturnVmTemplate();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockOsRepository();
    mockOsRepositoryGraphics(0, Version.v3_3, new Pair<>(GraphicsType.SPICE, DisplayType.qxl));
    mockGraphicsDevices(vm.getId());
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
}
#end_block

#method_before
private void mockGraphicsDevices(Guid vmId) {
    VmDevice graphicsDevice = new GraphicsDevice(VmDeviceType.SPICE);
    graphicsDevice.setDeviceId(Guid.Empty);
    graphicsDevice.setVmId(vmId);
    when(deviceDao.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.GRAPHICS)).thenReturn(Arrays.asList(graphicsDevice));
    doReturn(deviceDao).when(dbFacade).getVmDeviceDao();
}
#method_after
private void mockGraphicsDevices(Guid vmId) {
    VmDevice graphicsDevice = new GraphicsDevice(VmDeviceType.SPICE);
    graphicsDevice.setDeviceId(Guid.Empty);
    graphicsDevice.setVmId(vmId);
    when(deviceDao.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.GRAPHICS)).thenReturn(Collections.singletonList(graphicsDevice));
    doReturn(deviceDao).when(dbFacade).getVmDeviceDao();
}
#end_block

#method_before
private void mockOsRepositoryGraphics(int osId, Version ver, Pair<GraphicsType, DisplayType> supportedGraphicsAndDisplay) {
    HashMap<Version, List<Pair<GraphicsType, DisplayType>>> value = new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>();
    value.put(ver, Collections.singletonList(supportedGraphicsAndDisplay));
    HashMap<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> g = new HashMap<>();
    g.put(osId, value);
    when(osRepository.getGraphicsAndDisplays()).thenReturn(g);
}
#method_after
private void mockOsRepositoryGraphics(int osId, Version ver, Pair<GraphicsType, DisplayType> supportedGraphicsAndDisplay) {
    Map<Version, List<Pair<GraphicsType, DisplayType>>> value = new HashMap<>();
    value.put(ver, Collections.singletonList(supportedGraphicsAndDisplay));
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> g = new HashMap<>();
    g.put(osId, value);
    when(osRepository.getGraphicsAndDisplays()).thenReturn(g);
}
#end_block

#method_before
protected void mockOsRepository() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
}
#method_after
protected void mockOsRepository() {
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
}
#end_block

#method_before
@Test
public void canAddVm() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 5;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    cmd.postConstruct();
    doReturn(true).when(cmd).validateCustomProperties(any(VmStatic.class), any(ArrayList.class));
    doReturn(true).when(cmd).validateSpaceRequirements();
    assertTrue("vm could not be added", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
}
#method_after
@Test
public void canAddVm() {
    ArrayList<String> reasons = new ArrayList<>();
    final int domainSizeGB = 20;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB);
    cmd.postConstruct();
    doReturn(true).when(cmd).validateCustomProperties(any(VmStatic.class), anyList());
    doReturn(true).when(cmd).validateSpaceRequirements();
    assertTrue("vm could not be added", cmd.canAddVm(reasons, Collections.singletonList(createStorageDomain(domainSizeGB))));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST);
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION);
}
#end_block

#method_before
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    VDSGroup vdsGroup = createVdsGroup();
    vm.setVdsGroupId(vdsGroup.getId());
    mockStorageDomainDaoGetForStoragePool();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs(), vdsGroup.getCompatibilityVersion());
    mockGraphicsDevices(vm.getId());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.isSoundDeviceEnabled(any(Integer.class), any(Version.class))).thenReturn(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    mockGetAllSnapshots(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    vdsGroup = createVdsGroup();
    vm.setVdsGroupId(vdsGroup.getId());
    mockStorageDomainDaoGetForStoragePool();
    mockVmTemplateDaoReturnVmTemplate();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs());
    mockGraphicsDevices(vm.getId());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.isSoundDeviceEnabled(any(Integer.class), any(Version.class))).thenReturn(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO")));
    mockGetAllSnapshots(cmd);
    cmd.initEffectiveCompatibilityVersion();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
@Test
public void isVirtioScsiEnabledDefaultedToTrue() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(0, 0);
    VDSGroup vdsGroup = createVdsGroup();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    cmd.getParameters().getVm().setVdsGroupId(vdsGroup.getId());
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO_SCSI")));
    assertTrue("isVirtioScsiEnabled hasn't been defaulted to true on cluster >= 3.3.", cmd.isVirtioScsiEnabled());
}
#method_after
@Test
public void isVirtioScsiEnabledDefaultedToTrue() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(0);
    VDSGroup vdsGroup = createVdsGroup();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    cmd.getParameters().getVm().setVdsGroupId(vdsGroup.getId());
    cmd.initEffectiveCompatibilityVersion();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO_SCSI")));
    assertTrue("isVirtioScsiEnabled hasn't been defaulted to true on cluster >= 3.3.", cmd.isVirtioScsiEnabled());
}
#end_block

#method_before
@Test
public void validateSpaceAndThreshold() {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#method_after
@Test
public void validateSpaceAndThreshold() {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotEnough() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
    verify(storageDomainValidator).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#method_after
@Test
public void validateSpaceNotEnough() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
    verify(storageDomainValidator).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotWithinThreshold() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn((new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN))).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
}
#method_after
@Test
public void validateSpaceNotWithinThreshold() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0);
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
}
#end_block

#method_before
@Test
public void testUnsupportedCpus() {
    // prepare a command to pass canDo action
    VM vm = createVm();
    vm.setVmOs(OsRepository.DEFAULT_X86_OS);
    VDSGroup vdsGroup = createVdsGroup();
    vm.setVdsGroupId(vdsGroup.getId());
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockDisplayTypes(vm.getOs(), vdsGroup.getCompatibilityVersion());
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    when(osRepository.getArchitectureFromOS(0)).thenReturn(ArchitectureType.x86_64);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    // prepare the mock values
    HashMap<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    HashSet<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(vm.getVmOsId(), vdsGroup.getCompatibilityVersion()), value);
    when(osRepository.isCpuSupported(vm.getVmOsId(), vdsGroup.getCompatibilityVersion(), CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#method_after
@Test
public void testUnsupportedCpus() {
    // prepare a command to pass canDo action
    VM vm = createVm();
    vm.setVmOs(OsRepository.DEFAULT_X86_OS);
    vdsGroup = createVdsGroup();
    vm.setVdsGroupId(vdsGroup.getId());
    when(vdsGroupDao.get(vdsGroup.getId())).thenReturn(vdsGroup);
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockVmTemplateDaoReturnVmTemplate();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockDisplayTypes(vm.getOs());
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    when(osRepository.getArchitectureFromOS(0)).thenReturn(ArchitectureType.x86_64);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    // prepare the mock values
    Map<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    Set<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(vm.getVmOsId(), vdsGroup.getCompatibilityVersion()), value);
    when(osRepository.isCpuSupported(vm.getVmOsId(), vdsGroup.getCompatibilityVersion(), CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#end_block

#method_before
private void mockDisplayTypes(int osId, Version clusterVersion) {
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#method_after
private void mockDisplayTypes(int osId) {
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(null, Collections.singletonList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#end_block

#method_before
private void mockMaxPciSlots() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    doReturn(MAX_PCI_SLOTS).when(osRepository).getMaxPciDevices(anyInt(), any(Version.class));
}
#method_after
private void mockMaxPciSlots() {
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    doReturn(MAX_PCI_SLOTS).when(osRepository).getMaxPciDevices(anyInt(), any(Version.class));
}
#end_block

#method_before
protected AddVmFromTemplateCommand<AddVmParameters> createVmFromTemplateCommand(VM vm) {
    AddVmParameters param = new AddVmParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmParameters> concrete = new AddVmFromTemplateCommand<AddVmParameters>(param) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(true).when(result).validateCustomProperties(any(VmStatic.class), any(ArrayList.class));
    mockDaos(result);
    mockBackend(result);
    initCommandMethods(result);
    result.postConstruct();
    return result;
}
#method_after
protected AddVmFromTemplateCommand<AddVmParameters> createVmFromTemplateCommand(VM vm) {
    AddVmParameters param = new AddVmParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmParameters> concrete = new AddVmFromTemplateCommand<AddVmParameters>(param) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(true).when(result).validateCustomProperties(any(VmStatic.class), anyList());
    mockDaos(result);
    mockBackend(result);
    initCommandMethods(result);
    result.postConstruct();
    return result;
}
#end_block

#method_before
protected AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> setupCanAddVmFromSnapshotTests(final int domainSizeGB, final int sizeRequired, Guid sourceSnapshotId) {
    VM vm = initializeMock(domainSizeGB, sizeRequired);
    initializeVmDaoMock(vm);
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = createVmFromSnapshotCommand(vm, sourceSnapshotId);
    initCommandMethods(cmd);
    return cmd;
}
#method_after
protected AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> setupCanAddVmFromSnapshotTests(final int domainSizeGB, Guid sourceSnapshotId) {
    VM vm = initializeMock(domainSizeGB);
    initializeVmDaoMock(vm);
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = createVmFromSnapshotCommand(vm, sourceSnapshotId);
    initCommandMethods(cmd);
    return cmd;
}
#end_block

#method_before
private void initializeVmDaoMock(VM vm) {
    when(vmDao.get(Matchers.<Guid>any(Guid.class))).thenReturn(vm);
}
#method_after
private void initializeVmDaoMock(VM vm) {
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
}
#end_block

#method_before
private AddVmCommand<AddVmParameters> setupCanAddVmTests(final int domainSizeGB, final int sizeRequired) {
    VM vm = initializeMock(domainSizeGB, sizeRequired);
    AddVmCommand<AddVmParameters> cmd = createCommand(vm);
    initCommandMethods(cmd);
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    return cmd;
}
#method_after
private AddVmCommand<AddVmParameters> setupCanAddVmTests(final int domainSizeGB) {
    VM vm = initializeMock(domainSizeGB);
    AddVmCommand<AddVmParameters> cmd = createCommand(vm);
    initCommandMethods(cmd);
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    return cmd;
}
#end_block

#method_before
private VM initializeMock(final int domainSizeGB, final int sizeRequired) {
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockStorageDomainDaoGetForStoragePool(domainSizeGB);
    mockStorageDomainDaoGet(domainSizeGB);
    mockConfig();
    VM vm = createVm();
    return vm;
}
#method_after
private VM initializeMock(final int domainSizeGB) {
    mockVmTemplateDaoReturnVmTemplate();
    mockStorageDomainDaoGetForStoragePool(domainSizeGB);
    mockStorageDomainDaoGet(domainSizeGB);
    mockConfig();
    return createVm();
}
#end_block

#method_before
private void mockBackend(AddVmCommand<?> cmd) {
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doReturn(backend).when(cmd).getBackend();
}
#method_after
private void mockBackend(AddVmCommand<?> cmd) {
    doReturn(backend).when(cmd).getBackend();
}
#end_block

#method_before
private void mockStorageDomainDaoGetForStoragePool(int domainSpaceGB) {
    when(sdDao.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<Guid>any(Guid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#method_after
private void mockStorageDomainDaoGetForStoragePool(int domainSpaceGB) {
    when(sdDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#end_block

#method_before
private void mockStorageDomainDaoGetAllStoragesForPool(int domainSpaceGB) {
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Arrays.asList(createStorageDomain(domainSpaceGB)));
}
#method_after
private void mockStorageDomainDaoGetAllStoragesForPool(int domainSpaceGB) {
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Collections.singletonList(createStorageDomain(domainSpaceGB)));
}
#end_block

#method_before
private void mockVmTemplateDaoReturnVmTemplate() {
    when(vmTemplateDao.get(Matchers.<Guid>any(Guid.class))).thenReturn(createVmTemplate());
}
#method_after
private void mockVmTemplateDaoReturnVmTemplate() {
    when(vmTemplateDao.get(any(Guid.class))).thenReturn(createVmTemplate());
}
#end_block

#method_before
private void mockVdsGroupDaoReturnVdsGroup() {
    when(vdsGroupDao.get(Matchers.<Guid>any(Guid.class))).thenReturn(createVdsGroup());
}
#method_after
private void mockVdsGroupDaoReturnVdsGroup() {
    when(vdsGroupDao.get(any(Guid.class))).thenReturn(createVdsGroup());
}
#end_block

#method_before
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskTemplateMap().put(image.getImageId(), image);
        HashMap<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#method_after
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskTemplateMap().put(image.getImageId(), image);
        HashMap<Guid, DiskImage> diskImageMap = new HashMap<>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#end_block

#method_before
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.newGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID_1)));
    return i;
}
#method_after
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.newGuid());
    i.setStorageIds(new ArrayList<>(Collections.singletonList(STORAGE_DOMAIN_ID_1)));
    return i;
}
#end_block

#method_before
private static DiskImage createDiskImage(int size) {
    DiskImage diskImage = new DiskImage();
    diskImage.setSizeInGigabytes(size);
    diskImage.setActualSize(size);
    diskImage.setId(Guid.newGuid());
    diskImage.setImageId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID_1)));
    return diskImage;
}
#method_after
private static DiskImage createDiskImage(int size) {
    DiskImage diskImage = new DiskImage();
    diskImage.setSizeInGigabytes(size);
    diskImage.setActualSize(size);
    diskImage.setId(Guid.newGuid());
    diskImage.setImageId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(STORAGE_DOMAIN_ID_1)));
    return diskImage;
}
#end_block

#method_before
protected void generateStorageToDisksMap(AddVmCommand<? extends AddVmParameters> command) {
    command.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_1, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_1));
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_2, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_2));
}
#method_after
protected void generateStorageToDisksMap(AddVmCommand<? extends AddVmParameters> command) {
    command.storageToDisksMap = new HashMap<>();
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_1, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_1));
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_2, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_2));
}
#end_block

#method_before
private void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            List<DiskImage> list = createDiskSnapshot(arg.getId(), 3);
            return list;
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#method_after
private void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            return createDiskSnapshot(arg.getId(), 3);
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#end_block

#method_before
private <T extends AddVmParameters> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString(), any(Guid.class));
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(true).when(osRepository).isSoundDeviceEnabled(any(Integer.class), any(Version.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#method_after
private <T extends AddVmParameters> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString(), any(Guid.class));
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(true).when(osRepository).isSoundDeviceEnabled(any(Integer.class), any(Version.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#end_block

#method_before
@Test
public void testBeanValidations() {
    assertTrue(createCommand(initializeMock(1, 1)).validateInputs());
}
#method_after
@Test
public void testBeanValidations() {
    assertTrue(createCommand(initializeMock(1)).validateInputs());
}
#end_block

#method_before
@Test
public void testPatternBasedNameFails() {
    AddVmCommand<AddVmParameters> cmd = createCommand(initializeMock(1, 1));
    cmd.getParameters().getVm().setName("aa-??bb");
    assertFalse("Pattern-based name should not be supported for VM", cmd.validateInputs());
}
#method_after
@Test
public void testPatternBasedNameFails() {
    AddVmCommand<AddVmParameters> cmd = createCommand(initializeMock(1));
    cmd.getParameters().getVm().setName("aa-??bb");
    assertFalse("Pattern-based name should not be supported for VM", cmd.validateInputs());
}
#end_block

#method_before
@Test
public void refuseBalloonOnPPC() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.getParameters().setBalloonEnabled(true);
    when(osRepository.isBalloonEnabled(cmd.getParameters().getVm().getVmOsId(), cmd.getVdsGroup().getCompatibilityVersion())).thenReturn(false);
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH.toString()));
}
#method_after
@Test
public void refuseBalloonOnPPC() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.getParameters().setBalloonEnabled(true);
    when(osRepository.isBalloonEnabled(cmd.getParameters().getVm().getVmOsId(), cmd.getVdsGroup().getCompatibilityVersion())).thenReturn(false);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
}
#end_block

#method_before
@Test
public void refuseSoundDeviceOnPPC() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.getParameters().setSoundDeviceEnabled(true);
    when(osRepository.isSoundDeviceEnabled(cmd.getParameters().getVm().getVmOsId(), cmd.getVdsGroup().getCompatibilityVersion())).thenReturn(false);
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH.toString()));
}
#method_after
@Test
public void refuseSoundDeviceOnPPC() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.getParameters().setSoundDeviceEnabled(true);
    when(osRepository.isSoundDeviceEnabled(cmd.getParameters().getVm().getVmOsId(), cmd.getVdsGroup().getCompatibilityVersion())).thenReturn(false);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
}
#end_block

#method_before
private AddVmCommand<AddVmParameters> setupCanAddPpcTest() {
    final int domainSizeGB = 20;
    final int sizeRequired = 5;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(true).when(cmd).validateSpaceRequirements();
    doReturn(true).when(cmd).buildAndCheckDestStorageDomains();
    cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.ppc64);
    cluster.setCompatibilityVersion(Version.getLast());
    doReturn(cluster).when(cmd).getVdsGroup();
    return cmd;
}
#method_after
private AddVmCommand<AddVmParameters> setupCanAddPpcTest() {
    final int domainSizeGB = 20;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB);
    doReturn(true).when(cmd).validateSpaceRequirements();
    doReturn(true).when(cmd).buildAndCheckDestStorageDomains();
    cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.ppc64);
    cluster.setCompatibilityVersion(Version.getLast());
    doReturn(cluster).when(cmd).getVdsGroup();
    return cmd;
}
#end_block

#method_before
@Test
public void testStoragePoolDoesntExist() {
    final int domainSizeGB = 20;
    final int sizeRequired = 5;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(null).when(cmd).getStoragePool();
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST.toString()));
}
#method_after
@Test
public void testStoragePoolDoesntExist() {
    final int domainSizeGB = 20;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB);
    doReturn(null).when(cmd).getStoragePool();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
}
#end_block

#method_before
private StorageDomain updateStorageDomainInMemoryVolumes(List<DiskImage> disksList) {
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.META_DATA_SIZE_IN_BYTES);
    StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getParameters().getStoragePoolId(), memoryDisksList, getVmDisksDummies(), getVm());
    disksList.addAll(memoryDisksList);
    return storageDomain;
}
#method_after
private StorageDomain updateStorageDomainInMemoryVolumes(List<DiskImage> disksList) {
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.METADATA_SIZE_IN_BYTES);
    StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getParameters().getStoragePoolId(), memoryDisksList, getVmDisksDummies(), getVm());
    disksList.addAll(memoryDisksList);
    return storageDomain;
}
#end_block

#method_before
private Collection<DiskImage> getVmDisksDummies() {
    Collection<DiskImage> disksDummies = new LinkedList<>();
    for (Guid storageDomainId : getParameters().getImageToDestinationDomainMap().values()) {
        DiskImage diskImage = new DiskImage();
        diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
        disksDummies.add(diskImage);
    }
    return disksDummies;
}
#method_after
private Collection<DiskImage> getVmDisksDummies() {
    Collection<DiskImage> disksDummies = new LinkedList<>();
    for (Guid storageDomainId : getParameters().getImageToDestinationDomainMap().values()) {
        DiskImage diskImage = new DiskImage();
        diskImage.setStorageIds(new ArrayList<>(Arrays.asList(storageDomainId)));
        disksDummies.add(diskImage);
    }
    return disksDummies;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.transformToList(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        Set<Guid> domainsId = domains.stream().map(StorageDomain::getId).collect(Collectors.toSet());
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
protected Snapshot addActiveSnapshot(Guid snapshotId) {
    return snapshotsManager.addActiveSnapshot(snapshotId, getVm(), getMemoryVolumeForNewActiveSnapshot(), getCompensationContext());
}
#method_after
protected Snapshot addActiveSnapshot(Guid snapshotId) {
    Snapshot activeSnapshot = getActiveSnapshot();
    // We currently don't support using memory from a
    // snapshot that was taken for VM with different id
    String memoryVolume = activeSnapshot != null && !getParameters().isImportAsNewEntity() ? activeSnapshot.getMemoryVolume() : StringUtils.EMPTY;
    return snapshotsManager.addActiveSnapshot(snapshotId, getVm(), memoryVolume, getCompensationContext());
}
#end_block

#method_before
public int getNumOfCpus() {
    return this.getCpuPerSocket() * this.getNumOfSockets();
}
#method_after
public int getNumOfCpus() {
    return this.getCpuPerSocket() * this.getNumOfSockets() * this.getThreadsPerCpu();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVdsList == null) ? 0 : dedicatedVmForVdsList.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((customEmulatedMachine == null) ? 0 : customEmulatedMachine.hashCode());
    result = prime * result + ((customCpuName == null) ? 0 : customCpuName.hashCode());
    result = prime * result + ((smallIconId == null) ? 0 : smallIconId.hashCode());
    result = prime * result + ((largeIconId == null) ? 0 : largeIconId.hashCode());
    result = prime * result + ((consoleDisconnectAction == null) ? 0 : consoleDisconnectAction.hashCode());
    result = prime * result + ((compatibilityVersion == null) ? 0 : compatibilityVersion.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, autoStartup, cpuPerSocket, threadsPerCpu, creationDate, defaultBootSequence, description, failBack, initrdUrl, isoPath, kernelParams, kernelUrl, osId, memSizeMb, niceLevel, cpuShares, numOfSockets, numOfMonitors, origin, priority, stateless, smartcardEnabled, timeZone, usbPolicy, vdsGroupId, vmType, quotaId, allowConsoleReconnect, dedicatedVmForVdsList, migrationSupport, tunnelMigration, vncKeyboardLayout, createdByUserId, defaultDisplayType, migrationDowntime, serialNumberPolicy, customSerialNumber, bootMenuEnabled, spiceFileTransferEnabled, spiceCopyPasteEnabled, cpuProfileId, numaTuneMode, vNumaNodeList, autoConverge, migrateCompressed, predefinedProperties, userDefinedProperties, customEmulatedMachine, customCpuName, smallIconId, largeIconId, consoleDisconnectAction, customCompatibilityVersion);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList)) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties) && ObjectUtils.objectsEqual(customEmulatedMachine, other.customEmulatedMachine) && ObjectUtils.objectsEqual(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && ObjectUtils.objectsEqual(consoleDisconnectAction, other.consoleDisconnectAction) && ObjectUtils.objectsEqual(compatibilityVersion, other.compatibilityVersion);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return Objects.equals(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && Objects.equals(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && Objects.equals(description, other.description) && failBack == other.failBack && Objects.equals(initrdUrl, other.initrdUrl) && Objects.equals(isoPath, other.isoPath) && Objects.equals(kernelParams, other.kernelParams) && Objects.equals(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && threadsPerCpu == other.threadsPerCpu && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && Objects.equals(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && Objects.equals(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && Objects.equals(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && Objects.equals(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && Objects.equals(tunnelMigration, other.tunnelMigration) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && Objects.equals(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && Objects.equals(cpuProfileId, other.cpuProfileId) && Objects.equals(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && Objects.equals(vNumaNodeList, other.vNumaNodeList) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(predefinedProperties, other.predefinedProperties) && Objects.equals(userDefinedProperties, other.userDefinedProperties) && Objects.equals(customEmulatedMachine, other.customEmulatedMachine) && Objects.equals(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && Objects.equals(consoleDisconnectAction, other.consoleDisconnectAction) && Objects.equals(customCompatibilityVersion, other.customCompatibilityVersion);
}
#end_block

#method_before
public List<Guid> getDedicatedVmForVdsList() {
    if (dedicatedVmForVdsList == null) {
        dedicatedVmForVdsList = new LinkedList<Guid>();
    }
    return dedicatedVmForVdsList;
}
#method_after
public List<Guid> getDedicatedVmForVdsList() {
    if (dedicatedVmForVdsList == null) {
        dedicatedVmForVdsList = new LinkedList<>();
    }
    return dedicatedVmForVdsList;
}
#end_block

#method_before
public void setDedicatedVmForVdsList(Guid value) {
    dedicatedVmForVdsList = new LinkedList<Guid>();
    dedicatedVmForVdsList.add(value);
}
#method_after
public void setDedicatedVmForVdsList(Guid value) {
    dedicatedVmForVdsList = new LinkedList<>();
    dedicatedVmForVdsList.add(value);
}
#end_block

#method_before
public void setvNumaNodeList(List<VmNumaNode> vNumaNodeList) {
    this.vNumaNodeList = vNumaNodeList;
}
#method_after
public void setvNumaNodeList(List<VmNumaNode> vNumaNodeList) {
    if (vNumaNodeList != null) {
        this.vNumaNodeList = vNumaNodeList;
    } else {
        this.vNumaNodeList = new ArrayList<>();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getEffectiveCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getEffectiveCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getEffectiveCompatibilityVersion())) {
            addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
            return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion())).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVmTemplate().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getParameters().getVmTemplateData().getThreadsPerCpu(), getVmTemplate().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVmTemplate().getCompatibilityVersion())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
            return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!isInstanceType() && !isBlankTemplate()) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getEffectiveCompatibilityVersion());
    }
    getVmStaticDao().incrementDbGeneration(getVmTemplate().getId());
    updateOriginalTemplateNameOnDerivedVms();
    List<Guid> oldIconIds = Collections.emptyList();
    if (isTemplate()) {
        oldIconIds = IconUtils.updateVmIcon(oldTemplate, getVmTemplate(), getParameters().getVmLargeIcon());
    }
    updateVmTemplate();
    IconUtils.removeUnusedIcons(oldIconIds);
    updateWatchdog(getParameters().getVmTemplateData().getId());
    updateRngDevice(getParameters().getVmTemplateData().getId());
    updateGraphicsDevice();
    checkTrustedService();
    updateVmsOfInstanceType();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!isInstanceType() && !isBlankTemplate()) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getVmTemplate().getCompatibilityVersion());
    }
    getVmStaticDao().incrementDbGeneration(getVmTemplate().getId());
    updateOriginalTemplateNameOnDerivedVms();
    List<Guid> oldIconIds = Collections.emptyList();
    if (isTemplate()) {
        oldIconIds = IconUtils.updateVmIcon(oldTemplate, getVmTemplate(), getParameters().getVmLargeIcon());
    }
    updateVmTemplate();
    IconUtils.removeUnusedIcons(oldIconIds);
    updateWatchdog(getParameters().getVmTemplateData().getId());
    updateRngDevice(getParameters().getVmTemplateData().getId());
    updateGraphicsDevice();
    checkTrustedService();
    updateVmsOfInstanceType();
    setSucceeded(true);
}
#end_block

#method_before
private void updateOriginalTemplateNameOnDerivedVms() {
    boolean templateNameChanged = !ObjectUtils.equals(oldTemplate.getName(), getVmTemplate().getName());
    if (templateNameChanged) {
        getVmDao().updateOriginalTemplateName(getVmTemplate().getId(), getVmTemplate().getName());
    }
}
#method_after
private void updateOriginalTemplateNameOnDerivedVms() {
    boolean templateNameChanged = !Objects.equals(oldTemplate.getName(), getVmTemplate().getName());
    if (templateNameChanged) {
        getVmDao().updateOriginalTemplateName(getVmTemplate().getId(), getVmTemplate().getName());
    }
}
#end_block

#method_before
private void updateVmTemplate() {
    VmHandler.updateVmInitToDB(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    VmDeviceUtils.updateSoundDevice(oldTemplate, getVmTemplate(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled());
    VmDeviceUtils.updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    VmDeviceUtils.updateVirtioScsiController(getVmTemplateId(), getParameters().isVirtioScsiEnabled());
    if (getParameters().isBalloonEnabled() != null) {
        VmDeviceUtils.updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
    }
}
#method_after
private void updateVmTemplate() {
    VmHandler.updateVmInitToDB(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    VmDeviceUtils.updateSoundDevice(oldTemplate, getVmTemplate(), getVmTemplate().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled());
    VmDeviceUtils.updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    VmDeviceUtils.updateVirtioScsiController(getVmTemplateId(), getParameters().isVirtioScsiEnabled());
    if (getParameters().isBalloonEnabled() != null) {
        VmDeviceUtils.updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
    }
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types nor for blank template.
    if (isInstanceType() || isBlankTemplate()) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getEffectiveCompatibilityVersion()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types nor for blank template.
    if (isInstanceType() || isBlankTemplate()) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getVmTemplate().getCompatibilityVersion()));
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependecyInjector.getInstance().bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#end_block

#method_before
@Test
public void testValidName() {
    prepareVmToPassCanDoAction();
    mockVmValidator();
    boolean c = command.canDoAction();
    assertTrue("canDoAction should have passed.", c);
}
#method_after
@Test
public void testValidName() {
    prepareVmToPassCanDoAction();
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    boolean c = command.canDoAction();
    assertTrue("canDoAction should have passed.", c);
}
#end_block

#method_before
@Test
public void testNameNotChanged() {
    prepareVmToPassCanDoAction();
    vm.setName("vm1");
    mockSameNameQuery(true);
    mockVmValidator();
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#method_after
@Test
public void testNameNotChanged() {
    prepareVmToPassCanDoAction();
    vm.setName("vm1");
    mockSameNameQuery(true);
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#end_block

#method_before
@Test
public void testValidDedicatedHost() {
    prepareVmToPassCanDoAction();
    mockVmValidator();
    VDS vds = new VDS();
    vds.setVdsGroupId(group.getId());
    doReturn(vdsDao).when(command).getVdsDao();
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    doReturn(true).when(command).isDedicatedVdsExistOnSameCluster(any(VmBase.class), any(ArrayList.class));
    vmStatic.setDedicatedVmForVdsList(Guid.newGuid());
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#method_after
@Test
public void testValidDedicatedHost() {
    prepareVmToPassCanDoAction();
    mockVmValidator();
    VDS vds = new VDS();
    vds.setVdsGroupId(group.getId());
    doReturn(vdsDao).when(command).getVdsDao();
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    doReturn(true).when(command).isDedicatedVdsExistOnSameCluster(any(VmBase.class), any(ArrayList.class));
    vmStatic.setDedicatedVmForVdsList(Guid.newGuid());
    command.initEffectiveCompatibilityVersion();
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#end_block

#method_before
@Test
public void testCannotDisableVirtioScsi() {
    prepareVmToPassCanDoAction();
    command.getParameters().setVirtioScsiEnabled(false);
    Disk disk = new DiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO_SCSI);
    disk.setPlugged(true);
    mockDiskDaoGetAllForVm(Collections.singletonList(disk), true);
    mockVmValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
}
#method_after
@Test
public void testCannotDisableVirtioScsi() {
    prepareVmToPassCanDoAction();
    command.getParameters().setVirtioScsiEnabled(false);
    Disk disk = new DiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO_SCSI);
    disk.setPlugged(true);
    mockDiskDaoGetAllForVm(Collections.singletonList(disk), true);
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
}
#end_block

#method_before
@Test
public void testCanEditARunningVM() {
    prepareVmToPassCanDoAction();
    vm.setStatus(VMStatus.Up);
    mockDiskDaoGetAllForVm(Collections.<Disk>emptyList(), true);
    mockVmValidator();
    doReturn(vmDeviceDao).when(command).getVmDeviceDao();
    doReturn(true).when(command).areUpdatedFieldsLegal();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void testCanEditARunningVM() {
    prepareVmToPassCanDoAction();
    vm.setStatus(VMStatus.Up);
    mockDiskDaoGetAllForVm(Collections.<Disk>emptyList(), true);
    mockVmValidator();
    doReturn(vmDeviceDao).when(command).getVmDeviceDao();
    doReturn(true).when(command).areUpdatedFieldsLegal();
    command.initEffectiveCompatibilityVersion();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Test
public void testUnsupportedCpus() {
    prepareVmToPassCanDoAction();
    // prepare the mock values
    HashMap<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    HashSet<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(0, Version.v3_0), value);
    when(osRepository.isCpuSupported(0, Version.v3_0, CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#method_after
@Test
public void testUnsupportedCpus() {
    prepareVmToPassCanDoAction();
    // prepare the mock values
    HashMap<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    HashSet<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(0, Version.v3_0), value);
    when(osRepository.isCpuSupported(0, Version.v3_0, CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    command.initEffectiveCompatibilityVersion();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#end_block

#method_before
@Test
public void testMigratoinCanBeSetWhenVMUsesScsiReservation() {
    prepareVmToPassCanDoAction();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    VmDevice device = createVmDevice();
    device.setUsingScsiReservation(false);
    mockVmDevice(device);
    mockVmValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void testMigratoinCanBeSetWhenVMUsesScsiReservation() {
    prepareVmToPassCanDoAction();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    VmDevice device = createVmDevice();
    device.setUsingScsiReservation(false);
    mockVmDevice(device);
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
private VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(Guid.Empty, vm.getId()), VmDeviceGeneralType.DISK, "device", "address", 1, new HashMap<String, Object>(), true, true, true, "alias", new HashMap<String, String>(), Guid.newGuid(), "logical", true);
}
#method_after
private VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(Guid.Empty, vm.getId()), VmDeviceGeneralType.DISK, "device", "address", 1, new HashMap<>(), true, true, true, "alias", new HashMap<>(), Guid.newGuid(), "logical", true);
}
#end_block

#method_before
@Override
protected void init() {
    // skipped if participating in compensation flow
    if (getParameters() == null) {
        return;
    }
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#method_after
@Override
protected void init() {
    // skipped if participating in compensation flow
    if (getParameters() == null) {
        return;
    }
    setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getVdsGroup));
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int threadsPerCpu = newVmStatic.getThreadsPerCpu();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets, threadsPerCpu);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#method_after
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets, int newThreadsPerCpu) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    int currentThreadsPerCpu = getVm().getThreadsPerCpu();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket && currentThreadsPerCpu == newThreadsPerCpu) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#end_block

#method_before
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getVdsGroupId(), getParameters().getVmStaticData().getVdsGroupId())) {
        List<Network> networks = getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getVdsGroupId());
        List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return ObjectUtils.equals(n.getId(), network.getId());
                }
            });
            // if network not exists in cluster we remove the network from the interface
            if (net == null) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
}
#method_after
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getVdsGroupId(), getParameters().getVmStaticData().getVdsGroupId())) {
        List<Network> networks = getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getVdsGroupId());
        List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFound = networks.stream().anyMatch(n -> Objects.equals(n.getId(), network.getId()));
            // if network not exists in cluster we remove the network from the interface
            if (!networkFound) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    VmNumaNodeDao dao = DbFacade.getInstance().getVmNumaNodeDao();
    List<VmNumaNode> addList = new ArrayList<>();
    List<VmNumaNode> oldList = dao.getAllVmNumaNodeByVmId(getVmId());
    Map<Guid, VmNumaNode> removeMap = new HashMap<>();
    for (VmNumaNode node : oldList) {
        removeMap.put(node.getId(), node);
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    List<VmNumaNode> updateList = new ArrayList<>();
    if (newList != null) {
        for (VmNumaNode node : newList) {
            // no id means new entity
            if (node.getId() == null) {
                addList.add(node);
            } else {
                updateList.add(node);
            }
        }
    }
    for (VmNumaNode vmNumaNode : updateList) {
        removeMap.remove(vmNumaNode.getId());
    }
    VmNumaNodeOperationParameters params;
    if (!removeMap.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), new ArrayList<>(removeMap.values()));
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.RemoveVmNumaNodes, params));
    }
    if (!updateList.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), updateList);
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.UpdateVmNumaNodes, params));
    }
    if (!addList.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), addList);
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params));
    }
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(VdcActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // The cases must be persistent with the create_functions_sp
    if (!getQuotaManager().isVmStatusQuotaCountable(getVm().getStatus())) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
        quotaSanityOnly = true;
    } else {
        if (getParameters().getVmStaticData().getQuotaId() == null || getParameters().getVmStaticData().getQuotaId().equals(Guid.Empty) || !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getVmtCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getVdsGroupId(), getParameters().getVmStaticData().getCpuPerSocket() * getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getMemSizeMb()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // The cases must be persistent with the create_functions_sp
    if (!getQuotaManager().isVmStatusQuotaCountable(getVm().getStatus())) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
        quotaSanityOnly = true;
    } else {
        if (getParameters().getVmStaticData().getQuotaId() == null || getParameters().getVmStaticData().getQuotaId().equals(Guid.Empty) || !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getNumOfCpus(), getVm().getMemSizeMb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getVdsGroupId(), getParameters().getVmStaticData().getNumOfCpus(), getParameters().getVmStaticData().getMemSizeMb()));
        }
    }
    return list;
}
#end_block

#method_before
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("num_of_io_threads", entity.getNumOfIoThreads()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVdsList().isEmpty() ? null : StringUtils.join(entity.getDedicatedVmForVdsList(), BaseDao.SEPARATOR)).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName()).addValue(SMALL_ICON_ID_COLUMN, entity.getSmallIconId()).addValue(LARGE_ICON_ID_COLUMN, entity.getLargeIconId()).addValue("console_disconnect_action", entity.getConsoleDisconnectAction().toString()).addValue("compatibility_version", entity.getCompatibilityVersion());
}
#method_after
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("num_of_io_threads", entity.getNumOfIoThreads()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("threads_per_cpu", entity.getThreadsPerCpu()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVdsList().isEmpty() ? null : StringUtils.join(entity.getDedicatedVmForVdsList(), BaseDao.SEPARATOR)).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName()).addValue(SMALL_ICON_ID_COLUMN, entity.getSmallIconId()).addValue(LARGE_ICON_ID_COLUMN, entity.getLargeIconId()).addValue("console_disconnect_action", entity.getConsoleDisconnectAction().toString()).addValue("custom_compatibility_version", entity.getCustomCompatibilityVersion());
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setNumOfIoThreads(rs.getInt("num_of_io_threads"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVdsList(GuidUtils.getGuidListFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
    entity.setSmallIconId(getGuid(rs, SMALL_ICON_ID_COLUMN));
    entity.setLargeIconId(getGuid(rs, LARGE_ICON_ID_COLUMN));
    entity.setConsoleDisconnectAction(ConsoleDisconnectAction.fromDbString(rs.getString("console_disconnect_action")));
    entity.setCompatibilityVersion(((rs.getString("compatibility_version") != null) ? (new Version(rs.getString("compatibility_version"))) : null));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setNumOfIoThreads(rs.getInt("num_of_io_threads"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setThreadsPerCpu(rs.getInt("threads_per_cpu"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVdsList(GuidUtils.getGuidListFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
    entity.setSmallIconId(getGuid(rs, SMALL_ICON_ID_COLUMN));
    entity.setLargeIconId(getGuid(rs, LARGE_ICON_ID_COLUMN));
    entity.setConsoleDisconnectAction(ConsoleDisconnectAction.fromDbString(rs.getString("console_disconnect_action")));
    entity.setCustomCompatibilityVersion(rs.getString("custom_compatibility_version") != null ? new Version(rs.getString("custom_compatibility_version")) : null);
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (shouldOverrideSoundDevice()) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (shouldOverrideSoundDevice()) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#end_block

#method_before
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<VmNic>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#end_block

#method_before
protected boolean shouldCheckSpaceInStorageDomains() {
    return !getImagesToCheckDestinationStorageDomains().isEmpty() && !LinqUtils.firstOrNull(getImagesToCheckDestinationStorageDomains(), new All<DiskImage>()).getImageId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
}
#method_after
protected boolean shouldCheckSpaceInStorageDomains() {
    return !getImagesToCheckDestinationStorageDomains().stream().map(DiskImage::getImageId).findFirst().orElse(VmTemplateHandler.BLANK_VM_TEMPLATE_ID).equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, int threadsPerCpu, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket * threadsPerCpu) > Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && threadsPerCpu > Config.<Integer>getValue(ConfigValues.MaxNumOfThreadsPerCpu, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && threadsPerCpu < 1) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_THREADS_PER_CPU.toString());
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    // validate NUMA nodes count not more than CPUs
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getParameters().getVmStaticData().getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean validateProvidedDestinations() {
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        if (diskImage.getStorageIds() == null || diskImage.getStorageIds().isEmpty()) {
            diskImage.setStorageIds(new ArrayList<Guid>());
            diskImage.getStorageIds().add(getParameters().getStorageDomainId());
        }
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        if (destStorages.get(storageDomainId) == null) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePoolId());
            StorageDomainValidator validator = new StorageDomainValidator(storage);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            destStorages.put(storage.getId(), storage);
        }
    }
    return true;
}
#method_after
private boolean validateProvidedDestinations() {
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        if (diskImage.getStorageIds() == null || diskImage.getStorageIds().isEmpty()) {
            diskImage.setStorageIds(new ArrayList<>());
            diskImage.getStorageIds().add(getParameters().getStorageDomainId());
        }
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        if (destStorages.get(storageDomainId) == null) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePoolId());
            StorageDomainValidator validator = new StorageDomainValidator(storage);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            destStorages.put(storage.getId(), storage);
        }
    }
    return true;
}
#end_block

#method_before
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getVmId(), numaNodes);
    params.setNumaTuneMode(getParameters().getVmStaticData().getNumaTuneMode());
    params.setDedicatedHostList(getParameters().getVmStaticData().getDedicatedVmForVdsList());
    params.setMigrationSupport(getParameters().getVmStaticData().getMigrationSupport());
    if (numaNodes == null || numaNodes.isEmpty()) {
        return;
    }
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && getInstanceTypeId() != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance may be sufficient
        if (getInstanceTypeId() != null && checkCreateInstancePermission(permSubject)) {
            continue;
        }
        // create_vm is overriding in case no create_instance, try again with it
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData(), getVdsGroup());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getVdsGroup(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    autoSelectGraphicsDevice();
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData(), getVdsGroup());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getVdsGroup(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    autoSelectGraphicsDevice();
}
#end_block

#method_before
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getVdsGroup() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getEffectiveCompatibilityVersion(), parameterMasterVm);
    }
}
#method_after
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getVdsGroup() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVm().getCompatibilityVersion(), parameterMasterVm);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
        // Error cloning Cinder disks for template
        return;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.hasMemoryBalloon(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getEffectiveCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
        // Error cloning Cinder disks for template
        return;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.hasMemoryBalloon(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
        return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getEffectiveCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVm().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVm().getCompatibilityVersion())) {
        return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getVm().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCompatibilityVersion()));
    updateVmIcons();
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion()));
    updateVmIcons();
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getParameters().getMasterVm(), getEffectiveCompatibilityVersion()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getParameters().getMasterVm(), getVm().getCompatibilityVersion()));
}
#end_block

#method_before
@Before
public void setUp() {
    // init the injector with the osRepository instance
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#method_after
@Before
public void setUp() {
    // init the injector with the osRepository instance
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(null, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#end_block

#method_before
void addBalloonToVm(VM vm) {
    Guid deviceId = Guid.newGuid();
    Map<String, Object> specParams = new HashMap<String, Object>();
    specParams.put(VdsProperties.Model, VdsProperties.Virtio);
    VmDevice balloon = new VmDevice(new VmDeviceId(deviceId, vm.getId()), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.toString(), null, 0, specParams, true, true, true, null, null, null, null);
    vm.getManagedVmDeviceMap().put(deviceId, balloon);
}
#method_after
void addBalloonToVm(VM vm) {
    Guid deviceId = Guid.newGuid();
    Map<String, Object> specParams = new HashMap<>();
    specParams.put(VdsProperties.Model, VdsProperties.Virtio);
    VmDevice balloon = new VmDevice(new VmDeviceId(deviceId, vm.getId()), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.toString(), null, 0, specParams, true, true, true, null, null, null, null);
    vm.getManagedVmDeviceMap().put(deviceId, balloon);
}
#end_block

#method_before
@Test
public void acceptBalloon() {
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(createParameters());
    addBalloonToVm(c.getParameters().getVm());
    c.getParameters().getVm().setClusterArch(ArchitectureType.x86_64);
    VDSGroup cluster = new VDSGroup();
    cluster.setId(Guid.newGuid());
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setCompatibilityVersion(Version.getLast());
    doReturn(cluster).when(c).getVdsGroup();
    c.setVdsGroupId(cluster.getId());
    c.getParameters().setVdsGroupId(cluster.getId());
    osRepository.getGraphicsAndDisplays().get(0).put(Version.getLast(), Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.isBalloonEnabled(c.getParameters().getVm().getVmOsId(), cluster.getCompatibilityVersion())).thenReturn(true);
    assertTrue(c.validateBallonDevice());
}
#method_after
@Test
public void acceptBalloon() {
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(createParameters());
    addBalloonToVm(c.getParameters().getVm());
    c.getParameters().getVm().setClusterArch(ArchitectureType.x86_64);
    VDSGroup cluster = new VDSGroup();
    cluster.setId(Guid.newGuid());
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setCompatibilityVersion(Version.getLast());
    doReturn(cluster).when(c).getVdsGroup();
    c.setVdsGroupId(cluster.getId());
    c.getParameters().setVdsGroupId(cluster.getId());
    osRepository.getGraphicsAndDisplays().get(0).put(Version.getLast(), Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.isBalloonEnabled(c.getParameters().getVm().getVmOsId(), cluster.getCompatibilityVersion())).thenReturn(true);
    c.initEffectiveCompatibilityVersion();
    assertTrue(c.validateBallonDevice());
}
#end_block

#method_before
private ImportVmCommand<ImportVmParameters> setupDiskSpaceTest(ImportVmParameters parameters) {
    final ImportValidator validator = spy(new ImportValidator(parameters));
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(parameters) {

        @Override
        protected void initUser() {
        }

        @Override
        protected ImportValidator getImportValidator() {
            return validator;
        }

        @Override
        public VDSGroup getVdsGroup() {
            return null;
        }
    });
    cmd.postConstruct();
    parameters.setCopyCollapse(true);
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).validateUniqueVmName();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).setAndValidateDiskProfiles();
    doReturn(true).when(cmd).setAndValidateCpuProfile();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(parameters.getVm()).when(cmd).getVmFromExportDomain(any(Guid.class));
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDao();
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setVdsGroupId(parameters.getVdsGroupId());
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    doReturn(macPoolManagerStrategy).when(cmd).getMacPool();
    ArrayList<Guid> sdIds = new ArrayList<Guid>(Collections.singletonList(Guid.newGuid()));
    for (DiskImage image : parameters.getVm().getImages()) {
        image.setStorageIds(sdIds);
    }
    doReturn(Collections.<DiskImage>emptyList()).when(cmd).createDiskDummiesForSpaceValidations(anyList());
    return cmd;
}
#method_after
private ImportVmCommand<ImportVmParameters> setupDiskSpaceTest(ImportVmParameters parameters) {
    final ImportValidator validator = spy(new ImportValidator(parameters));
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(parameters) {

        @Override
        protected void initUser() {
        }

        @Override
        protected ImportValidator getImportValidator() {
            return validator;
        }

        @Override
        public VDSGroup getVdsGroup() {
            return null;
        }
    });
    cmd.postConstruct();
    parameters.setCopyCollapse(true);
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).validateUniqueVmName();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).setAndValidateDiskProfiles();
    doReturn(true).when(cmd).setAndValidateCpuProfile();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(parameters.getVm()).when(cmd).getVmFromExportDomain(any(Guid.class));
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDao();
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setVdsGroupId(parameters.getVdsGroupId());
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    doReturn(macPoolManagerStrategy).when(cmd).getMacPool();
    ArrayList<Guid> sdIds = new ArrayList<>(Collections.singletonList(Guid.newGuid()));
    for (DiskImage image : parameters.getVm().getImages()) {
        image.setStorageIds(sdIds);
    }
    doReturn(Collections.<DiskImage>emptyList()).when(cmd).createDiskDummiesForSpaceValidations(anyList());
    return cmd;
}
#end_block

#method_before
protected VM createVmWithSnapshots() {
    final VM v = new VM();
    v.setId(Guid.newGuid());
    Snapshot baseSnapshot = new Snapshot();
    baseSnapshot.setVmId(v.getId());
    Snapshot activeSnapshot = new Snapshot();
    activeSnapshot.setVmId(v.getId());
    DiskImage baseImage = createDiskImage(Guid.newGuid(), Guid.newGuid(), baseSnapshot.getId(), false);
    DiskImage activeImage = createDiskImage(baseImage.getId(), baseImage.getImageId(), activeSnapshot.getId(), true);
    baseSnapshot.setDiskImages(Collections.singletonList(baseImage));
    activeSnapshot.setDiskImages(Collections.singletonList(activeImage));
    v.setDiskMap(Collections.<Guid, Disk>singletonMap(activeImage.getId(), activeImage));
    v.setImages(new ArrayList<DiskImage>(Arrays.asList(baseImage, activeImage)));
    v.setSnapshots(new ArrayList<Snapshot>(Arrays.asList(baseSnapshot, activeSnapshot)));
    v.setVdsGroupId(Guid.Empty);
    return v;
}
#method_after
protected VM createVmWithSnapshots() {
    final VM v = new VM();
    v.setId(Guid.newGuid());
    Snapshot baseSnapshot = new Snapshot();
    baseSnapshot.setVmId(v.getId());
    Snapshot activeSnapshot = new Snapshot();
    activeSnapshot.setVmId(v.getId());
    DiskImage baseImage = createDiskImage(Guid.newGuid(), Guid.newGuid(), baseSnapshot.getId(), false);
    DiskImage activeImage = createDiskImage(baseImage.getId(), baseImage.getImageId(), activeSnapshot.getId(), true);
    baseSnapshot.setDiskImages(Collections.singletonList(baseImage));
    activeSnapshot.setDiskImages(Collections.singletonList(activeImage));
    v.setDiskMap(Collections.<Guid, Disk>singletonMap(activeImage.getId(), activeImage));
    v.setImages(new ArrayList<>(Arrays.asList(baseImage, activeImage)));
    v.setSnapshots(new ArrayList<>(Arrays.asList(baseSnapshot, activeSnapshot)));
    v.setVdsGroupId(Guid.Empty);
    return v;
}
#end_block

#method_before
protected VM createVmWithNoSnapshots() {
    final VM v = new VM();
    v.setId(Guid.newGuid());
    Snapshot activeSnapshot = new Snapshot();
    activeSnapshot.setVmId(v.getId());
    DiskImage activeImage = createDiskImage(Guid.newGuid(), Guid.newGuid(), activeSnapshot.getId(), true);
    activeSnapshot.setDiskImages(Collections.singletonList(activeImage));
    v.setImages(new ArrayList<DiskImage>(Collections.singletonList(activeImage)));
    v.setSnapshots(new ArrayList<Snapshot>(Collections.singletonList(activeSnapshot)));
    v.setDiskMap(Collections.<Guid, Disk>singletonMap(activeImage.getId(), activeImage));
    v.setVdsGroupId(Guid.Empty);
    return v;
}
#method_after
protected VM createVmWithNoSnapshots() {
    final VM v = new VM();
    v.setId(Guid.newGuid());
    Snapshot activeSnapshot = new Snapshot();
    activeSnapshot.setVmId(v.getId());
    DiskImage activeImage = createDiskImage(Guid.newGuid(), Guid.newGuid(), activeSnapshot.getId(), true);
    activeSnapshot.setDiskImages(Collections.singletonList(activeImage));
    v.setImages(new ArrayList<>(Collections.singletonList(activeImage)));
    v.setSnapshots(new ArrayList<>(Collections.singletonList(activeSnapshot)));
    v.setDiskMap(Collections.<Guid, Disk>singletonMap(activeImage.getId(), activeImage));
    v.setVdsGroupId(Guid.Empty);
    return v;
}
#end_block

#method_before
@Test
public void testManagedDeviceSyncWithNewDiskId() {
    ImportVmParameters parameters = createParameters();
    ImportVmCommand<ImportVmParameters> command = new ImportVmCommand<ImportVmParameters>(parameters) {

        @Override
        protected void initUser() {
        }

        @Override
        public VDSGroup getVdsGroup() {
            return null;
        }
    };
    command.postConstruct();
    List<DiskImage> diskList = new ArrayList<>();
    DiskImage diskImage = new DiskImage();
    diskImage.setStorageIds(new ArrayList<Guid>());
    DiskImage diskImage2 = new DiskImage();
    diskImage2.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    diskList.add(diskImage2);
    DiskImage disk = command.getActiveVolumeDisk(diskList);
    Map<Guid, VmDevice> managedDevices = new HashMap<>();
    managedDevices.put(disk.getId(), new VmDevice());
    Guid beforeOldDiskId = disk.getId();
    command.generateNewDiskId(diskList, disk);
    command.updateManagedDeviceMap(disk, managedDevices);
    Guid oldDiskId = command.newDiskIdForDisk.get(disk.getId()).getId();
    assertEquals("The old disk id should be similar to the value at the newDiskIdForDisk.", beforeOldDiskId, oldDiskId);
    assertNotNull("The manged device should return the disk device by the new key", managedDevices.get(disk.getId()));
    assertNull("The manged device should not return the disk device by the old key", managedDevices.get(beforeOldDiskId));
}
#method_after
@Test
public void testManagedDeviceSyncWithNewDiskId() {
    ImportVmParameters parameters = createParameters();
    ImportVmCommand<ImportVmParameters> command = new ImportVmCommand<ImportVmParameters>(parameters) {

        @Override
        protected void initUser() {
        }

        @Override
        public VDSGroup getVdsGroup() {
            return null;
        }
    };
    command.postConstruct();
    List<DiskImage> diskList = new ArrayList<>();
    DiskImage diskImage = new DiskImage();
    diskImage.setStorageIds(new ArrayList<>());
    DiskImage diskImage2 = new DiskImage();
    diskImage2.setStorageIds(new ArrayList<>());
    diskList.add(diskImage);
    diskList.add(diskImage2);
    DiskImage disk = command.getActiveVolumeDisk(diskList);
    Map<Guid, VmDevice> managedDevices = new HashMap<>();
    managedDevices.put(disk.getId(), new VmDevice());
    Guid beforeOldDiskId = disk.getId();
    command.generateNewDiskId(diskList, disk);
    command.updateManagedDeviceMap(disk, managedDevices);
    Guid oldDiskId = command.newDiskIdForDisk.get(disk.getId()).getId();
    assertEquals("The old disk id should be similar to the value at the newDiskIdForDisk.", beforeOldDiskId, oldDiskId);
    assertNotNull("The manged device should return the disk device by the new key", managedDevices.get(disk.getId()));
    assertNull("The manged device should not return the disk device by the old key", managedDevices.get(beforeOldDiskId));
}
#end_block

#method_before
@Test
public void testValidateClusterSupportForVirtioScsi() {
    ImportVmCommand<ImportVmParameters> cmd = setupDiskSpaceTest(createParameters());
    doReturn(true).when(cmd).validateImages(any(Map.class));
    cmd.getParameters().getVm().getDiskMap().values().iterator().next().setDiskInterface(DiskInterface.VirtIO_SCSI);
    cmd.getVdsGroup().setCompatibilityVersion(Version.v3_2);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
}
#method_after
@Test
public void testValidateClusterSupportForVirtioScsi() {
    ImportVmCommand<ImportVmParameters> cmd = setupDiskSpaceTest(createParameters());
    doReturn(true).when(cmd).validateImages(any(Map.class));
    cmd.getParameters().getVm().getDiskMap().values().iterator().next().setDiskInterface(DiskInterface.VirtIO_SCSI);
    cmd.getVdsGroup().setCompatibilityVersion(Version.v3_2);
    cmd.initEffectiveCompatibilityVersion();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
}
#end_block

#method_before
public static Version getEffective(Version vmCompatibilityVersion, Version vdsGroupCompatibilityVersion, Version defaultVersion) {
    if (vmCompatibilityVersion != null) {
        return vmCompatibilityVersion;
    } else if (vdsGroupCompatibilityVersion != null) {
        return vdsGroupCompatibilityVersion;
    } else {
        return defaultVersion;
    }
}
#method_after
public static Version getEffective(Version vmCustomCompatibilityVersion, Version vdsGroupCompatibilityVersion, Version defaultVersion) {
    if (vmCustomCompatibilityVersion != null) {
        return vmCustomCompatibilityVersion;
    }
    if (vdsGroupCompatibilityVersion != null) {
        return vdsGroupCompatibilityVersion;
    }
    return defaultVersion;
}
#end_block

#method_before
public static Version getEffective(Version vmCompatibilityVersion, Version vdsGroupCompatibilityVersion, Version defaultVersion) {
    if (vmCompatibilityVersion != null) {
        return vmCompatibilityVersion;
    } else if (vdsGroupCompatibilityVersion != null) {
        return vdsGroupCompatibilityVersion;
    } else {
        return defaultVersion;
    }
}
#method_after
public static Version getEffective(VmBase vmBase, VDSGroup cluster) {
    Version vmCustomCompatibilityVersion = vmBase != null ? vmBase.getCustomCompatibilityVersion() : null;
    Version clusterCompatibilityVersion = cluster != null ? cluster.getCompatibilityVersion() : null;
    return CompatibilityVersionUtils.getEffective(vmCustomCompatibilityVersion, clusterCompatibilityVersion, Version.getLast());
}
#end_block

#method_before
protected boolean validateBallonDevice() {
    if (!VmDeviceCommonUtils.isBalloonDeviceExists(getVm().getManagedVmDeviceMap().values())) {
        return true;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    if (!osRepository.isBalloonEnabled(getVm().getStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#method_after
protected boolean validateBallonDevice() {
    if (!VmDeviceCommonUtils.isBalloonDeviceExists(getVm().getManagedVmDeviceMap().values())) {
        return true;
    }
    if (!osRepository.isBalloonEnabled(getVm().getStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return true;
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    // in the postConstruct phase.
    if (parameters.isImportAsNewEntity() && parameters.getVmId().equals(parameters.getVm().getId())) {
        parameters.getVm().setId(Guid.newGuid());
    }
    setVdsGroupId(parameters.getVdsGroupId());
    setVm(parameters.getVm());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    // in the postConstruct phase.
    if (parameters.isImportAsNewEntity() && parameters.getVmId().equals(parameters.getVm().getId())) {
        parameters.getVm().setId(Guid.newGuid());
    }
    setVdsGroupId(parameters.getVdsGroupId());
    setVm(parameters.getVm());
    initEffectiveCompatibilityVersion();
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    cpuFlagsManagerHandler = Injector.get(CpuFlagsManagerHandler.class);
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    updateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        updateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        updateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            updateVmsStatic.AddHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.UpdateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.RemoveVm);
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    cpuFlagsManagerHandler = Injector.get(CpuFlagsManagerHandler.class);
    osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    updateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        updateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        updateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            updateVmsStatic.AddHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.UpdateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.RemoveVm);
}
#end_block

#method_before
public static boolean isGraphicsAndDisplaySupported(int osId, Collection<GraphicsType> graphics, DisplayType displayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, graphics, displayType);
    if (!result) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.name());
    }
    return result;
}
#method_after
public static boolean isGraphicsAndDisplaySupported(int osId, Collection<GraphicsType> graphics, DisplayType displayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, graphics, displayType);
    if (!result) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.name());
    }
    if (graphics.size() > 1 && !FeatureSupported.multipleGraphicsSupported(clusterVersion)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ONLY_ONE_GRAPHICS_SUPPORTED_IN_THIS_CLUSTER_LEVEL.name());
        result = false;
    }
    return result;
}
#end_block

#method_before
public static boolean isNotDuplicateInterfaceName(List<VmNic> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNic iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(EngineMessage.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#method_after
public static boolean isNotDuplicateInterfaceName(List<VmNic> interfaces, final String candidateInterfaceName, List<String> messages) {
    boolean candidateNameUsed = interfaces.stream().anyMatch(i -> i.getName().equals(candidateInterfaceName));
    if (candidateNameUsed) {
        messages.add(EngineMessage.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#end_block

#method_before
public static void autoSelectUsbPolicy(VmBase fromParams, VDSGroup cluster) {
    if (fromParams.getUsbPolicy() == null) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion(fromParams, cluster);
        UsbPolicy usbPolicy = compatibilityVersion.compareTo(Version.v3_1) >= 0 ? UsbPolicy.ENABLED_NATIVE : UsbPolicy.ENABLED_LEGACY;
        fromParams.setUsbPolicy(usbPolicy);
    }
}
#method_after
public static void autoSelectUsbPolicy(VmBase fromParams, VDSGroup cluster) {
    if (fromParams.getUsbPolicy() == null) {
        Version compatibilityVersion = CompatibilityVersionUtils.getEffective(fromParams, cluster);
        UsbPolicy usbPolicy = compatibilityVersion.compareTo(Version.v3_1) >= 0 ? UsbPolicy.ENABLED_NATIVE : UsbPolicy.ENABLED_LEGACY;
        fromParams.setUsbPolicy(usbPolicy);
    }
}
#end_block

#method_before
public static void autoSelectDefaultDisplayType(Guid srcEntityId, VmBase parametersStaticData, VDSGroup cluster, Map<GraphicsType, GraphicsDevice> graphicsDevices) {
    if (parametersStaticData.getOsId() == OsRepository.AUTO_SELECT_OS || parametersStaticData.getDefaultDisplayType() != null) {
        return;
    }
    DisplayType defaultDisplayType = DisplayType.qxl;
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = osRepository.getGraphicsAndDisplays(parametersStaticData.getOsId(), getEffectiveCompatibilityVersion(parametersStaticData, cluster));
    // map holding display type -> set of supported graphics types for this display type
    Map<DisplayType, Set<GraphicsType>> displayGraphicsSupport = new HashMap<>();
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        DisplayType display = graphicsAndDisplay.getSecond();
        if (!displayGraphicsSupport.containsKey(display)) {
            displayGraphicsSupport.put(display, new HashSet<GraphicsType>());
        }
        displayGraphicsSupport.get(display).add(graphicsAndDisplay.getFirst());
    }
    for (Map.Entry<DisplayType, Set<GraphicsType>> entry : displayGraphicsSupport.entrySet()) {
        if (entry.getValue().containsAll(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcEntityId), graphicsDevices))) {
            defaultDisplayType = entry.getKey();
            break;
        }
    }
    parametersStaticData.setDefaultDisplayType(defaultDisplayType);
}
#method_after
public static void autoSelectDefaultDisplayType(Guid srcEntityId, VmBase parametersStaticData, VDSGroup cluster, Map<GraphicsType, GraphicsDevice> graphicsDevices) {
    if (parametersStaticData.getOsId() == OsRepository.AUTO_SELECT_OS || parametersStaticData.getDefaultDisplayType() != null) {
        return;
    }
    DisplayType defaultDisplayType = DisplayType.qxl;
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = osRepository.getGraphicsAndDisplays(parametersStaticData.getOsId(), CompatibilityVersionUtils.getEffective(parametersStaticData, cluster));
    // map holding display type -> set of supported graphics types for this display type
    Map<DisplayType, Set<GraphicsType>> displayGraphicsSupport = new HashMap<>();
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        DisplayType display = graphicsAndDisplay.getSecond();
        if (!displayGraphicsSupport.containsKey(display)) {
            displayGraphicsSupport.put(display, new HashSet<>());
        }
        displayGraphicsSupport.get(display).add(graphicsAndDisplay.getFirst());
    }
    for (Map.Entry<DisplayType, Set<GraphicsType>> entry : displayGraphicsSupport.entrySet()) {
        if (entry.getValue().containsAll(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcEntityId), graphicsDevices))) {
            defaultDisplayType = entry.getKey();
            break;
        }
    }
    parametersStaticData.setDefaultDisplayType(defaultDisplayType);
}
#end_block

#method_before
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        if (FeatureSupported.isIoThreadsSupported(getEffectiveCompatibilityVersion())) {
            vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        }
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
    }
}
#method_after
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        if (FeatureSupported.isIoThreadsSupported(getEffectiveCompatibilityVersion())) {
            vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        }
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
    }
}
#end_block

#method_before
protected boolean validate() {
    VM vm = parentCommand.getVm();
    if (vm == null) {
        parentCommand.addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    } else {
        targetCluster = DbFacade.getInstance().getVdsGroupDao().get(targetClusterId);
        if (targetCluster == null) {
            parentCommand.addCanDoActionMessage(EngineMessage.VM_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // Check that the target cluster is in the same data center.
        if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
            parentCommand.addCanDoActionMessage(EngineMessage.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
            return false;
        }
        List<VmNic> interfaces = DbFacade.getInstance().getVmNicDao().getAllForVm(vm.getId());
        Version clusterCompatibilityVersion = targetCluster.getCompatibilityVersion();
        if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
            return false;
        }
        // Check if VM static parameters are compatible for new cluster.
        boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), parentCommand.getReturnValue().getCanDoActionMessages());
        if (!isCpuSocketsValid) {
            return false;
        }
        // Check that the USB policy is legal
        if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster.getCompatibilityVersion(), parentCommand.getReturnValue().getCanDoActionMessages())) {
            return false;
        }
        // Check if the display type is supported
        if (!VmHandler.isGraphicsAndDisplaySupported(vm.getOs(), VmDeviceUtils.getGraphicsTypesOfEntity(vm.getId()), vm.getDefaultDisplayType(), parentCommand.getReturnValue().getCanDoActionMessages(), clusterCompatibilityVersion)) {
            return false;
        }
        if (VmDeviceUtils.hasVirtioScsiController(vm.getId())) {
            // Verify cluster compatibility
            if (!FeatureSupported.virtIoScsi(targetCluster.getCompatibilityVersion())) {
                return parentCommand.failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
            }
            // Verify OS compatibility
            if (!VmHandler.isOsTypeSupportedForVirtioScsi(vm.getOs(), targetCluster.getCompatibilityVersion(), parentCommand.getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        }
        // A existing VM cannot be changed into a cluster without a defined architecture
        if (targetCluster.getArchitecture() == ArchitectureType.undefined) {
            return parentCommand.failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        } else if (targetCluster.getArchitecture() != vm.getClusterArch()) {
            return parentCommand.failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    return true;
}
#method_after
protected boolean validate() {
    VM vm = parentCommand.getVm();
    if (vm == null) {
        parentCommand.addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    } else {
        targetCluster = DbFacade.getInstance().getVdsGroupDao().get(targetClusterId);
        if (targetCluster == null) {
            parentCommand.addCanDoActionMessage(EngineMessage.VM_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // Check that the target cluster is in the same data center.
        if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
            parentCommand.addCanDoActionMessage(EngineMessage.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
            return false;
        }
        List<VmNic> interfaces = DbFacade.getInstance().getVmNicDao().getAllForVm(vm.getId());
        Version clusterCompatibilityVersion = targetCluster.getCompatibilityVersion();
        if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
            return false;
        }
        // Check if VM static parameters are compatible for new cluster.
        boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), vm.getStaticData().getThreadsPerCpu(), clusterCompatibilityVersion.getValue(), parentCommand.getReturnValue().getCanDoActionMessages());
        if (!isCpuSocketsValid) {
            return false;
        }
        // Check that the USB policy is legal
        if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster.getCompatibilityVersion(), parentCommand.getReturnValue().getCanDoActionMessages())) {
            return false;
        }
        // Check if the display type is supported
        if (!VmHandler.isGraphicsAndDisplaySupported(vm.getOs(), VmDeviceUtils.getGraphicsTypesOfEntity(vm.getId()), vm.getDefaultDisplayType(), parentCommand.getReturnValue().getCanDoActionMessages(), clusterCompatibilityVersion)) {
            return false;
        }
        if (VmDeviceUtils.hasVirtioScsiController(vm.getId())) {
            // Verify cluster compatibility
            if (!FeatureSupported.virtIoScsi(targetCluster.getCompatibilityVersion())) {
                return parentCommand.failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
            }
            // Verify OS compatibility
            if (!VmHandler.isOsTypeSupportedForVirtioScsi(vm.getOs(), targetCluster.getCompatibilityVersion(), parentCommand.getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        }
        // A existing VM cannot be changed into a cluster without a defined architecture
        if (targetCluster.getArchitecture() == ArchitectureType.undefined) {
            return parentCommand.failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        } else if (targetCluster.getArchitecture() != vm.getClusterArch()) {
            return parentCommand.failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    return true;
}
#end_block

#method_before
public static <T extends Disk> boolean checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<VmNic> interfaces, List<T> disks, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO;
        }
    }).size();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    if (pciInUse > maxPciSlots) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    } else if (MAX_VIRTIO_SCSI_DISKS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO_SCSI;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS.name());
    } else if (MAX_SPAPR_SCSI_DISKS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.SPAPR_VSCSI;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS.name());
    }
    return result;
}
#method_after
public static <T extends Disk> boolean checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<VmNic> interfaces, List<T> disks, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += disks.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO).count();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    if (pciInUse > maxPciSlots) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < disks.stream().filter(a -> a.getDiskInterface() == DiskInterface.IDE).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    } else if (MAX_VIRTIO_SCSI_DISKS < disks.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO_SCSI).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS.name());
    } else if (MAX_SPAPR_SCSI_DISKS < disks.stream().filter(a -> a.getDiskInterface() == DiskInterface.SPAPR_VSCSI).count()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS.name());
    }
    return result;
}
#end_block

#method_before
protected boolean removeMemoryVolumes(String memVols, VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    List<Guid> guids = GuidUtils.getGuidListFromString(memVols);
    if (guids.size() == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        Guid taskId1 = persistAsyncTaskPlaceHolder(parentCommand, DELETE_PRIMARY_IMAGE_TASK_KEY);
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the image removal:
        VDSReturnValue vdsRetValue = runVdsCommand(VDSCommandType.DeleteImageGroup, PostZeroHandler.fixParametersWithPostZero(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(2), postZero, false)));
        if (!vdsRetValue.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(taskId1, vdsRetValue.getCreationInfo(), parentCommand, VdcObjectType.Storage, guids.get(0));
        getTaskIdList().add(guid1);
        Guid taskId2 = persistAsyncTaskPlaceHolder(parentCommand, DELETE_SECONDARY_IMAGES_TASK_KEY);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the image removal:
        vdsRetValue = runVdsCommand(VDSCommandType.DeleteImageGroup, PostZeroHandler.fixParametersWithPostZero(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(4), postZero, false)));
        if (!vdsRetValue.getSucceeded()) {
            if (startPollingTasks) {
                CommandCoordinatorUtil.startPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(taskId2, vdsRetValue.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            CommandCoordinatorUtil.startPollingTask(guid1);
            CommandCoordinatorUtil.startPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean removeMemoryVolumes(String memVols, VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    List<Guid> guids = GuidUtils.getGuidListFromString(memVols);
    if (guids.size() == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = getDiskDao().getAllForVm(getVm().getId()).stream().anyMatch(BaseDisk::isWipeAfterDelete);
        Guid taskId1 = persistAsyncTaskPlaceHolder(parentCommand, DELETE_PRIMARY_IMAGE_TASK_KEY);
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the image removal:
        VDSReturnValue vdsRetValue = runVdsCommand(VDSCommandType.DeleteImageGroup, PostZeroHandler.fixParametersWithPostZero(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(2), postZero, false)));
        if (!vdsRetValue.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(taskId1, vdsRetValue.getCreationInfo(), parentCommand, VdcObjectType.Storage, guids.get(0));
        getTaskIdList().add(guid1);
        Guid taskId2 = persistAsyncTaskPlaceHolder(parentCommand, DELETE_SECONDARY_IMAGES_TASK_KEY);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the image removal:
        vdsRetValue = runVdsCommand(VDSCommandType.DeleteImageGroup, PostZeroHandler.fixParametersWithPostZero(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(4), postZero, false)));
        if (!vdsRetValue.getSucceeded()) {
            if (startPollingTasks) {
                CommandCoordinatorUtil.startPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(taskId2, vdsRetValue.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            CommandCoordinatorUtil.startPollingTask(guid1);
            CommandCoordinatorUtil.startPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean removeHibernationDisks(String memory) {
    String[] guids = memory.split(",");
    RemoveDiskParameters removeMemoryDumpDiskParameters = new RemoveDiskParameters(new Guid(guids[2]));
    removeMemoryDumpDiskParameters.setShouldBeLogged(false);
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveDisk, removeMemoryDumpDiskParameters);
    if (!retVal.getSucceeded()) {
        return false;
    }
    RemoveDiskParameters removeMemoryMetadataDiskParameters = new RemoveDiskParameters(new Guid(guids[4]));
    removeMemoryMetadataDiskParameters.setShouldBeLogged(false);
    retVal = runInternalAction(VdcActionType.RemoveDisk, removeMemoryMetadataDiskParameters);
    if (!retVal.getSucceeded()) {
        return false;
    }
    return true;
}
#method_after
protected boolean removeHibernationDisks(String memory) {
    List<Guid> guids = GuidUtils.getGuidListFromString(memory);
    RemoveDiskParameters removeMemoryDumpDiskParameters = new RemoveDiskParameters(guids.get(2));
    removeMemoryDumpDiskParameters.setShouldBeLogged(false);
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveDisk, removeMemoryDumpDiskParameters);
    if (!retVal.getSucceeded()) {
        return false;
    }
    RemoveDiskParameters removeMemoryMetadataDiskParameters = new RemoveDiskParameters(guids.get(4));
    removeMemoryMetadataDiskParameters.setShouldBeLogged(false);
    retVal = runInternalAction(VdcActionType.RemoveDisk, removeMemoryMetadataDiskParameters);
    if (!retVal.getSucceeded()) {
        return false;
    }
    return true;
}
#end_block

#method_before
public int getNumOfCpus() {
    return this.vmStatic.getNumOfCpus();
}
#method_after
public int getNumOfCpus(boolean countThreadsAsCPU) {
    return countThreadsAsCPU ? this.getNumOfCpus() : (getNumOfSockets() * getCpuPerSocket());
}
#end_block

#method_before
public Version getCompatibilityVersion() {
    return this.vmStatic.getCompatibilityVersion();
}
#method_after
public Version getCompatibilityVersion() {
    return getCustomCompatibilityVersion() != null ? getCustomCompatibilityVersion() : getVdsGroupCompatibilityVersion();
}
#end_block

#method_before
public boolean isSysprepUsed() {
    return getInitializationType() == InitializationType.Sysprep && SimpleDependecyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId()) && (getFloppyPath() == null || "".equals(getFloppyPath()));
}
#method_after
public boolean isSysprepUsed() {
    return getInitializationType() == InitializationType.Sysprep && SimpleDependencyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId()) && (getFloppyPath() == null || "".equals(getFloppyPath()));
}
#end_block

#method_before
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && !SimpleDependecyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId());
}
#method_after
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && !SimpleDependencyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId());
}
#end_block

#method_before
private void initRunOnceGraphics() {
    runOnceGraphics = new HashSet<GraphicsType>();
}
#method_after
private void initRunOnceGraphics() {
    runOnceGraphics = new HashSet<>();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof HostDeviceView)) {
        return false;
    }
    if (!super.equals(o))
        return false;
    HostDeviceView other = (HostDeviceView) o;
    return super.equals(other) && Objects.equals(configuredVmId, other.configuredVmId) && Objects.equals(attachedVmNames, other.attachedVmNames) && Objects.equals(runningVmName, other.runningVmName) && Objects.equals(iommuPlaceholder, other.iommuPlaceholder);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof HostDeviceView)) {
        return false;
    }
    HostDeviceView other = (HostDeviceView) o;
    return super.equals(other) && Objects.equals(configuredVmId, other.configuredVmId) && Objects.equals(attachedVmNames, other.attachedVmNames) && Objects.equals(runningVmName, other.runningVmName) && Objects.equals(iommuPlaceholder, other.iommuPlaceholder);
}
#end_block

#method_before
public int getNumOfCpus() {
    return this.getCpuPerSocket() * this.getNumOfSockets();
}
#method_after
public int getNumOfCpus() {
    return this.getCpuPerSocket() * this.getNumOfSockets() * this.getThreadsPerCpu();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, autoStartup, cpuPerSocket, creationDate, defaultBootSequence, description, failBack, initrdUrl, isoPath, kernelParams, kernelUrl, osId, memSizeMb, niceLevel, cpuShares, numOfSockets, numOfMonitors, origin, priority, stateless, smartcardEnabled, timeZone, usbPolicy, vdsGroupId, vmType, quotaId, allowConsoleReconnect, dedicatedVmForVdsList, migrationSupport, tunnelMigration, vncKeyboardLayout, createdByUserId, defaultDisplayType, migrationDowntime, serialNumberPolicy, customSerialNumber, bootMenuEnabled, spiceFileTransferEnabled, spiceCopyPasteEnabled, cpuProfileId, numaTuneMode, vNumaNodeList, autoConverge, migrateCompressed, predefinedProperties, userDefinedProperties, customEmulatedMachine, customCpuName, smallIconId, largeIconId, consoleDisconnectAction);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, autoStartup, cpuPerSocket, threadsPerCpu, creationDate, defaultBootSequence, description, failBack, initrdUrl, isoPath, kernelParams, kernelUrl, osId, memSizeMb, niceLevel, cpuShares, numOfSockets, numOfMonitors, origin, priority, stateless, smartcardEnabled, timeZone, usbPolicy, vdsGroupId, vmType, quotaId, allowConsoleReconnect, dedicatedVmForVdsList, migrationSupport, tunnelMigration, vncKeyboardLayout, createdByUserId, defaultDisplayType, migrationDowntime, serialNumberPolicy, customSerialNumber, bootMenuEnabled, spiceFileTransferEnabled, spiceCopyPasteEnabled, cpuProfileId, numaTuneMode, vNumaNodeList, autoConverge, migrateCompressed, predefinedProperties, userDefinedProperties, customEmulatedMachine, customCpuName, smallIconId, largeIconId, consoleDisconnectAction);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return Objects.equals(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && Objects.equals(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && Objects.equals(description, other.description) && failBack == other.failBack && Objects.equals(initrdUrl, other.initrdUrl) && Objects.equals(isoPath, other.isoPath) && Objects.equals(kernelParams, other.kernelParams) && Objects.equals(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && Objects.equals(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && Objects.equals(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && Objects.equals(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && Objects.equals(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && Objects.equals(tunnelMigration, other.tunnelMigration) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && Objects.equals(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && Objects.equals(cpuProfileId, other.cpuProfileId) && Objects.equals(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && Objects.equals(vNumaNodeList, other.vNumaNodeList) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(predefinedProperties, other.predefinedProperties) && Objects.equals(userDefinedProperties, other.userDefinedProperties) && Objects.equals(customEmulatedMachine, other.customEmulatedMachine) && Objects.equals(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && Objects.equals(consoleDisconnectAction, other.consoleDisconnectAction);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return Objects.equals(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && Objects.equals(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && Objects.equals(description, other.description) && failBack == other.failBack && Objects.equals(initrdUrl, other.initrdUrl) && Objects.equals(isoPath, other.isoPath) && Objects.equals(kernelParams, other.kernelParams) && Objects.equals(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && threadsPerCpu == other.threadsPerCpu && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && Objects.equals(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && Objects.equals(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && Objects.equals(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && Objects.equals(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && Objects.equals(tunnelMigration, other.tunnelMigration) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && Objects.equals(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && Objects.equals(cpuProfileId, other.cpuProfileId) && Objects.equals(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && Objects.equals(vNumaNodeList, other.vNumaNodeList) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(predefinedProperties, other.predefinedProperties) && Objects.equals(userDefinedProperties, other.userDefinedProperties) && Objects.equals(customEmulatedMachine, other.customEmulatedMachine) && Objects.equals(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && Objects.equals(consoleDisconnectAction, other.consoleDisconnectAction);
}
#end_block

#method_before
public List<Guid> getDedicatedVmForVdsList() {
    if (dedicatedVmForVdsList == null) {
        dedicatedVmForVdsList = new LinkedList<Guid>();
    }
    return dedicatedVmForVdsList;
}
#method_after
public List<Guid> getDedicatedVmForVdsList() {
    if (dedicatedVmForVdsList == null) {
        dedicatedVmForVdsList = new LinkedList<>();
    }
    return dedicatedVmForVdsList;
}
#end_block

#method_before
public void setDedicatedVmForVdsList(Guid value) {
    dedicatedVmForVdsList = new LinkedList<Guid>();
    dedicatedVmForVdsList.add(value);
}
#method_after
public void setDedicatedVmForVdsList(Guid value) {
    dedicatedVmForVdsList = new LinkedList<>();
    dedicatedVmForVdsList.add(value);
}
#end_block

#method_before
public void setvNumaNodeList(List<VmNumaNode> vNumaNodeList) {
    this.vNumaNodeList = vNumaNodeList;
}
#method_after
public void setvNumaNodeList(List<VmNumaNode> vNumaNodeList) {
    if (vNumaNodeList != null) {
        this.vNumaNodeList = vNumaNodeList;
    } else {
        this.vNumaNodeList = new ArrayList<>();
    }
}
#end_block

#method_before
public Map<String, Object> getSpecParams() {
    // function produce something like that:
    // vmPayload={volumeId:volume-id,file:{filename:content,filename2:content2,...}}
    Map<String, Object> specParams = new HashMap<String, Object>();
    Map<String, Object> payload = new HashMap<String, Object>();
    specParams.put(SpecParamsPayload, payload);
    if (volumeId != null) {
        payload.put(SpecParamsVolumeIdType, volumeId);
    }
    payload.put(SpecParamsFileType, files);
    return specParams;
}
#method_after
public Map<String, Object> getSpecParams() {
    // function produce something like that:
    // vmPayload={volumeId:volume-id,file:{filename:content,filename2:content2,...}}
    Map<String, Object> specParams = new HashMap<>();
    Map<String, Object> payload = new HashMap<>();
    specParams.put(SpecParamsPayload, payload);
    if (volumeId != null) {
        payload.put(SpecParamsVolumeIdType, volumeId);
    }
    payload.put(SpecParamsFileType, files);
    return specParams;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof IconWithOsDefault))
        return false;
    IconWithOsDefault other = (IconWithOsDefault) obj;
    return Objects.equals(icon, other.icon) && Objects.equals(osDefaultIcon, other.osDefaultIcon) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(validationResult, other.validationResult);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof IconWithOsDefault)) {
        return false;
    }
    IconWithOsDefault other = (IconWithOsDefault) obj;
    return Objects.equals(icon, other.icon) && Objects.equals(osDefaultIcon, other.osDefaultIcon) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(validationResult, other.validationResult);
}
#end_block

#method_before
List<Integer> addToHistory(List<Integer> current, Integer newValue, int limit) {
    if (newValue == null) {
        return current;
    }
    if (current == null || current.isEmpty()) {
        return Arrays.asList(newValue);
    }
    if (limit == 0) {
        return Collections.emptyList();
    }
    List<Integer> res = new ArrayList<Integer>(current);
    res.add(newValue);
    if (limit >= res.size()) {
        return res;
    }
    return res.subList(res.size() - limit, res.size());
}
#method_after
List<Integer> addToHistory(List<Integer> current, Integer newValue, int limit) {
    if (newValue == null) {
        return current;
    }
    if (current == null || current.isEmpty()) {
        return Arrays.asList(newValue);
    }
    if (limit == 0) {
        return Collections.emptyList();
    }
    List<Integer> res = new ArrayList<>(current);
    res.add(newValue);
    if (limit >= res.size()) {
        return res;
    }
    return res.subList(res.size() - limit, res.size());
}
#end_block

#method_before
private void updateSelectedList() {
    Set<Integer> indexes = new HashSet<Integer>();
    // Reset the current selected values, we will locate the right selected values below.
    selectedList.clear();
    ListBox listBox = asListBox();
    // item and deselecting it, then at the end re-select them all. This avoids the loop.
    while (listBox.getSelectedIndex() >= 0) {
        int index = listBox.getSelectedIndex();
        listBox.setItemSelected(index, false);
        if (index >= 0 && index < typedItemList.size()) {
            T value = typedItemList.get(index);
            selectedList.add(value);
        }
        // Mark the index, so we can reselect at the end.
        indexes.add(index);
    }
    // Put back the selection.
    for (Integer index : indexes) {
        listBox.setItemSelected(index, true);
    }
}
#method_after
private void updateSelectedList() {
    Set<Integer> indexes = new HashSet<>();
    // Reset the current selected values, we will locate the right selected values below.
    selectedList.clear();
    ListBox listBox = asListBox();
    // item and deselecting it, then at the end re-select them all. This avoids the loop.
    while (listBox.getSelectedIndex() >= 0) {
        int index = listBox.getSelectedIndex();
        listBox.setItemSelected(index, false);
        if (index >= 0 && index < typedItemList.size()) {
            T value = typedItemList.get(index);
            selectedList.add(value);
        }
        // Mark the index, so we can reselect at the end.
        indexes.add(index);
    }
    // Put back the selection.
    for (Integer index : indexes) {
        listBox.setItemSelected(index, true);
    }
}
#end_block

#method_before
@Override
public void setAcceptableValues(Collection<List<T>> newValues) {
    // Set a value in the super class, so calling setAcceptableValues doesn't add a null value and
    // potentially NPE if the renderer doesn't take kindly to getting a null value passed to it.
    List<T> val = (newValues == null || newValues.isEmpty()) ? null : newValues.iterator().next();
    super.setValue(val, false);
    // Populate the list box.
    super.setAcceptableValues(newValues);
    // break if more than one type value renders to the same string.
    for (List<T> value : newValues) {
        addToItems(value);
    }
}
#method_after
@Override
public void setAcceptableValues(Collection<List<T>> newValues) {
    if (newValues == null) {
        newValues = Collections.emptyList();
    }
    // Set a value in the super class, so calling setAcceptableValues doesn't add a null value and
    // potentially NPE if the renderer doesn't take kindly to getting a null value passed to it.
    List<T> val = newValues.isEmpty() ? Collections.<T>emptyList() : newValues.iterator().next();
    super.setValue(val, false);
    // Populate the list box.
    super.setAcceptableValues(newValues);
    // Store the rendered values so we can reverse them to find the right typed value. This will
    // break if more than one type value renders to the same string.
    typedItemList.clear();
    for (List<T> value : newValues) {
        addToItems(value);
    }
}
#end_block

#method_before
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("num_of_io_threads", entity.getNumOfIoThreads()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("threads_per_cpu", entity.getThreadsPerCore()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVdsList().isEmpty() ? null : StringUtils.join(entity.getDedicatedVmForVdsList(), BaseDao.SEPARATOR)).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName()).addValue(SMALL_ICON_ID_COLUMN, entity.getSmallIconId()).addValue(LARGE_ICON_ID_COLUMN, entity.getLargeIconId()).addValue("console_disconnect_action", entity.getConsoleDisconnectAction().toString());
}
#method_after
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("num_of_io_threads", entity.getNumOfIoThreads()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("threads_per_cpu", entity.getThreadsPerCpu()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVdsList().isEmpty() ? null : StringUtils.join(entity.getDedicatedVmForVdsList(), BaseDao.SEPARATOR)).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName()).addValue(SMALL_ICON_ID_COLUMN, entity.getSmallIconId()).addValue(LARGE_ICON_ID_COLUMN, entity.getLargeIconId()).addValue("console_disconnect_action", entity.getConsoleDisconnectAction().toString());
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setNumOfIoThreads(rs.getInt("num_of_io_threads"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setThreadsPerCore(rs.getInt("threads_per_cpu"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVdsList(GuidUtils.getGuidListFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
    entity.setSmallIconId(getGuid(rs, SMALL_ICON_ID_COLUMN));
    entity.setLargeIconId(getGuid(rs, LARGE_ICON_ID_COLUMN));
    entity.setConsoleDisconnectAction(ConsoleDisconnectAction.fromDbString(rs.getString("console_disconnect_action")));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setNumOfIoThreads(rs.getInt("num_of_io_threads"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setThreadsPerCpu(rs.getInt("threads_per_cpu"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVdsList(GuidUtils.getGuidListFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
    entity.setSmallIconId(getGuid(rs, SMALL_ICON_ID_COLUMN));
    entity.setLargeIconId(getGuid(rs, LARGE_ICON_ID_COLUMN));
    entity.setConsoleDisconnectAction(ConsoleDisconnectAction.fromDbString(rs.getString("console_disconnect_action")));
}
#end_block

#method_before
@Override
public boolean isApplicable(VDSGroup oldCluster, VDSGroup newCluster) {
    if (!newCluster.supportsVirtService() || !oldCluster.supportsVirtService()) {
        return true;
    }
    newCpuName = newCluster.getCpuName();
    final String oldCpuName = oldCluster.getCpuName();
    return !newCpuName.equals(oldCpuName);
}
#method_after
@Override
public boolean isApplicable(VDSGroup oldCluster, VDSGroup newCluster) {
    newCpuName = newCluster.getCpuName();
    final String oldCpuName = oldCluster.getCpuName();
    return newCpuName != null && !newCpuName.equals(oldCpuName);
}
#end_block

#method_before
public static boolean supportedInConfig(ConfigValues feature, Version version, ArchitectureType arch) {
    Map<String, String> archOptions = Config.<Map>getValue(feature, version.getValue());
    if (archOptions != null) {
        String val = archOptions.get(arch.name());
        if (val == null) {
            val = archOptions.get(arch.getBaseArchitecture().name());
        }
        return Boolean.parseBoolean(val);
    }
    return false;
}
#method_after
public static boolean supportedInConfig(ConfigValues feature, Version version, ArchitectureType arch) {
    Map<String, String> archOptions = Config.<Map>getValue(feature, version.getValue());
    return Boolean.parseBoolean(archOptions.getOrDefault(arch.name(), archOptions.get(arch.getFamily().name())));
}
#end_block

#method_before
private VM mockVm() {
    vm = new VM();
    vm.setId(vmId);
    vm.setName(VM_NAME);
    vm.setDiskMap(new HashMap<Guid, Disk>());
    return vm;
}
#method_after
private VM mockVm() {
    vm = new VM();
    vm.setId(vmId);
    vm.setName(VM_NAME);
    vm.setDiskMap(new HashMap<>());
    return vm;
}
#end_block

#method_before
private Collection<DiskImage> getVmDisksDummies() {
    Collection<DiskImage> disksDummies = new LinkedList<>();
    for (Guid storageDomainId : getParameters().getImageToDestinationDomainMap().values()) {
        DiskImage diskImage = new DiskImage();
        diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
        disksDummies.add(diskImage);
    }
    return disksDummies;
}
#method_after
private Collection<DiskImage> getVmDisksDummies() {
    Collection<DiskImage> disksDummies = new LinkedList<>();
    for (Guid storageDomainId : getParameters().getImageToDestinationDomainMap().values()) {
        DiskImage diskImage = new DiskImage();
        diskImage.setStorageIds(new ArrayList<>(Arrays.asList(storageDomainId)));
        disksDummies.add(diskImage);
    }
    return disksDummies;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.transformToList(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        Set<Guid> domainsId = domains.stream().map(StorageDomain::getId).collect(Collectors.toSet());
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<RemoveSnapshotSingleDiskLiveStep, Guid>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(CommandCoordinatorUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case NOT_STARTED:
                log.info("Waiting on Live Merge command step '{}' to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
                if (cmdEntity.isCallbackEnabled() && !cmdEntity.isCallbackNotified()) {
                    log.info("Waiting on Live Merge command step '{}' to finalize", getParameters().getCommandStep());
                    return;
                }
                vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.error("Unknown child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
    }
}
#method_after
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(CommandCoordinatorUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case NOT_STARTED:
                log.info("Waiting on Live Merge command step '{}' to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
                if (cmdEntity.isCallbackEnabled() && !cmdEntity.isCallbackNotified()) {
                    log.info("Waiting on Live Merge command step '{}' to finalize", getParameters().getCommandStep());
                    return;
                }
                vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.error("Unknown child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
    }
}
#end_block

#method_before
private void prepareCopyNotTemplate(MoveOrCopyImageGroupParameters parameters) {
    parameters.setAddImageDomainMapping(false);
    Guid newImageId = Guid.newGuid();
    Guid newId = Guid.newGuid();
    DiskImage image = getImage();
    image.setId(newId);
    image.setImageId(newImageId);
    image.setDiskAlias(getDiskAlias());
    image.setStorageIds(new ArrayList<Guid>());
    image.getStorageIds().add(getParameters().getStorageDomainId());
    image.setQuotaId(getParameters().getQuotaId());
    image.setDiskProfileId(getParameters().getDiskProfileId());
    image.setImageStatus(ImageStatus.LOCKED);
    parameters.setDestinationImageId(newImageId);
    parameters.setDestImageGroupId(newId);
}
#method_after
private void prepareCopyNotTemplate(MoveOrCopyImageGroupParameters parameters) {
    parameters.setAddImageDomainMapping(false);
    Guid newImageId = Guid.newGuid();
    Guid newId = Guid.newGuid();
    DiskImage image = getImage();
    image.setId(newId);
    image.setImageId(newImageId);
    image.setDiskAlias(getDiskAlias());
    image.setStorageIds(new ArrayList<>());
    image.getStorageIds().add(getParameters().getStorageDomainId());
    image.setQuotaId(getParameters().getQuotaId());
    image.setDiskProfileId(getParameters().getDiskProfileId());
    image.setImageStatus(ImageStatus.LOCKED);
    parameters.setDestinationImageId(newImageId);
    parameters.setDestImageGroupId(newId);
}
#end_block

#method_before
@Before
public void setUp() {
    disk = new DiskImage();
    setupDisk();
    Guid vmId = Guid.newGuid();
    vm = new VM();
    vm.setId(vmId);
    VmDeviceId vmDeviceId = new VmDeviceId(disk.getId(), vmId);
    vmDevice = new VmDevice();
    vmDevice.setId(vmDeviceId);
    vmDevice.setIsPlugged(true);
    when(vmDao.getVmsListForDisk(disk.getId(), Boolean.TRUE)).thenReturn(Collections.singletonList(vm));
    when(vmDeviceDao.get(vmDeviceId)).thenReturn(vmDevice);
    RemoveDiskParameters params = new RemoveDiskParameters(disk.getId());
    cmd = spy(new RemoveDiskCommand<RemoveDiskParameters>(params));
    doReturn(disk).when(cmd).getDisk();
    doReturn(vmDeviceDao).when(cmd).getVmDeviceDao();
    doReturn(vmDao).when(cmd).getVmDao();
}
#method_after
@Before
public void setUp() {
    disk = new DiskImage();
    setupDisk();
    Guid vmId = Guid.newGuid();
    vm = new VM();
    vm.setId(vmId);
    VmDeviceId vmDeviceId = new VmDeviceId(disk.getId(), vmId);
    vmDevice = new VmDevice();
    vmDevice.setId(vmDeviceId);
    vmDevice.setIsPlugged(true);
    when(vmDao.getVmsListForDisk(disk.getId(), Boolean.TRUE)).thenReturn(Collections.singletonList(vm));
    when(vmDeviceDao.get(vmDeviceId)).thenReturn(vmDevice);
    RemoveDiskParameters params = new RemoveDiskParameters(disk.getId());
    cmd = spy(new RemoveDiskCommand<>(params));
    doReturn(disk).when(cmd).getDisk();
    doReturn(vmDeviceDao).when(cmd).getVmDeviceDao();
    doReturn(vmDao).when(cmd).getVmDao();
}
#end_block

#method_before
@Before
public void setUp() {
    vmId = Guid.newGuid();
    diskId = Guid.newGuid();
    poolId = Guid.newGuid();
    storageDomainId = Guid.newGuid();
    groupId = Guid.newGuid();
    vdsId = Guid.newGuid();
    disk = new DiskImage();
    disk.setId(diskId);
    disk.setVmEntityType(VmEntityType.VM);
    disk.setImageStatus(ImageStatus.OK);
    disk.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
    vm = new VM();
    vm.setId(vmId);
    vm.setStatus(VMStatus.Down);
    vm.setStoragePoolId(poolId);
    vm.setVdsGroupId(groupId);
    VmDeviceId vmDeviceId = new VmDeviceId(diskId, vmId);
    vmDevice = new VmDevice();
    vmDevice.setId(vmDeviceId);
    vdsGroup = new VDSGroup();
    vdsGroup.setId(groupId);
    vds = new VDS();
    vds.setId(vdsId);
    storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    storageDomain = new StorageDomain();
    storageDomain.setStorageType(StorageType.ISCSI);
    when(vmDao.getVmsListForDisk(diskId, Boolean.FALSE)).thenReturn(Collections.singletonList(vm));
    when(vmDeviceDao.get(vmDeviceId)).thenReturn(vmDevice);
    when(vdsDao.getAllForVdsGroupWithStatus(groupId, VDSStatus.Up)).thenReturn(Collections.singletonList(vds));
    when(spDao.get(poolId)).thenReturn(storagePool);
    when(vdsGroupDao.get(groupId)).thenReturn(vdsGroup);
    when(storageDomainStaticDao.get(storageDomainId)).thenReturn(storageDomain.getStorageStaticData());
    cmd = spy(new GetDiskAlignmentCommand<GetDiskAlignmentParameters>(new GetDiskAlignmentParameters(diskId)));
    doReturn(disk).when(cmd).getDisk();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(spDao).when(cmd).getStoragePoolDao();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDao();
    doReturn(storageDomainStaticDao).when(cmd).getStorageDomainStaticDao();
}
#method_after
@Before
public void setUp() {
    vmId = Guid.newGuid();
    diskId = Guid.newGuid();
    poolId = Guid.newGuid();
    storageDomainId = Guid.newGuid();
    groupId = Guid.newGuid();
    vdsId = Guid.newGuid();
    disk = new DiskImage();
    disk.setId(diskId);
    disk.setVmEntityType(VmEntityType.VM);
    disk.setImageStatus(ImageStatus.OK);
    disk.setStorageIds(new ArrayList<>(Arrays.asList(storageDomainId)));
    vm = new VM();
    vm.setId(vmId);
    vm.setStatus(VMStatus.Down);
    vm.setStoragePoolId(poolId);
    vm.setVdsGroupId(groupId);
    VmDeviceId vmDeviceId = new VmDeviceId(diskId, vmId);
    vmDevice = new VmDevice();
    vmDevice.setId(vmDeviceId);
    vdsGroup = new VDSGroup();
    vdsGroup.setId(groupId);
    vds = new VDS();
    vds.setId(vdsId);
    storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    storageDomain = new StorageDomain();
    storageDomain.setStorageType(StorageType.ISCSI);
    when(vmDao.getVmsListForDisk(diskId, Boolean.FALSE)).thenReturn(Collections.singletonList(vm));
    when(vmDeviceDao.get(vmDeviceId)).thenReturn(vmDevice);
    when(vdsDao.getAllForVdsGroupWithStatus(groupId, VDSStatus.Up)).thenReturn(Collections.singletonList(vds));
    when(spDao.get(poolId)).thenReturn(storagePool);
    when(vdsGroupDao.get(groupId)).thenReturn(vdsGroup);
    when(storageDomainStaticDao.get(storageDomainId)).thenReturn(storageDomain.getStorageStaticData());
    cmd = spy(new GetDiskAlignmentCommand<>(new GetDiskAlignmentParameters(diskId)));
    doReturn(disk).when(cmd).getDisk();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(spDao).when(cmd).getStoragePoolDao();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDao();
    doReturn(storageDomainStaticDao).when(cmd).getStorageDomainStaticDao();
}
#end_block

#method_before
@Test
public void getFCStorageTypeForLun() throws Exception {
    LUNs lun = new LUNs();
    ArrayList<StorageServerConnections> connections = new ArrayList<StorageServerConnections>();
    lun.setLunConnections(connections);
    StorageType storageType = command.getLUNStorageType(lun);
    assertEquals("Lun disk should be of FC storage type since it does not had connections", StorageType.FCP, storageType);
}
#method_after
@Test
public void getFCStorageTypeForLun() throws Exception {
    LUNs lun = new LUNs();
    ArrayList<StorageServerConnections> connections = new ArrayList<>();
    lun.setLunConnections(connections);
    StorageType storageType = command.getLUNStorageType(lun);
    assertEquals("Lun disk should be of FC storage type since it does not had connections", StorageType.FCP, storageType);
}
#end_block

#method_before
@Test
public void getISCSIStorageTypeForLun() throws Exception {
    LUNs lun = new LUNs();
    ArrayList<StorageServerConnections> connections = new ArrayList<StorageServerConnections>();
    connections.add(new StorageServerConnections("Some LUN connection", "id", "iqn", "password", StorageType.ISCSI, "Username", "port", "portal"));
    lun.setLunConnections(connections);
    StorageType storageType = command.getLUNStorageType(lun);
    assertEquals("Lun disk should be of ISCSI storage type since it has one connection with ISCSI storage type", StorageType.ISCSI, storageType);
}
#method_after
@Test
public void getISCSIStorageTypeForLun() throws Exception {
    LUNs lun = new LUNs();
    ArrayList<StorageServerConnections> connections = new ArrayList<>();
    connections.add(new StorageServerConnections("Some LUN connection", "id", "iqn", "password", StorageType.ISCSI, "Username", "port", "portal"));
    lun.setLunConnections(connections);
    StorageType storageType = command.getLUNStorageType(lun);
    assertEquals("Lun disk should be of ISCSI storage type since it has one connection with ISCSI storage type", StorageType.ISCSI, storageType);
}
#end_block

#method_before
protected HotPlugDiskToVmCommand<HotPlugDiskToVmParameters> createCommand() {
    return new HotPlugDiskToVmCommand<HotPlugDiskToVmParameters>(createParameters());
}
#method_after
protected HotPlugDiskToVmCommand<HotPlugDiskToVmParameters> createCommand() {
    return new HotPlugDiskToVmCommand<>(createParameters());
}
#end_block

#method_before
private void mockVMDao(VM vm) {
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDao.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(vmList);
}
#method_after
private void mockVMDao(VM vm) {
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDao.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(vmList);
}
#end_block

#method_before
protected void mockInterfaceList() {
    ArrayList<String> diskInterfaces = new ArrayList<String>(Arrays.asList(new String[] { "IDE", "VirtIO", "VirtIO_SCSI" }));
    when(osRepository.getDiskInterfaces(anyInt(), any(Version.class))).thenReturn(diskInterfaces);
}
#method_after
protected void mockInterfaceList() {
    ArrayList<String> diskInterfaces = new ArrayList<>(Arrays.asList(new String[] { "IDE", "VirtIO", "VirtIO_SCSI" }));
    when(osRepository.getDiskInterfaces(anyInt(), any(Version.class))).thenReturn(diskInterfaces);
}
#end_block

#method_before
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    return disk;
}
#method_after
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<>(DISK_HOTPLUGGABLE_INTERFACES));
    return disk;
}
#end_block

#method_before
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(false);
}
#method_after
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(false);
}
#end_block

#method_before
protected void addConnection(LUNs lun, StorageServerConnections cnx) {
    if (lun.getLunConnections() == null) {
        lun.setLunConnections(new ArrayList<StorageServerConnections>());
    }
    lun.getLunConnections().add(cnx);
}
#method_after
protected void addConnection(LUNs lun, StorageServerConnections cnx) {
    if (lun.getLunConnections() == null) {
        lun.setLunConnections(new ArrayList<>());
    }
    lun.getLunConnections().add(cnx);
}
#end_block

#method_before
private void initializeCommand(Guid storageId, AddDiskParameters params) {
    params.setStorageDomainId(storageId);
    command = spy(new AddDiskCommand<AddDiskParameters>(params));
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(storagePoolIsoMapDao).when(command).getStoragePoolIsoMapDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(vmNicDao).when(command).getVmNicDao();
    doReturn(diskLunMapDao).when(command).getDiskLunMapDao();
    doReturn(vmDao).when(command).getVmDao();
    doNothing().when(command).updateDisksFromDb();
    doReturn(true).when(command).checkImageConfiguration();
    doReturn(mockSnapshotValidator()).when(command).getSnapshotsValidator();
    doReturn(false).when(command).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(false).when(command).hasWatchdog(any(Guid.class));
    doReturn(false).when(command).isBalloonEnabled(any(Guid.class));
    doReturn(false).when(command).isSoundDeviceEnabled(any(Guid.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
}
#method_after
private void initializeCommand(Guid storageId, AddDiskParameters params) {
    params.setStorageDomainId(storageId);
    command = spy(new AddDiskCommand<>(params));
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(storagePoolIsoMapDao).when(command).getStoragePoolIsoMapDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(vmNicDao).when(command).getVmNicDao();
    doReturn(diskLunMapDao).when(command).getDiskLunMapDao();
    doReturn(vmDao).when(command).getVmDao();
    doNothing().when(command).updateDisksFromDb();
    doReturn(true).when(command).checkImageConfiguration();
    doReturn(mockSnapshotValidator()).when(command).getSnapshotsValidator();
    doReturn(false).when(command).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(false).when(command).hasWatchdog(any(Guid.class));
    doReturn(false).when(command).isBalloonEnabled(any(Guid.class));
    doReturn(false).when(command).isSoundDeviceEnabled(any(Guid.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
}
#end_block

#method_before
private void mockVmWithDisk(Guid storageId) {
    DiskImage image = new DiskImage();
    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageId)));
    mockVm().getDiskMap().put(image.getId(), image);
}
#method_after
private void mockVmWithDisk(Guid storageId) {
    DiskImage image = new DiskImage();
    image.setStorageIds(new ArrayList<>(Arrays.asList(storageId)));
    mockVm().getDiskMap().put(image.getId(), image);
}
#end_block

#method_before
protected void mockInterfaceList() {
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    ArrayList<String> diskInterfaces = new ArrayList<String>(Arrays.asList(new String[] { "IDE", "VirtIO", "VirtIO_SCSI" }));
    when(osRepository.getDiskInterfaces(anyInt(), any(Version.class))).thenReturn(diskInterfaces);
}
#method_after
protected void mockInterfaceList() {
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    ArrayList<String> diskInterfaces = new ArrayList<>(Arrays.asList(new String[] { "IDE", "VirtIO", "VirtIO_SCSI" }));
    when(osRepository.getDiskInterfaces(anyInt(), any(Version.class))).thenReturn(diskInterfaces);
}
#end_block

#method_before
private static LunDisk createISCSILunDisk() {
    LunDisk disk = new LunDisk();
    LUNs lun = new LUNs();
    lun.setLUN_id("lunid");
    lun.setLunType(StorageType.ISCSI);
    StorageServerConnections connection = new StorageServerConnections();
    connection.setiqn("a");
    connection.setconnection("0.0.0.0");
    connection.setport("1234");
    ArrayList<StorageServerConnections> connections = new ArrayList<StorageServerConnections>();
    connections.add(connection);
    lun.setLunConnections(connections);
    disk.setLun(lun);
    return disk;
}
#method_after
private static LunDisk createISCSILunDisk() {
    LunDisk disk = new LunDisk();
    LUNs lun = new LUNs();
    lun.setLUN_id("lunid");
    lun.setLunType(StorageType.ISCSI);
    StorageServerConnections connection = new StorageServerConnections();
    connection.setiqn("a");
    connection.setconnection("0.0.0.0");
    connection.setport("1234");
    ArrayList<StorageServerConnections> connections = new ArrayList<>();
    connections.add(connection);
    lun.setLunConnections(connections);
    disk.setLun(lun);
    return disk;
}
#end_block

#method_before
private void fillDiskMap(LunDisk disk, VM vm, int expectedMapSize) {
    Map<Guid, Disk> diskMap = new HashMap<Guid, Disk>();
    for (int i = 0; i < expectedMapSize; i++) {
        diskMap.put(Guid.newGuid(), disk);
    }
    vm.setDiskMap(diskMap);
}
#method_after
private void fillDiskMap(LunDisk disk, VM vm, int expectedMapSize) {
    Map<Guid, Disk> diskMap = new HashMap<>();
    for (int i = 0; i < expectedMapSize; i++) {
        diskMap.put(Guid.newGuid(), disk);
    }
    vm.setDiskMap(diskMap);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (!getParameters().isLeaveLocked()) {
        getDestinationDiskImage().setImageStatus(ImageStatus.OK);
        getImageDao().update(getDestinationDiskImage().getImage());
    }
    if (!getParameters().isParentHasTasks() && CommandCoordinatorUtil.getChildCommandIds(getParentParameters().getCommandId()).size() == 1) {
        getBackend().endAction(getParameters().getParentCommand(), getParameters().getParentParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (!getParameters().isLeaveLocked()) {
        getDestinationDiskImage().setImageStatus(ImageStatus.OK);
        getImageDao().update(getDestinationDiskImage().getImage());
    }
    if (!getParameters().isParentHasTasks() && CommandCoordinatorUtil.getChildCommandIds(getParentParameters().getCommandId()).size() == 1) {
        getBackend().endAction(getParameters().getParentCommand(), getParameters().getParentParameters(), getContext().clone().withoutCompensationContext().withoutLock());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // TODO: Add revert tasks for Cinder
    if (isDestinationImageExists(getDestinationDiskImage().getId()) && (isImageSnapshot(getDestinationDiskImage()))) {
        updateLastModifiedInParent(getDestinationDiskImage().getParentId());
    }
    super.endWithFailure();
    if (!getParameters().isParentHasTasks()) {
        getParameters().getParentParameters().setTaskGroupSuccess(false);
        getBackend().endAction(getParameters().getParentCommand(), getParameters().getParentParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#method_after
@Override
protected void endWithFailure() {
    // TODO: Add revert tasks for Cinder
    if (isDestinationImageExists(getDestinationDiskImage().getId()) && (isImageSnapshot(getDestinationDiskImage()))) {
        updateLastModifiedInParent(getDestinationDiskImage().getParentId());
    }
    super.endWithFailure();
    if (!getParameters().isParentHasTasks()) {
        getParameters().getParentParameters().setTaskGroupSuccess(false);
        getBackend().endAction(getParameters().getParentCommand(), getParameters().getParentParameters(), getContext().clone().withoutCompensationContext().withoutLock());
    }
}
#end_block

#method_before
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Guid vdsToRunOn = schedulingManager.schedule(getVdsGroup(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setDestinationVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (vdsToRunOn != null && vdsToRunOn.equals(Guid.Empty)) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#method_after
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Guid vdsToRunOn = schedulingManager.schedule(getVdsGroup(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setDestinationVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (vdsToRunOn != null && vdsToRunOn.equals(Guid.Empty)) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected void initializeCommand(ImageOperation operation, Disk disk) {
    command = spy(new MoveOrCopyDiskCommandDummy(new MoveOrCopyImageGroupParameters(diskImageGuid, srcStorageId, destStorageId, operation)));
    doReturn(vmDao).when(command).getVmDao();
    doReturn(diskDao).when(command).getDiskDao();
    this.disk = disk;
    when(diskDao.get(any(Guid.class))).thenReturn(this.disk);
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(new ArrayList<Pair<VM, VmDevice>>());
    doReturn(new ArrayList<DiskImage>()).when(command).getAllImageSnapshots();
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(disk.getId()).when(command).getImageGroupId();
}
#method_after
@SuppressWarnings("unchecked")
protected void initializeCommand(ImageOperation operation, Disk disk) {
    command = spy(new MoveOrCopyDiskCommandDummy(new MoveOrCopyImageGroupParameters(diskImageGuid, srcStorageId, destStorageId, operation)));
    doReturn(vmDao).when(command).getVmDao();
    doReturn(diskDao).when(command).getDiskDao();
    this.disk = disk;
    when(diskDao.get(any(Guid.class))).thenReturn(this.disk);
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(new ArrayList<>());
    doReturn(new ArrayList<DiskImage>()).when(command).getAllImageSnapshots();
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(disk.getId()).when(command).getImageGroupId();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnValue = extendUnderlyingVolumeSize(getImage());
    setSucceeded(vdsReturnValue.getSucceeded());
    if (vdsReturnValue.getSucceeded()) {
        Guid taskId = createTask(getAsyncTaskId(), vdsReturnValue.getCreationInfo(), getParameters().getParentCommand());
        getReturnValue().getInternalVdsmTaskIdList().add(taskId);
        if (getParameters().getParentNotifiesCallback()) {
            getParameters().setVdsmTaskIds(new ArrayList<Guid>(Collections.singletonList(taskId)));
            getReturnValue().getVdsmTaskIdList().add(taskId);
            persistCommand(getParameters().getParentCommand(), true);
        }
    } else {
        updateAuditLog(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, getParameters().getNewSizeInGB());
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnValue = extendUnderlyingVolumeSize(getImage());
    setSucceeded(vdsReturnValue.getSucceeded());
    if (vdsReturnValue.getSucceeded()) {
        Guid taskId = createTask(getAsyncTaskId(), vdsReturnValue.getCreationInfo(), getParameters().getParentCommand());
        getReturnValue().getInternalVdsmTaskIdList().add(taskId);
        if (getParameters().getParentNotifiesCallback()) {
            getParameters().setVdsmTaskIds(new ArrayList<>(Collections.singletonList(taskId)));
            getReturnValue().getVdsmTaskIdList().add(taskId);
            persistCommand(getParameters().getParentCommand(), true);
        }
    } else {
        updateAuditLog(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, getParameters().getNewSizeInGB());
    }
}
#end_block

#method_before
private void createInputLUNs() {
    LUNs lunWithVG = new LUNs();
    lunWithVG.setLUN_id(Guid.newGuid().toString());
    lunWithVG.setvolume_group_id(Guid.newGuid().toString());
    LUNs lunExistsInDB = new LUNs();
    lunExistsInDB.setLUN_id(Guid.newGuid().toString());
    lunsInput = new ArrayList<LUNs>();
    lunsInput.add(lunWithVG);
    lunsInput.add(lunExistsInDB);
    lunsFromDb = new ArrayList<LUNs>();
    lunsFromDb.add(lunExistsInDB);
}
#method_after
private void createInputLUNs() {
    LUNs lunWithVG = new LUNs();
    lunWithVG.setLUN_id(Guid.newGuid().toString());
    lunWithVG.setvolume_group_id(Guid.newGuid().toString());
    LUNs lunExistsInDB = new LUNs();
    lunExistsInDB.setLUN_id(Guid.newGuid().toString());
    lunsInput = new ArrayList<>();
    lunsInput.add(lunWithVG);
    lunsInput.add(lunExistsInDB);
    lunsFromDb = new ArrayList<>();
    lunsFromDb.add(lunExistsInDB);
}
#end_block

#method_before
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getSnappableVmDisks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.METADATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#method_after
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getDisksListForChecks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.METADATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#end_block

#method_before
private void createSnapshotsForDisks() {
    for (DiskImage disk : getDisksList()) {
        if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
            ImagesContainterParametersBase params = buildChildCommandParameters(disk);
            params.setQuotaId(disk.getQuotaId());
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CreateCinderSnapshot, params, cloneContextAndDetachFromParent());
            try {
                VdcReturnValueBase vdcReturnValueBase = future.get();
                if (!vdcReturnValueBase.getSucceeded()) {
                    log.error("Error creating snapshot for Cinder disk '{}'", disk.getDiskAlias());
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error creating snapshot for Cinder disk '{}': {}", disk.getDiskAlias(), e.getMessage());
                throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
            }
            continue;
        }
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshot, buildCreateSnapshotParameters(disk), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (vdcReturnValue.getSucceeded()) {
            getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            throw new EngineException(vdcReturnValue.getFault().getError(), "Failed to create snapshot!");
        }
    }
}
#method_after
private void createSnapshotsForDisks() {
    for (DiskImage disk : getDisksList()) {
        if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
            ImagesContainterParametersBase params = buildChildCommandParameters(disk);
            params.setQuotaId(disk.getQuotaId());
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CreateCinderSnapshot, params, cloneContext().withoutCompensationContext().withoutLock());
            try {
                VdcReturnValueBase vdcReturnValueBase = future.get();
                if (!vdcReturnValueBase.getSucceeded()) {
                    log.error("Error creating snapshot for Cinder disk '{}'", disk.getDiskAlias());
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error creating snapshot for Cinder disk '{}': {}", disk.getDiskAlias(), e.getMessage());
                throw new EngineException(EngineError.CINDER_ERROR, "Failed to create snapshot!");
            }
            continue;
        }
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshot, buildCreateSnapshotParameters(disk), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (vdcReturnValue.getSucceeded()) {
            getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            throw new EngineException(vdcReturnValue.getFault().getError(), "Failed to create snapshot!");
        }
    }
}
#end_block

#method_before
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            VmTemplate tmpl = LinqUtils.firstOrNull(templates.keySet(), new Predicate<VmTemplate>() {

                @Override
                public boolean eval(VmTemplate vmTemplate) {
                    return vmTemplate.getId().equals(tmplId);
                }
            });
            retVal = tmpl != null;
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#method_after
public static boolean checkTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId, EngineContext engineContext) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, engineContext);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(tmplId)) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            retVal = templates.keySet().stream().anyMatch(vmTemplate -> vmTemplate.getId().equals(tmplId));
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (shouldOverrideSoundDevice()) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (shouldOverrideSoundDevice()) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#end_block

#method_before
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<VmNic>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#end_block

#method_before
protected boolean shouldCheckSpaceInStorageDomains() {
    return !getImagesToCheckDestinationStorageDomains().isEmpty() && !LinqUtils.firstOrNull(getImagesToCheckDestinationStorageDomains(), new All<DiskImage>()).getImageId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
}
#method_after
protected boolean shouldCheckSpaceInStorageDomains() {
    return !getImagesToCheckDestinationStorageDomains().stream().map(DiskImage::getImageId).findFirst().orElse(VmTemplateHandler.BLANK_VM_TEMPLATE_ID).equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
}
#end_block

#method_before
private boolean validateProvidedDestinations() {
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        if (diskImage.getStorageIds() == null || diskImage.getStorageIds().isEmpty()) {
            diskImage.setStorageIds(new ArrayList<Guid>());
            diskImage.getStorageIds().add(getParameters().getStorageDomainId());
        }
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        if (destStorages.get(storageDomainId) == null) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePoolId());
            StorageDomainValidator validator = new StorageDomainValidator(storage);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            destStorages.put(storage.getId(), storage);
        }
    }
    return true;
}
#method_after
private boolean validateProvidedDestinations() {
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        if (diskImage.getStorageIds() == null || diskImage.getStorageIds().isEmpty()) {
            diskImage.setStorageIds(new ArrayList<>());
            diskImage.getStorageIds().add(getParameters().getStorageDomainId());
        }
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        if (destStorages.get(storageDomainId) == null) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePoolId());
            StorageDomainValidator validator = new StorageDomainValidator(storage);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            destStorages.put(storage.getId(), storage);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance on the cluster is enough
        if (permSubject.getObjectType() == VdcObjectType.VdsGroups && getInstanceTypeId() != null) {
            permSubject.setActionGroup(ActionGroup.CREATE_INSTANCE);
            if (checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
                continue;
            }
            // create_vm is overriding in case no create_instance, try again with it
            permSubject.setActionGroup(getActionType().getActionGroup());
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance may be sufficient
        if (getInstanceTypeId() != null && checkCreateInstancePermission(permSubject)) {
            continue;
        }
        // create_vm is overriding in case no create_instance, try again with it
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private DiskImage createDiskImage() {
    DiskImage disk = new DiskImage();
    disk.setId(diskId);
    Collections.singletonList(storageId);
    disk.setStorageIds(new ArrayList<Guid>(Collections.singletonList(storageId)));
    return disk;
}
#method_after
private DiskImage createDiskImage() {
    DiskImage disk = new DiskImage();
    disk.setId(diskId);
    Collections.singletonList(storageId);
    disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageId)));
    return disk;
}
#end_block

#method_before
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, Guid diskProfileId, VdcActionType parentCommandType) {
    DiskImage newDiskImage = cloneDiskImage(destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage, diskProfileId);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, result);
}
#method_after
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, Guid diskProfileId, VdcActionType parentCommandType) {
    DiskImage newDiskImage = ImagesHandler.cloneDiskImage(getVmId(), destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage, diskProfileId, getVmSnapshotId(), diskInfoDestinationMap != null ? diskInfoDestinationMap.get(diskImage.getId()) : null);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, result);
}
#end_block

#method_before
private void setUpDaoMocks() {
    // Mock some devices
    VmDevice pluggedDevice = createVMDevice(vmID, pluggedDisk);
    VmDevice unpluggedDevice = createVMDevice(vmID, unpluggedDisk);
    VmDevice pluggedSnapshotDevice = createVMDevice(vmID, pluggedDiskSnapshot);
    VmDevice unpluggedSnapshotDevice = createVMDevice(vmID, unpluggedDiskSnapshot);
    // Mock the Daos
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    // Disk Image Dao
    List<Disk> returnArray = new ArrayList<Disk>();
    returnArray.add(pluggedDisk);
    returnArray.add(unpluggedDisk);
    returnArray.add(pluggedDiskSnapshot);
    returnArray.add(unpluggedDiskSnapshot);
    diskDaoMock = mock(DiskDao.class);
    when(dbFacadeMock.getDiskDao()).thenReturn(diskDaoMock);
    when(diskDaoMock.getAllForVm(vmID, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(returnArray);
    // VM Device Dao
    vmDeviceDaoMock = mock(VmDeviceDao.class);
    when(dbFacadeMock.getVmDeviceDao()).thenReturn(vmDeviceDaoMock);
    when(vmDeviceDaoMock.getVmDeviceByVmIdTypeAndDevice(vmID, VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), getUser().getId(), getQueryParameters().isFiltered())).thenReturn(Arrays.asList(pluggedDevice, unpluggedDevice, pluggedSnapshotDevice, unpluggedSnapshotDevice));
    // Snapshots
    doReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(pluggedDisk.getId())))).when(getQuery()).getAllImageSnapshots(pluggedDisk);
    doReturn(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(unpluggedDisk.getId()))).when(getQuery()).getAllImageSnapshots(unpluggedDisk);
    doReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(pluggedDiskSnapshot.getId())))).when(getQuery()).getAllImageSnapshots(pluggedDiskSnapshot);
    doReturn(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(unpluggedDiskSnapshot.getId()))).when(getQuery()).getAllImageSnapshots(unpluggedDiskSnapshot);
}
#method_after
private void setUpDaoMocks() {
    // Mock some devices
    VmDevice pluggedDevice = createVMDevice(vmID, pluggedDisk);
    VmDevice unpluggedDevice = createVMDevice(vmID, unpluggedDisk);
    VmDevice pluggedSnapshotDevice = createVMDevice(vmID, pluggedDiskSnapshot);
    VmDevice unpluggedSnapshotDevice = createVMDevice(vmID, unpluggedDiskSnapshot);
    // Mock the Daos
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    // Disk Image Dao
    List<Disk> returnArray = new ArrayList<>();
    returnArray.add(pluggedDisk);
    returnArray.add(unpluggedDisk);
    returnArray.add(pluggedDiskSnapshot);
    returnArray.add(unpluggedDiskSnapshot);
    diskDaoMock = mock(DiskDao.class);
    when(dbFacadeMock.getDiskDao()).thenReturn(diskDaoMock);
    when(diskDaoMock.getAllForVm(vmID, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(returnArray);
    // VM Device Dao
    vmDeviceDaoMock = mock(VmDeviceDao.class);
    when(dbFacadeMock.getVmDeviceDao()).thenReturn(vmDeviceDaoMock);
    when(vmDeviceDaoMock.getVmDeviceByVmIdTypeAndDevice(vmID, VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), getUser().getId(), getQueryParameters().isFiltered())).thenReturn(Arrays.asList(pluggedDevice, unpluggedDevice, pluggedSnapshotDevice, unpluggedSnapshotDevice));
    // Snapshots
    doReturn(new ArrayList<>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(pluggedDisk.getId())))).when(getQuery()).getAllImageSnapshots(pluggedDisk);
    doReturn(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(unpluggedDisk.getId()))).when(getQuery()).getAllImageSnapshots(unpluggedDisk);
    doReturn(new ArrayList<>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(pluggedDiskSnapshot.getId())))).when(getQuery()).getAllImageSnapshots(pluggedDiskSnapshot);
    doReturn(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(unpluggedDiskSnapshot.getId()))).when(getQuery()).getAllImageSnapshots(unpluggedDiskSnapshot);
}
#end_block

#method_before
public static void autoSelectDefaultDisplayType(Guid srcEntityId, VmBase parametersStaticData, VDSGroup cluster, Map<GraphicsType, GraphicsDevice> graphicsDevices) {
    if (parametersStaticData.getOsId() == OsRepository.AUTO_SELECT_OS || parametersStaticData.getDefaultDisplayType() != null) {
        return;
    }
    DisplayType defaultDisplayType = DisplayType.qxl;
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = osRepository.getGraphicsAndDisplays(parametersStaticData.getOsId(), // cluster == null for the non cluster entities (e.g. Blank template and instance types)
    cluster != null ? cluster.getCompatibilityVersion() : Version.getLast());
    // map holding display type -> set of supported graphics types for this display type
    Map<DisplayType, Set<GraphicsType>> displayGraphicsSupport = new HashMap<>();
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        DisplayType display = graphicsAndDisplay.getSecond();
        if (!displayGraphicsSupport.containsKey(display)) {
            displayGraphicsSupport.put(display, new HashSet<GraphicsType>());
        }
        displayGraphicsSupport.get(display).add(graphicsAndDisplay.getFirst());
    }
    for (Map.Entry<DisplayType, Set<GraphicsType>> entry : displayGraphicsSupport.entrySet()) {
        if (entry.getValue().containsAll(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcEntityId), graphicsDevices))) {
            defaultDisplayType = entry.getKey();
            break;
        }
    }
    parametersStaticData.setDefaultDisplayType(defaultDisplayType);
}
#method_after
public static void autoSelectDefaultDisplayType(Guid srcEntityId, VmBase parametersStaticData, VDSGroup cluster, Map<GraphicsType, GraphicsDevice> graphicsDevices) {
    if (parametersStaticData.getOsId() == OsRepository.AUTO_SELECT_OS || parametersStaticData.getDefaultDisplayType() != null) {
        return;
    }
    DisplayType defaultDisplayType = DisplayType.qxl;
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = osRepository.getGraphicsAndDisplays(parametersStaticData.getOsId(), // cluster == null for the non cluster entities (e.g. Blank template and instance types)
    cluster != null ? cluster.getCompatibilityVersion() : Version.getLast());
    // map holding display type -> set of supported graphics types for this display type
    Map<DisplayType, Set<GraphicsType>> displayGraphicsSupport = new HashMap<>();
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        DisplayType display = graphicsAndDisplay.getSecond();
        if (!displayGraphicsSupport.containsKey(display)) {
            displayGraphicsSupport.put(display, new HashSet<>());
        }
        displayGraphicsSupport.get(display).add(graphicsAndDisplay.getFirst());
    }
    for (Map.Entry<DisplayType, Set<GraphicsType>> entry : displayGraphicsSupport.entrySet()) {
        if (entry.getValue().containsAll(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcEntityId), graphicsDevices))) {
            defaultDisplayType = entry.getKey();
            break;
        }
    }
    parametersStaticData.setDefaultDisplayType(defaultDisplayType);
}
#end_block

#method_before
@Test
public void testRemoveImageFromSnapshotConfiguration() throws OvfReaderException {
    Guid vmId = Guid.newGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setStoragePoolId(Guid.newGuid());
    vm.setVmtName(RandomUtils.instance().nextString(10));
    vm.setOrigin(OriginType.OVIRT);
    vm.setDbGeneration(1L);
    Guid vmSnapshotId = Guid.newGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<DiskImage>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.exportVm(vm, disks, Version.v3_1);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDao.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snap, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<DiskImage>();
    ovfManager.importVm(actualOvf, new VM(), actualImages, new ArrayList<VmNetworkInterface>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#method_after
@Test
public void testRemoveImageFromSnapshotConfiguration() throws OvfReaderException {
    Guid vmId = Guid.newGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setStoragePoolId(Guid.newGuid());
    vm.setVmtName(RandomUtils.instance().nextString(10));
    vm.setOrigin(OriginType.OVIRT);
    vm.setDbGeneration(1L);
    Guid vmSnapshotId = Guid.newGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.exportVm(vm, disks, Version.v3_1);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDao.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snap, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<>();
    ovfManager.importVm(actualOvf, new VM(), actualImages, new ArrayList<>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#end_block

#method_before
@Test
public void testRemoveImageFromSnapshotConfigurationBackwardCompatibility() throws OvfReaderException {
    Guid vmId = Guid.newGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setStoragePoolId(Guid.newGuid());
    vm.setVmtName(RandomUtils.instance().nextString(10));
    vm.setOrigin(OriginType.OVIRT);
    vm.setDbGeneration(1L);
    Guid vmSnapshotId = Guid.newGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<DiskImage>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.exportVm(vm, disks, Version.v3_0);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDao.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snap, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<DiskImage>();
    ovfManager.importVm(actualOvf, new VM(), actualImages, new ArrayList<VmNetworkInterface>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#method_after
@Test
public void testRemoveImageFromSnapshotConfigurationBackwardCompatibility() throws OvfReaderException {
    Guid vmId = Guid.newGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setStoragePoolId(Guid.newGuid());
    vm.setVmtName(RandomUtils.instance().nextString(10));
    vm.setOrigin(OriginType.OVIRT);
    vm.setDbGeneration(1L);
    Guid vmSnapshotId = Guid.newGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.exportVm(vm, disks, Version.v3_0);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDao.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snap, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<>();
    ovfManager.importVm(actualOvf, new VM(), actualImages, new ArrayList<>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    if (!super.canDoAction()) {
        return false;
    }
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(vmTemplateId)) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (!isInstanceType && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    if (!isInstanceType) {
        fetchImageTemplates();
    }
    // populate all the domains of the template
    Set<Guid> allDomainsList = getStorageDomainsByDisks(imageTemplates, true);
    getParameters().setStorageDomainsList(new ArrayList<>(allDomainsList));
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDao().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<>();
    for (VM vm : vms) {
        problematicVmNames.add(vm.getName());
    }
    if (!problematicVmNames.isEmpty()) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM, String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
    }
    // for base templates, make sure it has no versions that need to be removed first
    if (vmTemplateId.equals(template.getBaseTemplateId())) {
        List<VmTemplate> templateVersions = getVmTemplateDao().getTemplateVersionsForBaseTemplate(vmTemplateId);
        if (!templateVersions.isEmpty()) {
            List<String> templateVersionsNames = new ArrayList<>();
            for (VmTemplate version : templateVersions) {
                templateVersionsNames.add(version.getName());
            }
            return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_BASE_WITH_VERSIONS, String.format("$versionsList %1$s", StringUtils.join(templateVersionsNames, ",")));
        }
    }
    if (!isInstanceType && !validate(checkNoDisksBasedOnTemplateDisks())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    if (!super.canDoAction()) {
        return false;
    }
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(vmTemplateId)) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (!isInstanceType && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    if (!isInstanceType) {
        fetchImageTemplates();
    }
    // populate all the domains of the template
    Set<Guid> allDomainsList = getStorageDomainsByDisks(imageTemplates, true);
    getParameters().setStorageDomainsList(new ArrayList<>(allDomainsList));
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDao().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<>();
    for (VM vm : vms) {
        problematicVmNames.add(vm.getName());
    }
    if (!problematicVmNames.isEmpty()) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM, String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
    }
    if (template.isBaseTemplate() && !tryLockSubVersionIfExists()) {
        return false;
    }
    if (!isInstanceType && !validate(checkNoDisksBasedOnTemplateDisks())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()));
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!imageTemplates.isEmpty() || !cinderDisks.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (!imageTemplates.isEmpty() && removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                if (!cinderDisks.isEmpty()) {
                    removeCinderDisks(cinderDisks);
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        // if for some reason template doesn't have images, remove it now and not in end action
        HandleEndAction();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmTemplate().isBaseTemplate()) {
        shiftBaseTemplateToSuccessor();
    }
    final List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()));
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!imageTemplates.isEmpty() || !cinderDisks.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (!imageTemplates.isEmpty() && removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                if (!cinderDisks.isEmpty()) {
                    removeCinderDisks(cinderDisks);
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        // if for some reason template doesn't have images, remove it now and not in end action
        HandleEndAction();
    }
}
#end_block

#method_before
private String getTemplateExclusiveLockMessage() {
    return new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_REMOVED.name()).append(String.format("$TemplateName %1$s", getVmTemplate().getName())).toString();
}
#method_after
private String getTemplateExclusiveLockMessage() {
    return new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_REMOVED.name()).append(String.format("$templateName %s$templateId %s", getVmTemplate().getName(), getVmTemplate().getId())).toString();
}
#end_block

#method_before
private void initSpyCommand() {
    command = spy(new MoveDisksCommand<MoveDisksParameters>(new MoveDisksParameters(new ArrayList<MoveDiskParameters>())));
}
#method_after
private void initSpyCommand() {
    command = spy(new MoveDisksCommand<>(new MoveDisksParameters(new ArrayList<>())));
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    newDiskImage.setVolumeType(VolumeType.Sparse);
    newDiskImage.setvolumeFormat(VolumeFormat.COW);
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        vdsReturnValue = runVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getSize(), newDiskImage.getVolumeType(), newDiskImage.getVolumeFormat(), getDiskImage().getId(), getDestinationImageId(), ""));
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<Guid>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
        }
    } catch (Exception e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        CommandCoordinatorUtil.logAndFailTaskOfCommandWithEmptyVdsmId(getAsyncTaskId(), "Create snapshot failed at VDSM. DB task ID is " + getAsyncTaskId());
        throw new EngineException(EngineError.VolumeCreationError);
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    newDiskImage.setVolumeType(VolumeType.Sparse);
    newDiskImage.setvolumeFormat(VolumeFormat.COW);
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        vdsReturnValue = runVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getSize(), newDiskImage.getVolumeType(), newDiskImage.getVolumeFormat(), getDiskImage().getId(), getDestinationImageId(), ""));
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
        }
    } catch (Exception e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        CommandCoordinatorUtil.logAndFailTaskOfCommandWithEmptyVdsmId(getAsyncTaskId(), "Create snapshot failed at VDSM. DB task ID is " + getAsyncTaskId());
        throw new EngineException(EngineError.VolumeCreationError);
    }
    return vdsReturnValue;
}
#end_block

#method_before
public static boolean isImagesExists(Iterable<DiskImage> images, Guid storagePoolId) {
    return isImagesExists(images, storagePoolId, new ArrayList<DiskImage>());
}
#method_after
public static boolean isImagesExists(Iterable<DiskImage> images, Guid storagePoolId) {
    return isImagesExists(images, storagePoolId, new ArrayList<>());
}
#end_block

#method_before
public static Snapshot prepareSnapshotConfigWithAlternateImage(Snapshot snapshot, Guid oldImageId, DiskImage newImage) {
    try {
        OvfManager ovfManager = new OvfManager();
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<>();
            ovfManager.importVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<VmNetworkInterface>());
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(oldImageId)) {
                    log.debug("Recreating vmSnapshot '{}' without the image '{}'", snapshot.getId(), oldImageId);
                    diskIter.remove();
                    break;
                }
            }
            if (newImage != null) {
                log.debug("Adding image '{}' to vmSnapshot '{}'", newImage.getImageId(), snapshot.getId());
                snapshotImages.add(newImage);
            }
            String newOvf = ovfManager.exportVm(vmSnapshot, snapshotImages, ClusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.error("Can't remove image '{}' from snapshot '{}'", oldImageId, snapshot.getId());
    }
    return snapshot;
}
#method_after
public static Snapshot prepareSnapshotConfigWithAlternateImage(Snapshot snapshot, Guid oldImageId, DiskImage newImage) {
    try {
        OvfManager ovfManager = new OvfManager();
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            ArrayList<DiskImage> snapshotImages = new ArrayList<>();
            ovfManager.importVm(snapConfig, vmSnapshot, snapshotImages, new ArrayList<>());
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = snapshotImages.iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(oldImageId)) {
                    log.debug("Recreating vmSnapshot '{}' without the image '{}'", snapshot.getId(), oldImageId);
                    diskIter.remove();
                    break;
                }
            }
            if (newImage != null) {
                log.debug("Adding image '{}' to vmSnapshot '{}'", newImage.getImageId(), snapshot.getId());
                snapshotImages.add(newImage);
            }
            String newOvf = ovfManager.exportVm(vmSnapshot, snapshotImages, ClusterUtils.getCompatibilityVersion(vmSnapshot));
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.error("Can't remove image '{}' from snapshot '{}'", oldImageId, snapshot.getId());
    }
    return snapshot;
}
#end_block

#method_before
public String buildMetadataDictionaryForVm(VM vm, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary, ArrayList<DiskImage> allVmImages) {
    String vmMeta = generateVmMetadata(vm, allVmImages);
    metaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, LinqUtils.transformToList(vm.getDiskMap().values(), new Function<Disk, Guid>() {

        @Override
        public Guid eval(Disk a) {
            return a.getId();
        }
    })));
    return vmMeta;
}
#method_after
public String buildMetadataDictionaryForVm(VM vm, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary, ArrayList<DiskImage> allVmImages) {
    String vmMeta = generateVmMetadata(vm, allVmImages);
    metaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, vm.getDiskMap().values().stream().map(BaseDisk::getId).collect(Collectors.toList())));
    return vmMeta;
}
#end_block

#method_before
public String buildMetadataDictionaryForTemplate(VmTemplate template, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary) {
    List<DiskImage> allTemplateImages = template.getDiskList();
    String templateMeta = generateVmTemplateMetadata(template, allTemplateImages);
    metaDictionary.put(template.getId(), new KeyValuePairCompat<>(templateMeta, LinqUtils.transformToList(allTemplateImages, new Function<DiskImage, Guid>() {

        @Override
        public Guid eval(DiskImage diskImage) {
            return diskImage.getId();
        }
    })));
    return templateMeta;
}
#method_after
public String buildMetadataDictionaryForTemplate(VmTemplate template, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary) {
    List<DiskImage> allTemplateImages = template.getDiskList();
    String templateMeta = generateVmTemplateMetadata(template, allTemplateImages);
    metaDictionary.put(template.getId(), new KeyValuePairCompat<>(templateMeta, allTemplateImages.stream().map(BaseDisk::getId).collect(Collectors.toList())));
    return templateMeta;
}
#end_block

#method_before
@Override
public Guid getStorageDomainId() {
    Guid storageDomainId = super.getStorageDomainId();
    if (Guid.Empty.equals(storageDomainId) || storageDomainId == null) {
        List<StorageDomain> storagesInPool = LinqUtils.filter(DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePoolId()), new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return (!a.getStorageDomainType().isIsoOrImportExportDomain()) && (a.getStatus() != null) && (a.getStatus() == StorageDomainStatus.Active);
            }
        });
        storageDomainId = (storagesInPool.size() > 0) ? storagesInPool.get(0).getId() : Guid.Empty;
        getParameters().setStorageDomainId(storageDomainId);
        setStorageDomainId(storageDomainId);
    }
    return storageDomainId;
}
#method_after
@Override
public Guid getStorageDomainId() {
    Guid storageDomainId = super.getStorageDomainId();
    if (Guid.Empty.equals(storageDomainId) || storageDomainId == null) {
        storageDomainId = getStorageDomainDao().getAllForStoragePool(getStoragePoolId()).stream().filter(a -> (!a.getStorageDomainType().isIsoOrImportExportDomain()) && (a.getStatus() == StorageDomainStatus.Active)).map(StorageDomain::getId).findFirst().orElse(Guid.Empty);
        getParameters().setStorageDomainId(storageDomainId);
        setStorageDomainId(storageDomainId);
    }
    return storageDomainId;
}
#end_block

#method_before
@Override
protected boolean addVmImages() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmStaticData().getVmtGuid());
    if (disks.isEmpty() && !getParameters().getVmStaticData().getVmtGuid().equals(Guid.Empty)) {
        throw new EngineException(EngineError.VM_TEMPLATE_CANT_LOCATE_DISKS_IN_DB);
    }
    Disk defBootDisk = null;
    for (Disk disk : getVmDisks()) {
        if (disk.isBoot()) {
            defBootDisk = disk;
            break;
        }
    }
    if (defBootDisk != null) {
        for (Disk disk : getVmDisks()) {
            if (!disk.equals(defBootDisk))
                disk.setBoot(false);
        }
    }
    return (!disks.isEmpty()) ? concreteAddVmImages(((DiskImage) disks.get(0)).getImageId()) : true;
}
#method_after
@Override
protected boolean addVmImages() {
    List<Disk> disks = getDiskDao().getAllForVm(getParameters().getVmStaticData().getVmtGuid());
    if (disks.isEmpty() && !getParameters().getVmStaticData().getVmtGuid().equals(Guid.Empty)) {
        throw new EngineException(EngineError.VM_TEMPLATE_CANT_LOCATE_DISKS_IN_DB);
    }
    Disk defBootDisk = null;
    for (Disk disk : getVmDisks()) {
        if (disk.isBoot()) {
            defBootDisk = disk;
            break;
        }
    }
    if (defBootDisk != null) {
        for (Disk disk : getVmDisks()) {
            if (!disk.equals(defBootDisk))
                disk.setBoot(false);
        }
    }
    return (!disks.isEmpty()) ? concreteAddVmImages(((DiskImage) disks.get(0)).getImageId()) : true;
}
#end_block

#method_before
protected boolean concreteAddVmImages(Guid itGuid) {
    boolean ret = true;
    if (getVmDisks().size() > 0) {
        for (Disk diskInfo : getVmDisks()) {
            VdcReturnValueBase tmpRetValue = null;
            AddImageFromScratchParameters tempVar = new AddImageFromScratchParameters(itGuid, getParameters().getVmStaticData().getId(), (DiskImage) diskInfo);
            tempVar.setStorageDomainId(this.getStorageDomainId());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVmFromScratch);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, tempVar);
            if (!tmpRetValue.getSucceeded()) {
                log.error("concreteAddVmImages: AddImageFromScratch Command failed.");
                ret = false;
            } else // the AddImageFromScratch task created ended successfully:
            {
                getReturnValue().getVdsmTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
            }
        }
        VmHandler.lockVm(getParameters().getVmStaticData().getId());
    } else {
        // if no disks send update vm here
        getVmStaticDao().incrementDbGeneration(getVm().getId());
    }
    return ret;
}
#method_after
protected boolean concreteAddVmImages(Guid itGuid) {
    boolean ret = true;
    if (getVmDisks().size() > 0) {
        for (Disk diskInfo : getVmDisks()) {
            VdcReturnValueBase tmpRetValue = null;
            AddImageFromScratchParameters tempVar = new AddImageFromScratchParameters(itGuid, getParameters().getVmStaticData().getId(), (DiskImage) diskInfo);
            tempVar.setStorageDomainId(this.getStorageDomainId());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVmFromScratch);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, tempVar);
            if (!tmpRetValue.getSucceeded()) {
                log.error("concreteAddVmImages: AddImageFromScratch Command failed.");
                ret = false;
            } else {
                // the AddImageFromScratch task created ended successfully:
                getReturnValue().getVdsmTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
            }
        }
        VmHandler.lockVm(getParameters().getVmStaticData().getId());
    } else {
        // if no disks send update vm here
        getVmStaticDao().incrementDbGeneration(getVm().getId());
    }
    return ret;
}
#end_block

#method_before
@Override
protected List<? extends Disk> getVmDisks() {
    if (_vmDisks == null) {
        _vmDisks = ((getParameters().getDiskInfoList()) != null) ? getParameters().getDiskInfoList() : new ArrayList<Disk>();
    }
    return _vmDisks;
}
#method_after
@Override
protected List<? extends Disk> getVmDisks() {
    if (_vmDisks == null) {
        _vmDisks = ((getParameters().getDiskInfoList()) != null) ? getParameters().getDiskInfoList() : new ArrayList<>();
    }
    return _vmDisks;
}
#end_block

#method_before
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = LinqUtils.filter(images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage image) {
                return getImages().contains(image);
            }
        });
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    ArrayList<Guid> imageIds = new ArrayList<>();
    for (DiskImage diskImage : getImages()) {
        if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageIds.add(diskImage.getImageId());
        }
    }
    getParameters().setImageIds(imageIds);
    for (Guid imageId : imageIds) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return !taskHandlers.isEmpty() ? taskHandlers : null;
}
#method_after
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = images.stream().filter(image -> getImages().contains(image)).collect(Collectors.toList());
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    ArrayList<Guid> imageIds = new ArrayList<>();
    for (DiskImage diskImage : getImages()) {
        if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageIds.add(diskImage.getImageId());
        }
    }
    getParameters().setImageIds(imageIds);
    for (Guid imageId : imageIds) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return !taskHandlers.isEmpty() ? taskHandlers : null;
}
#end_block

#method_before
private static DiskImage createImage() {
    final DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(Guid.newGuid())));
    return diskImage;
}
#method_after
private static DiskImage createImage() {
    final DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<>(Arrays.asList(Guid.newGuid())));
    return diskImage;
}
#end_block

#method_before
@Before
public void initMockitoAnnotations() {
    MockitoAnnotations.initMocks(this);
}
#method_after
public void initMockitoAnnotations() {
    MockitoAnnotations.initMocks(this);
}
#end_block

#method_before
@Before
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(Mockito.anyInt(), Mockito.any(Version.class), Mockito.anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#method_after
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(Mockito.anyInt(), Mockito.any(Version.class), Mockito.anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#end_block

#method_before
@Test
public void testCanDoAction() {
    final ArrayList<Disk> disks = new ArrayList<Disk>();
    final DiskImage diskImage = createImage();
    disks.add(diskImage);
    initDaoMocks(disks);
    final VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    doReturn(new StoragePool()).when(command).getStoragePool();
    doReturn(vm).when(command).getVm();
    doReturn(true).when(command).checkRngDeviceClusterCompatibility();
    doReturn(true).when(command).checkPayload(any(VmPayload.class), anyString());
    doReturn(new VDSGroup()).when(command).getVdsGroup();
    assertTrue(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().isEmpty());
}
#method_after
@Test
public void testCanDoAction() {
    final ArrayList<Disk> disks = new ArrayList<>();
    final DiskImage diskImage = createImage();
    disks.add(diskImage);
    initDaoMocks(disks);
    final VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    doReturn(new StoragePool()).when(command).getStoragePool();
    doReturn(vm).when(command).getVm();
    doReturn(true).when(command).checkRngDeviceClusterCompatibility();
    doReturn(true).when(command).checkPayload(any(VmPayload.class), anyString());
    doReturn(new VDSGroup()).when(command).getVdsGroup();
    assertTrue(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().isEmpty());
}
#end_block

#method_before
protected void initDaoMocks(final List<Disk> disks) {
    final DiskDao diskDao = mock(DiskDao.class);
    when(diskDao.getAllForVm(Guid.Empty, true)).thenReturn(disks);
    doReturn(diskDao).when(command).getDiskDao();
    final StorageDomainDao storageDomainDao = mock(StorageDomainDao.class);
    when(storageDomainDao.getAllForStoragePool(Guid.Empty)).thenReturn(new ArrayList<StorageDomain>());
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
}
#method_after
protected void initDaoMocks(final List<Disk> disks) {
    final DiskDao diskDao = mock(DiskDao.class);
    when(diskDao.getAllForVm(Guid.Empty, true)).thenReturn(disks);
    doReturn(diskDao).when(command).getDiskDao();
    final StorageDomainDao storageDomainDao = mock(StorageDomainDao.class);
    when(storageDomainDao.getAllForStoragePool(Guid.Empty)).thenReturn(new ArrayList<>());
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
}
#end_block

#method_before
@Override
protected HotUnPlugDiskFromVmCommand<HotPlugDiskToVmParameters> createCommand() {
    return new HotUnPlugDiskFromVmCommand<HotPlugDiskToVmParameters>(createParameters());
}
#method_after
@Override
protected HotUnPlugDiskFromVmCommand<HotPlugDiskToVmParameters> createCommand() {
    return new HotUnPlugDiskFromVmCommand<>(createParameters());
}
#end_block

#method_before
@Override
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(true);
}
#method_after
@Override
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(true);
}
#end_block

#method_before
@Override
protected Collection<DiskImage> getAdjustedDiskImagesFromConfiguration() {
    VdcQueryReturnValue vdcReturnValue = runInternalQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(oldVmId));
    List<Disk> loadedImages = vdcReturnValue.getReturnValue() != null ? (List<Disk>) vdcReturnValue.getReturnValue() : new ArrayList<Disk>();
    if (diskImagesFromConfiguration == null) {
        diskImagesFromConfiguration = ImagesHandler.filterImageDisks(loadedImages, false, true, true);
        diskImagesFromConfiguration.addAll(ImagesHandler.filterDisksBasedOnCinder(loadedImages, true));
    }
    return diskImagesFromConfiguration;
}
#method_after
@Override
protected Collection<DiskImage> getAdjustedDiskImagesFromConfiguration() {
    VdcQueryReturnValue vdcReturnValue = runInternalQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(oldVmId));
    List<Disk> loadedImages = vdcReturnValue.getReturnValue() != null ? (List<Disk>) vdcReturnValue.getReturnValue() : new ArrayList<>();
    if (diskImagesFromConfiguration == null) {
        diskImagesFromConfiguration = ImagesHandler.filterImageDisks(loadedImages, false, true, true);
        diskImagesFromConfiguration.addAll(ImagesHandler.filterDisksBasedOnCinder(loadedImages, true));
    }
    return diskImagesFromConfiguration;
}
#end_block

#method_before
private void attachDetachDisks(VdcActionType actionType) {
    VdcQueryReturnValue vdcReturnValue = runInternalQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(oldVmId));
    List<Disk> loadedImages = vdcReturnValue.getReturnValue() != null ? (List<Disk>) vdcReturnValue.getReturnValue() : new ArrayList<Disk>();
    for (Disk disk : loadedImages) {
        if (disk.getDiskStorageType() == DiskStorageType.LUN || disk.isShareable()) {
            attachDetachDisk(disk, actionType);
        }
    }
}
#method_after
private void attachDetachDisks(VdcActionType actionType) {
    VdcQueryReturnValue vdcReturnValue = runInternalQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(oldVmId));
    List<Disk> loadedImages = vdcReturnValue.getReturnValue() != null ? (List<Disk>) vdcReturnValue.getReturnValue() : new ArrayList<>();
    for (Disk disk : loadedImages) {
        if (disk.getDiskStorageType() == DiskStorageType.LUN || disk.isShareable()) {
            attachDetachDisk(disk, actionType);
        }
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = schedulingManager.schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = schedulingManager.schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        getParameters().setVdsmTaskIds(new ArrayList<Guid>());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getReturnValue().getInternalVdsmTaskIdList().add(result);
        getReturnValue().getVdsmTaskIdList().add(result);
        getParameters().getVdsmTaskIds().add(result);
        setSucceeded(vdsReturnValue.getSucceeded());
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    } else {
        setSucceeded(false);
        setCommandStatus(CommandStatus.FAILED);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        getParameters().setVdsmTaskIds(new ArrayList<>());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getReturnValue().getInternalVdsmTaskIdList().add(result);
        getReturnValue().getVdsmTaskIdList().add(result);
        getParameters().getVdsmTaskIds().add(result);
        setSucceeded(vdsReturnValue.getSucceeded());
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    } else {
        setSucceeded(false);
        setCommandStatus(CommandStatus.FAILED);
    }
}
#end_block

#method_before
protected void updateVmDeviceAddress(final String address, final VmDevice vmDevice) {
    vmDevice.setAddress(address);
    getCompensationContext().snapshotEntity(vmDevice);
    getCompensationContext().stateChanged();
    vmDeviceDao.update(vmDevice);
}
#method_after
protected void updateVmDeviceAddress(final String address, final VmDevice vmDevice) {
    vmDevice.setAddress(address);
    getCompensationContext().snapshotEntity(vmDevice);
    getCompensationContext().stateChanged();
    getVmDeviceDao().update(vmDevice);
}
#end_block

#method_before
private VM mockVm() {
    vm = new VM();
    vm.setId(vmId);
    vm.setName(VM_NAME);
    vm.setDiskMap(new HashMap<Guid, Disk>());
    return vm;
}
#method_after
private VM mockVm() {
    vm = new VM();
    vm.setId(vmId);
    vm.setName(VM_NAME);
    vm.setDiskMap(new HashMap<>());
    return vm;
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    newDiskImage.setVolumeType(VolumeType.Sparse);
    newDiskImage.setvolumeFormat(VolumeFormat.COW);
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        vdsReturnValue = runVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getSize(), newDiskImage.getVolumeType(), newDiskImage.getVolumeFormat(), getDiskImage().getId(), getDestinationImageId(), ""));
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<Guid>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
        }
    } catch (Exception e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        CommandCoordinatorUtil.logAndFailTaskOfCommandWithEmptyVdsmId(getAsyncTaskId(), "Create snapshot failed at VDSM. DB task ID is " + getAsyncTaskId());
        throw new EngineException(EngineError.VolumeCreationError);
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    newDiskImage.setVolumeType(VolumeType.Sparse);
    newDiskImage.setvolumeFormat(VolumeFormat.COW);
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        vdsReturnValue = runVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getSize(), newDiskImage.getVolumeType(), newDiskImage.getVolumeFormat(), getDiskImage().getId(), getDestinationImageId(), ""));
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setVdsmTaskIds(new ArrayList<>());
            getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
        }
    } catch (Exception e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        CommandCoordinatorUtil.logAndFailTaskOfCommandWithEmptyVdsmId(getAsyncTaskId(), "Create snapshot failed at VDSM. DB task ID is " + getAsyncTaskId());
        throw new EngineException(EngineError.VolumeCreationError);
    }
    return vdsReturnValue;
}
#end_block

#method_before
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<RemoveSnapshotSingleDiskLiveStep, Guid>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(CommandCoordinatorUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case NOT_STARTED:
                log.info("Waiting on Live Merge command step '{}' to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
                if (cmdEntity.isCallbackEnabled() && !cmdEntity.isCallbackNotified()) {
                    log.info("Waiting on Live Merge command step '{}' to finalize", getParameters().getCommandStep());
                    return;
                }
                vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.error("Unknown child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
    }
}
#method_after
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(CommandCoordinatorUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case NOT_STARTED:
                log.info("Waiting on Live Merge command step '{}' to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
                if (cmdEntity.isCallbackEnabled() && !cmdEntity.isCallbackNotified()) {
                    log.info("Waiting on Live Merge command step '{}' to finalize", getParameters().getCommandStep());
                    return;
                }
                vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.error("Unknown child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Before
public void setUp() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(Guid.newGuid(), "");
    cmd = spy(new CreateAllSnapshotsFromVmCommand<CreateAllSnapshotsFromVmParameters>(params));
    doReturn(true).when(vm).isManagedVm();
    doReturn(vm).when(cmd).getVm();
    doReturn(vmValidator).when(cmd).createVmValidator();
    doReturn(snapshotsValidator).when(cmd).createSnapshotValidator();
    doReturn(storagePoolValidator).when(cmd).createStoragePoolValidator();
    doReturn(diskImagesValidator).when(cmd).createDiskImageValidator(any(List.class));
    doReturn(multipleStorageDomainsValidator).when(cmd).createMultipleStorageDomainsValidator(any(List.class));
    doReturn(memoryImageBuilder).when(cmd).getMemoryImageBuilder();
    doReturn(true).when(cmd).validateCinder();
    doReturn(Guid.newGuid()).when(cmd).getStorageDomainIdForVmMemory(anyList());
    doReturn(getEmptyDiskList()).when(cmd).getDisksListForChecks();
}
#method_after
@SuppressWarnings("unchecked")
@Before
public void setUp() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(Guid.newGuid(), "");
    cmd = spy(new CreateAllSnapshotsFromVmCommand<>(params));
    doReturn(true).when(vm).isManagedVm();
    doReturn(vm).when(cmd).getVm();
    doReturn(vmValidator).when(cmd).createVmValidator();
    doReturn(snapshotsValidator).when(cmd).createSnapshotValidator();
    doReturn(storagePoolValidator).when(cmd).createStoragePoolValidator();
    doReturn(diskImagesValidator).when(cmd).createDiskImageValidator(any(List.class));
    doReturn(multipleStorageDomainsValidator).when(cmd).createMultipleStorageDomainsValidator(any(List.class));
    doReturn(memoryImageBuilder).when(cmd).getMemoryImageBuilder();
    doReturn(true).when(cmd).validateCinder();
    doReturn(Guid.newGuid()).when(cmd).getStorageDomainIdForVmMemory(anyList());
    doReturn(getEmptyDiskList()).when(cmd).getDisksListForChecks();
}
#end_block

#method_before
private static List<DiskImage> getNonEmptyDiskList() {
    List<DiskImage> diskList = new ArrayList<>();
    DiskImage newDiskImage = new DiskImage();
    newDiskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(newDiskImage);
    return diskList;
}
#method_after
private static List<DiskImage> getNonEmptyDiskList() {
    List<DiskImage> diskList = new ArrayList<>();
    DiskImage newDiskImage = new DiskImage();
    newDiskImage.setStorageIds(new ArrayList<>());
    diskList.add(newDiskImage);
    return diskList;
}
#end_block

#method_before
@Before
public void setUp() {
    vmId = Guid.newGuid();
    vm = new VM();
    vm.setId(vmId);
    when(vmDao.get(vmId)).thenReturn(vm);
    Guid snapshotId = Guid.newGuid();
    snapshot = new Snapshot();
    snapshot.setId(snapshotId);
    snapshot.setVmId(vmId);
    when(snapshotDao.get(snapshotId)).thenReturn(snapshot);
    TryBackToAllSnapshotsOfVmParameters params = new TryBackToAllSnapshotsOfVmParameters(vmId, snapshotId);
    cmd = spy(new TryBackToAllSnapshotsOfVmCommand<TryBackToAllSnapshotsOfVmParameters>(params));
    doNothing().when(cmd).updateVmDisksFromDb();
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    doReturn(vmDao).when(cmd).getVmDao();
}
#method_after
@Before
public void setUp() {
    vmId = Guid.newGuid();
    vm = new VM();
    vm.setId(vmId);
    when(vmDao.get(vmId)).thenReturn(vm);
    Guid snapshotId = Guid.newGuid();
    snapshot = new Snapshot();
    snapshot.setId(snapshotId);
    snapshot.setVmId(vmId);
    when(snapshotDao.get(snapshotId)).thenReturn(snapshot);
    TryBackToAllSnapshotsOfVmParameters params = new TryBackToAllSnapshotsOfVmParameters(vmId, snapshotId);
    cmd = spy(new TryBackToAllSnapshotsOfVmCommand<>(params));
    doNothing().when(cmd).updateVmDisksFromDb();
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    doReturn(vmDao).when(cmd).getVmDao();
}
#end_block

#method_before
@Test
public void testCanDoActionWithEmptySnapshotGuid() {
    TryBackToAllSnapshotsOfVmParameters params = new TryBackToAllSnapshotsOfVmParameters(vmId, Guid.Empty);
    cmd = spy(new TryBackToAllSnapshotsOfVmCommand<TryBackToAllSnapshotsOfVmParameters>(params));
    doNothing().when(cmd).updateVmDisksFromDb();
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
}
#method_after
@Test
public void testCanDoActionWithEmptySnapshotGuid() {
    TryBackToAllSnapshotsOfVmParameters params = new TryBackToAllSnapshotsOfVmParameters(vmId, Guid.Empty);
    cmd = spy(new TryBackToAllSnapshotsOfVmCommand<>(params));
    doNothing().when(cmd).updateVmDisksFromDb();
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
}
#end_block

#method_before
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = LinqUtils.filter(images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage image) {
                return getImages().contains(image);
            }
        });
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    ArrayList<Guid> imageIds = new ArrayList<>();
    for (DiskImage diskImage : getImages()) {
        if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageIds.add(diskImage.getImageId());
        }
    }
    getParameters().setImageIds(imageIds);
    for (Guid imageId : imageIds) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return !taskHandlers.isEmpty() ? taskHandlers : null;
}
#method_after
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = images.stream().filter(image -> getImages().contains(image)).collect(Collectors.toList());
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    ArrayList<Guid> imageIds = new ArrayList<>();
    for (DiskImage diskImage : getImages()) {
        if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageIds.add(diskImage.getImageId());
        }
    }
    getParameters().setImageIds(imageIds);
    for (Guid imageId : imageIds) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return !taskHandlers.isEmpty() ? taskHandlers : null;
}
#end_block

#method_before
@Before
public void setUp() {
    Guid vmGuid = Guid.newGuid();
    Guid snapGuid = Guid.newGuid();
    RemoveSnapshotParameters params = new RemoveSnapshotParameters(snapGuid, vmGuid);
    cmd = spy(new RemoveSnapshotCommand<RemoveSnapshotParameters>(params));
    doReturn(spDao).when(cmd).getStoragePoolDao();
    doReturn(vmTemplateDao).when(cmd).getVmTemplateDao();
    doReturn(diskImageDao).when(cmd).getDiskImageDao();
    doReturn(sdDao).when(cmd).getStorageDomainDao();
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockVm();
    vmValidator = spy(new VmValidator(cmd.getVm()));
    doReturn(ValidationResult.VALID).when(vmValidator).vmNotHavingDeviceSnapshotsAttachedToOtherVms(anyBoolean());
    doReturn(vmValidator).when(cmd).createVmValidator(any(VM.class));
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
    mockSnapshot(SnapshotType.REGULAR);
    snapshotValidator = spy(new SnapshotsValidator());
    doReturn(snapshotValidator).when(cmd).createSnapshotValidator();
    spySdValidator();
}
#method_after
@Before
public void setUp() {
    Guid vmGuid = Guid.newGuid();
    Guid snapGuid = Guid.newGuid();
    RemoveSnapshotParameters params = new RemoveSnapshotParameters(snapGuid, vmGuid);
    cmd = spy(new RemoveSnapshotCommand<>(params));
    doReturn(spDao).when(cmd).getStoragePoolDao();
    doReturn(vmTemplateDao).when(cmd).getVmTemplateDao();
    doReturn(diskImageDao).when(cmd).getDiskImageDao();
    doReturn(sdDao).when(cmd).getStorageDomainDao();
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockVm();
    vmValidator = spy(new VmValidator(cmd.getVm()));
    doReturn(ValidationResult.VALID).when(vmValidator).vmNotHavingDeviceSnapshotsAttachedToOtherVms(anyBoolean());
    doReturn(vmValidator).when(cmd).createVmValidator(any(VM.class));
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
    mockSnapshot(SnapshotType.REGULAR);
    snapshotValidator = spy(new SnapshotsValidator());
    doReturn(snapshotValidator).when(cmd).createSnapshotValidator();
    spySdValidator();
}
#end_block

#method_before
private List<DiskImage> createDiskImageList() {
    DiskImage disk = new DiskImage();
    disk.setImageId(diskImageId);
    disk.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
    List<DiskImage> diskImageList = new ArrayList<DiskImage>();
    diskImageList.add(disk);
    return diskImageList;
}
#method_after
private List<DiskImage> createDiskImageList() {
    DiskImage disk = new DiskImage();
    disk.setImageId(diskImageId);
    disk.setStorageIds(new ArrayList<>(Arrays.asList(storageDomainId)));
    List<DiskImage> diskImageList = new ArrayList<>();
    diskImageList.add(disk);
    return diskImageList;
}
#end_block

#method_before
private void mockDiskImageDao() {
    List<Disk> diskImageList = new ArrayList<Disk>();
    DiskImage diskImage = new DiskImage();
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(Guid.newGuid())));
    diskImageList.add(diskImage);
    doReturn(diskDao).when(spyCommand).getDiskDao();
    when(diskDao.getAllForVm(vmId)).thenReturn(diskImageList);
}
#method_after
private void mockDiskImageDao() {
    List<Disk> diskImageList = new ArrayList<>();
    DiskImage diskImage = new DiskImage();
    diskImage.setStorageIds(new ArrayList<>(Arrays.asList(Guid.newGuid())));
    diskImageList.add(diskImage);
    doReturn(diskDao).when(spyCommand).getDiskDao();
    when(diskDao.getAllForVm(vmId)).thenReturn(diskImageList);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected void initializeCommand(ImageOperation operation, Disk disk) {
    command = spy(new MoveOrCopyDiskCommandDummy(new MoveOrCopyImageGroupParameters(diskImageGuid, srcStorageId, destStorageId, operation)));
    doReturn(vmDao).when(command).getVmDao();
    doReturn(diskDao).when(command).getDiskDao();
    this.disk = disk;
    when(diskDao.get(any(Guid.class))).thenReturn(this.disk);
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(new ArrayList<Pair<VM, VmDevice>>());
    doReturn(new ArrayList<DiskImage>()).when(command).getAllImageSnapshots();
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    doReturn(false).when(command).acquireLock();
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(disk.getId()).when(command).getImageGroupId();
}
#method_after
@SuppressWarnings("unchecked")
protected void initializeCommand(ImageOperation operation, Disk disk) {
    command = spy(new MoveOrCopyDiskCommandDummy(new MoveOrCopyImageGroupParameters(diskImageGuid, srcStorageId, destStorageId, operation)));
    doReturn(vmDao).when(command).getVmDao();
    doReturn(diskDao).when(command).getDiskDao();
    this.disk = disk;
    when(diskDao.get(any(Guid.class))).thenReturn(this.disk);
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(new ArrayList<>());
    doReturn(new ArrayList<DiskImage>()).when(command).getAllImageSnapshots();
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    doReturn(false).when(command).acquireLock();
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(storageDomainDao).when(command).getStorageDomainDao();
    doReturn(disk.getId()).when(command).getImageGroupId();
}
#end_block

#method_before
private void prepareCopyNotTemplate(MoveOrCopyImageGroupParameters parameters) {
    parameters.setAddImageDomainMapping(false);
    Guid newImageId = Guid.newGuid();
    Guid newId = Guid.newGuid();
    DiskImage image = getImage();
    image.setId(newId);
    image.setImageId(newImageId);
    image.setDiskAlias(getDiskAlias());
    image.setStorageIds(new ArrayList<Guid>());
    image.getStorageIds().add(getParameters().getStorageDomainId());
    image.setQuotaId(getParameters().getQuotaId());
    image.setDiskProfileId(getParameters().getDiskProfileId());
    image.setImageStatus(ImageStatus.LOCKED);
    parameters.setDestinationImageId(newImageId);
    parameters.setDestImageGroupId(newId);
}
#method_after
private void prepareCopyNotTemplate(MoveOrCopyImageGroupParameters parameters) {
    parameters.setAddImageDomainMapping(false);
    Guid newImageId = Guid.newGuid();
    Guid newId = Guid.newGuid();
    DiskImage image = getImage();
    image.setId(newId);
    image.setImageId(newImageId);
    image.setDiskAlias(getDiskAlias());
    image.setStorageIds(new ArrayList<>());
    image.getStorageIds().add(getParameters().getStorageDomainId());
    image.setQuotaId(getParameters().getQuotaId());
    image.setDiskProfileId(getParameters().getDiskProfileId());
    image.setImageStatus(ImageStatus.LOCKED);
    parameters.setDestinationImageId(newImageId);
    parameters.setDestImageGroupId(newId);
}
#end_block

#method_before
protected void updateVmDeviceAddress(final String address, final VmDevice vmDevice) {
    vmDevice.setAddress(address);
    getCompensationContext().snapshotEntity(vmDevice);
    getCompensationContext().stateChanged();
    vmDeviceDao.update(vmDevice);
}
#method_after
protected void updateVmDeviceAddress(final String address, final VmDevice vmDevice) {
    vmDevice.setAddress(address);
    getCompensationContext().snapshotEntity(vmDevice);
    getCompensationContext().stateChanged();
    getVmDeviceDao().update(vmDevice);
}
#end_block

#method_before
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = LinqUtils.filter(images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage image) {
                return getImages().contains(image);
            }
        });
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    ArrayList<Guid> imageIds = new ArrayList<>();
    for (DiskImage diskImage : getImages()) {
        if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageIds.add(diskImage.getImageId());
        }
    }
    getParameters().setImageIds(imageIds);
    for (Guid imageId : imageIds) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return !taskHandlers.isEmpty() ? taskHandlers : null;
}
#method_after
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = images.stream().filter(image -> getImages().contains(image)).collect(Collectors.toList());
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    ArrayList<Guid> imageIds = new ArrayList<>();
    for (DiskImage diskImage : getImages()) {
        if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageIds.add(diskImage.getImageId());
        }
    }
    getParameters().setImageIds(imageIds);
    for (Guid imageId : imageIds) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return !taskHandlers.isEmpty() ? taskHandlers : null;
}
#end_block

#method_before
protected Map<String, VmHostDevice> getExistingVmHostDevicesByName() {
    List<VmDevice> existingDevices = vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
    List<VmHostDevice> result = new ArrayList<>();
    for (VmDevice device : existingDevices) {
        result.add(new VmHostDevice(device));
    }
    return Entities.vmDevicesByDevice(result);
}
#method_after
protected Map<String, VmHostDevice> getExistingVmHostDevicesByName() {
    List<VmDevice> existingDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
    List<VmHostDevice> result = new ArrayList<>();
    for (VmDevice device : existingDevices) {
        result.add(new VmHostDevice(device));
    }
    return Entities.vmDevicesByDevice(result);
}
#end_block

#method_before
protected void updateVmDeviceAddress(final String address, final VmDevice vmDevice) {
    vmDevice.setAddress(address);
    getCompensationContext().snapshotEntity(vmDevice);
    getCompensationContext().stateChanged();
    vmDeviceDao.update(vmDevice);
}
#method_after
protected void updateVmDeviceAddress(final String address, final VmDevice vmDevice) {
    vmDevice.setAddress(address);
    getCompensationContext().snapshotEntity(vmDevice);
    getCompensationContext().stateChanged();
    getVmDeviceDao().update(vmDevice);
}
#end_block

#method_before
@Override
protected void readDiskImageItem(XmlNode node) {
    final Guid guid = new Guid(selectSingleNode(node, "rasd:InstanceId", _xmlNS).innerText);
    DiskImage image = _images.stream().filter(d -> d.getImageId().equals(guid)).findFirst().orElse(null);
    image.setId(OvfParser.getImageGroupIdFromImageFile(selectSingleNode(node, "rasd:HostResource", _xmlNS).innerText));
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText)) {
        image.setParentId(new Guid(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Template", _xmlNS).innerText)) {
        image.setImageTemplateId(new Guid(selectSingleNode(node, "rasd:Template", _xmlNS).innerText));
    }
    image.setAppList(selectSingleNode(node, "rasd:ApplicationList", _xmlNS).innerText);
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StorageId", _xmlNS).innerText)) {
        image.setStorageIds(new ArrayList<Guid>(Arrays.asList(new Guid(selectSingleNode(node, "rasd:StorageId", _xmlNS).innerText))));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText)) {
        image.setStoragePoolId(new Guid(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText));
    }
    final Date creationDate = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:CreationDate", _xmlNS).innerText);
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    final Date lastModified = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:LastModified", _xmlNS).innerText);
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    readManagedVmDevice(node, image.getId());
}
#method_after
@Override
protected void readDiskImageItem(XmlNode node) {
    final Guid guid = new Guid(selectSingleNode(node, "rasd:InstanceId", _xmlNS).innerText);
    DiskImage image = _images.stream().filter(d -> d.getImageId().equals(guid)).findFirst().orElse(null);
    image.setId(OvfParser.getImageGroupIdFromImageFile(selectSingleNode(node, "rasd:HostResource", _xmlNS).innerText));
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText)) {
        image.setParentId(new Guid(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Template", _xmlNS).innerText)) {
        image.setImageTemplateId(new Guid(selectSingleNode(node, "rasd:Template", _xmlNS).innerText));
    }
    image.setAppList(selectSingleNode(node, "rasd:ApplicationList", _xmlNS).innerText);
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StorageId", _xmlNS).innerText)) {
        image.setStorageIds(new ArrayList<>(Arrays.asList(new Guid(selectSingleNode(node, "rasd:StorageId", _xmlNS).innerText))));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText)) {
        image.setStoragePoolId(new Guid(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText));
    }
    final Date creationDate = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:CreationDate", _xmlNS).innerText);
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    final Date lastModified = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:LastModified", _xmlNS).innerText);
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    readManagedVmDevice(node, image.getId());
}
#end_block

#method_before
private void readDedicatedHostsList() {
    // initialize to empty list
    vmBase.setDedicatedVmForVdsList(new LinkedList<Guid>());
    // search all dedicated hosts with xPath
    XmlNodeList hostsList = selectNodes(_document, "//*/Content/" + OvfProperties.DEDICATED_VM_FOR_VDS);
    for (XmlNode hostNode : hostsList) {
        if (hostNode != null && StringUtils.isNotEmpty(hostNode.innerText)) {
            vmBase.getDedicatedVmForVdsList().add(Guid.createGuidFromString(hostNode.innerText));
        }
    }
}
#method_after
private void readDedicatedHostsList() {
    // initialize to empty list
    vmBase.setDedicatedVmForVdsList(new LinkedList<>());
    // search all dedicated hosts with xPath
    XmlNodeList hostsList = selectNodes(_document, "//*/Content/" + OvfProperties.DEDICATED_VM_FOR_VDS);
    for (XmlNode hostNode : hostsList) {
        if (hostNode != null && StringUtils.isNotEmpty(hostNode.innerText)) {
            vmBase.getDedicatedVmForVdsList().add(Guid.createGuidFromString(hostNode.innerText));
        }
    }
}
#end_block

#method_before
private static Map<String, Object> getMapNode(XmlNode node) {
    Map<String, Object> returnValue = new HashMap<String, Object>();
    NodeList list = node.getChildNodes();
    for (int index = 0; index < list.getLength(); ++index) {
        Node currNode = list.item(index);
        short nodeType = currNode.getNodeType();
        if (nodeType == Node.ELEMENT_NODE) {
            NodeList childNodes = currNode.getChildNodes();
            // If the element node has only one child, then it contains the value
            if (childNodes.getLength() == 1) {
                Node valueNode = childNodes.item(0);
                if (valueNode.getNodeType() == Node.TEXT_NODE) {
                    returnValue.put(currNode.getNodeName(), valueNode.getNodeValue());
                }
            } else if (childNodes.getLength() > 1) {
                // In this case, we have a nested map, so we parse it
                returnValue.put(currNode.getNodeName(), getMapNode(new XmlNode(currNode)));
            }
        }
    }
    return returnValue;
}
#method_after
private static Map<String, Object> getMapNode(XmlNode node) {
    Map<String, Object> returnValue = new HashMap<>();
    NodeList list = node.getChildNodes();
    for (int index = 0; index < list.getLength(); ++index) {
        Node currNode = list.item(index);
        short nodeType = currNode.getNodeType();
        if (nodeType == Node.ELEMENT_NODE) {
            NodeList childNodes = currNode.getChildNodes();
            // If the element node has only one child, then it contains the value
            if (childNodes.getLength() == 1) {
                Node valueNode = childNodes.item(0);
                if (valueNode.getNodeType() == Node.TEXT_NODE) {
                    returnValue.put(currNode.getNodeName(), valueNode.getNodeValue());
                }
            } else if (childNodes.getLength() > 1) {
                // In this case, we have a nested map, so we parse it
                returnValue.put(currNode.getNodeName(), getMapNode(new XmlNode(currNode)));
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void readDiskImageItem(XmlNode node) {
    final Guid guid = new Guid(selectSingleNode(node, "rasd:InstanceId", _xmlNS).innerText);
    DiskImage image = _images.stream().filter(d -> d.getImageId().equals(guid)).findFirst().orElse(null);
    image.setId(OvfParser.getImageGroupIdFromImageFile(selectSingleNode(node, "rasd:HostResource", _xmlNS).innerText));
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText)) {
        image.setParentId(new Guid(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Template", _xmlNS).innerText)) {
        image.setImageTemplateId(new Guid(selectSingleNode(node, "rasd:Template", _xmlNS).innerText));
    }
    image.setAppList(selectSingleNode(node, "rasd:ApplicationList", _xmlNS).innerText);
    XmlNode storageNode = selectSingleNode(node, "rasd:StorageId", _xmlNS);
    if (storageNode != null && StringUtils.isNotEmpty(storageNode.innerText)) {
        image.setStorageIds(new ArrayList<Guid>(Arrays.asList(new Guid(storageNode.innerText))));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText)) {
        image.setStoragePoolId(new Guid(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText));
    }
    final Date creationDate = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:CreationDate", _xmlNS).innerText);
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    final Date lastModified = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:LastModified", _xmlNS).innerText);
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    final Date last_modified_date = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:last_modified_date", _xmlNS).innerText);
    if (last_modified_date != null) {
        image.setLastModifiedDate(last_modified_date);
    }
    VmDevice readDevice = readManagedVmDevice(node, image.getId());
    image.setPlugged(readDevice.getIsPlugged());
    image.setReadOnly(readDevice.getIsReadOnly());
}
#method_after
@Override
protected void readDiskImageItem(XmlNode node) {
    final Guid guid = new Guid(selectSingleNode(node, "rasd:InstanceId", _xmlNS).innerText);
    DiskImage image = _images.stream().filter(d -> d.getImageId().equals(guid)).findFirst().orElse(null);
    image.setId(OvfParser.getImageGroupIdFromImageFile(selectSingleNode(node, "rasd:HostResource", _xmlNS).innerText));
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText)) {
        image.setParentId(new Guid(selectSingleNode(node, "rasd:Parent", _xmlNS).innerText));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:Template", _xmlNS).innerText)) {
        image.setImageTemplateId(new Guid(selectSingleNode(node, "rasd:Template", _xmlNS).innerText));
    }
    image.setAppList(selectSingleNode(node, "rasd:ApplicationList", _xmlNS).innerText);
    XmlNode storageNode = selectSingleNode(node, "rasd:StorageId", _xmlNS);
    if (storageNode != null && StringUtils.isNotEmpty(storageNode.innerText)) {
        image.setStorageIds(new ArrayList<>(Arrays.asList(new Guid(storageNode.innerText))));
    }
    if (StringUtils.isNotEmpty(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText)) {
        image.setStoragePoolId(new Guid(selectSingleNode(node, "rasd:StoragePoolId", _xmlNS).innerText));
    }
    final Date creationDate = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:CreationDate", _xmlNS).innerText);
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    final Date lastModified = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:LastModified", _xmlNS).innerText);
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    final Date last_modified_date = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "rasd:last_modified_date", _xmlNS).innerText);
    if (last_modified_date != null) {
        image.setLastModifiedDate(last_modified_date);
    }
    VmDevice readDevice = readManagedVmDevice(node, image.getId());
    image.setPlugged(readDevice.getIsPlugged());
    image.setReadOnly(readDevice.getIsReadOnly());
}
#end_block

#method_before
@Override
protected void readSnapshotsSection(XmlNode section) {
    XmlNodeList list = selectNodes(section, "Snapshot");
    ArrayList<Snapshot> snapshots = new ArrayList<Snapshot>();
    _vm.setSnapshots(snapshots);
    for (XmlNode node : list) {
        XmlNode vmConfiguration = selectSingleNode(node, "VmConfiguration", _xmlNS);
        Snapshot snapshot = new Snapshot(vmConfiguration != null);
        snapshot.setId(new Guid(node.attributes.get("ovf:id").getValue()));
        snapshot.setVmId(_vm.getId());
        snapshot.setType(SnapshotType.valueOf(selectSingleNode(node, "Type", _xmlNS).innerText));
        snapshot.setStatus(SnapshotStatus.OK);
        snapshot.setDescription(selectSingleNode(node, "Description", _xmlNS).innerText);
        XmlNode memory = selectSingleNode(node, "Memory", _xmlNS);
        if (memory != null) {
            snapshot.setMemoryVolume(memory.innerText);
        }
        final Date creationDate = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "CreationDate", _xmlNS).innerText);
        if (creationDate != null) {
            snapshot.setCreationDate(creationDate);
        }
        snapshot.setVmConfiguration(vmConfiguration == null ? null : new String(Base64.decodeBase64(vmConfiguration.innerText)));
        XmlNode appList = selectSingleNode(node, "ApplicationList", _xmlNS);
        if (appList != null) {
            snapshot.setAppList(appList.innerText);
        }
        snapshots.add(snapshot);
    }
}
#method_after
@Override
protected void readSnapshotsSection(XmlNode section) {
    XmlNodeList list = selectNodes(section, "Snapshot");
    ArrayList<Snapshot> snapshots = new ArrayList<>();
    _vm.setSnapshots(snapshots);
    for (XmlNode node : list) {
        XmlNode vmConfiguration = selectSingleNode(node, "VmConfiguration", _xmlNS);
        Snapshot snapshot = new Snapshot(vmConfiguration != null);
        snapshot.setId(new Guid(node.attributes.get("ovf:id").getValue()));
        snapshot.setVmId(_vm.getId());
        snapshot.setType(SnapshotType.valueOf(selectSingleNode(node, "Type", _xmlNS).innerText));
        snapshot.setStatus(SnapshotStatus.OK);
        snapshot.setDescription(selectSingleNode(node, "Description", _xmlNS).innerText);
        XmlNode memory = selectSingleNode(node, "Memory", _xmlNS);
        if (memory != null) {
            snapshot.setMemoryVolume(memory.innerText);
        }
        final Date creationDate = OvfParser.utcDateStringToLocaDate(selectSingleNode(node, "CreationDate", _xmlNS).innerText);
        if (creationDate != null) {
            snapshot.setCreationDate(creationDate);
        }
        snapshot.setVmConfiguration(vmConfiguration == null ? null : new String(Base64.decodeBase64(vmConfiguration.innerText)));
        XmlNode appList = selectSingleNode(node, "ApplicationList", _xmlNS);
        if (appList != null) {
            snapshot.setAppList(appList.innerText);
        }
        snapshots.add(snapshot);
    }
}
#end_block

#method_before
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachmentA, networkAttachmentB)).addNetworks(Arrays.asList(networkA, networkB)).build();
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#method_after
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<>());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachmentA, networkAttachmentB)).addNetworks(Arrays.asList(networkA, networkB)).build();
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#end_block

#method_before
public ParametersBuilder addNetworkAttachments(NetworkAttachment... networkAttachments) {
    if (nullParameters(networkAttachments)) {
        return this;
    }
    if (parameters.getNetworkAttachments() == null) {
        parameters.setNetworkAttachments(new ArrayList<NetworkAttachment>());
    }
    parameters.getNetworkAttachments().addAll(Arrays.asList(networkAttachments));
    return this;
}
#method_after
public ParametersBuilder addNetworkAttachments(NetworkAttachment... networkAttachments) {
    if (nullParameters(networkAttachments)) {
        return this;
    }
    if (parameters.getNetworkAttachments() == null) {
        parameters.setNetworkAttachments(new ArrayList<>());
    }
    parameters.getNetworkAttachments().addAll(Arrays.asList(networkAttachments));
    return this;
}
#end_block

#method_before
public ParametersBuilder addRemovedBonds(Guid... ids) {
    if (nullParameters(ids)) {
        return this;
    }
    if (parameters.getRemovedBonds() == null) {
        parameters.setRemovedBonds(new HashSet<Guid>());
    }
    parameters.getRemovedBonds().addAll(Arrays.asList(ids));
    return this;
}
#method_after
public ParametersBuilder addRemovedBonds(Guid... ids) {
    if (nullParameters(ids)) {
        return this;
    }
    if (parameters.getRemovedBonds() == null) {
        parameters.setRemovedBonds(new HashSet<>());
    }
    parameters.getRemovedBonds().addAll(Arrays.asList(ids));
    return this;
}
#end_block

#method_before
public ParametersBuilder addRemovedNetworkAttachments(NetworkAttachment... networkAttachments) {
    if (nullParameters(networkAttachments)) {
        return this;
    }
    if (parameters.getRemovedNetworkAttachments() == null) {
        parameters.setRemovedNetworkAttachments(new HashSet<Guid>());
    }
    for (NetworkAttachment networkAttachment : networkAttachments) {
        parameters.getRemovedNetworkAttachments().add(networkAttachment.getId());
    }
    return this;
}
#method_after
public ParametersBuilder addRemovedNetworkAttachments(NetworkAttachment... networkAttachments) {
    if (nullParameters(networkAttachments)) {
        return this;
    }
    if (parameters.getRemovedNetworkAttachments() == null) {
        parameters.setRemovedNetworkAttachments(new HashSet<>());
    }
    for (NetworkAttachment networkAttachment : networkAttachments) {
        parameters.getRemovedNetworkAttachments().add(networkAttachment.getId());
    }
    return this;
}
#end_block

#method_before
public ParametersBuilder addBonds(Bond... bonds) {
    if (nullParameters(bonds)) {
        return this;
    }
    if (parameters.getBonds() == null) {
        parameters.setBonds(new ArrayList<Bond>());
    }
    parameters.getBonds().addAll(Arrays.asList(bonds));
    return this;
}
#method_after
public ParametersBuilder addBonds(Bond... bonds) {
    if (nullParameters(bonds)) {
        return this;
    }
    if (parameters.getBonds() == null) {
        parameters.setBonds(new ArrayList<>());
    }
    parameters.getBonds().addAll(Arrays.asList(bonds));
    return this;
}
#end_block

#method_before
public ParametersBuilder addRemovedLabels(String... removedLabels) {
    if (nullParameters(removedLabels)) {
        return this;
    }
    if (parameters.getRemovedLabels() == null) {
        parameters.setRemovedLabels(new HashSet<String>());
    }
    parameters.getRemovedLabels().addAll(Arrays.asList(removedLabels));
    return this;
}
#method_after
public ParametersBuilder addRemovedLabels(String... removedLabels) {
    if (nullParameters(removedLabels)) {
        return this;
    }
    if (parameters.getRemovedLabels() == null) {
        parameters.setRemovedLabels(new HashSet<>());
    }
    parameters.getRemovedLabels().addAll(Arrays.asList(removedLabels));
    return this;
}
#end_block

#method_before
public ParametersBuilder addLabels(NicLabel... nicLabels) {
    if (nullParameters(nicLabels)) {
        return this;
    }
    if (parameters.getLabels() == null) {
        parameters.setLabels(new HashSet<NicLabel>());
    }
    parameters.getLabels().addAll(Arrays.asList(nicLabels));
    return this;
}
#method_after
public ParametersBuilder addLabels(NicLabel... nicLabels) {
    if (nullParameters(nicLabels)) {
        return this;
    }
    if (parameters.getLabels() == null) {
        parameters.setLabels(new HashSet<>());
    }
    parameters.getLabels().addAll(Arrays.asList(nicLabels));
    return this;
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    return vr;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    return vr;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    final List<String> sortedRemovedNetworks = new ArrayList<>(removedNetworks);
    Collections.sort(sortedRemovedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else if (vmNames.size() > 1 && sortedRemovedNetworks.size() > 1) {
        return new ValidationResult(EngineMessage.MULTIPLE_NETWORKS_CANNOT_DETACH_NETWORKS_USED_BY_VMS, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, sortedRemovedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNames)));
    } else if (vmNames.size() > 1) {
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAME, sortedRemovedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNames)));
    } else if (vmNames.size() == 1 && sortedRemovedNetworks.size() > 1) {
        return new ValidationResult(EngineMessage.MULTIPLE_NETWORKS_CANNOT_DETACH_NETWORKS_USED_BY_SINGLE_VM, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, sortedRemovedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAME, vmNames)));
    } else {
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_SINGLE_VM, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAME, sortedRemovedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAME, vmNames)));
    }
}
#method_after
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmsNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    final List<String> removedNetworksList = new ArrayList<>(removedNetworks);
    DetachNetworkUsedByVmValidator detachNetworkUsedByVmValidator = new DetachNetworkUsedByVmValidator(vmsNames, removedNetworksList);
    return detachNetworkUsedByVmValidator.validate();
}
#end_block

#method_before
private Map<String, List<Guid>> getIdsOfNetworkAttachmentsRelatedToInterfaceNames(Collection<NetworkAttachment> networkAttachments) {
    Map<String, List<Guid>> map = new HashMap<>();
    for (NetworkAttachment attachment : networkAttachments) {
        MultiValueMapUtils.addToMap(attachment.getNicName(), attachment.getId(), map, new ListCreator<Guid>());
    }
    return map;
}
#method_after
private Map<String, List<Guid>> getIdsOfNetworkAttachmentsRelatedToInterfaceNames(Collection<NetworkAttachment> networkAttachments) {
    Map<String, List<Guid>> map = new HashMap<>();
    for (NetworkAttachment attachment : networkAttachments) {
        MultiValueMapUtils.addToMap(attachment.getNicName(), attachment.getId(), map, new ListCreator<>());
    }
    return map;
}
#end_block

#method_before
@Override
public void executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
    ArrayList<VmTemplate> templates = (ArrayList<VmTemplate>) returnValueList.get(0).getReturnValue();
    initTemplates(templates);
}
#method_after
@Override
public void executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
    ArrayList<VmTemplate> templates = returnValueList.get(0).getReturnValue();
    initTemplates(templates);
}
#end_block

#method_before
private void optimizeVolumesForVirtStore(final List<GlusterVolumeEntity> volumeList) {
    if (getConfirmWindow() != null) {
        setConfirmWindow(null);
    }
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<>();
                            for (GlusterVolumeEntity volume : volumeList) {
                                Guid volumeId = volume.getId();
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "group", optionGroupVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-uid", optionOwnerUserVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-gid", optionOwnerGroupVirt)));
                                // $NON-NLS-1$ $NON-NLS-2$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "server.allow-insecure", "on")));
                                // $NON-NLS-1$//$NON-NLS-2$
                                final GlusterVolumeOptionEntity checkOption = getOption(volumeId, "network.ping-timeout", "10");
                                List<PredicateFilter<GlusterVolumeOptionEntity>> predicaetFilters = Collections.singletonList(new PredicateFilter<>(new Predicate<GlusterVolumeOptionEntity>() {

                                    @Override
                                    public boolean evaluate(GlusterVolumeOptionEntity obj) {
                                        return obj.getKey().equalsIgnoreCase(checkOption.getKey());
                                    }
                                }));
                                if (!isOptionEnabledOnVolume(volume, predicaetFilters)) {
                                    // $NON-NLS-1$
                                    list.add(new GlusterVolumeOptionParameters(checkOption));
                                }
                            }
                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQuery);
}
#method_after
private void optimizeVolumesForVirtStore(final List<GlusterVolumeEntity> volumeList) {
    if (getConfirmWindow() != null) {
        setConfirmWindow(null);
    }
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<>();
                            for (GlusterVolumeEntity volume : volumeList) {
                                Guid volumeId = volume.getId();
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "group", optionGroupVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-uid", optionOwnerUserVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-gid", optionOwnerGroupVirt)));
                                // $NON-NLS-1$ $NON-NLS-2$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "server.allow-insecure", "on")));
                                // $NON-NLS-1$//$NON-NLS-2$
                                final GlusterVolumeOptionEntity checkOption = getOption(volumeId, "network.ping-timeout", "10");
                                IPredicate<GlusterVolumeOptionEntity> predicaetFilter = new IPredicate<GlusterVolumeOptionEntity>() {

                                    @Override
                                    public boolean match(GlusterVolumeOptionEntity obj) {
                                        return obj.getKey().equalsIgnoreCase(checkOption.getKey());
                                    }
                                };
                                if (!isOptionEnabledOnVolume(volume, predicaetFilter)) {
                                    // $NON-NLS-1$
                                    list.add(new GlusterVolumeOptionParameters(checkOption));
                                }
                            }
                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
private boolean isOptionEnabledOnVolume(GlusterVolumeEntity volume, List<PredicateFilter<GlusterVolumeOptionEntity>> predicates) {
    List<GlusterVolumeOptionEntity> volumeOptionsEnabled = new ArrayList<>(volume.getOptions());
    List<GlusterVolumeOptionEntity> filteredOptions = volumeOptionsEnabled;
    for (PredicateFilter<GlusterVolumeOptionEntity> predicate : predicates) {
        filteredOptions = ListUtils.filter(filteredOptions, predicate);
    }
    if (filteredOptions.size() > 0) {
        return true;
    }
    return false;
}
#method_after
private boolean isOptionEnabledOnVolume(GlusterVolumeEntity volume, IPredicate<GlusterVolumeOptionEntity> predicate) {
    return Linq.firstOrNull(volume.getOptions(), predicate) != null;
}
#end_block

#method_before
private void flush() {
    provider.setName(name.getEntity());
    provider.setType(type.getSelectedItem());
    provider.setDescription(description.getEntity());
    provider.setUrl(url.getEntity());
    if (isTypeOpenStackNetwork()) {
        getNeutronAgentModel().flush(provider);
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    } else if (isTypeOpenStackVolume()) {
        provider.setAdditionalProperties(new OpenStackVolumeProviderProperties(getDataCenter().getSelectedItem().getId()));
    } else if (isTypeVmware()) {
        provider.setAdditionalProperties(getVmwarePropertiesModel().getVmwareVmProviderProperties(dataCenter.getSelectedItem().getId()));
        provider.setUrl(getVmwarePropertiesModel().getUrl());
    }
    boolean authenticationRequired = requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername(getUsername().getEntity());
        provider.setPassword(getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName(getTenantName().getEntity());
        }
        provider.setAuthUrl(getAuthUrl().getEntity());
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
        provider.setAuthUrl(null);
    }
}
#method_after
private void flush() {
    provider.setName(name.getEntity());
    provider.setType(type.getSelectedItem());
    provider.setDescription(description.getEntity());
    provider.setUrl(url.getEntity());
    if (isTypeOpenStackNetwork()) {
        getNeutronAgentModel().flush(provider);
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    } else if (isTypeOpenStackVolume()) {
        provider.setAdditionalProperties(new OpenStackVolumeProviderProperties(getDataCenter().getSelectedItem().getId()));
    } else if (isTypeVmware()) {
        provider.setAdditionalProperties(getVmwarePropertiesModel().getVmwareVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
        provider.setUrl(getVmwarePropertiesModel().getUrl());
    }
    boolean authenticationRequired = requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername(getUsername().getEntity());
        provider.setPassword(getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName(getTenantName().getEntity());
        }
        provider.setAuthUrl(getAuthUrl().getEntity());
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
        provider.setAuthUrl(null);
    }
}
#end_block

#method_before
private String availableName(ArrayList<String> list) {
    String commonName = getCommonName();
    ArrayList<Integer> notAvailableNumberList = new ArrayList<>();
    String temp;
    for (String str : list) {
        // $NON-NLS-1$
        temp = str.replace(getCommonName(), "");
        if (StringHelper.isNullOrEmpty(temp)) {
            // $NON-NLS-1$
            temp = "0";
        }
        ListUtils.nullSafeElemAdd(notAvailableNumberList, IntegerCompat.tryParse(temp));
    }
    Collections.sort(notAvailableNumberList);
    int i;
    for (i = 0; i < notAvailableNumberList.size(); i++) {
        if (notAvailableNumberList.get(i) == i) {
            continue;
        }
        break;
    }
    if (i > 0) {
        commonName = getCommonName() + String.valueOf(i);
    }
    return commonName;
}
#method_after
private String availableName(ArrayList<String> list) {
    String commonName = getCommonName();
    ArrayList<Integer> notAvailableNumberList = new ArrayList<>();
    String temp;
    for (String str : list) {
        // $NON-NLS-1$
        temp = str.replace(getCommonName(), "");
        if (StringHelper.isNullOrEmpty(temp)) {
            // $NON-NLS-1$
            temp = "0";
        }
        try {
            Integer i = Integer.valueOf(temp);
            notAvailableNumberList.add(i);
        } catch (NumberFormatException ignore) {
        // do nothing, this is not a number
        }
    }
    Collections.sort(notAvailableNumberList);
    int i;
    for (i = 0; i < notAvailableNumberList.size(); i++) {
        if (notAvailableNumberList.get(i) == i) {
            continue;
        }
        break;
    }
    if (i > 0) {
        commonName = getCommonName() + String.valueOf(i);
    }
    return commonName;
}
#end_block

#method_before
public ArrayList<VolumeType> getVolumeTypeList() {
    return new ArrayList<>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated, VolumeType.Sparse }));
}
#method_after
public ArrayList<VolumeType> getVolumeTypeList() {
    return new ArrayList<>(Arrays.asList(VolumeType.Preallocated, VolumeType.Sparse));
}
#end_block

#method_before
public ArrayList<StorageType> getStorageTypeList() {
    return new ArrayList<>(Arrays.asList(new StorageType[] { StorageType.ISCSI, StorageType.FCP }));
}
#method_after
public ArrayList<StorageType> getStorageTypeList() {
    return new ArrayList<>(Arrays.asList(StorageType.ISCSI, StorageType.FCP));
}
#end_block

#method_before
@Test
public void testGetOperationResult_Empty() {
    List<VdcOperation<?, ?>> testOperationList = new ArrayList<>();
    List<VdcOperation<?, ?>> allOperationList = new ArrayList<>();
    List<?> allResults = new ArrayList<VdcReturnValueBase>();
    List<?> result = testProvider.getOperationResult(testOperationList, allOperationList, allResults);
    // $NON-NLS-1$
    assertEquals("Result should have no results", 0, result.size());
}
#method_after
@Test
public void testGetOperationResult_Empty() {
    List<VdcOperation<?, ?>> testOperationList = new ArrayList<>();
    List<VdcOperation<?, ?>> allOperationList = new ArrayList<>();
    List<?> allResults = new ArrayList<>();
    List<?> result = testProvider.getOperationResult(testOperationList, allOperationList, allResults);
    // $NON-NLS-1$
    assertEquals("Result should have no results", 0, result.size());
}
#end_block

#method_before
private void initRoleTable() {
    this.table = new SimpleActionTable<>(roleModelProvider, getTableHeaderlessResources(), getTableResources(), eventBus, clientStorage);
    AbstractTextColumn<Role> nameColumn = new AbstractTextColumn<Role>() {

        @Override
        public String getValue(Role object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    table.addColumn(new IsLockedImageTypeColumn(), constants.empty(), "20px");
    // $NON-NLS-1$
    table.addColumn(new RoleTypeColumn(), constants.empty(), "20px");
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameRole(), "100px");
    AbstractTextColumn<Role> descColumn = new AbstractTextColumn<Role>() {

        @Override
        public String getValue(Role object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    table.addColumn(descColumn, constants.descriptionRole(), "300px");
    table.addActionButton(new WebAdminButtonDefinition<Role>(constants.newRole()) {

        @Override
        protected UICommand resolveCommand() {
            return roleModelProvider.getModel().getNewCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<Role>(constants.editRole()) {

        @Override
        protected UICommand resolveCommand() {
            return roleModelProvider.getModel().getEditCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<Role>(constants.copyRole()) {

        @Override
        protected UICommand resolveCommand() {
            return roleModelProvider.getModel().getCloneCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<Role>(constants.removeRole()) {

        @Override
        protected UICommand resolveCommand() {
            return roleModelProvider.getModel().getRemoveCommand();
        }
    });
    splitLayoutPanel.add(table);
    table.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            roleModelProvider.setSelectedItems(table.getSelectionModel().getSelectedList());
            if (table.getSelectionModel().getSelectedList().size() > 0) {
                setSubTabVisibility(true);
            } else {
                setSubTabVisibility(false);
            }
        }
    });
}
#method_after
private void initRoleTable() {
    this.table = new SimpleActionTable<>(roleModelProvider, getTableHeaderlessResources(), getTableResources(), eventBus, clientStorage);
    this.table.enableColumnResizing();
    AbstractTextColumn<Role> nameColumn = new AbstractTextColumn<Role>() {

        @Override
        public String getValue(Role object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(new IsLockedImageTypeColumn(), constants.empty(), "25px");
    // $NON-NLS-1$
    table.addColumn(new RoleTypeColumn(), constants.empty(), "25px");
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameRole(), "175px");
    AbstractTextColumn<Role> descColumn = new AbstractTextColumn<Role>() {

        @Override
        public String getValue(Role object) {
            return object.getDescription();
        }
    };
    descColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(descColumn, constants.descriptionRole(), "575px");
    table.addActionButton(new WebAdminButtonDefinition<Role>(constants.newRole()) {

        @Override
        protected UICommand resolveCommand() {
            return roleModelProvider.getModel().getNewCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<Role>(constants.editRole()) {

        @Override
        protected UICommand resolveCommand() {
            return roleModelProvider.getModel().getEditCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<Role>(constants.copyRole()) {

        @Override
        protected UICommand resolveCommand() {
            return roleModelProvider.getModel().getCloneCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<Role>(constants.removeRole()) {

        @Override
        protected UICommand resolveCommand() {
            return roleModelProvider.getModel().getRemoveCommand();
        }
    });
    splitLayoutPanel.add(table);
    table.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            roleModelProvider.setSelectedItems(table.getSelectionModel().getSelectedList());
            if (table.getSelectionModel().getSelectedList().size() > 0) {
                setSubTabVisibility(true);
            } else {
                setSubTabVisibility(false);
            }
        }
    });
}
#end_block

#method_before
private void initPermissionTable() {
    permissionTable = new SimpleActionTable<>(permissionModelProvider, getTableHeaderlessResources(), getTableResources(), eventBus, clientStorage);
    AbstractTextColumn<Permission> userColumn = new AbstractTextColumn<Permission>() {

        @Override
        public String getValue(Permission object) {
            return object.getOwnerName();
        }
    };
    permissionTable.addColumn(userColumn, constants.userPermission());
    AbstractTextColumn<Permission> permissionColumn = new AbstractObjectNameColumn<Permission>() {

        @Override
        protected Object[] getRawValue(Permission object) {
            return new Object[] { object.getObjectType(), object.getObjectName() };
        }
    };
    permissionTable.addColumn(permissionColumn, constants.objectPermission());
    permissionTable.addActionButton(new WebAdminButtonDefinition<Permission>(constants.removePermission()) {

        @Override
        protected UICommand resolveCommand() {
            return permissionModelProvider.getModel().getRemoveCommand();
        }
    });
    permissionTable.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            permissionModelProvider.setSelectedItems(permissionTable.getSelectionModel().getSelectedList());
        }
    });
}
#method_after
private void initPermissionTable() {
    permissionTable = new SimpleActionTable<>(permissionModelProvider, getTableHeaderlessResources(), getTableResources(), eventBus, clientStorage);
    permissionTable.enableColumnResizing();
    AbstractTextColumn<Permission> userColumn = new AbstractTextColumn<Permission>() {

        @Override
        public String getValue(Permission object) {
            return object.getOwnerName();
        }
    };
    userColumn.makeSortable();
    permissionTable.addColumn(userColumn, constants.userPermission());
    AbstractTextColumn<Permission> permissionColumn = new AbstractObjectNameColumn<Permission>() {

        @Override
        protected Object[] getRawValue(Permission object) {
            return new Object[] { object.getObjectType(), object.getObjectName() };
        }
    };
    permissionColumn.makeSortable();
    permissionTable.addColumn(permissionColumn, constants.objectPermission());
    permissionTable.addActionButton(new WebAdminButtonDefinition<Permission>(constants.removePermission()) {

        @Override
        protected UICommand resolveCommand() {
            return permissionModelProvider.getModel().getRemoveCommand();
        }
    });
    permissionTable.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            permissionModelProvider.setSelectedItems(permissionTable.getSelectionModel().getSelectedList());
        }
    });
}
#end_block

#method_before
public void pinVNodeToNumaNode(Guid sourceVMGuid, boolean isPinned, int sourceVNumaIndex, int targetPNumaNodeIndex) {
    boolean breakFlag = false;
    for (VM vm : getVmsWithvNumaNodeList()) {
        if (vm.getId().equals(sourceVMGuid)) {
            for (VmNumaNode vmNumaNode : vm.getvNumaNodeList()) {
                if (vmNumaNode.getIndex() == sourceVNumaIndex) {
                    vmNumaNode.setVdsNumaNodeList(new ArrayList<Pair<Guid, Pair<Boolean, Integer>>>());
                    if (targetPNumaNodeIndex != -1) {
                        Pair<Guid, Pair<Boolean, Integer>> pair = new Pair<>();
                        pair.setFirst(getNodeByIndex(targetPNumaNodeIndex).getId());
                        pair.setSecond(new Pair<Boolean, Integer>());
                        pair.getSecond().setFirst(true);
                        pair.getSecond().setSecond(targetPNumaNodeIndex);
                        vmNumaNode.getVdsNumaNodeList().add(pair);
                    }
                    break;
                }
            }
            updateParametersMap.put(vm.getId(), new VmNumaNodeOperationParameters(vm.getId(), vm.getvNumaNodeList()));
        }
        if (breakFlag) {
            break;
        }
    }
    modelReady();
}
#method_after
public void pinVNodeToNumaNode(Guid sourceVMGuid, boolean isPinned, int sourceVNumaIndex, int targetPNumaNodeIndex) {
    for (VM vm : getVmsWithvNumaNodeList()) {
        if (vm.getId().equals(sourceVMGuid)) {
            for (VmNumaNode vmNumaNode : vm.getvNumaNodeList()) {
                if (vmNumaNode.getIndex() == sourceVNumaIndex) {
                    vmNumaNode.setVdsNumaNodeList(new ArrayList<Pair<Guid, Pair<Boolean, Integer>>>());
                    if (targetPNumaNodeIndex != -1) {
                        Pair<Guid, Pair<Boolean, Integer>> pair = new Pair<>();
                        pair.setFirst(getNodeByIndex(targetPNumaNodeIndex).getId());
                        pair.setSecond(new Pair<Boolean, Integer>());
                        pair.getSecond().setFirst(true);
                        pair.getSecond().setSecond(targetPNumaNodeIndex);
                        vmNumaNode.getVdsNumaNodeList().add(pair);
                    }
                    break;
                }
            }
            updateParametersMap.put(vm.getId(), new VmNumaNodeOperationParameters(vm.getId(), vm.getvNumaNodeList()));
        }
    }
    modelReady();
}
#end_block

#method_before
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from runMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            fireAsyncQuerySucceededEvent(state);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runMultipleQueries: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                fireAsyncQueryFailedEvent(state);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<>(queryTypeList.get(i), parameters, true, multiCallback));
    }
    fireAsyncOperationStartedEvent(state);
    getOperationManager().addOperationList(operationList);
}
#method_after
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from runMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            fireAsyncQuerySucceededEvent(state);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runMultipleQueries: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                fireAsyncQueryFailedEvent(state);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, true, multiCallback));
    }
    fireAsyncOperationStartedEvent(state);
    getOperationManager().addOperationList(operationList);
}
#end_block

#method_before
public void runMultipleActions(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final IFrontendActionAsyncCallback successCallback, final Object state, final boolean runCallbacksOnEmptyRun) {
    if (parameters == null || parameters.isEmpty()) {
        if (runCallbacksOnEmptyRun && successCallback != null) {
            successCallback.executed(new FrontendActionAsyncResult(actionType, null, null, state));
        }
        return;
    }
    int n = parameters.size();
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    callbacks[n - 1] = successCallback;
    runMultipleActions(actionType, parameters, new LinkedList<>(Arrays.asList(callbacks)), state, true);
}
#method_after
public void runMultipleActions(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final IFrontendActionAsyncCallback successCallback, final Object state, final boolean runCallbacksOnEmptyRun) {
    if (parameters == null || parameters.isEmpty()) {
        if (runCallbacksOnEmptyRun && successCallback != null) {
            successCallback.executed(new FrontendActionAsyncResult(actionType, null, null, state));
        }
        return;
    }
    int n = parameters.size();
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    callbacks[n - 1] = successCallback;
    runMultipleActions(actionType, parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), state, true);
}
#end_block

#method_before
public void runMultipleActions(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final Object state, boolean aggregateErrors) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    VdcActionType[] actionTypes = new VdcActionType[parameters.size()];
    Arrays.fill(actionTypes, actionType);
    runMultipleActions(new LinkedList<>(Arrays.asList(actionTypes)), parameters, callbacks, null, state, aggregateErrors);
}
#method_after
public void runMultipleActions(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final Object state, boolean aggregateErrors) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    VdcActionType[] actionTypes = new VdcActionType[parameters.size()];
    Arrays.fill(actionTypes, actionType);
    runMultipleActions(new LinkedList<VdcActionType>(Arrays.asList(actionTypes)), parameters, callbacks, null, state, aggregateErrors);
}
#end_block

#method_before
public void onFinish(TaskContext context, boolean isSucceeded, IStorageModel model, String message) {
    context.invokeUIThread(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
    "Finish", // $NON-NLS-1$
    isSucceeded, // $NON-NLS-1$
    model, message })));
}
#method_after
public void onFinish(TaskContext context, boolean isSucceeded, IStorageModel model, String message) {
    context.invokeUIThread(this, // $NON-NLS-1$
    new ArrayList<>(Arrays.asList(new Object[] { "Finish", isSucceeded, model, message })));
}
#end_block

#method_before
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections storageConnection = new StorageServerConnections();
    storageConnection.setconnection(path);
    storageConnection.setstorage_type(nfsModel.getType());
    if (isConnectionOverriden()) {
        storageConnection.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        storageConnection.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
        storageConnection.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
        storageConnection.setMountOptions(nfsModel.getMountOptions().getEntity());
    }
    connection = storageConnection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
    tempVar2.setStoragePoolId(dataCenter.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = vdcReturnValueBase.getActionReturnValue();
        }
    };
    IFrontendActionAsyncCallback callback3 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            // Attach storage to data center as necessary.
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId(), storageModel.getActivateDomain().getEntity());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2, callback3 })), failureCallback, this);
}
#method_after
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections storageConnection = new StorageServerConnections();
    storageConnection.setconnection(path);
    storageConnection.setstorage_type(nfsModel.getType());
    if (isConnectionOverriden()) {
        storageConnection.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        storageConnection.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
        storageConnection.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
        storageConnection.setMountOptions(nfsModel.getMountOptions().getEntity());
    }
    connection = storageConnection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
    tempVar2.setStoragePoolId(dataCenter.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = vdcReturnValueBase.getActionReturnValue();
        }
    };
    IFrontendActionAsyncCallback callback3 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            // Attach storage to data center as necessary.
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId(), storageModel.getActivateDomain().getEntity());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(callback1, callback2, callback3)), failureCallback, this);
}
#end_block

#method_before
public void onFinish(TaskContext context, boolean isSucceeded, IStorageModel model, String message) {
    context.invokeUIThread(this, new ArrayList<>(Arrays.asList(new Object[] { // $NON-NLS-1$
    "Finish", // $NON-NLS-1$
    isSucceeded, // $NON-NLS-1$
    model, message })));
}
#method_after
public void onFinish(TaskContext context, boolean isSucceeded, IStorageModel model, String message) {
    context.invokeUIThread(this, // $NON-NLS-1$
    new ArrayList<>(Arrays.asList(new Object[] { "Finish", isSucceeded, model, message })));
}
#end_block

#method_before
private void loadVmwareProviders() {
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Provider<VmwareVmProviderProperties>> providers = new ArrayList<>();
            for (Provider<VmwareVmProviderProperties> provider : (List<Provider<VmwareVmProviderProperties>>) returnValue) {
                if (getDataCenters().getSelectedItem().getId().equals(provider.getAdditionalProperties().getStoragePoolId())) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getVmwareProviders().setItems(providers);
        }
    }), ProviderType.VMWARE);
}
#method_after
private void loadVmwareProviders() {
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Provider<VmwareVmProviderProperties>> providers = new ArrayList<>();
            for (Provider<VmwareVmProviderProperties> provider : (List<Provider<VmwareVmProviderProperties>>) returnValue) {
                if (getDataCenters().getSelectedItem().getId().equals(provider.getAdditionalProperties().getStoragePoolId()) || provider.getAdditionalProperties().getStoragePoolId() == null) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getVmwareProviders().setItems(providers);
        }
    }), ProviderType.VMWARE);
}
#end_block

#method_before
public void loadVmsFromVmware() {
    clearProblem();
    if (!validateVmwareConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getVmsFromExternalServer(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<VM> remoteVms = (List<VM>) returnValue;
            List<VM> remoteDownVms = new ArrayList<>();
            for (VM vm : remoteVms) {
                if (vm.isDown()) {
                    remoteDownVms.add(vm);
                }
            }
            if (remoteVms.size() != remoteDownVms.size()) {
                setWarning(constants.runningVmsWereFilteredOnImportVm());
            }
            updateVms(remoteDownVms);
        }
    }), getDataCenters().getSelectedItem().getId(), getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null, getUrl(), getUsername().getEntity(), getPassword().getEntity());
}
#method_after
public void loadVmsFromVmware() {
    clearProblem();
    if (!validateVmwareConfiguration()) {
        return;
    }
    startProgress();
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsFromExternalServer(query, getDataCenters().getSelectedItem().getId(), getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null, getUrl(), getUsername().getEntity(), getPassword().getEntity());
}
#end_block

#method_before
protected List<Widget> consoleTabWidgets() {
    return Arrays.<Widget>asList(displayTypeEditor, graphicsTypeEditor, usbSupportEditor, consoleDisconnectActionEditor, isSmartcardEnabledEditor, nativeUsbWarningMessage, expander, numOfMonitorsEditor, vncKeyboardLayoutEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent);
}
#method_after
protected List<Widget> consoleTabWidgets() {
    return Arrays.asList(displayTypeEditor, graphicsTypeEditor, usbSupportEditor, consoleDisconnectActionEditor, isSmartcardEnabledEditor, nativeUsbWarningMessage, expander, numOfMonitorsEditor, vncKeyboardLayoutEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent);
}
#end_block

#method_before
protected List<Widget> poolSpecificFields() {
    return Arrays.<Widget>asList(numOfVmsEditor, newPoolEditVmsPanel, editPoolEditVmsPanel, editPoolIncraseNumOfVmsPanel, poolTab, prestartedVmsEditor, poolNameIcon, newPoolEditMaxAssignedVmsPerUserPanel, editPoolEditMaxAssignedVmsPerUserPanel, spiceProxyEditor, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyOverrideEnabledEditor);
}
#method_after
protected List<Widget> poolSpecificFields() {
    return Arrays.asList(numOfVmsEditor, newPoolEditVmsPanel, editPoolEditVmsPanel, editPoolIncraseNumOfVmsPanel, poolTab, prestartedVmsEditor, poolNameIcon, newPoolEditMaxAssignedVmsPerUserPanel, editPoolEditMaxAssignedVmsPerUserPanel, spiceProxyEditor, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyOverrideEnabledEditor);
}
#end_block

#method_before
protected List<Widget> adminOnlyWidgets() {
    return Arrays.<Widget>asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, consoleDisconnectActionEditor, monitors, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#method_after
protected List<Widget> adminOnlyWidgets() {
    return Arrays.asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, consoleDisconnectActionEditor, monitors, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#end_block

#method_before
protected void spyCommand(StoragePoolManagementParameter params) {
    UpdateStoragePoolCommand<StoragePoolManagementParameter> realCommand = new UpdateStoragePoolCommand<>(params);
    cmd = spy(realCommand);
    doReturn(10).when(cmd).getStoragePoolNameSizeLimit();
    doReturn(createVersionSet().contains(cmd.getStoragePool().getCompatibilityVersion())).when(cmd).isStoragePoolVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDao();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDao();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(managementNetworkUtil).when(cmd).getManagementNetworkUtil();
    // Spy the StoragePoolValidator:
    poolValidator = spy(new StoragePoolValidator(params.getStoragePool()));
    doReturn(ValidationResult.VALID).when(poolValidator).isNotLocalfsWithDefaultCluster();
    doReturn(poolValidator).when(cmd).createStoragePoolValidator();
}
#method_after
protected void spyCommand(StoragePoolManagementParameter params) {
    UpdateStoragePoolCommand<StoragePoolManagementParameter> realCommand = new UpdateStoragePoolCommand<>(params);
    cmd = spy(realCommand);
    doReturn(createVersionSet().contains(cmd.getStoragePool().getCompatibilityVersion())).when(cmd).isStoragePoolVersionSupported();
    doReturn(spDao).when(cmd).getStoragePoolDao();
    doReturn(sdDao).when(cmd).getStorageDomainStaticDao();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(managementNetworkUtil).when(cmd).getManagementNetworkUtil();
    // Spy the StoragePoolValidator:
    poolValidator = spy(new StoragePoolValidator(params.getStoragePool()));
    doReturn(ValidationResult.VALID).when(poolValidator).isNotLocalfsWithDefaultCluster();
    doReturn(poolValidator).when(cmd).createStoragePoolValidator();
}
#end_block

#method_before
protected boolean checkStoragePoolNameLengthValid() {
    boolean result = true;
    if (getStoragePool().getName().length() > getStoragePoolNameSizeLimit()) {
        result = false;
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    return result;
}
#method_after
protected boolean checkStoragePoolNameLengthValid() {
    boolean result = true;
    if (getStoragePool().getName().length() > Config.<Integer>getValue(ConfigValues.StoragePoolNameSizeLimit)) {
        result = false;
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    return result;
}
#end_block

#method_before
private List<VdcActionParametersBase> createMigrateVmToServerParametersList(List<VmStatic> vmsToMigrate, final VDS vds) {
    return LinqUtils.transformToList(vmsToMigrate, new Function<VmStatic, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase eval(VmStatic vm) {
            MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), vds.getId());
            parameters.setShouldBeLogged(false);
            return parameters;
        }
    });
}
#method_after
private List<VdcActionParametersBase> createMigrateVmToServerParametersList(List<VmStatic> vmsToMigrate, final VDS vds) {
    return vmsToMigrate.stream().map(vm -> {
        MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), vds.getId());
        parameters.setShouldBeLogged(false);
        return parameters;
    }).collect(Collectors.toList());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    VDSReturnValue returnValue = null;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateIfaces(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
        }
    }
    EngineFault engineFault = null;
    if (!isSuccess && returnValue != null && returnValue.getVdsError() != null) {
        engineFault = new EngineFault();
        engineFault.setError(returnValue.getVdsError().getCode());
    }
    return new Pair<>(isSuccess, engineFault);
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected Pair<Boolean, EngineFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    VDSReturnValue returnValue = null;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateIfaces(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
        }
    }
    EngineFault engineFault = null;
    if (!isSuccess && returnValue.getVdsError() != null) {
        engineFault = new EngineFault();
        engineFault.setError(returnValue.getVdsError().getCode());
    }
    return new Pair<>(isSuccess, engineFault);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected List<StorageServerConnections> filterConnectionsUsedByOthers(List<StorageServerConnections> connections, String vgId, final String lunId) {
    // if we have lun id then filter by this lun
    // else get vg's luns from db
    List<String> lunsByVg = lunId.isEmpty() ? LinqUtils.transformToList(DbFacade.getInstance().getLunDao().getAllForVolumeGroup(vgId), new Function<LUNs, String>() {

        @Override
        public String eval(LUNs a) {
            return a.getLUN_id();
        }
    }) : null;
    // if a luns were retrieved by vgId, they can belongs not only to storage but also to disks
    // at that case they should left at db
    List<String> lunsByVgWithNoDisks = new ArrayList<>();
    if (lunId.isEmpty()) {
        for (String lunIdByVg : lunsByVg) {
            if (DbFacade.getInstance().getDiskLunMapDao().getDiskIdByLunId(lunIdByVg) == null) {
                lunsByVgWithNoDisks.add(lunIdByVg);
            }
        }
    } else {
        lunsByVgWithNoDisks.add(lunId);
    }
    List<StorageServerConnections> toRemove = new ArrayList<>();
    for (StorageServerConnections connection : connections) {
        fillConnectionDetailsIfNeeded(connection);
        if (connection.getid() != null) {
            List<String> list = LinqUtils.transformToList(DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(connection.getid()), new Function<LUNs, String>() {

                @Override
                public String eval(LUNs a) {
                    return a.getLUN_id();
                }
            });
            if (0 < CollectionUtils.subtract(list, lunsByVgWithNoDisks).size()) {
                toRemove.add(connection);
            }
        }
    }
    return (List<StorageServerConnections>) CollectionUtils.subtract(connections, toRemove);
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected List<StorageServerConnections> filterConnectionsUsedByOthers(List<StorageServerConnections> connections, String vgId, final String lunId) {
    // if we have lun id then filter by this lun
    // else get vg's luns from db
    List<String> lunsByVg = lunId.isEmpty() ? DbFacade.getInstance().getLunDao().getAllForVolumeGroup(vgId).stream().map(LUNs::getLUN_id).collect(Collectors.toList()) : null;
    // if a luns were retrieved by vgId, they can belongs not only to storage but also to disks
    // at that case they should left at db
    List<String> lunsByVgWithNoDisks = new ArrayList<>();
    if (lunId.isEmpty()) {
        for (String lunIdByVg : lunsByVg) {
            if (DbFacade.getInstance().getDiskLunMapDao().getDiskIdByLunId(lunIdByVg) == null) {
                lunsByVgWithNoDisks.add(lunIdByVg);
            }
        }
    } else {
        lunsByVgWithNoDisks.add(lunId);
    }
    List<StorageServerConnections> toRemove = new ArrayList<>();
    for (StorageServerConnections connection : connections) {
        fillConnectionDetailsIfNeeded(connection);
        if (connection.getid() != null) {
            List<String> list = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(connection.getid()).stream().map(LUNs::getLUN_id).collect(Collectors.toList());
            if (0 < CollectionUtils.subtract(list, lunsByVgWithNoDisks).size()) {
                toRemove.add(connection);
            }
        }
    }
    return (List<StorageServerConnections>) CollectionUtils.subtract(connections, toRemove);
}
#end_block

#method_before
@Override
public boolean isConnectSucceeded(final Map<String, String> returnValue, List<StorageServerConnections> connections) {
    boolean result = true;
    List<String> failedConnectionsList = LinqUtils.filter(returnValue.keySet(), new Predicate<String>() {

        @Override
        public boolean eval(String a) {
            return !"0".equals(returnValue.get(a));
        }
    });
    for (String failedConnection : failedConnectionsList) {
        List<LUNs> failedLuns = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(failedConnection);
        if (!failedLuns.isEmpty()) {
            for (LUNs lun : failedLuns) {
                /**
                 * TODO: check if LUNs in the same pool.
                 */
                List<String> strings = LinqUtils.transformToList(DbFacade.getInstance().getStorageServerConnectionLunMapDao().getAll(lun.getLUN_id()), new Function<LUNStorageServerConnectionMap, String>() {

                    @Override
                    public String eval(LUNStorageServerConnectionMap a) {
                        return a.getstorage_server_connection();
                    }
                });
                if (CollectionUtils.subtract(strings, failedConnectionsList).size() == 0) {
                    // At case of failure the appropriate log message will be
                    // added
                    log.info("The lun with id '{}' was reported as problematic", lun.getphysical_volume_id());
                    for (String connectionFailed : failedConnectionsList) {
                        String connectionField = addToAuditLogErrorMessage(connectionFailed, returnValue.get(connectionFailed), connections, lun);
                        printLog(log, connectionField, returnValue.get(connectionFailed));
                    }
                    return false;
                }
            }
        } else {
            result = false;
            printLog(log, failedConnection, returnValue.get(failedConnection));
        }
    }
    return result;
}
#method_after
@Override
public boolean isConnectSucceeded(final Map<String, String> returnValue, List<StorageServerConnections> connections) {
    boolean result = true;
    List<String> failedConnectionsList = returnValue.keySet().stream().filter(a -> !"0".equals(returnValue.get(a))).collect(Collectors.toList());
    for (String failedConnection : failedConnectionsList) {
        List<LUNs> failedLuns = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(failedConnection);
        if (!failedLuns.isEmpty()) {
            for (LUNs lun : failedLuns) {
                // TODO: check if LUNs in the same pool.
                List<String> strings = DbFacade.getInstance().getStorageServerConnectionLunMapDao().getAll(lun.getLUN_id()).stream().map(LUNStorageServerConnectionMap::getstorage_server_connection).collect(Collectors.toList());
                if (CollectionUtils.subtract(strings, failedConnectionsList).size() == 0) {
                    // At case of failure the appropriate log message will be
                    // added
                    log.info("The lun with id '{}' was reported as problematic", lun.getphysical_volume_id());
                    for (String connectionFailed : failedConnectionsList) {
                        String connectionField = addToAuditLogErrorMessage(connectionFailed, returnValue.get(connectionFailed), connections, lun);
                        printLog(log, connectionField, returnValue.get(connectionFailed));
                    }
                    return false;
                }
            }
        } else {
            result = false;
            printLog(log, failedConnection, returnValue.get(failedConnection));
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<RepoImage> imageList = IsoDomainListSyncronizer.getInstance().getUserRequestForStorageDomainRepoFileList(getParameters().getStorageDomainId(), ImageFileType.All, true);
    getQueryReturnValue().setReturnValue(LinqUtils.firstOrNull(imageList, new Predicate<RepoImage>() {

        @Override
        public boolean eval(RepoImage repoImage) {
            return repoImage.getRepoImageId().equals(getParameters().getRepoImageId());
        }
    }));
}
#method_after
@Override
protected void executeQueryCommand() {
    List<RepoImage> imageList = IsoDomainListSyncronizer.getInstance().getUserRequestForStorageDomainRepoFileList(getParameters().getStorageDomainId(), ImageFileType.All, true);
    getQueryReturnValue().setReturnValue(imageList.stream().filter(repoImage -> repoImage.getRepoImageId().equals(getParameters().getRepoImageId())).findFirst().orElse(null));
}
#end_block

#method_before
private void resumeVm() {
    setVdsId(getVm().getRunOnVds());
    if (getVds() != null) {
        try {
            VDSReturnValue result = getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
        }
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#method_after
private void resumeVm() {
    setVdsId(getVm().getRunOnVds());
    if (getVds() != null) {
        try {
            VDSReturnValue result = getVdsBroker().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
        }
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#end_block

#method_before
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.info("Running VM with attached cd '{}'", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks();
    initParametersForPassthroughVnics();
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.info("Running VM with attached cd '{}'", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks();
    initParametersForPassthroughVnics();
    VMStatus vmStatus = (VMStatus) getVdsBroker().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return resourceManger;
}
#method_after
@Deprecated
@Override
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return resourceManger;
}
#end_block

#method_before
public void mockBackend() {
    doReturn(backend).when(command).getBackend();
    VDSReturnValue vdsReturnValue = new VDSReturnValue();
    vdsReturnValue.setReturnValue(true);
    when(vdsBrokerFrontend.RunVdsCommand(any(VDSCommandType.class), any(VDSParametersBase.class))).thenReturn(vdsReturnValue);
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    // Set Valid Iso Prefix
    setIsoPrefixVDSMethod(ACTIVE_ISO_PREFIX);
    // Set create Vm.
    setCreateVmVDSMethod();
}
#method_after
public void mockBackend() {
    doReturn(backend).when(command).getBackend();
    VDSReturnValue vdsReturnValue = new VDSReturnValue();
    vdsReturnValue.setReturnValue(true);
    when(vdsBrokerFrontend.RunVdsCommand(any(VDSCommandType.class), any(VDSParametersBase.class))).thenReturn(vdsReturnValue);
    // Set Valid Iso Prefix
    setIsoPrefixVDSMethod(ACTIVE_ISO_PREFIX);
    // Set create Vm.
    setCreateVmVDSMethod();
}
#end_block

#method_before
private void setCreateVmVDSMethod() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(VMStatus.Up);
    when(backend.getResourceManager().RunAsyncVdsCommand(eq(VDSCommandType.CreateVm), any(VdsAndVmIDVDSParametersBase.class), any(IVdsAsyncCommand.class))).thenReturn(returnValue);
}
#method_after
private void setCreateVmVDSMethod() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(VMStatus.Up);
    when(vdsBrokerFrontend.RunAsyncVdsCommand(eq(VDSCommandType.CreateVm), any(VdsAndVmIDVDSParametersBase.class), any(IVdsAsyncCommand.class))).thenReturn(returnValue);
}
#end_block

#method_before
private VM mockVm(RunVmCommand<RunVmParams> spyVmCommand) {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    doReturn(vmDao).when(command).getVmDao();
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    doReturn(new VDSGroup()).when(command).getVdsGroup();
    // Avoid referencing the unmockable static VmHandler.updateCurrentCd
    doNothing().when(command).updateCurrentCd(any(String.class));
    return vm;
}
#method_after
private VM mockVm(RunVmCommand<RunVmParams> spyVmCommand) {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    doReturn(vmDao).when(command).getVmDao();
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    doReturn(new VDSGroup()).when(command).getVdsGroup();
    doReturn(vdsBrokerFrontend).when(command).getVdsBroker();
    // Avoid referencing the unmockable static VmHandler.updateCurrentCd
    doNothing().when(command).updateCurrentCd(any(String.class));
    return vm;
}
#end_block

#method_before
@Before
public void initMockitoAnnotations() {
    MockitoAnnotations.initMocks(this);
}
#method_after
public void initMockitoAnnotations() {
    MockitoAnnotations.initMocks(this);
}
#end_block

#method_before
@Before
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(Mockito.anyInt(), Mockito.any(Version.class), Mockito.anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#method_after
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(Mockito.anyInt(), Mockito.any(Version.class), Mockito.anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#end_block

#method_before
@Test
public void vlanOverNic() {
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, null);
    VdsNetworkInterface vlan = createVlan(nic, net);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(nic), Collections.<String>emptySet(), Arrays.asList(nic, vlan), new CustomPropertiesForVdsNetworkInterface());
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
}
#method_after
@Test
public void vlanOverNic() {
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, null);
    VdsNetworkInterface vlan = createVlan(nic, net);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(nic), Collections.<String>emptySet(), Arrays.asList(nic, vlan), new CustomPropertiesForVdsNetworkInterface(), true);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
}
#end_block

#method_before
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface vlan = createVlan(bond, net);
    List<VdsNetworkInterface> ifaces = new ArrayList<>(slaves);
    ifaces.add(bond);
    ifaces.add(vlan);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces, new CustomPropertiesForVdsNetworkInterface());
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    assertBondWasSent(bond, slaves);
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(bond.getName(), networkStruct.get("bonding"));
}
#method_after
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface vlan = createVlan(bond, net);
    List<VdsNetworkInterface> ifaces = new ArrayList<>(slaves);
    ifaces.add(bond);
    ifaces.add(vlan);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces, new CustomPropertiesForVdsNetworkInterface(), true);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    assertBondWasSent(bond, slaves);
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(bond.getName(), networkStruct.get("bonding"));
}
#end_block

#method_before
@Test
public void networkWithDhcp() {
    Network net = createNetwork(null);
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, net.getName());
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(nic), new CustomPropertiesForVdsNetworkInterface());
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
    assertEquals(SetupNetworksVDSCommand.DHCP_BOOT_PROTOCOL, networkStruct.get(SetupNetworksVDSCommand.BOOT_PROTOCOL));
}
#method_after
@Test
public void networkWithDhcp() {
    Network net = createNetwork(null);
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, net.getName());
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(nic), new CustomPropertiesForVdsNetworkInterface(), true);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
    assertEquals(SetupNetworksVDSCommand.DHCP_BOOT_PROTOCOL, networkStruct.get(SetupNetworksVDSCommand.BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void bondModified() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    List<VdsNetworkInterface> ifaces = new ArrayList<>(slaves);
    ifaces.add(bond);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.<Network>emptyList(), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces, new CustomPropertiesForVdsNetworkInterface());
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> bondMap = assertBondWasSent(bond, slaves);
    assertEquals(bond.getBondOptions(), bondMap.get(SetupNetworksVDSCommand.BONDING_OPTIONS));
}
#method_after
@Test
public void bondModified() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    List<VdsNetworkInterface> ifaces = new ArrayList<>(slaves);
    ifaces.add(bond);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.<Network>emptyList(), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces, new CustomPropertiesForVdsNetworkInterface(), true);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> bondMap = assertBondWasSent(bond, slaves);
    assertEquals(bond.getBondOptions(), bondMap.get(SetupNetworksVDSCommand.BONDING_OPTIONS));
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, HostNetworkQos expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface), new CustomPropertiesForVdsNetworkInterface());
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    HostNetworkQos result = new HostNetworkQosMapper(networkStruct).deserialize();
    iface.setQos(result);
    assertTrue(new NetworkInSyncWithVdsNetworkInterface(iface, network, expectedQos, null).qosParametersEqual());
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, HostNetworkQos expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface), new CustomPropertiesForVdsNetworkInterface(), true);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    HostNetworkQos result = new HostNetworkQosMapper(networkStruct).deserialize();
    iface.setQos(result);
    assertTrue(new NetworkInSyncWithVdsNetworkInterface(iface, network, expectedQos, null).qosParametersEqual());
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final ClientPolicy policy = client.getClientRetryPolicy();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            if (isPolicyReset) {
                updateHeartbeatPolicy(policy.clone(), false);
            }
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(policy, true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            if (isPolicyReset) {
                updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            }
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    httpTask = getBroker().setupNetworks(generateNetworks(), generateBonds(), generateOptions(), true);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    httpTask = getBroker().setupNetworks(generateNetworks(), generateBonds(), generateOptions(), getParameters().isManagementNetworkChanged());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    fillInUnsetBondingOptions();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    fillInUnsetBondingOptions();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    completeMissingDataInParameters();
    IdQueryParameters idParameters = new IdQueryParameters(getVdsId());
    VdcQueryReturnValue existingBondsResponse = runInternalQuery(VdcQueryType.GetHostBondsByHostId, idParameters);
    if (!existingBondsResponse.getSucceeded()) {
        return false;
    }
    List<VdsNetworkInterface> existingBonds = existingBondsResponse.getReturnValue();
    removeUnchangedAttachments(networkAttachmentDao.getAllForHost(getVdsId()));
    removeUnchangedBonds(existingBonds);
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
private FutureVDSCall<VDSReturnValue> invokeSetupNetworksCommand(int timeout) {
    final HostSetupNetworksVdsCommandParameters parameters = createSetupNetworksParameters(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = getBackend().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.HostSetupNetworks, parameters);
    if (parameters.isRollbackOnFailure()) {
        HostSetupNetworkPoller poller = new HostSetupNetworkPoller();
        while (!setupNetworksTask.isDone()) {
            poller.poll(getVdsId());
        }
    }
    return setupNetworksTask;
}
#method_after
private FutureVDSCall<VDSReturnValue> invokeSetupNetworksCommand(int timeout) {
    final HostSetupNetworksVdsCommandParameters parameters = createSetupNetworksParameters(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = getVdsBroker().runFutureVdsCommand(FutureVDSCommandType.HostSetupNetworks, parameters);
    if (parameters.isRollbackOnFailure()) {
        HostSetupNetworkPoller poller = new HostSetupNetworkPoller();
        while (!setupNetworksTask.isDone()) {
            poller.poll(getVdsId());
        }
    }
    return setupNetworksTask;
}
#end_block

#method_before
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    hostCmdParams.setManagementNetworkChanged(hasManagementNetworkChanged());
    return hostCmdParams;
}
#method_after
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    hostCmdParams.setManagementNetworkChanged(isManagementNetworkChanged());
    return hostCmdParams;
}
#end_block

#method_before
private boolean noChangesDetected() {
    return getNetworksToConfigure().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty() && getRemovedUnmanagedNetworks().isEmpty() && getParameters().getLabels().isEmpty() && getParameters().getRemovedLabels().isEmpty();
}
#method_after
private boolean noChangesDetected() {
    return getParameters().isEmptyRequest();
}
#end_block

#method_before
private List<VdsNetworkInterface> getNicsToConfigureWithoutLabelsUpdates() {
    List<VdsNetworkInterface> nicsToConfigure = new ArrayList<>();
    nicsToConfigure.addAll(interfaceDao.getAllInterfacesForVds(getVdsId()));
    // slaves.
    for (Bond bond : getParameters().getBonds()) {
        if (bond.getId() == null) {
            Bond newBond = new Bond(bond.getName());
            nicsToConfigure.add(newBond);
        }
    }
    return nicsToConfigure;
}
#method_after
private List<VdsNetworkInterface> getNicsToConfigureWithoutLabelsUpdates() {
    List<VdsNetworkInterface> nicsToConfigure = new ArrayList<>();
    nicsToConfigure.addAll(interfaceDao.getAllInterfacesForVds(getVdsId()));
    // TODO MM: The bonds in the parameters shouldn't contain the whole VdsNetworkInterface. 0nly the id, name, bondOptions and slaves.
    for (Bond bond : getParameters().getBonds()) {
        if (bond.getId() == null) {
            Bond newBond = new Bond(bond.getName());
            nicsToConfigure.add(newBond);
        }
    }
    return nicsToConfigure;
}
#end_block

#method_before
public boolean isManagementNetworkChanged() {
    return isManagementNetworkChanged;
}
#method_after
public boolean isManagementNetworkChanged() {
    return managementNetworkChanged;
}
#end_block

#method_before
public void setManagementNetworkChanged(boolean hasManagementNetworkChanged) {
    this.isManagementNetworkChanged = hasManagementNetworkChanged;
}
#method_after
public void setManagementNetworkChanged(boolean isManagementNetworkChanged) {
    this.managementNetworkChanged = isManagementNetworkChanged;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    httpTask = getBroker().setupNetworks(generateNetworks(), generateBonds(), generateOptions(), isManagementNetworkChanged());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    httpTask = getBroker().setupNetworks(generateNetworks(), generateBonds(), generateOptions(), getParameters().isManagementNetworkChanged());
}
#end_block

#method_before
@Parameters
public static Collection<Object[]> data() {
    RandomUtils random = RandomUtils.instance();
    VdsStatic vdsStatic = new VdsStatic(random.nextString(10), random.nextString(10), random.nextInt(), random.nextInt(), random.nextString(10), Guid.newGuid(), Guid.newGuid(), random.nextString(10), random.nextBoolean(), random.nextEnum(VDSType.class), Guid.newGuid());
    Object[][] data = new Object[][] { { vdsStatic }, { randomVdsDynamic() }, { randomVdsStatistics() }, { new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt()) }, { randomStorageDomainStatic() }, { new StorageDomainDynamic(random.nextInt(), Guid.newGuid(), random.nextInt()) }, { randomStoragePool() }, { new StoragePoolIsoMap(Guid.newGuid(), Guid.newGuid(), random.nextEnum(StorageDomainStatus.class)) }, { randomRole() }, { new IdContainerClass<vds_spm_id_map>(new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt())) }, { new IdContainerClass<Guid>(Guid.newGuid()) } };
    return Arrays.asList(data);
}
#method_after
@Parameters
public static Collection<Object[]> data() {
    RandomUtils random = RandomUtils.instance();
    VdsStatic vdsStatic = new VdsStatic(random.nextString(10), random.nextString(10), random.nextInt(), random.nextInt(), random.nextString(10), Guid.newGuid(), Guid.newGuid(), random.nextString(10), random.nextBoolean(), random.nextEnum(VDSType.class), Guid.newGuid());
    Object[][] data = new Object[][] { { vdsStatic }, { randomVdsDynamic() }, { randomVdsStatistics() }, { new VdsSpmIdMap(Guid.newGuid(), Guid.newGuid(), random.nextInt()) }, { randomStorageDomainStatic() }, { new StorageDomainDynamic(random.nextInt(), Guid.newGuid(), random.nextInt()) }, { randomStoragePool() }, { new StoragePoolIsoMap(Guid.newGuid(), Guid.newGuid(), random.nextEnum(StorageDomainStatus.class)) }, { randomRole() }, { new IdContainerClass<VdsSpmIdMap>(new VdsSpmIdMap(Guid.newGuid(), Guid.newGuid(), random.nextInt())) }, { new IdContainerClass<Guid>(Guid.newGuid()) } };
    return Arrays.asList(data);
}
#end_block

#method_before
@Override
public Object getQueryableId() {
    return getbookmark_id();
}
#method_after
@Override
public Object getQueryableId() {
    return getId();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    if (!super.canDoAction()) {
        return false;
    }
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(vmTemplateId)) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (!isInstanceType && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    if (!isInstanceType) {
        fetchImageTemplates();
    }
    // populate all the domains of the template
    Set<Guid> allDomainsList = getStorageDomainsByDisks(imageTemplates, true);
    getParameters().setStorageDomainsList(new ArrayList<>(allDomainsList));
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDao().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<>();
    for (VM vm : vms) {
        problematicVmNames.add(vm.getName());
    }
    if (!problematicVmNames.isEmpty()) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM, String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
    }
    // for base templates: lock sub-templates if there are any
    if (template.isBaseTemplate()) {
        templateSubVersions = getVmTemplateDao().getTemplateVersionsForBaseTemplate(vmTemplateId);
        if (!templateSubVersions.isEmpty()) {
            Collection<String> failReasons = acquireSubTemplatesLock();
            boolean lockAcquired = failReasons == null;
            if (!lockAcquired) {
                getReturnValue().getCanDoActionMessages().addAll(failReasons);
                return false;
            }
        }
    }
    if (!isInstanceType && !validate(checkNoDisksBasedOnTemplateDisks())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    if (!super.canDoAction()) {
        return false;
    }
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(vmTemplateId)) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (!isInstanceType && !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    if (!isInstanceType) {
        fetchImageTemplates();
    }
    // populate all the domains of the template
    Set<Guid> allDomainsList = getStorageDomainsByDisks(imageTemplates, true);
    getParameters().setStorageDomainsList(new ArrayList<>(allDomainsList));
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDao().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<>();
    for (VM vm : vms) {
        problematicVmNames.add(vm.getName());
    }
    if (!problematicVmNames.isEmpty()) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM, String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
    }
    if (template.isBaseTemplate() && !tryLockSubVersionIfExists()) {
        return false;
    }
    if (!isInstanceType && !validate(checkNoDisksBasedOnTemplateDisks())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private String createSubTemplateLockMessage(VmTemplate template) {
    return String.format("%s$templateName %s$templateId %s", EngineMessage.ACTION_TYPE_FAILED_BASE_TEMPLATE_OF_TEMPLATE_IS_BEING_REMOVED, template.getName(), template.getId());
}
#method_after
private String createSubTemplateLockMessage(VmTemplate template) {
    return String.format("%s$templateName %s$templateId %s", EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_SET_AS_BASE_TEMPLATE, template.getName(), template.getId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (subTemplatesLock != null) {
        shiftBaseTemplateToSuccessor();
    }
    final List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()));
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!imageTemplates.isEmpty() || !cinderDisks.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (!imageTemplates.isEmpty() && removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                if (!cinderDisks.isEmpty()) {
                    removeCinderDisks(cinderDisks);
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        // if for some reason template doesn't have images, remove it now and not in end action
        HandleEndAction();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmTemplate().isBaseTemplate()) {
        shiftBaseTemplateToSuccessor();
    }
    final List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()));
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!imageTemplates.isEmpty() || !cinderDisks.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (!imageTemplates.isEmpty() && removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                if (!cinderDisks.isEmpty()) {
                    removeCinderDisks(cinderDisks);
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        // if for some reason template doesn't have images, remove it now and not in end action
        HandleEndAction();
    }
}
#end_block

#method_before
private void shiftBaseTemplateToSuccessor() {
    try {
        final Guid newBaseTemplateId = findIdOfOldestTemplate(templateSubVersions);
        updateBaseTemplateId(newBaseTemplateId, templateSubVersions);
    } finally {
        freeSubTemplatesLock();
    }
}
#method_after
private void shiftBaseTemplateToSuccessor() {
    try {
        getVmTemplateDao().shiftBaseTemplate(getVmTemplateId());
    } finally {
        freeSubTemplateLock();
    }
}
#end_block

#method_before
private void removeCinderDisks(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters removeParam = new RemoveAllVmCinderDisksParameters(getVmTemplateId(), cinderDisks);
    removeParam.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(removeParam, getActionType()), cloneContextAndDetachFromParent(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        future.get().getActionReturnValue();
    } catch (InterruptedException | ExecutionException e) {
        log.error("Exception", e);
    }
}
#method_after
private void removeCinderDisks(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters removeParam = new RemoveAllVmCinderDisksParameters(getVmTemplateId(), cinderDisks);
    removeParam.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(removeParam), cloneContextAndDetachFromParent(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        future.get().getActionReturnValue();
    } catch (InterruptedException | ExecutionException e) {
        log.error("Exception", e);
    }
}
#end_block

#method_before
private String getTemplateExclusiveLockMessage() {
    return new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_REMOVED.name()).append(String.format("$TemplateName %1$s", getVmTemplate().getName())).toString();
}
#method_after
private String getTemplateExclusiveLockMessage() {
    return new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_REMOVED.name()).append(String.format("$templateName %s$templateId %s", getVmTemplate().getName(), getVmTemplate().getId())).toString();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    // validate NUMA nodes count not more than CPUs
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getVmId(), numaNodes);
    params.setNumaTuneMode(getParameters().getVmStaticData().getNumaTuneMode());
    params.setDedicatedHostList(getParameters().getVmStaticData().getDedicatedVmForVdsList());
    params.setMigrationSupport(getParameters().getVmStaticData().getMigrationSupport());
    if (numaNodes == null || numaNodes.isEmpty()) {
        return;
    }
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVm().getvNumaNodeList();
    if (numaNodes.isEmpty()) {
        return;
    }
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), numaNodes);
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance may be sufficient
        if (getInstanceTypeId() != null && checkCreateInstancePermission(permSubject)) {
            continue;
        }
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    if (getInstanceTypeId() != null && !checkInstanceTypeImagePermissions(getInstanceTypeId())) {
        return false;
    }
    if (imageTypeId != null && !checkInstanceTypeImagePermissions(imageTypeId)) {
        return false;
    }
    for (PermissionSubject permSubject : permSubjects) {
        // if user is using instance type, then create_instance may be sufficient
        if (getInstanceTypeId() != null && checkCreateInstancePermission(permSubject)) {
            continue;
        }
        // create_vm is overriding in case no create_instance, try again with it
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean checkCreateInstancePermission(PermissionSubject permSubject) {
    final Set<VdcObjectType> overriddenPermissionObjectTypes = new HashSet<VdcObjectType>() {

        {
            add(VdcObjectType.VdsGroups);
            add(VdcObjectType.VmTemplate);
        }
    };
    final boolean isInstanceCreateObjectType = overriddenPermissionObjectTypes.contains(permSubject.getObjectType());
    if (!isInstanceCreateObjectType) {
        return false;
    }
    final PermissionSubject alteredPermissionSubject = new PermissionSubject(permSubject.getObjectId(), permSubject.getObjectType(), ActionGroup.CREATE_INSTANCE, permSubject.getMessage());
    return checkSinglePermission(alteredPermissionSubject, getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean checkCreateInstancePermission(PermissionSubject permSubject) {
    final List<VdcObjectType> overriddenPermissionObjectTypes = Arrays.asList(VdcObjectType.VdsGroups, VdcObjectType.VmTemplate);
    final boolean instanceCreateObjectType = overriddenPermissionObjectTypes.contains(permSubject.getObjectType());
    if (!instanceCreateObjectType) {
        return false;
    }
    final PermissionSubject alteredPermissionSubject = new PermissionSubject(permSubject.getObjectId(), permSubject.getObjectType(), ActionGroup.CREATE_INSTANCE, permSubject.getMessage());
    return checkSinglePermission(alteredPermissionSubject, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
public void initTunedProfiles() {
    this.startProgress();
    if (getVersion() == null || getVersion().getSelectedItem() == null) {
        return;
    }
    Version version = getVersion().getSelectedItem();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterTunedProfiles, new IdAndNameQueryParameters(null, version.getValue()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterModel.this.stopProgress();
            ClusterModel clusterModel = (ClusterModel) model;
            List<String> glusterTunedProfiles = new ArrayList<>();
            if (((VdcQueryReturnValue) returnValue).getSucceeded()) {
                glusterTunedProfiles.addAll((List<String>) (((VdcQueryReturnValue) returnValue).getReturnValue()));
            }
            final String oldSelectedProfile = clusterModel != null && clusterModel.getGlusterTunedProfile() != null ? clusterModel.getGlusterTunedProfile().getSelectedItem() : getEntity() != null ? getEntity().getGlusterTunedProfile() : null;
            glusterTunedProfile.setItems(glusterTunedProfiles);
            glusterTunedProfile.setIsAvailable(glusterTunedProfile.getItems().size() > 0);
            if (oldSelectedProfile != null) {
                String newSelectedItem = Linq.firstOrDefault(glusterTunedProfiles, new IPredicate<String>() {

                    @Override
                    public boolean match(String item) {
                        // $NON-NLS-1$
                        return item.equals(oldSelectedProfile);
                    }
                });
                if (newSelectedItem != null) {
                    glusterTunedProfile.setSelectedItem(newSelectedItem);
                }
            }
            if (glusterTunedProfile.getSelectedItem() == null) {
                glusterTunedProfile.setSelectedItem(Linq.firstOrDefault(glusterTunedProfiles));
            }
        }
    }));
}
#method_after
public void initTunedProfiles() {
    this.startProgress();
    if (getVersion() == null || getVersion().getSelectedItem() == null) {
        return;
    }
    Version version = getVersion().getSelectedItem();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterTunedProfiles, new IdAndNameQueryParameters(null, version.getValue()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterModel.this.stopProgress();
            List<String> glusterTunedProfiles = new ArrayList<>();
            if (((VdcQueryReturnValue) returnValue).getSucceeded()) {
                glusterTunedProfiles.addAll((List<String>) (((VdcQueryReturnValue) returnValue).getReturnValue()));
            }
            final String oldSelectedProfile = glusterTunedProfile.getSelectedItem();
            glusterTunedProfile.setItems(glusterTunedProfiles);
            glusterTunedProfile.setIsAvailable(glusterTunedProfile.getItems().size() > 0);
            if (oldSelectedProfile != null) {
                String newSelectedItem = Linq.firstOrNull(glusterTunedProfiles, new Linq.EqualsPredicate(oldSelectedProfile));
                if (newSelectedItem != null) {
                    glusterTunedProfile.setSelectedItem(newSelectedItem);
                } else if (getIsEdit()) {
                    glusterTunedProfile.setSelectedItem(Linq.firstOrNull(glusterTunedProfiles, new Linq.EqualsPredicate(getEntity().getGlusterTunedProfile())));
                }
            }
        }
    }));
}
#end_block

#method_before
public void mockBackend() {
    doReturn(backend).when(command).getBackend();
    VDSReturnValue vdsReturnValue = new VDSReturnValue();
    vdsReturnValue.setReturnValue(true);
    when(vdsBrokerFrontend.RunVdsCommand(any(VDSCommandType.class), any(VDSParametersBase.class))).thenReturn(vdsReturnValue);
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    // Set Valid Iso Prefix
    setIsoPrefixVDSMethod(ACTIVE_ISO_PREFIX);
    // Set create Vm.
    setCreateVmVDSMethod();
}
#method_after
public void mockBackend() {
    doReturn(backend).when(command).getBackend();
    VDSReturnValue vdsReturnValue = new VDSReturnValue();
    vdsReturnValue.setReturnValue(true);
    when(vdsBrokerFrontend.RunVdsCommand(any(VDSCommandType.class), any(VDSParametersBase.class))).thenReturn(vdsReturnValue);
    // Set Valid Iso Prefix
    setIsoPrefixVDSMethod(ACTIVE_ISO_PREFIX);
    // Set create Vm.
    setCreateVmVDSMethod();
}
#end_block

#method_before
private void setCreateVmVDSMethod() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(VMStatus.Up);
    when(backend.getResourceManager().RunAsyncVdsCommand(eq(VDSCommandType.CreateVm), any(VdsAndVmIDVDSParametersBase.class), any(IVdsAsyncCommand.class))).thenReturn(returnValue);
}
#method_after
private void setCreateVmVDSMethod() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(VMStatus.Up);
    when(vdsBrokerFrontend.RunAsyncVdsCommand(eq(VDSCommandType.CreateVm), any(VdsAndVmIDVDSParametersBase.class), any(IVdsAsyncCommand.class))).thenReturn(returnValue);
}
#end_block

#method_before
private VM mockVm(RunVmCommand<RunVmParams> spyVmCommand) {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    doReturn(vmDao).when(command).getVmDao();
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    doReturn(new VDSGroup()).when(command).getVdsGroup();
    // Avoid referencing the unmockable static VmHandler.updateCurrentCd
    doNothing().when(command).updateCurrentCd(any(String.class));
    return vm;
}
#method_after
private VM mockVm(RunVmCommand<RunVmParams> spyVmCommand) {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    doReturn(vmDao).when(command).getVmDao();
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    doReturn(new VDSGroup()).when(command).getVdsGroup();
    doReturn(vdsBrokerFrontend).when(command).getVdsBroker();
    // Avoid referencing the unmockable static VmHandler.updateCurrentCd
    doNothing().when(command).updateCurrentCd(any(String.class));
    return vm;
}
#end_block

#method_before
@Before
public void createCommand() {
    MockitoAnnotations.initMocks(this);
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(Mockito.anyInt(), Mockito.any(Version.class), Mockito.anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#method_after
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(Mockito.anyInt(), Mockito.any(Version.class), Mockito.anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#end_block

#method_before
private void mockIsoDomainListSyncronizer() {
    doNothing().when(isoDomainListSyncronizer).init();
    doReturn(isoDomainListSyncronizer).when(command).getIsoDomainListSyncronizer();
}
#method_after
private void mockIsoDomainListSyncronizer() {
    doReturn(isoDomainListSyncronizer).when(command).getIsoDomainListSyncronizer();
}
#end_block

#method_before
private static VdsDao getVdsDao() {
    return DbFacade.getInstance().getVdsDao();
}
#method_after
private static VdsDao getVdsDao() {
    return Injector.get(VdsDao.class);
}
#end_block

#method_before
protected void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName(getName().getEntity());
    VnicProfileView profile = getProfile().getSelectedItem();
    nic.setVnicProfileId(profile.getId());
    nic.setNetworkName(profile.getNetworkName());
    nic.setLinked(getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(getNicType().getSelectedItem().getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged(getPlugged().getEntity());
    startProgress(null);
    Frontend.getInstance().runAction(getVdcActionType(), createVdcActionParameters(nic), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
                postOnSave();
            }
        }
    }, this);
}
#method_after
protected void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName(getName().getEntity());
    VnicProfileView profile = getProfile().getSelectedItem();
    nic.setVnicProfileId(profile.getId());
    nic.setNetworkName(profile.getNetworkName());
    nic.setLinked(getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(getNicType().getSelectedItem().getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged(getPlugged().getEntity());
    startProgress();
    Frontend.getInstance().runAction(getVdcActionType(), createVdcActionParameters(nic), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
                postOnSave();
            }
        }
    }, this);
}
#end_block

#method_before
protected void initProfiles() {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model1, Object result1) {
            getProfile().setItems((List<VnicProfileView>) result1);
            profileBehavior.initSelectedProfile(getProfile(), getNic());
            updateProfileChangability();
            // fetch completed
            okCommand.setIsExecutionAllowed(true);
        }
    };
    profileBehavior.initProfiles(hotUpdateSupported, getVm().getVdsGroupId(), dcId, _asyncQuery);
}
#method_after
protected void initProfiles() {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model1, Object result1) {
            getProfile().setItems((List<VnicProfileView>) result1);
            profileBehavior.initSelectedProfile(getProfile(), getNic());
            updateProfileChangability();
            // fetch completed
            okCommand.setIsExecutionAllowed(true);
            initSelectedType();
        }
    };
    profileBehavior.initProfiles(hotUpdateSupported, getVm().getVdsGroupId(), dcId, _asyncQuery);
}
#end_block

#method_before
@OnTimerMethodAnnotation("pmHealthCheck")
public synchronized void pmHealthCheck() {
    // skip PM health check if previous operation is not completed yet
    if (!active) {
        try {
            log.info("Power Management Health Check started.");
            active = true;
            List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
            for (VDS host : hosts) {
                if (host.isPmEnabled()) {
                    pmHealthCheck(host);
                }
            }
            log.info("Power Management Health Check completed.");
        } finally {
            active = false;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("pmHealthCheck")
public void pmHealthCheck() {
    // skip PM health check if previous operation is not completed yet
    if (lock.tryLock()) {
        try {
            log.info("Power Management Health Check started.");
            List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
            for (VDS host : hosts) {
                if (host.isPmEnabled()) {
                    pmHealthCheck(host);
                }
            }
            log.info("Power Management Health Check completed.");
        } finally {
            lock.unlock();
        }
    }
}
#end_block

#method_before
private void waitUntilFencingAllowed() {
    // wait the quiet time from engine start in which we skip fencing operations
    int secToWait = Config.<Integer>getValue(ConfigValues.DisableFenceAtStartupInSec) * 1000;
    ThreadUtils.sleep(secToWait);
}
#method_after
private void waitUntilFencingAllowed() {
    // wait the quiet time from engine start in which we skip fencing operations
    ThreadUtils.sleep(TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.DisableFenceAtStartupInSec)));
}
#end_block

#method_before
@OnTimerMethodAnnotation("backupCheck")
public synchronized void backupCheck() {
    // skip backup check if previous operation is not completed yet
    if (!active) {
        try {
            log.info("Backup check started.");
            active = true;
            doBackupCheck();
            log.info("Backup check completed.");
        } finally {
            active = false;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("backupCheck")
public void backupCheck() {
    // skip backup check if previous operation is not completed yet
    if (lock.tryLock()) {
        try {
            log.info("Backup check started.");
            doBackupCheck();
            log.info("Backup check completed.");
        } finally {
            lock.unlock();
        }
    }
}
#end_block

#method_before
public void doImport(VM vm) {
    if (!Config.<Boolean>getValue(ConfigValues.AutoImportHostedEngine, vdsGroupDAO.get(vm.getVdsGroupId()).getCompatibilityVersion().getValue())) {
        return;
    }
    VdcReturnValueBase heVmImported;
    // get the special sd of hosted engine
    StorageDomain sd = getHEStorageDomain(vm);
    // no point in trying this without the SD
    if (sd != null && (sd.getStatus() == StorageDomainStatus.Active)) {
        log.info("Try to import the Hosted Engine VM '{}'", vm);
        if (vmStaticDAO.get(vm.getId()) == null || removedHEVM(vm)) {
            heVmImported = importHEVM(vm, sd);
            if (heVmImported.getSucceeded()) {
                log.info("Successfully imported the Hosted Engine VM");
                auditLogDirector.log(new AuditLogableBase(), AuditLogType.HOSTED_ENGINE_VM_IMPORT_SUCCEEDED);
            } else {
                log.error("Failed importing the Hosted Engine VM");
                auditLogDirector.log(new AuditLogableBase(), AuditLogType.HOSTED_ENGINE_VM_IMPORT_FAILED);
            }
        }
    } else {
        if (sd == null) {
            log.debug("Skip trying to import the Hosted Engine VM. Storage Domain '{}' doesn't exist", Config.<String>getValue(ConfigValues.HostedEngineStorageDomainName));
            auditLogDirector.log(new AuditLogableBase(), AuditLogType.HOSTED_ENGINE_SD_NOT_EXIT);
        } else {
            log.debug("Skip trying to import the Hosted Engine VM. Storage Domain '{}' isn't ACTIVE", sd);
            auditLogDirector.log(new AuditLogableBase(), AuditLogType.HOSTED_ENGINE_SD_NOT_ACTIVE);
        }
    }
}
#method_after
public void doImport(VM vm) {
    StoragePool storagePool = storagePoolDao.getForVdsGroup(vm.getVdsGroupId());
    VDSGroup vdsGroup = vdsGroupDAO.get(vm.getVdsGroupId());
    if (!importSupported(storagePool.getCompatibilityVersion(), vdsGroup.getCompatibilityVersion())) {
        return;
    }
    VdcReturnValueBase heVmImported;
    // get the special sd of hosted engine
    StorageDomain sd = getHEStorageDomain(vm);
    // no point in trying this without the SD
    if (sd != null && (sd.getStatus() == StorageDomainStatus.Active) && storagePool.getStatus() == StoragePoolStatus.Up) {
        log.info("Try to import the Hosted Engine VM '{}'", vm);
        if (vmStaticDAO.get(vm.getId()) == null || removedHEVM(vm)) {
            heVmImported = importHEVM(vm, sd);
            if (heVmImported.getSucceeded()) {
                log.info("Successfully imported the Hosted Engine VM");
                auditLogDirector.log(new AuditLogableBase(), AuditLogType.HOSTED_ENGINE_VM_IMPORT_SUCCEEDED);
            } else {
                log.error("Failed importing the Hosted Engine VM");
                auditLogDirector.log(new AuditLogableBase(), AuditLogType.HOSTED_ENGINE_VM_IMPORT_FAILED);
            }
        }
    } else {
        if (sd == null) {
            log.debug("Skip trying to import the Hosted Engine VM. Storage Domain '{}' doesn't exist", Config.<String>getValue(ConfigValues.HostedEngineStorageDomainName));
            auditLogDirector.log(new AuditLogableBase(), AuditLogType.HOSTED_ENGINE_SD_NOT_EXIT);
        } else {
            log.debug("Skip trying to import the Hosted Engine VM. Storage Domain '{}' isn't ACTIVE", sd);
            auditLogDirector.log(new AuditLogableBase(), AuditLogType.HOSTED_ENGINE_SD_NOT_ACTIVE);
        }
    }
}
#end_block

#method_before
public Map<Guid, HostNicVfsConfig> findHostNicVfsConfigs() {
    final List<HostNicVfsConfig> hostNicVfsConfigs = getBackendCollection(HostNicVfsConfig.class, VdcQueryType.GetAllVfsConfigByHostId, new IdQueryParameters(asGuid(hostId)));
    return hostNicVfsConfigs.stream().collect(Collectors.toMap(HostNicVfsConfig::getNicId, x -> x));
}
#method_after
public Map<Guid, HostNicVfsConfig> findHostNicVfsConfigs() {
    final List<HostNicVfsConfig> hostNicVfsConfigs = getBackendCollection(HostNicVfsConfig.class, VdcQueryType.GetAllVfsConfigByHostId, new IdQueryParameters(asGuid(hostId)));
    return hostNicVfsConfigs.stream().collect(toMap(HostNicVfsConfig::getNicId, x -> x));
}
#end_block

#method_before
// Gets the ID of the CPU. If the CPU is IBM Power 8, allow both
// "IBM POWER 8" and "IBM POWER8". The latter is more correct,
// but the former is allowed for backwards compatibility. See:
private static String getCpuId(Cluster model) {
    String cpuId = model.getCpu().getId();
    if (cpuId.equals("IBM POWER 8")) {
        cpuId = "IBM POWER8";
    }
    if (cpuId.equals("IBM POWER 8E")) {
        cpuId = "IBM POWER8E";
    }
    return cpuId;
}
#method_after
// Gets the ID of the CPU. If the CPU is IBM Power 8, allow both
// "IBM POWER 8" and "IBM POWER8". The latter is more correct,
// but the former is allowed for backwards compatibility. See:
private static String getCpuId(Cluster model) {
    String cpuId = model.getCpu().getId();
    if (cpuId.equals("IBM POWER 8")) {
        cpuId = "IBM POWER8";
    }
    if (cpuId.equals("IBM POWER 8 v1.0")) {
        cpuId = "IBM POWER8 v1.0";
    }
    return cpuId;
}
#end_block

#method_before
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getVdsGroupId(), getParameters().getVmStaticData().getVdsGroupId())) {
        List<Network> networks = getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getVdsGroupId());
        List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFound = networks.stream().allMatch(n -> ObjectUtils.equals(n.getId(), network.getId()));
            // if network not exists in cluster we remove the network from the interface
            if (!networkFound) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
}
#method_after
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getVdsGroupId(), getParameters().getVmStaticData().getVdsGroupId())) {
        List<Network> networks = getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getVdsGroupId());
        List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFound = networks.stream().anyMatch(n -> ObjectUtils.equals(n.getId(), network.getId()));
            // if network not exists in cluster we remove the network from the interface
            if (!networkFound) {
                iface.setVnicProfileId(null);
                getVmNicDao().update(iface);
            }
        }
    }
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    VmNumaNodeDao dao = DbFacade.getInstance().getVmNumaNodeDao();
    List<VmNumaNode> addList = new ArrayList<>();
    List<VmNumaNode> oldList = dao.getAllVmNumaNodeByVmId(getVmId());
    Map<Guid, VmNumaNode> removeMap = new HashMap<>();
    for (VmNumaNode node : oldList) {
        removeMap.put(node.getId(), node);
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    List<VmNumaNode> updateList = new ArrayList<>();
    if (newList != null) {
        for (VmNumaNode node : newList) {
            // no id means new entity
            if (node.getId() == null) {
                addList.add(node);
            } else {
                updateList.add(node);
            }
        }
    }
    for (VmNumaNode vmNumaNode : updateList) {
        removeMap.remove(vmNumaNode.getId());
    }
    VmNumaNodeOperationParameters params;
    if (!removeMap.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), new ArrayList<>(removeMap.values()));
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.RemoveVmNumaNodes, params));
    }
    if (!updateList.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), updateList);
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.UpdateVmNumaNodes, params));
    }
    if (!addList.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), addList);
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params));
    }
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(VdcActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
private void doFetchPrincipalRecord(ExtMap input, ExtMap output) throws SQLException, IOException {
    int flags = input.get(Authz.InvokeKeys.QUERY_FLAGS, Integer.class, 0);
    Collection<ExtMap> principals = authorization.getResults(Formatter.format("{} = {}", Schema.SEARCH_KEYS.get(Authz.PrincipalRecord.NAME), Formatter.escapeString(input.containsKey(Authz.InvokeKeys.PRINCIPAL) ? input.get(Authz.InvokeKeys.PRINCIPAL, String.class) : input.get(Authn.InvokeKeys.AUTH_RECORD, ExtMap.class).get(Authn.AuthRecord.PRINCIPAL, String.class))), new ExtMap().mput(Global.SearchContext.IS_PRINCIPAL, true).mput(Global.SearchContext.WITH_GROUPS, (flags & Authz.QueryFlags.RESOLVE_GROUPS) != 0).mput(Global.SearchContext.RECURSIVE, (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0).mput(Global.SearchContext.PAGE_SIZE, 1).mput(Global.SearchContext.ALL_ATTRIBUTES, false));
    output.put(Authz.InvokeKeys.PRINCIPAL_RECORD, principals.size() > 0 ? principals.iterator().next() : null);
    ExtMap principalRecord = output.get(Authz.InvokeKeys.PRINCIPAL_RECORD);
    if (principalRecord != null && (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0) {
        Set<String> searchedGroups = new HashSet<>();
        resolveNestedGroups(principalRecord.<List>get(Authz.PrincipalRecord.GROUPS), searchedGroups);
    }
    output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    output.put(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
}
#method_after
private void doFetchPrincipalRecord(ExtMap input, ExtMap output) throws SQLException, IOException {
    int flags = input.get(Authz.InvokeKeys.QUERY_FLAGS, Integer.class, 0);
    Collection<ExtMap> principals = authorization.getResults(Formatter.format("{} = {}", Schema.SEARCH_KEYS.get(Authz.PrincipalRecord.NAME), Formatter.escapeString(input.containsKey(Authz.InvokeKeys.PRINCIPAL) ? input.get(Authz.InvokeKeys.PRINCIPAL, String.class) : input.get(Authn.InvokeKeys.AUTH_RECORD, ExtMap.class).get(Authn.AuthRecord.PRINCIPAL, String.class))), new ExtMap().mput(Global.SearchContext.IS_PRINCIPAL, true).mput(Global.SearchContext.WITH_GROUPS, (flags & Authz.QueryFlags.RESOLVE_GROUPS) != 0).mput(Global.SearchContext.RECURSIVE, (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0).mput(Global.SearchContext.PAGE_SIZE, 1).mput(Global.SearchContext.ALL_ATTRIBUTES, false));
    output.put(Authz.InvokeKeys.PRINCIPAL_RECORD, principals.size() > 0 ? principals.iterator().next() : null);
    ExtMap principalRecord = output.get(Authz.InvokeKeys.PRINCIPAL_RECORD);
    if (principalRecord != null && (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0) {
        resolveNestedGroups(principalRecord.<List<ExtMap>>get(Authz.PrincipalRecord.GROUPS), new HashSet<String>());
    }
    output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    output.put(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
}
#end_block

#method_before
private void resolveNestedGroups(List<ExtMap> groupsToResolve, Set<String> resolvedGroups) throws IOException, SQLException {
    if (groupsToResolve != null) {
        for (ExtMap groupRecord : groupsToResolve) {
            if (!resolvedGroups.contains(groupRecord.<String>get(Authz.GroupRecord.ID))) {
                resolvedGroups.add(groupRecord.<String>get(Authz.GroupRecord.ID));
                groupRecord.put(Authz.GroupRecord.GROUPS, getGroupMembers(groupRecord));
                resolveNestedGroups(groupRecord.<List>get(Authz.PrincipalRecord.GROUPS), resolvedGroups);
            }
        }
    }
}
#method_after
private void resolveNestedGroups(List<ExtMap> groupsToResolve, Set<String> resolvedGroups) throws IOException, SQLException {
    if (groupsToResolve != null) {
        for (ExtMap groupRecord : groupsToResolve) {
            if (!resolvedGroups.contains(groupRecord.<String>get(Authz.GroupRecord.ID))) {
                resolvedGroups.add(groupRecord.<String>get(Authz.GroupRecord.ID));
                groupRecord.put(Authz.GroupRecord.GROUPS, getGroupMembers(groupRecord));
                resolveNestedGroups(groupRecord.<List<ExtMap>>get(Authz.PrincipalRecord.GROUPS), resolvedGroups);
            }
        }
    }
}
#end_block

#method_before
private void sleepOnReboot(final VDSStatus status) {
    long sleepInterval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.ServerRebootTimeout));
    log.info("Waiting {} seconds, for server to finish reboot process.", sleepInterval);
    ThreadUtils.sleep(sleepInterval);
    setVdsStatus(status);
}
#method_after
private void sleepOnReboot(final VDSStatus status) {
    int sleepTimeInSec = Config.<Integer>getValue(ConfigValues.ServerRebootTimeout);
    log.info("Waiting {} seconds, for server to finish reboot process.", sleepTimeInSec);
    ThreadUtils.sleep(TimeUnit.SECONDS.toMillis(sleepTimeInSec));
    setVdsStatus(status);
}
#end_block

