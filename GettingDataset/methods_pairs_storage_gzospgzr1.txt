9
#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.THREE_FINGER_GESTURE), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_ROTATION_SUGGESTIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.VOLUME_HUSH_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.OMNI_USE_BOTTOM_GESTURE_NAVIGATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.THREE_FINGER_GESTURE), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources resources = mContext.getResources();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Three Finger Gesture
        boolean threeFingerGesture = Settings.System.getIntForUser(resolver, Settings.System.THREE_FINGER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        enableSwipeThreeFingerGesture(threeFingerGesture);
        final boolean defaultToNavigationBar = resources.getBoolean(com.android.internal.R.bool.config_defaultToNavigationBar);
        final boolean navBarEnabled = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_ENABLED, defaultToNavigationBar ? 1 : 0, UserHandle.USER_CURRENT) == 1;
        final boolean buttonBrightnessEnabled = Settings.System.getIntForUser(resolver, Settings.System.BUTTON_BRIGHTNESS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        if (navBarEnabled != mNavBarEnabled) {
            mNavBarEnabled = navBarEnabled;
            if (mDeviceHardwareKeys != 0) {
                SystemProperties.set("qemu.hw.mainkeys", mNavBarEnabled ? "0" : "1");
                if (!mNavBarEnabled && buttonBrightnessEnabled) {
                    Settings.System.putInt(resolver, Settings.System.BUTTON_BRIGHTNESS_ENABLED, 0);
                }
            }
        }
        readConfigurationDependentBehaviors();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources resources = mContext.getResources();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mSystemNavigationKeysEnabled = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        mRingerToggleChord = Settings.Secure.getIntForUser(resolver, Settings.Secure.VOLUME_HUSH_GESTURE, VOLUME_HUSH_OFF, UserHandle.USER_CURRENT);
        if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_volumeHushGestureEnabled)) {
            mRingerToggleChord = Settings.Secure.VOLUME_HUSH_OFF;
        }
        // Configure rotation suggestions.
        int showRotationSuggestions = Settings.Secure.getIntForUser(resolver, Settings.Secure.SHOW_ROTATION_SUGGESTIONS, Settings.Secure.SHOW_ROTATION_SUGGESTIONS_DEFAULT, UserHandle.USER_CURRENT);
        if (mShowRotationSuggestions != showRotationSuggestions) {
            mShowRotationSuggestions = showRotationSuggestions;
            // Enable, disable the orientation listener
            updateOrientationListenerLp();
        }
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Three Finger Gesture
        boolean threeFingerGesture = Settings.System.getIntForUser(resolver, Settings.System.THREE_FINGER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        enableSwipeThreeFingerGesture(threeFingerGesture);
        final boolean defaultToNavigationBar = resources.getBoolean(com.android.internal.R.bool.config_defaultToNavigationBar);
        final boolean navBarEnabled = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_ENABLED, defaultToNavigationBar ? 1 : 0, UserHandle.USER_CURRENT) == 1;
        final boolean buttonBrightnessEnabled = Settings.System.getIntForUser(resolver, Settings.System.BUTTON_BRIGHTNESS_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        if (navBarEnabled != mNavBarEnabled) {
            mNavBarEnabled = navBarEnabled;
            if (mDeviceHardwareKeys != 0) {
                SystemProperties.set("qemu.hw.mainkeys", mNavBarEnabled ? "0" : "1");
                if (!mNavBarEnabled && buttonBrightnessEnabled) {
                    Settings.System.putInt(resolver, Settings.System.BUTTON_BRIGHTNESS_ENABLED, 0);
                }
            }
        }
        readConfigurationDependentBehaviors();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
        mUseGestureButton = Settings.System.getIntForUser(resolver, Settings.System.OMNI_USE_BOTTOM_GESTURE_NAVIGATION, 0, UserHandle.USER_CURRENT) != 0;
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
    if (mUseGestureButton && !mGestureButtonRegistered) {
        mGestureButton = new GestureButton(mContext, this);
        mWindowManagerFuncs.registerPointerEventListener(mGestureButton);
        mGestureButtonRegistered = true;
    }
    if (mGestureButtonRegistered && !mUseGestureButton) {
        mWindowManagerFuncs.unregisterPointerEventListener(mGestureButton);
        mGestureButtonRegistered = false;
    }
}
#end_block

#method_before
private void preloadRecentApps() {
    mPreloadedRecentApps = true;
    StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
    if (statusbar != null) {
        statusbar.preloadRecentApps();
    }
}
#method_after
protected void preloadRecentApps() {
    mPreloadedRecentApps = true;
    StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
    if (statusbar != null) {
        statusbar.preloadRecentApps();
    }
}
#end_block

#method_before
private void cancelPreloadRecentApps() {
    if (mPreloadedRecentApps) {
        mPreloadedRecentApps = false;
        StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
        if (statusbar != null) {
            statusbar.cancelPreloadRecentApps();
        }
    }
}
#method_after
protected void cancelPreloadRecentApps() {
    if (mPreloadedRecentApps) {
        mPreloadedRecentApps = false;
        StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
        if (statusbar != null) {
            statusbar.cancelPreloadRecentApps();
        }
    }
}
#end_block

#method_before
private void toggleRecentApps() {
    // preloading no longer needs to be canceled
    mPreloadedRecentApps = false;
    StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
    if (statusbar != null) {
        statusbar.toggleRecentApps();
    }
}
#method_after
protected void toggleRecentApps() {
    // preloading no longer needs to be canceled
    mPreloadedRecentApps = false;
    StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
    if (statusbar != null) {
        statusbar.toggleRecentApps();
    }
}
#end_block

#method_before
void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) {
    // Abort possibly stuck animations.
    mHandler.post(mWindowManagerFuncs::triggerAnimationFailsafe);
    if (respectKeyguard) {
        if (isKeyguardShowingAndNotOccluded()) {
            // don't launch home if keyguard showing
            return;
        } else if (mKeyguardOccluded && mKeyguardDelegate.isShowing()) {
            mKeyguardDelegate.dismiss(new KeyguardDismissCallback() {

                @Override
                public void onDismissSucceeded() throws RemoteException {
                    mHandler.post(() -> {
                        startDockOrHome(true, /*fromHomeKey*/
                        awakenFromDreams);
                    });
                }
            }, null);
            return;
        } else if (!mKeyguardOccluded && mKeyguardDelegate.isInputRestricted()) {
            // when in keyguard restricted mode, must first verify unlock
            // before launching home
            mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {

                @Override
                public void onKeyguardExitResult(boolean success) {
                    if (success) {
                        startDockOrHome(true, /*fromHomeKey*/
                        awakenFromDreams);
                    }
                }
            });
            return;
        }
    }
    // no keyguard stuff to worry about, just launch home!
    if (mRecentsVisible) {
        try {
            ActivityManager.getService().stopAppSwitches();
        } catch (RemoteException e) {
        }
        // Hide Recents and notify it to launch Home
        if (awakenFromDreams) {
            awakenDreams();
        }
        hideRecentApps(false, true);
    } else {
        // Otherwise, just launch Home
        startDockOrHome(true, /*fromHomeKey*/
        awakenFromDreams);
    }
}
#method_after
void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) {
    // Abort possibly stuck animations.
    mHandler.post(mWindowManagerFuncs::triggerAnimationFailsafe);
    if (respectKeyguard) {
        if (isKeyguardShowingAndNotOccluded()) {
            // don't launch home if keyguard showing
            return;
        }
        if (!mKeyguardOccluded && mKeyguardDelegate.isInputRestricted()) {
            // when in keyguard restricted mode, must first verify unlock
            // before launching home
            mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() {

                @Override
                public void onKeyguardExitResult(boolean success) {
                    if (success) {
                        startDockOrHome(true, /*fromHomeKey*/
                        awakenFromDreams);
                    }
                }
            });
            return;
        }
    }
    // no keyguard stuff to worry about, just launch home!
    if (mRecentsVisible) {
        try {
            ActivityManager.getService().stopAppSwitches();
        } catch (RemoteException e) {
        }
        // Hide Recents and notify it to launch Home
        if (awakenFromDreams) {
            awakenDreams();
        }
        hideRecentApps(false, true);
    } else {
        // Otherwise, just launch Home
        startDockOrHome(true, /*fromHomeKey*/
        awakenFromDreams);
    }
}
#end_block

#method_before
@Override
public void beginLayoutLw(DisplayFrames displayFrames, int uiMode) {
    displayFrames.onBeginLayout();
    // TODO(multi-display): This doesn't seem right...Maybe only apply to default display?
    mSystemGestures.screenWidth = displayFrames.mUnrestricted.width();
    mSystemGestures.screenHeight = displayFrames.mUnrestricted.height();
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    vf.set(displayFrames.mDock);
    of.set(displayFrames.mDock);
    df.set(displayFrames.mDock);
    pf.set(displayFrames.mDock);
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (displayFrames.mDisplayId == DEFAULT_DISPLAY) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mKeyguardOccluded;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        boolean statusBarExpandedNotKeyguard = !isKeyguardShowing && mStatusBar != null && mStatusBar.getAttrs().height == MATCH_PARENT && mStatusBar.getAttrs().width == MATCH_PARENT;
        // nav bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mInputConsumer != null) {
                mHandler.sendMessage(mHandler.obtainMessage(MSG_DISPOSE_INPUT_CONSUMER, mInputConsumer));
                mInputConsumer = null;
            }
        } else if (mInputConsumer == null && mStatusBar != null && canHideNavigationBar()) {
            mInputConsumer = mWindowManagerFuncs.createInputConsumer(mHandler.getLooper(), INPUT_CONSUMER_NAVIGATION, (channel, looper) -> new HideNavInputEventReceiver(channel, looper));
            // As long as mInputConsumer is active, hover events are not dispatched to the app
            // and the pointer icon is likely to become stale. Hide it to avoid confusion.
            InputManager.getInstance().setPointerIconType(PointerIcon.TYPE_NULL);
        }
        // For purposes of positioning and showing the nav bar, if we have decided that it can't
        // be hidden (because of the screen aspect ratio), then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = layoutNavigationBar(displayFrames, uiMode, dcf, navVisible, navTranslucent, navAllowedHidden, statusBarExpandedNotKeyguard);
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "mDock rect:" + displayFrames.mDock);
        updateSysUiVisibility |= layoutStatusBar(displayFrames, pf, df, of, vf, dcf, sysui, isKeyguardShowing);
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
    layoutScreenDecorWindows(displayFrames, pf, df, dcf);
    if (displayFrames.mDisplayCutoutSafe.top > displayFrames.mUnrestricted.top) {
        // Make sure that the zone we're avoiding for the cutout is at least as tall as the
        // status bar; otherwise fullscreen apps will end up cutting halfway into the status
        // bar.
        displayFrames.mDisplayCutoutSafe.top = Math.max(displayFrames.mDisplayCutoutSafe.top, displayFrames.mStable.top);
    }
}
#method_after
@Override
public void beginLayoutLw(DisplayFrames displayFrames, int uiMode) {
    displayFrames.onBeginLayout();
    // TODO(multi-display): This doesn't seem right...Maybe only apply to default display?
    mSystemGestures.screenWidth = displayFrames.mUnrestricted.width();
    mSystemGestures.screenHeight = displayFrames.mUnrestricted.height();
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    final int displayHeight = displayFrames.mDisplayHeight;
    final int displayWidth = displayFrames.mDisplayWidth;
    final int displayRotation = displayFrames.mRotation;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    vf.set(displayFrames.mDock);
    of.set(displayFrames.mDock);
    df.set(displayFrames.mDock);
    pf.set(displayFrames.mDock);
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (displayFrames.mDisplayId == DEFAULT_DISPLAY) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mKeyguardOccluded;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        boolean statusBarExpandedNotKeyguard = !isKeyguardShowing && mStatusBar != null && (mStatusBar.getAttrs().privateFlags & PRIVATE_FLAG_STATUS_BAR_EXPANDED) != 0;
        // nav bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mInputConsumer != null) {
                mHandler.sendMessage(mHandler.obtainMessage(MSG_DISPOSE_INPUT_CONSUMER, mInputConsumer));
                mInputConsumer = null;
            }
        } else if (mInputConsumer == null && mStatusBar != null && canHideNavigationBar()) {
            mInputConsumer = mWindowManagerFuncs.createInputConsumer(mHandler.getLooper(), INPUT_CONSUMER_NAVIGATION, (channel, looper) -> new HideNavInputEventReceiver(channel, looper));
            // As long as mInputConsumer is active, hover events are not dispatched to the app
            // and the pointer icon is likely to become stale. Hide it to avoid confusion.
            InputManager.getInstance().setPointerIconType(PointerIcon.TYPE_NULL);
        }
        // For purposes of positioning and showing the nav bar, if we have decided that it can't
        // be hidden (because of the screen aspect ratio), then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = layoutNavigationBar(displayFrames, uiMode, dcf, navVisible, navTranslucent, navAllowedHidden, statusBarExpandedNotKeyguard);
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "mDock rect:" + displayFrames.mDock);
        updateSysUiVisibility |= layoutStatusBar(displayFrames, pf, df, of, vf, dcf, sysui, isKeyguardShowing);
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
        if (!mHasNavigationBar && mUseGestureButton && mGestureButton != null) {
            mGestureButton.navigationBarPosition(displayWidth, displayHeight, displayRotation);
        }
    }
    layoutScreenDecorWindows(displayFrames, pf, df, dcf);
    if (displayFrames.mDisplayCutoutSafe.top > displayFrames.mUnrestricted.top) {
        // Make sure that the zone we're avoiding for the cutout is at least as tall as the
        // status bar; otherwise fullscreen apps will end up cutting halfway into the status
        // bar.
        displayFrames.mDisplayCutoutSafe.top = Math.max(displayFrames.mDisplayCutoutSafe.top, displayFrames.mStable.top);
    }
}
#end_block

#method_before
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached, WindowState imeTarget) {
    final boolean affectsSystemUi = win.canAffectSystemUiFlags();
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": affectsSystemUi=" + affectsSystemUi);
    applyKeyguardPolicyLw(win, imeTarget);
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final int windowingMode = win.getWindowingMode();
    final boolean inFullScreenOrSplitScreenSecondaryWindowingMode = windowingMode == WINDOWING_MODE_FULLSCREEN || windowingMode == WINDOWING_MODE_SPLIT_SCREEN_SECONDARY;
    if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            mForceStatusBar = true;
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (attrs.isFullscreen() && inFullScreenOrSplitScreenSecondaryWindowingMode) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
        }
    }
    // Voice interaction overrides both top fullscreen and top docked.
    if (affectsSystemUi && win.getAttrs().type == TYPE_VOICE_INTERACTION) {
        if (mTopFullscreenOpaqueWindowState == null) {
            mTopFullscreenOpaqueWindowState = win;
            if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                mTopFullscreenOpaqueOrDimmingWindowState = win;
            }
        }
        if (mTopDockedOpaqueWindowState == null) {
            mTopDockedOpaqueWindowState = win;
            if (mTopDockedOpaqueOrDimmingWindowState == null) {
                mTopDockedOpaqueOrDimmingWindowState = win;
            }
        }
    }
    // Keep track of the window if it's dimming but not necessarily fullscreen.
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && affectsSystemUi && win.isDimming() && inFullScreenOrSplitScreenSecondaryWindowingMode) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
    // stack can control View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.
    if (mTopDockedOpaqueWindowState == null && affectsSystemUi && appWindow && attached == null && attrs.isFullscreen() && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {
        mTopDockedOpaqueWindowState = win;
        if (mTopDockedOpaqueOrDimmingWindowState == null) {
            mTopDockedOpaqueOrDimmingWindowState = win;
        }
    }
    // docked stack.
    if (mTopDockedOpaqueOrDimmingWindowState == null && affectsSystemUi && win.isDimming() && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {
        mTopDockedOpaqueOrDimmingWindowState = win;
    }
    // Take note if a window wants to acquire a sleep token.
    if (win.isVisibleLw() && (attrs.privateFlags & PRIVATE_FLAG_ACQUIRES_SLEEP_TOKEN) != 0 && win.canAcquireSleepToken()) {
        mWindowSleepTokenNeeded = true;
    }
}
#method_after
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached, WindowState imeTarget) {
    final boolean affectsSystemUi = win.canAffectSystemUiFlags();
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": affectsSystemUi=" + affectsSystemUi);
    applyKeyguardPolicyLw(win, imeTarget);
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final int windowingMode = win.getWindowingMode();
    final boolean inFullScreenOrSplitScreenSecondaryWindowingMode = windowingMode == WINDOWING_MODE_FULLSCREEN || windowingMode == WINDOWING_MODE_SPLIT_SCREEN_SECONDARY;
    if (mTopFullscreenOpaqueWindowState == null && affectsSystemUi) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            mForceStatusBar = true;
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (attrs.isFullscreen() && inFullScreenOrSplitScreenSecondaryWindowingMode) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
        }
    }
    // Voice interaction overrides both top fullscreen and top docked.
    if (affectsSystemUi && win.getAttrs().type == TYPE_VOICE_INTERACTION) {
        if (mTopFullscreenOpaqueWindowState == null) {
            mTopFullscreenOpaqueWindowState = win;
            if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                mTopFullscreenOpaqueOrDimmingWindowState = win;
            }
        }
        if (mTopDockedOpaqueWindowState == null) {
            mTopDockedOpaqueWindowState = win;
            if (mTopDockedOpaqueOrDimmingWindowState == null) {
                mTopDockedOpaqueOrDimmingWindowState = win;
            }
        }
    }
    // Keep track of the window if it's dimming but not necessarily fullscreen.
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && affectsSystemUi && win.isDimming() && inFullScreenOrSplitScreenSecondaryWindowingMode) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
    // stack can control View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.
    if (mTopDockedOpaqueWindowState == null && affectsSystemUi && appWindow && attached == null && attrs.isFullscreen() && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {
        mTopDockedOpaqueWindowState = win;
        if (mTopDockedOpaqueOrDimmingWindowState == null) {
            mTopDockedOpaqueOrDimmingWindowState = win;
        }
    }
    // docked stack.
    if (mTopDockedOpaqueOrDimmingWindowState == null && affectsSystemUi && win.isDimming() && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_PRIMARY) {
        mTopDockedOpaqueOrDimmingWindowState = win;
    }
    // Take note if a window wants to acquire a sleep token.
    if ((attrs.privateFlags & PRIVATE_FLAG_ACQUIRES_SLEEP_TOKEN) != 0 && win.canAcquireSleepToken()) {
        mWindowSleepTokenNeeded = true;
    }
}
#end_block

#method_before
@Override
public int finishPostLayoutPolicyLw() {
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = isKeyguardShowingAndNotOccluded();
        if (mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = false;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 0, 1).sendToTarget();
        }
    } else {
        if (!mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = true;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 1, 1).sendToTarget();
        }
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        boolean shouldBeTransparent = mForceStatusBarTransparent && !mForceStatusBar && !mForceStatusBarFromKeyguard;
        if (!shouldBeTransparent) {
            mStatusBarController.setShowTransparent(false);
        } else if (!mStatusBar.isVisibleLw()) {
            mStatusBarController.setShowTransparent(true);
        }
        WindowManager.LayoutParams statusBarAttrs = mStatusBar.getAttrs();
        boolean statusBarExpanded = statusBarAttrs.height == MATCH_PARENT && statusBarAttrs.width == MATCH_PARENT;
        boolean topAppHidesStatusBar = topAppHidesStatusBar();
        if (mForceStatusBar || mForceStatusBarFromKeyguard || mForceStatusBarTransparent || statusBarExpanded) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if ((mForceStatusBarFromKeyguard || statusBarExpanded) && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            topIsFullscreen = topAppHidesStatusBar;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen && !mWindowManagerInternal.isStackVisible(WINDOWING_MODE_FREEFORM) && !mWindowManagerInternal.isStackVisible(WINDOWING_MODE_SPLIT_SCREEN_PRIMARY)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
                topAppHidesStatusBar = false;
            }
        }
        mStatusBarController.setTopAppHidesStatusBar(topAppHidesStatusBar);
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    if (mShowingDream != mLastShowingDream) {
        mLastShowingDream = mShowingDream;
        mWindowManagerFuncs.notifyShowingDreamChanged();
    }
    updateWindowSleepToken();
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
#method_after
@Override
public int finishPostLayoutPolicyLw() {
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = isKeyguardShowingAndNotOccluded();
        if (mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = false;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 0, 1).sendToTarget();
        }
    } else {
        if (!mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = true;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 1, 1).sendToTarget();
        }
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        boolean shouldBeTransparent = mForceStatusBarTransparent && !mForceStatusBar && !mForceStatusBarFromKeyguard;
        if (!shouldBeTransparent) {
            mStatusBarController.setShowTransparent(false);
        } else if (!mStatusBar.isVisibleLw()) {
            mStatusBarController.setShowTransparent(true);
        }
        boolean statusBarExpanded = (mStatusBar.getAttrs().privateFlags & PRIVATE_FLAG_STATUS_BAR_EXPANDED) != 0;
        boolean topAppHidesStatusBar = topAppHidesStatusBar();
        if (mForceStatusBar || mForceStatusBarFromKeyguard || mForceStatusBarTransparent || statusBarExpanded) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if ((mForceStatusBarFromKeyguard || statusBarExpanded) && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            topIsFullscreen = topAppHidesStatusBar;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen && !mWindowManagerInternal.isStackVisible(WINDOWING_MODE_FREEFORM) && !mWindowManagerInternal.isStackVisible(WINDOWING_MODE_SPLIT_SCREEN_PRIMARY)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
                topAppHidesStatusBar = false;
            }
        }
        mStatusBarController.setTopAppHidesStatusBar(topAppHidesStatusBar);
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    if (mShowingDream != mLastShowingDream) {
        mLastShowingDream = mShowingDream;
        mWindowManagerFuncs.notifyShowingDreamChanged();
    }
    updateWindowSleepToken();
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
#end_block

