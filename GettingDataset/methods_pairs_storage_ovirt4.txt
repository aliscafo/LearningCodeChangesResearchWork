330
#method_before
private String getIpv4AddressOfNetwork(String networkName) {
    return resolveHostManagementNetworkAddress(networkName, VdsNetworkInterface::getIpv4Address);
}
#method_after
String getIpv4AddressOfNetwork(String networkName) {
    return resolveHostNetworkAddress(networkName, VdsNetworkInterface::getIpv4Address);
}
#end_block

#method_before
private String getIpv6AddressOfNetwork(String networkName) {
    return resolveHostManagementNetworkAddress(networkName, VdsNetworkInterface::getIpv6Address);
}
#method_after
String getIpv6AddressOfNetwork(String networkName) {
    return resolveHostNetworkAddress(networkName, VdsNetworkInterface::getIpv6Address);
}
#end_block

#method_before
public boolean awaitVdsmResponse() {
    HostSetupNetworkPoller poller = new HostSetupNetworkPoller();
    boolean success = poller.pollWithDefaultTimeout(host.getId());
    if (success) {
        log.info("Engine managed to communicate with VDSM agent on host '{}' ('{}')", host.getName(), host.getId());
        return true;
    } else {
        // TODO MMUCHA: Dear code reviewer! Warning level, right? Please advise.
        log.warn("Engine failed to communicate with VDSM agent on host '{}' ('{}')", host.getName(), host.getId());
        return false;
    }
}
#method_after
public boolean awaitVdsmResponse() {
    final int checks = VDSM_RESPONSIVENESS_PERIOD_IN_SECONDS / Config.<Integer>getValue(ConfigValues.SetupNetworksPollingTimeout);
    HostSetupNetworkPoller poller = new HostSetupNetworkPoller();
    for (int i = 0; i < checks; i++) {
        if (poller.poll(host.getId())) {
            log.info("Engine managed to communicate with VDSM agent on host '{}' ('{}')", host.getName(), host.getId());
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void executeCommand() {
    boolean mergeSucceeded = false;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.Merge, createVDSParameters());
        if (vdsReturnValue.getSucceeded()) {
            Guid jobId = (Guid) vdsReturnValue.getReturnValue();
            persistBlockJobPlaceholder(jobId);
            getParameters().setVmJobId(jobId);
            persistCommand(getParameters().getParentCommand(), true);
            log.debug("Merge started successfully");
            mergeSucceeded = true;
        } else {
            log.error("Failed to start Merge on VDS");
        }
    } catch (EngineException e) {
        log.error("Engine exception thrown while sending merge command", e);
        if (e.getErrorCode() == EngineError.imageErr || e.getErrorCode() == EngineError.mergeErr) {
            // In this case, we are not certain about whether merge started or not. We assume it started
            // and continue merge flow
            mergeSucceeded = true;
        }
    } finally {
        if (mergeSucceeded) {
            // setSucceeded to indicate executeCommand success; doPolling will check commandStatus
            setSucceeded(true);
        } else {
            setCommandStatus(CommandStatus.FAILED);
        }
    }
}
#method_after
@Override
public void executeCommand() {
    boolean mergeRunning = false;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.Merge, createVDSParameters());
        if (vdsReturnValue.getSucceeded()) {
            Guid jobId = (Guid) vdsReturnValue.getReturnValue();
            persistBlockJobPlaceholder(jobId);
            getParameters().setVmJobId(jobId);
            persistCommand(getParameters().getParentCommand(), true);
            log.debug("Merge started successfully");
            mergeRunning = true;
        } else {
            log.error("Failed to start Merge on VDS");
        }
    } catch (EngineException e) {
        log.error("Engine exception thrown while sending merge command", e);
        if (e.getErrorCode() == EngineError.imageErr || e.getErrorCode() == EngineError.mergeErr) {
            // In this case, we are not certain whether merge is currently running or
            // whether one of the relevant volumes already removed from the chain. In these cases,
            // we want to verify the current state; therefore, we consider the merge to be running.
            mergeRunning = true;
        }
    } finally {
        if (mergeRunning) {
            setSucceeded(true);
        } else {
            setCommandStatus(CommandStatus.FAILED);
        }
    }
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new MergeCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return Injector.injectMembers(new MergeCommandCallback());
}
#end_block

#method_before
private void createVMFromTemplate() {
    VmTemplate template = getSelectedItem();
    final List<UICommand> commands = new ArrayList<>();
    // $NON-NLS-1$
    commands.add(UICommand.createDefaultOkUiCommand("OnSaveVm", this));
    // $NON-NLS-1$
    commands.add(UICommand.createCancelUiCommand("Cancel", this));
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmTemplate withVmInit = (VmTemplate) result;
            setupNewVmModel(new UnitVmModel(new NewVmFromTemplateModelBehavior(withVmInit), TemplateListModel.this), withVmInit.getVmType(), getSystemTreeSelectedItem(), commands);
        }
    };
    AsyncDataProvider.getInstance().getTemplateById(getVmInitQuery, template.getId());
}
#method_after
private void createVMFromTemplate() {
    VmTemplate template = getSelectedItem();
    final List<UICommand> commands = new ArrayList<>();
    // $NON-NLS-1$
    commands.add(UICommand.createDefaultOkUiCommand("OnSaveVm", this));
    // $NON-NLS-1$
    commands.add(UICommand.createCancelUiCommand("Cancel", this));
    AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VmTemplate withVmInit = (VmTemplate) returnValue;
            setupNewVmModel(new UnitVmModel(new NewVmFromTemplateModelBehavior(withVmInit), TemplateListModel.this), withVmInit.getVmType(), getSystemTreeSelectedItem(), commands);
        }
    }), template.getId());
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#end_block

#method_before
private static VdsNetworkInterface resolveActiveNic(VDS host, String hostIp) {
    if (hostIp == null) {
        return null;
    }
    final String managementAddress = hostIp;
    VdsNetworkInterface activeIface = host.getInterfaces().stream().filter(new InterfaceByAddressPredicate(managementAddress)).findFirst().orElse(null);
    return activeIface;
}
#method_after
private static VdsNetworkInterface resolveActiveNic(VDS host, String hostIp) {
    if (hostIp == null) {
        return null;
    }
    VdsNetworkInterface activeIface = host.getInterfaces().stream().filter(new InterfaceByAddressPredicate(hostIp)).findFirst().orElse(null);
    return activeIface;
}
#end_block

#method_before
private static String findActiveBridge(String ipAddress, Map<String, Map<String, Object>> bridges) {
    String activeBridge = null;
    if (bridges != null) {
        for (Entry<String, Map<String, Object>> entry : bridges.entrySet()) {
            Map<String, Object> bridgeProperties = entry.getValue();
            String bridgeName = entry.getKey();
            if (bridgeProperties != null) {
                String bridgeIpv4Address = (String) bridgeProperties.get("addr");
                String bridgeIpv6Address = extractIpv6Address(getIpv6Address(bridgeProperties));
                // in case host is communicating with engine over a bridge
                if ((bridgeIpv4Address != null && bridgeIpv4Address.equals(ipAddress)) || (bridgeIpv6Address != null && bridgeIpv6Address.equals(ipAddress))) {
                    activeBridge = bridgeName;
                }
            }
        }
    }
    return activeBridge;
}
#method_after
private static String findActiveBridge(String ipAddress, Map<String, Map<String, Object>> bridges) {
    if (bridges != null) {
        final Predicate<String> ipAddressPredicate = new IpAddressPredicate(ipAddress);
        for (Entry<String, Map<String, Object>> entry : bridges.entrySet()) {
            Map<String, Object> bridgeProperties = entry.getValue();
            String bridgeName = entry.getKey();
            if (bridgeProperties != null) {
                String bridgeIpv4Address = (String) bridgeProperties.get("addr");
                String bridgeIpv6Address = extractIpv6Address(getIpv6Address(bridgeProperties));
                // in case host is communicating with engine over a bridge
                if (ipAddressPredicate.test(bridgeIpv4Address) || ipAddressPredicate.test(bridgeIpv6Address)) {
                    return bridgeName;
                }
            }
        }
    }
    return null;
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", interfaces.stream().map(VdsNetworkInterface::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
private static void addBootProtocol(Map<String, Object> nicProperties, VdsNetworkInterface iface) {
    if (nicProperties == null) {
        return;
    }
    final BootProtocolResolver resolver = getBootProtocolResolver();
    setBootProtocolAndGateway(resolver, new NoCfgIpv4InfoFetcher(nicProperties, iface.getIpv4Address()), iface::setIpv4BootProtocol, iface::setIpv4Gateway);
    setBootProtocolAndGateway(resolver, new NoCfgIpv6InfoFetcher(nicProperties, iface.getIpv6Address()), iface::setIpv6BootProtocol, iface::setIpv6Gateway);
}
#method_after
private static void addBootProtocol(Map<String, Object> nicProperties, VdsNetworkInterface iface) {
    if (nicProperties == null) {
        return;
    }
    setBootProtocolAndGateway(getIpv4BootProtocolResolver(), new NoCfgIpv4InfoFetcher(nicProperties, iface.getIpv4Address()), bootProtocol -> Ipv4BootProtocol.STATIC_IP == bootProtocol, iface::setIpv4BootProtocol, iface::setIpv4Gateway);
    setBootProtocolAndGateway(getIpv6BootProtocolResolver(), new NoCfgIpv6InfoFetcher(nicProperties, iface.getIpv6Address()), bootProtocol -> Ipv6BootProtocol.STATIC_IP == bootProtocol, iface::setIpv6BootProtocol, iface::setIpv6Gateway);
}
#end_block

#method_before
private static void setBootProtocolAndGateway(BootProtocolResolver bootProtocolResolver, IpInfoFetcher ipInfoFetcher, Consumer<Ipv4BootProtocol> bootProtocolSetter, Consumer<String> gatewaySetter) {
    final Ipv4BootProtocol bootProtocol = bootProtocolResolver.resolve(ipInfoFetcher);
    bootProtocolSetter.accept(bootProtocol);
    setGateway(bootProtocol, ipInfoFetcher, gatewaySetter);
}
#method_after
private static <T, F extends IpInfoFetcher> void setBootProtocolAndGateway(BootProtocolResolver<T, F> bootProtocolResolver, F infoFetcher, Predicate<T> bootProtocolStaticIpPredicate, Consumer<T> bootProtocolSetter, Consumer<String> gatewaySetter) {
    final T bootProtocol = bootProtocolResolver.resolve(infoFetcher);
    bootProtocolSetter.accept(bootProtocol);
    if (bootProtocolStaticIpPredicate.test(bootProtocol)) {
        String gateway = infoFetcher.fetchGateway();
        if (StringUtils.isNotEmpty(gateway)) {
            gatewaySetter.accept(gateway);
        }
    }
}
#end_block

#method_before
private String getMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        final String migrationDestinationIpv4Address = findMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv4Address);
        if (migrationDestinationIpv4Address != null) {
            return migrationDestinationIpv4Address;
        }
        final String migrationDestinationIpv6Address = findMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv6Address);
        if (migrationDestinationIpv6Address != null) {
            return migrationDestinationIpv6Address;
        }
    }
    return null;
}
#method_after
private String getMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        final String migrationDestinationIpv4Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv4Address);
        if (migrationDestinationIpv4Address != null) {
            return migrationDestinationIpv4Address;
        }
        final String migrationDestinationIpv6Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv6Address);
        if (migrationDestinationIpv6Address != null) {
            return migrationDestinationIpv6Address;
        }
    }
    return null;
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", interfaces.stream().map(VdsNetworkInterface::getName).collect(Collectors.joining(", ")));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", interfaces.stream().map(VdsNetworkInterface::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    log.info("Started HA reservation scoring method");
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    Map<Guid, Integer> hostsHaVmCount = new HashMap<Guid, Integer>();
    // If the vm is not HA or the cluster is not marked as HA Reservation set default score.
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(hosts.get(0).getVdsGroupId());
    if (!vm.isAutoStartup() || !vdsGroup.supportsHaReservation()) {
        fillDefaultScores(hosts, scores);
    } else {
        // Use a single call to the DB to retrieve all VM in the Cluster and map them by Host id
        Map<Guid, List<VM>> hostId2HaVmMapping = HaReservationHandling.mapHaVmToHostByCluster(vdsGroup.getId());
        int maxCount = 0;
        for (VDS host : hosts) {
            int count = 0;
            if (hostId2HaVmMapping.containsKey(host.getId())) {
                count = hostId2HaVmMapping.get(host.getId()).size();
            }
            maxCount = Math.max(maxCount, count);
            hostsHaVmCount.put(host.getId(), count);
        }
        // Fit count to scale of 0 to RATIO_FACTOR
        if (maxCount > 0) {
            for (VDS host : hosts) {
                int fittedCount = Math.round(hostsHaVmCount.get(host.getId()).floatValue() / maxCount * RATIO_FACTOR);
                hostsHaVmCount.put(host.getId(), fittedCount);
            }
        }
        // Get scale down param
        Integer scaleDownParameter = 1;
        if (parameters.get("ScaleDown") != null) {
            scaleDownParameter = Integer.parseInt(parameters.get("ScaleDown"));
        } else {
            scaleDownParameter = Config.<Integer>getValue(ConfigValues.ScaleDownForHaReservation);
        }
        // Set the score pairs
        for (VDS host : hosts) {
            // Scale down if needed
            int haCount = hostsHaVmCount.get(host.getId());
            haCount = (int) Math.ceil(haCount / scaleDownParameter.floatValue());
            scores.add(new Pair<Guid, Integer>(host.getId(), haCount));
            log.info("Score for host '{}' is {}", host.getName(), haCount);
        }
    }
    return scores;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    log.debug("Started HA reservation scoring method");
    List<Pair<Guid, Integer>> scores = new ArrayList<>();
    Map<Guid, Integer> hostsHaVmCount = new HashMap<>();
    // If the vm is not HA or the cluster is not marked as HA Reservation set default score.
    if (!vm.isAutoStartup() || !cluster.supportsHaReservation()) {
        fillDefaultScores(hosts, scores);
    } else {
        // Use a single call to the DB to retrieve all VM in the Cluster and map them by Host id
        Map<Guid, List<VM>> hostId2HaVmMapping = HaReservationHandling.mapHaVmToHostByCluster(cluster.getId());
        int maxCount = 0;
        for (VDS host : hosts) {
            int count = 0;
            if (hostId2HaVmMapping.containsKey(host.getId())) {
                count = hostId2HaVmMapping.get(host.getId()).size();
            }
            maxCount = Math.max(maxCount, count);
            hostsHaVmCount.put(host.getId(), count);
        }
        // Fit count to scale of 0 to RATIO_FACTOR
        if (maxCount > 0) {
            for (VDS host : hosts) {
                int fittedCount = Math.round(hostsHaVmCount.get(host.getId()).floatValue() / maxCount * RATIO_FACTOR);
                hostsHaVmCount.put(host.getId(), fittedCount);
            }
        }
        // Get scale down param
        Integer scaleDownParameter = 1;
        if (parameters.get("ScaleDown") != null) {
            scaleDownParameter = Integer.parseInt(parameters.get(PolicyUnitParameter.SCALE_DOWN.getDbName()));
        } else {
            scaleDownParameter = Config.<Integer>getValue(ConfigValues.ScaleDownForHaReservation);
        }
        // Set the score pairs
        for (VDS host : hosts) {
            // Scale down if needed
            int haCount = hostsHaVmCount.get(host.getId());
            haCount = (int) Math.ceil(haCount / scaleDownParameter.floatValue());
            scores.add(new Pair<>(host.getId(), haCount));
            log.info("Score for host '{}' is {}", host.getName(), haCount);
        }
    }
    log.debug("Ended HA reservation scoring method");
    return scores;
}
#end_block

#method_before
private void fillDefaultScores(List<VDS> hosts, List<Pair<Guid, Integer>> scores) {
    for (VDS host : hosts) {
        scores.add(new Pair<Guid, Integer>(host.getId(), DEFAULT_SCORE));
    }
}
#method_after
private void fillDefaultScores(List<VDS> hosts, List<Pair<Guid, Integer>> scores) {
    for (VDS host : hosts) {
        scores.add(new Pair<>(host.getId(), DEFAULT_SCORE));
    }
}
#end_block

#method_before
@Override
public void init() throws ServletException {
    postActionUrl = getServletContext().getInitParameter("post-action-url");
    if (postActionUrl == null) {
        throw new RuntimeException("No post-action-url init parameter specified for SSOLoginServlet.");
    }
    authSequencePriorityPropertyName = getServletContext().getInitParameter("auth-seq-priority-property-name");
    if (postActionUrl == null) {
        throw new RuntimeException("No auth-seq-priority-property-name init parameter specified for SSOLoginServlet.");
    }
}
#method_after
@Override
public void init() throws ServletException {
    postActionUrl = getServletContext().getInitParameter("post-action-url");
    if (postActionUrl == null) {
        throw new RuntimeException("No post-action-url init parameter specified for SsoLoginServlet.");
    }
    authSequencePriorityPropertyName = getServletContext().getInitParameter("auth-seq-priority-property-name");
    if (postActionUrl == null) {
        throw new RuntimeException("No auth-seq-priority-property-name init parameter specified for SsoLoginServlet.");
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SSOLogoutServlet");
    String token = null;
    try {
        String engineSessionId = (String) request.getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (StringUtils.isEmpty(engineSessionId) && request.getSession(false) != null) {
            engineSessionId = (String) request.getSession(false).getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        }
        if (StringUtils.isNotEmpty(engineSessionId)) {
            InitialContext ctx = new InitialContext();
            try {
                VdcQueryParametersBase params = new VdcQueryParametersBase(engineSessionId);
                params.setFiltered(true);
                VdcQueryReturnValue retValue = FiltersHelper.getBackend(ctx).runQuery(VdcQueryType.GetEngineSessionIdToken, params);
                token = retValue.getReturnValue();
                FiltersHelper.getBackend(ctx).runAction(VdcActionType.LogoutSession, new VdcActionParametersBase(engineSessionId));
            } finally {
                ctx.close();
            }
        }
    } catch (Exception ex) {
        log.error("Unable to clear user session {}", ex.getMessage());
    }
    HttpSession session = request.getSession(false);
    if (session != null) {
        log.debug("Setting session attribute {}", FiltersHelper.Constants.LOGOUT_INPROGRESS);
        session.setAttribute(FiltersHelper.Constants.LOGOUT_INPROGRESS, true);
    }
    Map<String, Object> revokeResponse = SsoOAuthServiceUtils.revoke(token);
    String error = (String) revokeResponse.get("error");
    String error_code = (String) revokeResponse.get("error_code");
    if (StringUtils.isNotEmpty(error)) {
        log.error("Unable to logout user: {}", error);
    }
    String url = String.format("%s://%s:%s%s/oauth2-callback", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), EngineLocalConfig.getInstance().getProperty("ENGINE_URI"));
    String redirectUri = new URLBuilder(url).addParameter("error", StringUtils.defaultIfEmpty(error, "")).addParameter("error_code", StringUtils.defaultIfEmpty(error_code, "")).build();
    if (session != null) {
        log.debug("Invalidating existing session");
        session.invalidate();
    }
    log.debug("Redirecting to {}", redirectUri);
    response.sendRedirect(redirectUri);
    log.debug("Exiting SSOLogoutServlet");
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoLogoutServlet");
    String token = null;
    try {
        String engineSessionId = (String) request.getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (StringUtils.isEmpty(engineSessionId) && request.getSession(false) != null) {
            engineSessionId = (String) request.getSession(false).getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        }
        if (StringUtils.isNotEmpty(engineSessionId)) {
            InitialContext ctx = new InitialContext();
            try {
                VdcQueryParametersBase params = new VdcQueryParametersBase(engineSessionId);
                params.setFiltered(true);
                VdcQueryReturnValue retValue = FiltersHelper.getBackend(ctx).runQuery(VdcQueryType.GetEngineSessionIdToken, params);
                token = retValue.getReturnValue();
                FiltersHelper.getBackend(ctx).runAction(VdcActionType.LogoutSession, new VdcActionParametersBase(engineSessionId));
            } finally {
                ctx.close();
            }
        }
    } catch (Exception ex) {
        log.error("Unable to clear user session {}", ex.getMessage());
    }
    HttpSession session = request.getSession(false);
    if (session != null) {
        log.debug("Setting session attribute {}", FiltersHelper.Constants.LOGOUT_INPROGRESS);
        session.setAttribute(FiltersHelper.Constants.LOGOUT_INPROGRESS, true);
    }
    Map<String, Object> revokeResponse = SsoOAuthServiceUtils.revoke(token);
    String error = (String) revokeResponse.get("error");
    String error_code = (String) revokeResponse.get("error_code");
    if (StringUtils.isNotEmpty(error)) {
        log.error("Unable to logout user: {}", error);
    }
    String url = String.format("%s://%s:%s%s/oauth2-callback", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), EngineLocalConfig.getInstance().getProperty("ENGINE_URI"));
    String redirectUri = new URLBuilder(url).addParameter("error", StringUtils.defaultIfEmpty(error, "")).addParameter("error_code", StringUtils.defaultIfEmpty(error_code, "")).build();
    if (session != null) {
        log.debug("Invalidating existing session");
        session.invalidate();
    }
    log.debug("Redirecting to {}", redirectUri);
    response.sendRedirect(redirectUri);
    log.debug("Exiting SsoLogoutServlet");
}
#end_block

#method_before
@Before
public void setUpContainer() {
    when(engineSessionDao.remove(any(Long.class))).thenReturn(1);
    when(ssoSessionValidator.isSessionValid(anyString())).thenReturn(true);
    DbUser user = mock(DbUser.class);
    container.setSSOSessionValidaor(ssoSessionValidator);
    container.setUser(TEST_SESSION_ID, user);
}
#method_after
@Before
public void setUpContainer() {
    when(engineSessionDao.remove(any(Long.class))).thenReturn(1);
    when(ssoSessionValidator.isSessionValid(anyString())).thenReturn(true);
    when(ssoSessionUtils.isSessionInUse(anyLong())).thenReturn(false);
    DbUser user = mock(DbUser.class);
    container.setUser(TEST_SESSION_ID, user);
}
#end_block

#method_before
private void persistEngineSession(String sessionId) {
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    if (sessionInfo != null) {
        sessionInfo.contentOfSession.put(ENGINE_SESSION_SEQ_ID, engineSessionDao.save(new EngineSession(getUser(sessionId, false), sessionId, getSourceIp(sessionId))));
    }
}
#method_after
private void persistEngineSession(String sessionId) {
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    if (sessionInfo != null) {
        sessionInfo.contentOfSession.put(ENGINE_SESSION_SEQ_ID, engineSessionDao.save(new EngineSession(getUser(sessionId, false), sessionId, getSourceIp(sessionId))));
        setSessionStartTime(sessionId);
    }
}
#end_block

#method_before
public boolean isSessionExists(String sessionId) {
    return sessionInfoMap.containsKey(sessionId);
}
#method_after
public boolean isSessionExists(String sessionId) {
    return StringUtils.isEmpty(sessionId) ? false : sessionInfoMap.containsKey(sessionId);
}
#end_block

#method_before
private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
    /*
         * So we won't need to add profile to tests
         */
    String authzName = null;
    if (getProfile(sessionId) != null) {
        authzName = getProfile(sessionId).getAuthzName();
    }
    AcctUtils.reportRecords(reason, authzName, getPrincipalName(sessionId), message, msgArgs);
    engineSessionDao.remove(getEngineSessionSeqId(sessionId));
    sessionInfoMap.remove(sessionId);
}
#method_after
private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
    // Only remove session if there are no running commands for this session
    if (ssoSessionUtils.isSessionInUse(getEngineSessionSeqId(sessionId))) {
        DbUser dbUser = getUser(sessionId, false);
        log.info("Not removing session '{}', session has running commands{}", sessionId, dbUser == null ? "." : String.format(" for user '%s@%s'.", dbUser.getLoginName(), dbUser.getDomain()));
        return;
    }
    /*
         * So we won't need to add profile to tests
         */
    String authzName = null;
    if (getProfile(sessionId) != null) {
        authzName = getProfile(sessionId).getAuthzName();
    }
    AcctUtils.reportRecords(reason, authzName, getPrincipalName(sessionId), message, msgArgs);
    engineSessionDao.remove(getEngineSessionSeqId(sessionId));
    sessionInfoMap.remove(sessionId);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    log.debug("Entered SsoRestApiNegotiationFilter");
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse resp = (HttpServletResponse) response;
    if ((FiltersHelper.isAuthenticated(req) && FiltersHelper.isSessionValid((HttpServletRequest) request)) || !EngineLocalConfig.getInstance().getBoolean("ENGINE_RESTAPI_NEGO")) {
        log.debug("SsoRestApiNegotiationFilter Not performing Negotiate Auth");
        chain.doFilter(request, response);
    } else {
        log.debug("SsoRestApiNegotiationFilter performing Negotiate Auth");
        try {
            req.setAttribute(FiltersHelper.Constants.REQUEST_SCHEMES_KEY, schemes);
            HttpSession session = req.getSession(false);
            Deque<AuthenticationProfile> stack = null;
            if (session != null) {
                stack = (Deque<AuthenticationProfile>) session.getAttribute(STACK_ATTR);
            }
            if (stack == null) {
                stack = new ArrayDeque<>();
                stack.addAll(profiles);
            }
            AuthResult authResult = doAuth(req, resp, stack);
            if (!stack.isEmpty()) {
                req.getSession(true).setAttribute(STACK_ATTR, stack);
            } else {
                if (session != null) {
                    session.removeAttribute(STACK_ATTR);
                }
                if (authResult.username != null) {
                    log.debug("SsoRestApiNegotiationFilter invoking SSOOAuthServiceUtils.loginOnBehalf for : {}", authResult.username);
                    Map<String, Object> jsonResponse = SsoOAuthServiceUtils.loginOnBehalf(authResult.username, scope, authResult.authRecord);
                    FiltersHelper.isStatusOk(jsonResponse);
                    log.debug("SsoRestApiNegotiationFilter creating user session");
                    SsoUtils.createUserSession(req, FiltersHelper.getPayloadForToken((String) jsonResponse.get("access_token")), false);
                    req.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, req.getSession().getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY));
                    req.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, req.getSession().getAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE));
                }
                chain.doFilter(req, resp);
            }
        } catch (Exception e) {
            log.error("Cannot authenticate using External Authentication: {}", e.getMessage());
            log.debug("Cannot authenticate using External Authentication", e);
            chain.doFilter(req, resp);
        }
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    log.debug("Entered SsoRestApiNegotiationFilter");
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse resp = (HttpServletResponse) response;
    if ((FiltersHelper.isAuthenticated(req) && FiltersHelper.isSessionValid((HttpServletRequest) request)) || !EngineLocalConfig.getInstance().getBoolean("ENGINE_RESTAPI_NEGO")) {
        log.debug("SsoRestApiNegotiationFilter Not performing Negotiate Auth");
        chain.doFilter(request, response);
    } else {
        log.debug("SsoRestApiNegotiationFilter performing Negotiate Auth");
        try {
            req.setAttribute(FiltersHelper.Constants.REQUEST_SCHEMES_KEY, schemes);
            HttpSession session = req.getSession(false);
            Deque<AuthenticationProfile> stack = null;
            if (session != null) {
                stack = (Deque<AuthenticationProfile>) session.getAttribute(STACK_ATTR);
            }
            if (stack == null) {
                stack = new ArrayDeque<>();
                stack.addAll(profiles);
            }
            AuthResult authResult = doAuth(req, resp, stack);
            if (!stack.isEmpty()) {
                req.getSession(true).setAttribute(STACK_ATTR, stack);
            } else {
                if (session != null) {
                    session.removeAttribute(STACK_ATTR);
                }
                if (authResult.username != null) {
                    log.debug("SsoRestApiNegotiationFilter invoking SsoAuthServiceUtils.loginOnBehalf for : {}", authResult.username);
                    Map<String, Object> jsonResponse = SsoOAuthServiceUtils.loginOnBehalf(authResult.username, scope, authResult.authRecord);
                    FiltersHelper.isStatusOk(jsonResponse);
                    log.debug("SsoRestApiNegotiationFilter creating user session");
                    SsoUtils.createUserSession(req, FiltersHelper.getPayloadForToken((String) jsonResponse.get("access_token")), false);
                    req.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, req.getSession().getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY));
                    req.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, req.getSession().getAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE));
                }
                chain.doFilter(req, resp);
            }
        } catch (Exception e) {
            log.error("Cannot authenticate using External Authentication: {}", e.getMessage());
            log.debug("Cannot authenticate using External Authentication", e);
            chain.doFilter(req, resp);
        }
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    log.debug("Entered SsoRestApiAuthFilter");
    HttpServletRequest req = (HttpServletRequest) request;
    if (!FiltersHelper.isAuthenticated(req) || !FiltersHelper.isSessionValid((HttpServletRequest) request)) {
        log.debug("SsoRestApiAuthFilter authenticating with sso");
        authenticateWithSSO(req, (HttpServletResponse) response);
    }
    chain.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    log.debug("Entered SsoRestApiAuthFilter");
    HttpServletRequest req = (HttpServletRequest) request;
    if (!FiltersHelper.isAuthenticated(req) || !FiltersHelper.isSessionValid((HttpServletRequest) request)) {
        log.debug("SsoRestApiAuthFilter authenticating with sso");
        authenticateWithSso(req, (HttpServletResponse) response);
    }
    chain.doFilter(request, response);
}
#end_block

#method_before
@Override
public void init() throws ServletException {
    String strVal = getServletConfig().getInitParameter("login-as-admin");
    if (strVal == null) {
        throw new RuntimeException("No login-as-admin init parameter specified for SSOPostLoginServlet.");
    }
    loginAsAdmin = Boolean.parseBoolean(strVal);
    postActionUrl = getServletContext().getInitParameter("post-action-url");
    if (postActionUrl == null) {
        throw new RuntimeException("No post-action-url init parameter specified for SSOLoginServlet.");
    }
}
#method_after
@Override
public void init() throws ServletException {
    String strVal = getServletConfig().getInitParameter("login-as-admin");
    if (strVal == null) {
        throw new RuntimeException("No login-as-admin init parameter specified for SsoPostLoginServlet.");
    }
    loginAsAdmin = Boolean.parseBoolean(strVal);
    postActionUrl = getServletContext().getInitParameter("post-action-url");
    if (postActionUrl == null) {
        throw new RuntimeException("No post-action-url init parameter specified for SsoPostLoginServlet.");
    }
}
#end_block

#method_before
private List<UserSession> searchSessions() {
    return genericSearch(getDbFacade().getEngineSessionDao(), false).stream().map(UserSession::new).collect(Collectors.toList());
}
#method_after
private List<UserSession> searchSessions() {
    return genericSearch(getDbFacade().getEngineSessionDao(), false).stream().peek(this::injectSessionInfo).map(UserSession::new).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public void init(FilterConfig filterConfig) throws ServletException {
    loginUrl = filterConfig.getInitParameter("login-url");
    if (loginUrl == null) {
        throw new RuntimeException("No login-url init parameter specified for SSOLoginFilter.");
    }
}
#method_after
@Override
public void init(FilterConfig filterConfig) throws ServletException {
    loginUrl = filterConfig.getInitParameter("login-url");
    if (loginUrl == null) {
        throw new RuntimeException("No login-url init parameter specified for SsoLoginFilter.");
    }
}
#end_block

#method_before
private boolean isSucceededWithReasonGiven() {
    return isSucceededWithHA() && !StringUtils.isEmpty(getVds().getMaintenanceReason());
}
#method_after
private boolean isSucceededWithReasonGiven() {
    return isSucceededWithHA() && StringUtils.isNotEmpty(getVds().getMaintenanceReason());
}
#end_block

#method_before
public void configure(ISpice spice) {
    if (spice instanceof ISpicePlugin) {
        // Unsupported since 4.0
        ((ISpicePlugin) spice).setPluginVersion(getSpiceVersion());
        ((ISpicePlugin) spice).setSpiceBaseURL(getSpiceBaseURL());
    }
    spice.getOptions().setAdminConsole(getSpiceAdminConsole());
    spice.getOptions().setFullScreen(getSpiceFullScreen());
    spice.getOptions().setUsbFilter(getUsbFilter());
    updateSpiceUsbAutoShare(spice);
}
#method_after
public void configure(ISpice spice) {
    if (spice instanceof ISpicePlugin) {
        // Unsupported since 4.0
        ((ISpicePlugin) spice).setPluginVersion(getSpiceVersion());
        ((ISpicePlugin) spice).setSpiceBaseURL(getSpiceBaseURL());
    }
    spice.getOptions().setAdminConsole(getSpiceAdminConsole());
    spice.getOptions().setUsbFilter(getUsbFilter());
    updateSpiceUsbAutoShare(spice);
    updateSpiceFullScreenDefault(spice);
}
#end_block

#method_before
private String createSpiceInvocationInfo() {
    return new KeyValueHtmlRowMaker(constants.auto(), constants.spiceInvokeAuto()).append(constants.nativeClient(), constants.consoleInvokeNative()).append(constants.spiceHtml5(), constants.spiceInvokeHtml5()).toString();
}
#method_after
private String createSpiceInvocationInfo() {
    KeyValueHtmlRowMaker rowMaker = new KeyValueHtmlRowMaker(constants.auto(), constants.spiceInvokeAuto());
    rowMaker.append(constants.nativeClient(), constants.consoleInvokeNative());
    if (AsyncDataProvider.getInstance().isEnableDeprecatedClientModeSpicePlugin()) {
        rowMaker.append(constants.browserPlugin(), constants.spiceInvokePlugin());
    }
    rowMaker.append(constants.spiceHtml5(), constants.spiceInvokeHtml5());
    return rowMaker.toString();
}
#end_block

#method_before
@Override
public void setSpicePluginImplEnabled(boolean enabled, String reason) {
    // Unsupported since 4.0
    spicePluginImplRadioButton.setVisible(enabled);
    spicePluginImplRadioButton.setEnabled(enabled);
    if (!enabled) {
        spicePluginImplRadioButtonTooltip.setText(reason);
    }
}
#method_after
@Override
public void setSpicePluginImplEnabled(boolean enabled, String reason) {
    spicePluginImplRadioButton.setEnabled(enabled);
    if (!enabled) {
        spicePluginImplRadioButtonTooltip.setText(reason);
    }
}
#end_block

#method_before
private void initView(ConsolePopupModel model) {
    listenOnRadioButtons(model);
    VmConsoles vmConsoles = model.getVmConsoles();
    getView().setSpiceAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.SPICE));
    getView().setVncAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.VNC));
    getView().setRdpAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.RDP));
    ConsoleProtocol selectedProtocol = vmConsoles.getSelectedProcotol();
    boolean rdpPreselected = ConsoleProtocol.RDP.equals(selectedProtocol);
    boolean spicePreselected = ConsoleProtocol.SPICE.equals(selectedProtocol);
    boolean vncPreselected = ConsoleProtocol.VNC.equals(selectedProtocol);
    getView().selectSpice(spicePreselected);
    getView().selectRdp(rdpPreselected);
    getView().selectVnc(vncPreselected);
    getView().showSpicePanel(spicePreselected);
    getView().showRdpPanel(rdpPreselected);
    getView().showVncPanel(vncPreselected);
    getView().setDisableSmartcardVisible(model.getVmConsoles().getVm().isSmartcardEnabled());
    ISpice spice = model.getVmConsoles().getConsoleModel(SpiceConsoleModel.class).getspice();
    if (spice != null) {
        if (!spice.getOptions().isWanOptionsEnabled()) {
            getView().selectWanOptionsEnabled(false);
        }
        spiceProxyUserPreference = vmConsoles.getConsoleModel(SpiceConsoleModel.class).getspice().getOptions().isSpiceProxyEnabled();
    }
    // The plugin is unsupported in 4.0 and related code will be removed in 4.1
    if (model.getVmConsoles().getConsoleModel(SpiceConsoleModel.class).getDefaultConsoleMode() != SpiceConsoleModel.ClientConsoleMode.Plugin || !consoleUtils.isBrowserPluginSupported(ConsoleProtocol.SPICE)) {
        // Unsupported since 4.0
        getView().setSpicePluginImplEnabled(false, constants.spicePluginNotSupportedByBrowser());
    }
    getView().setSpiceHtml5ImplEnabled(consoleUtils.webBasedClientsSupported(), constants.webBasedClientsUnsupported());
    getView().setNoVncEnabled(consoleUtils.webBasedClientsSupported(), constants.webBasedClientsUnsupported());
    if (!consoleUtils.isBrowserPluginSupported(ConsoleProtocol.RDP)) {
        getView().setRdpPluginImplEnabled(false, constants.rdpPluginNotSupportedByBrowser());
    }
    spiceProxyDefinedOnCluster = consoleUtils.isSpiceProxyDefined(vmConsoles.getVm());
    selectSpiceImplementation(vmConsoles.getConsoleModel(SpiceConsoleModel.class).getClientConsoleMode());
    getView().selectVncImplementation(vmConsoles.getConsoleModel(VncConsoleModel.class).getClientConsoleMode());
    getView().selectRdpImplementation(vmConsoles.getConsoleModel(RdpConsoleModel.class).getClientConsoleMode());
    wanOptionsAvailable = vmConsoles.getConsoleModel(SpiceConsoleModel.class).isWanOptionsAvailableForMyVm();
    if (wanOptionsAvailable) {
        getView().setWanOptionsVisible(true);
    } else {
        getView().setWanOptionsVisible(false);
    }
    getView().setAdditionalConsoleAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.RDP));
    getView().setSpiceConsoleAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.SPICE));
    registerHandler(getView().getConsoleClientResourcesAnchor().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            // $NON-NLS-1$ $NON-NLS-2$
            Window.open(dynamicMessages.consoleClientResourcesUrl(), "_blank", "resizable=yes,scrollbars=yes");
        }
    }));
    registerHandler(getView().getSpiceProxyEnabledCheckBox().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            spiceProxyUserPreference = booleanValueChangeEvent.getValue();
        }
    }));
}
#method_after
private void initView(ConsolePopupModel model) {
    listenOnRadioButtons(model);
    VmConsoles vmConsoles = model.getVmConsoles();
    getView().setSpiceAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.SPICE));
    getView().setVncAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.VNC));
    getView().setRdpAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.RDP));
    ConsoleProtocol selectedProtocol = vmConsoles.getSelectedProcotol();
    boolean rdpPreselected = ConsoleProtocol.RDP.equals(selectedProtocol);
    boolean spicePreselected = ConsoleProtocol.SPICE.equals(selectedProtocol);
    boolean vncPreselected = ConsoleProtocol.VNC.equals(selectedProtocol);
    getView().selectSpice(spicePreselected);
    getView().selectRdp(rdpPreselected);
    getView().selectVnc(vncPreselected);
    getView().showSpicePanel(spicePreselected);
    getView().showRdpPanel(rdpPreselected);
    getView().showVncPanel(vncPreselected);
    getView().setDisableSmartcardVisible(model.getVmConsoles().getVm().isSmartcardEnabled());
    ISpice spice = model.getVmConsoles().getConsoleModel(SpiceConsoleModel.class).getspice();
    if (spice != null) {
        if (!spice.getOptions().isWanOptionsEnabled()) {
            getView().selectWanOptionsEnabled(false);
        }
        spiceProxyUserPreference = vmConsoles.getConsoleModel(SpiceConsoleModel.class).getspice().getOptions().isSpiceProxyEnabled();
    }
    // TODO: The plugin is unsupported in 4.0 and all related code will be removed in 4.1
    if (model.getVmConsoles().getConsoleModel(SpiceConsoleModel.class).isEnableDeprecatedClientModeSpicePlugin()) {
        getView().setSpicePluginImplVisible(true);
        if (!consoleUtils.isBrowserPluginSupported(ConsoleProtocol.SPICE)) {
            getView().setSpicePluginImplEnabled(false, constants.spicePluginNotSupportedByBrowser());
        }
    } else {
        getView().setSpicePluginImplVisible(false);
    }
    getView().setSpiceHtml5ImplEnabled(consoleUtils.webBasedClientsSupported(), constants.webBasedClientsUnsupported());
    getView().setNoVncEnabled(consoleUtils.webBasedClientsSupported(), constants.webBasedClientsUnsupported());
    if (!consoleUtils.isBrowserPluginSupported(ConsoleProtocol.RDP)) {
        getView().setRdpPluginImplEnabled(false, constants.rdpPluginNotSupportedByBrowser());
    }
    spiceProxyDefinedOnCluster = consoleUtils.isSpiceProxyDefined(vmConsoles.getVm());
    selectSpiceImplementation(vmConsoles.getConsoleModel(SpiceConsoleModel.class).getClientConsoleMode());
    getView().selectVncImplementation(vmConsoles.getConsoleModel(VncConsoleModel.class).getClientConsoleMode());
    getView().selectRdpImplementation(vmConsoles.getConsoleModel(RdpConsoleModel.class).getClientConsoleMode());
    wanOptionsAvailable = vmConsoles.getConsoleModel(SpiceConsoleModel.class).isWanOptionsAvailableForMyVm();
    if (wanOptionsAvailable) {
        getView().setWanOptionsVisible(true);
    } else {
        getView().setWanOptionsVisible(false);
    }
    getView().setAdditionalConsoleAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.RDP));
    getView().setSpiceConsoleAvailable(vmConsoles.canSelectProtocol(ConsoleProtocol.SPICE));
    registerHandler(getView().getConsoleClientResourcesAnchor().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            // $NON-NLS-1$ $NON-NLS-2$
            Window.open(dynamicMessages.consoleClientResourcesUrl(), "_blank", "resizable=yes,scrollbars=yes");
        }
    }));
    registerHandler(getView().getSpiceProxyEnabledCheckBox().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            spiceProxyUserPreference = booleanValueChangeEvent.getValue();
        }
    }));
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createVolumeContainer(String sdUUID, String imgGUID, String size, int volFormat, int diskType, String volUUID, String descr, String srcImgGUID, String srcVolUUID) {
    JsonRpcRequest request = new RequestBuilder("SDM.createVolumeContainer").withParameter("volumeID", volUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).withParameter("volFormat", volFormat).withParameter("diskType", diskType).withParameter("desc", descr).withParameter("srcImgUUID", srcImgGUID).withParameter("srcVolUUID", srcVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc createVolumeContainer(String jobId, Map<String, Object> createVolumeInfo) {
    JsonRpcRequest request = new RequestBuilder("SDM.create_volume").withParameter("job_id", jobId).withParameter("vol_info", createVolumeInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            if (client.isClosed()) {
                waitUntilCheck(client -> client.isClosed(), "Waiting on losing connection to {}", "Connection lost for {}");
            }
            waitUntilCheck(client -> !client.isClosed(), "Waiting on opening connection for {}", "Done reconnecting for {}!");
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful upload to {}", getUploadDescription());
    stopImageTransferSession(context.entity);
    // We want to use the transferring vds for image actions for having a coherent log when uploading.
    Guid transferingVdsId = context.entity.getVdsId();
    if (verifyImage(transferingVdsId)) {
        setVolumeLegalityInStorage(true);
        unLockImage();
        updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
    } else {
        setImageStatus(ImageStatus.ILLEGAL);
        updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
    }
}
#method_after
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful upload to {}", getUploadDescription());
    stopImageTransferSession(context.entity);
    // We want to use the transferring vds for image actions for having a coherent log when uploading.
    Guid transferingVdsId = context.entity.getVdsId();
    if (verifyImage(transferingVdsId)) {
        setVolumeLegalityInStorage(LEGAL_IMAGE);
        unLockImage();
        updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
    } else {
        setImageStatus(ImageStatus.ILLEGAL);
        updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
    }
}
#end_block

#method_before
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(false)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
private boolean setVolumeLegalityInStorage(boolean legal) {
    SetVolumeLegalityVDSCommandParameters parameters = new SetVolumeLegalityVDSCommandParameters(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), legal);
    try {
        getBackend().getResourceManager().runVdsCommand(VDSCommandType.SetVolumeLegality, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to set image's volume's legality: {}", e);
        return false;
    }
    return true;
}
#method_after
private boolean setVolumeLegalityInStorage(boolean legal) {
    SetVolumeLegalityVDSCommandParameters parameters = new SetVolumeLegalityVDSCommandParameters(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), legal);
    try {
        runVdsCommand(VDSCommandType.SetVolumeLegality, parameters);
    } catch (EngineException e) {
        log.error("Failed to set image's volume's legality to {} for image {} and volume {}: {}", legal, getImage().getImage().getDiskId(), getImage().getImageId(), e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createVolumeContainer(String sdUUID, String imgGUID, String size, int volFormat, int diskType, String volUUID, String descr, String srcImgGUID, String srcVolUUID) {
    Map<String, Object> xmlRpcReturnValue = vdsServer.createVolumeContainer(sdUUID, imgGUID, size, volFormat, diskType, volUUID, descr, srcImgGUID, srcVolUUID);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc createVolumeContainer(String jobId, Map<String, Object> createVolumeInfo) {
    Map<String, Object> xmlRpcReturnValue = vdsServer.createVolumeContainer(jobId, createVolumeInfo);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful upload to {}", getUploadDescription());
    // If stopping the session did not succeed, don't change the upload state.
    if (stopImageTransferSession(context.entity)) {
        // We want to use the transferring vds for image actions for having a coherent log when uploading.
        Guid transferingVdsId = context.entity.getVdsId();
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(true);
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
    }
}
#method_after
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful upload to {}", getUploadDescription());
    // If stopping the session did not succeed, don't change the upload state.
    if (stopImageTransferSession(context.entity)) {
        // We want to use the transferring vds for image actions for having a coherent log when uploading.
        Guid transferingVdsId = context.entity.getVdsId();
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
    }
}
#end_block

#method_before
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(false)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
private boolean setVolumeLegalityInStorage(boolean legal) {
    SetVolumeLegalityVDSCommandParameters parameters = new SetVolumeLegalityVDSCommandParameters(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), legal);
    try {
        getBackend().getResourceManager().runVdsCommand(VDSCommandType.SetVolumeLegality, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to set image's volume's legality: {}", e);
        return false;
    }
    return true;
}
#method_after
private boolean setVolumeLegalityInStorage(boolean legal) {
    SetVolumeLegalityVDSCommandParameters parameters = new SetVolumeLegalityVDSCommandParameters(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), legal);
    try {
        runVdsCommand(VDSCommandType.SetVolumeLegality, parameters);
    } catch (EngineException e) {
        log.error("Failed to set image's volume's legality to {} for image {} and volume {}: {}", legal, getImage().getImage().getDiskId(), getImage().getImageId(), e);
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean stopImageTransferSession(ImageTransfer entity) {
    if (entity.getImagedTicketId() == null) {
        return false;
    }
    Guid resourceId = entity.getImagedTicketId();
    RemoveImageTicketVDSCommandParameters parameters = new RemoveImageTicketVDSCommandParameters(entity.getVdsId(), resourceId);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.RemoveImageTicket, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to stop image transfer session for ticket '{}': {}", resourceId.toString(), e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.warn("Failed to stop image transfer session for ticket '{}'", resourceId.toString());
        return false;
    }
    log.info("Successfully stopped image transfer session for ticket '{}'", resourceId.toString());
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setClearResourceId(true);
    updateEntity(updates);
    tearDownImage(entity.getVdsId());
    return true;
}
#method_after
private boolean stopImageTransferSession(ImageTransfer entity) {
    if (entity.getImagedTicketId() == null) {
        log.warn("Failed to stop image transfer session. Ticket does not exist for image '{}'", entity.getDiskId());
        return false;
    }
    Guid resourceId = entity.getImagedTicketId();
    RemoveImageTicketVDSCommandParameters parameters = new RemoveImageTicketVDSCommandParameters(entity.getVdsId(), resourceId);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.RemoveImageTicket, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to stop image transfer session for ticket '{}': {}", resourceId.toString(), e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.warn("Failed to stop image transfer session for ticket '{}'", resourceId.toString());
        return false;
    }
    log.info("Successfully stopped image transfer session for ticket '{}'", resourceId.toString());
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setClearResourceId(true);
    updateEntity(updates);
    tearDownImage(entity.getVdsId());
    return true;
}
#end_block

#method_before
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful upload to {}", getUploadDescription());
    stopImageTransferSession(context.entity);
    setVolumeLegalityInStorage(true);
    unLockImage();
    updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
}
#method_after
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful upload to {}", getUploadDescription());
    stopImageTransferSession(context.entity);
    setVolumeLegalityInStorage(LEGAL_IMAGE);
    unLockImage();
    updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
}
#end_block

#method_before
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(false)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
private boolean setVolumeLegalityInStorage(boolean legal) {
    SetVolumeLegalityVDSCommandParameters parameters = new SetVolumeLegalityVDSCommandParameters(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), legal);
    try {
        getBackend().getResourceManager().runVdsCommand(VDSCommandType.SetVolumeLegality, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to set image's volume's legality: {}", e);
        return false;
    }
    return true;
}
#method_after
private boolean setVolumeLegalityInStorage(boolean legal) {
    SetVolumeLegalityVDSCommandParameters parameters = new SetVolumeLegalityVDSCommandParameters(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), legal);
    try {
        runVdsCommand(VDSCommandType.SetVolumeLegality, parameters);
    } catch (EngineException e) {
        log.error("Failed to set image's volume's legality to {} for image {} and volume {}: {}", legal, getImage().getImage().getDiskId(), getImage().getImageId(), e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    ExtendCinderDiskCommand extendCinderDiskCommand = (ExtendCinderDiskCommand) command;
    UpdateVmDiskParameters parameters = (UpdateVmDiskParameters) extendCinderDiskCommand.getParameters();
    ImageStatus imageStatus = extendCinderDiskCommand.getCinderBroker().getDiskStatus(parameters.getDiskId());
    DiskImage disk = (CinderDisk) command.getDiskDao().get(parameters.getDiskId());
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case OK:
                super.childCommandsExecutionEnded(command, false, childCmdIds, status, completedChildren);
                break;
            case ILLEGAL:
                super.childCommandsExecutionEnded(command, true, childCmdIds, status, completedChildren);
                break;
        }
    }
}
#method_after
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    ExtendCinderDiskCommand<UpdateVmDiskParameters> extendCinderDiskCommand = (ExtendCinderDiskCommand<UpdateVmDiskParameters>) command;
    ImageStatus imageStatus = extendCinderDiskCommand.getCinderBroker().getDiskStatus(getDiskId(extendCinderDiskCommand));
    if (imageStatus != null && imageStatus != getDisk(extendCinderDiskCommand).getImageStatus()) {
        switch(imageStatus) {
            case OK:
                setCommandEndStatus(command, false, status, childCmdIds);
                break;
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    RemoveCinderDiskVolumeParameters parameters = (RemoveCinderDiskVolumeParameters) command.getParameters();
    RemoveCinderDiskVolumeCommand removeCinderDiskVolumeCommand = (RemoveCinderDiskVolumeCommand) command;
    CinderDisk removedVolume = parameters.getRemovedVolume();
    // In case the volume/snapshot has been deleted from Cinder.
    if (!removeCinderDiskVolumeCommand.getCinderBroker().isVolumeExistsByClassificationType(removedVolume)) {
        super.childCommandsExecutionEnded(command, false, childCmdIds, status, completedChildren);
    }
    ImageStatus imageStatus = checkImageStatus(removedVolume, removeCinderDiskVolumeCommand);
    if (imageStatus != null && imageStatus != removedVolume.getImageStatus()) {
        switch(imageStatus) {
            case ILLEGAL:
                super.childCommandsExecutionEnded(command, true, childCmdIds, status, completedChildren);
                break;
        }
    }
}
#method_after
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    RemoveCinderDiskVolumeCommand<RemoveCinderDiskVolumeParameters> removeCinderDiskVolumeCommand = (RemoveCinderDiskVolumeCommand<RemoveCinderDiskVolumeParameters>) command;
    CinderDisk removedVolume = removeCinderDiskVolumeCommand.getParameters().getRemovedVolume();
    // In case the volume/snapshot has been deleted from Cinder.
    if (!removeCinderDiskVolumeCommand.getCinderBroker().isVolumeExistsByClassificationType(removedVolume)) {
        setCommandEndStatus(command, false, status, childCmdIds);
    }
    ImageStatus imageStatus = checkImageStatus(removedVolume, removeCinderDiskVolumeCommand);
    if (imageStatus != null && imageStatus != removedVolume.getImageStatus()) {
        switch(imageStatus) {
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    RemoveCinderSnapshotDiskCommand removeCinderSnapshotDiskCommand = (RemoveCinderSnapshotDiskCommand) command;
    ImagesContainterParametersBase parameters = (ImagesContainterParametersBase) removeCinderSnapshotDiskCommand.getParameters();
    Guid diskId = parameters.getDestinationImageId();
    if (!removeCinderSnapshotDiskCommand.getCinderBroker().isSnapshotExist(diskId)) {
        // Cinder snapshot has been deleted successfully
        setCommandEndStatus(command, false, status, childCmdIds);
        return;
    }
    ImageStatus imageStatus = removeCinderSnapshotDiskCommand.getCinderBroker().getSnapshotStatus(diskId);
    DiskImage disk = DbFacade.getInstance().getDiskImageDao().getSnapshotById(diskId);
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#method_after
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    RemoveCinderSnapshotDiskCommand<ImagesContainterParametersBase> removeCinderSnapshotDiskCommand = (RemoveCinderSnapshotDiskCommand<ImagesContainterParametersBase>) command;
    ImagesContainterParametersBase parameters = removeCinderSnapshotDiskCommand.getParameters();
    Guid diskId = parameters.getDestinationImageId();
    if (!removeCinderSnapshotDiskCommand.getCinderBroker().isSnapshotExist(diskId)) {
        // Cinder snapshot has been deleted successfully
        setCommandEndStatus(command, false, status, childCmdIds);
        return;
    }
    ImageStatus imageStatus = removeCinderSnapshotDiskCommand.getCinderBroker().getSnapshotStatus(diskId);
    DiskImage disk = command.getDiskImageDao().getSnapshotById(diskId);
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    CreateCinderSnapshotCommand createCinderSnapshotCommand = (CreateCinderSnapshotCommand) command;
    CreateCinderSnapshotParameters parameters = (CreateCinderSnapshotParameters) createCinderSnapshotCommand.getParameters();
    Guid diskId = parameters.getDestinationImageId();
    ImageStatus imageStatus;
    if (parameters.getSnapshotType().equals(Snapshot.SnapshotType.STATELESS)) {
        imageStatus = createCinderSnapshotCommand.getCinderBroker().getDiskStatus(diskId);
    } else {
        imageStatus = createCinderSnapshotCommand.getCinderBroker().getSnapshotStatus(diskId);
    }
    DiskImage disk = DbFacade.getInstance().getDiskImageDao().getSnapshotById(diskId);
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case OK:
                setCommandEndStatus(command, false, status, childCmdIds);
                break;
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#method_after
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    CreateCinderSnapshotCommand<CreateCinderSnapshotParameters> createCinderSnapshotCommand = (CreateCinderSnapshotCommand<CreateCinderSnapshotParameters>) command;
    CreateCinderSnapshotParameters parameters = createCinderSnapshotCommand.getParameters();
    Guid diskId = parameters.getDestinationImageId();
    ImageStatus imageStatus;
    if (parameters.getSnapshotType().equals(Snapshot.SnapshotType.STATELESS)) {
        imageStatus = createCinderSnapshotCommand.getCinderBroker().getDiskStatus(diskId);
    } else {
        imageStatus = createCinderSnapshotCommand.getCinderBroker().getSnapshotStatus(diskId);
    }
    DiskImage disk = command.getDiskImageDao().getSnapshotById(diskId);
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case OK:
                setCommandEndStatus(command, false, status, childCmdIds);
                break;
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name, storagePoolId)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#method_after
protected boolean canAddVm(List<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return VmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams, getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    ArrayList<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", StringUtils.join(errorMessages, ','));
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
}
#end_block

#method_before
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    BaseImagesCommand cloneCinderDiskCommand = (BaseImagesCommand) command;
    ImagesContainterParametersBase parameters = (ImagesContainterParametersBase) cloneCinderDiskCommand.getParameters();
    ImageStatus imageStatus = cloneCinderDiskCommand.getCinderBroker().getDiskStatus(parameters.getDestinationImageId());
    DiskImage disk = (CinderDisk) DbFacade.getInstance().getDiskDao().get(parameters.getContainerId());
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case OK:
                setCommandEndStatus(command, false, status, childCmdIds);
                break;
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#method_after
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    BaseImagesCommand<ImagesContainterParametersBase> cloneCinderDiskCommand = (BaseImagesCommand<ImagesContainterParametersBase>) command;
    ImagesContainterParametersBase parameters = cloneCinderDiskCommand.getParameters();
    ImageStatus imageStatus = cloneCinderDiskCommand.getCinderBroker().getDiskStatus(parameters.getDestinationImageId());
    DiskImage disk = (CinderDisk) command.getDiskDao().get(parameters.getContainerId());
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case OK:
                setCommandEndStatus(command, false, status, childCmdIds);
                break;
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    AddCinderDiskCommand addCinderDiskCommand = (AddCinderDiskCommand) command;
    Guid diskId = ((AddDiskParameters) addCinderDiskCommand.getParameters()).getDiskInfo().getId();
    ImageStatus imageStatus = addCinderDiskCommand.getCinderBroker().getDiskStatus(diskId);
    DiskImage disk = (CinderDisk) DbFacade.getInstance().getDiskDao().get(diskId);
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case OK:
                super.childCommandsExecutionEnded(command, false, childCmdIds, status, completedChildren);
                break;
            case ILLEGAL:
                super.childCommandsExecutionEnded(command, true, childCmdIds, status, completedChildren);
                break;
        }
    }
}
#method_after
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    AddCinderDiskCommand<AddDiskParameters> addCinderDiskCommand = (AddCinderDiskCommand<AddDiskParameters>) command;
    Guid diskId = getDiskId(addCinderDiskCommand);
    ImageStatus imageStatus = addCinderDiskCommand.getCinderBroker().getDiskStatus(diskId);
    DiskImage disk = (CinderDisk) command.getDiskDao().get(diskId);
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case OK:
                setCommandEndStatus(command, false, status, childCmdIds);
                break;
            case ILLEGAL:
                setCommandEndStatus(command, true, status, childCmdIds);
                break;
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!getVm().isDown()) {
        if (FeatureSupported.liveMerge(getVm().getCompatibilityVersion())) {
            if (!getVm().isQualifiedForSnapshotMerge()) {
                log.error("Cannot remove VM snapshot. Vm is not Down, Up or Paused");
                throw new EngineException(EngineError.VM_NOT_QUALIFIED_FOR_SNAPSHOT_MERGE);
            } else if (getVm().getRunOnVds() == null || !getVdsDao().get(getVm().getRunOnVds()).getLiveMergeSupport()) {
                log.error("Cannot remove VM snapshot. The host on which VM is running does not support Live Merge");
                throw new EngineException(EngineError.VM_HOST_CANNOT_LIVE_MERGE);
            }
        } else {
            log.error("Cannot remove VM snapshot. Vm is not Down and cluster version does not support Live Merge");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
    }
    final Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    boolean snapshotHasImages = hasImages();
    boolean removeSnapshotMemory = isMemoryVolumeRemoveable(snapshot.getMemoryVolume());
    // No need for locking, VDSM tasks, and all that jazz.
    if (!snapshotHasImages && !removeSnapshotMemory) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    lockSnapshot(snapshot);
    freeLock();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    boolean useTaskManagerToRemoveMemory = false;
    if (snapshotHasImages) {
        removeImages();
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            persistCommand(getParameters().getParentCommand(), true);
            useTaskManagerToRemoveMemory = true;
        }
    }
    if (removeSnapshotMemory) {
        removeMemory(snapshot, useTaskManagerToRemoveMemory);
        if (!snapshotHasImages) {
            // no async tasks - ending command manually
            endVmCommand();
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!getVm().isDown() && !getVm().isQualifiedForSnapshotMerge()) {
        log.error("Cannot remove VM snapshot. Vm is not Down, Up or Paused");
        throw new EngineException(EngineError.VM_NOT_QUALIFIED_FOR_SNAPSHOT_MERGE);
    }
    final Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    boolean snapshotHasImages = hasImages();
    boolean removeSnapshotMemory = isMemoryVolumeRemoveable(snapshot.getMemoryVolume());
    // No need for locking, VDSM tasks, and all that jazz.
    if (!snapshotHasImages && !removeSnapshotMemory) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    lockSnapshot(snapshot);
    freeLock();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    boolean useTaskManagerToRemoveMemory = false;
    if (snapshotHasImages) {
        removeImages();
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            persistCommand(getParameters().getParentCommand(), true);
            useTaskManagerToRemoveMemory = true;
        }
    }
    if (removeSnapshotMemory) {
        removeMemory(snapshot, useTaskManagerToRemoveMemory);
        if (!snapshotHasImages) {
            // no async tasks - ending command manually
            endVmCommand();
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || (FeatureSupported.liveMerge(getVm().getCompatibilityVersion()) ? (!validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmHostCanLiveMerge())) : !validate(vmValidator.vmDown())) || !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || !validate(vmValidator.vmQualifiedForSnapshotMerge())) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(actionType, correlationId, endTime, id, isVisible, jobSubjectEntities, lastUpdateTime, ownerId, startTime, status, steps, external, autoCleared);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(actionType, engineSessionSeqId, correlationId, endTime, id, isVisible, jobSubjectEntities, lastUpdateTime, ownerId, startTime, status, steps, external, autoCleared);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Job)) {
        return false;
    }
    Job other = (Job) obj;
    return actionType == other.actionType && Objects.equals(correlationId, other.correlationId) && Objects.equals(endTime, other.endTime) && Objects.equals(id, other.id) && isVisible == other.isVisible && Objects.equals(jobSubjectEntities, other.jobSubjectEntities) && Objects.equals(lastUpdateTime, other.lastUpdateTime) && Objects.equals(ownerId, other.ownerId) && Objects.equals(startTime, other.startTime) && status == other.status && Objects.equals(steps, other.steps) && external == other.external && autoCleared == other.autoCleared;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Job)) {
        return false;
    }
    Job other = (Job) obj;
    return actionType == other.actionType && engineSessionSeqId == other.engineSessionSeqId && Objects.equals(correlationId, other.correlationId) && Objects.equals(endTime, other.endTime) && Objects.equals(id, other.id) && isVisible == other.isVisible && Objects.equals(jobSubjectEntities, other.jobSubjectEntities) && Objects.equals(lastUpdateTime, other.lastUpdateTime) && Objects.equals(ownerId, other.ownerId) && Objects.equals(startTime, other.startTime) && status == other.status && Objects.equals(steps, other.steps) && external == other.external && autoCleared == other.autoCleared;
}
#end_block

#method_before
private void generateActionHttpPost(Method method) {
    // Begin method:
    Name name = method.getName();
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(name));
    buffer.startBlock();
    buffer.addLine("self,");
    method.parameters().filter(Parameter::isIn).sorted().forEach(this::generateFormalParameter);
    buffer.endBlock();
    buffer.addLine("):");
    // Start body:
    buffer.startBlock();
    // Generate the method:
    buffer.addLine("buf = io.BytesIO()");
    buffer.addLine("writer = xml.XmlWriter(buf, indent=True)");
    buffer.addLine("writer.write_start('action')");
    method.parameters().filter(Parameter::isIn).sorted().forEach(this::generateWriteActionParameter);
    buffer.addLine("writer.write_end()");
    buffer.addLine("writer.flush()");
    buffer.addLine("body = buf.getvalue()");
    buffer.addLine("writer.close()");
    buffer.addLine("buf.close()");
    buffer.addLine("request = http.Request(");
    buffer.startBlock();
    buffer.addLine("method='POST',");
    buffer.addLine("path='%%s/%%s' %% (self._path, '%1$s'),", getPath(name));
    buffer.addLine("body=body,");
    buffer.endBlock();
    buffer.addLine(")");
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code in [200]:");
    buffer.startBlock();
    buffer.addLine("return self._check_action(response)");
    buffer.endBlock();
    buffer.addLine("else:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End method:
    buffer.endBlock();
    buffer.addLine();
}
#method_after
private void generateActionHttpPost(Method method) {
    // Begin method:
    Name name = method.getName();
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(name));
    buffer.startBlock();
    buffer.addLine("self,");
    method.parameters().filter(Parameter::isIn).sorted().forEach(this::generateFormalParameter);
    buffer.endBlock();
    buffer.addLine("):");
    // Start body:
    buffer.startBlock();
    // Generate the method:
    buffer.addLine("buf = io.BytesIO()");
    buffer.addLine("writer = xml.XmlWriter(buf, indent=True)");
    buffer.addLine("writer.write_start('action')");
    method.parameters().filter(Parameter::isIn).sorted().forEach(this::generateWriteActionParameter);
    buffer.addLine("writer.write_end()");
    buffer.addLine("writer.flush()");
    buffer.addLine("body = buf.getvalue()");
    buffer.addLine("writer.close()");
    buffer.addLine("buf.close()");
    buffer.addLine("request = http.Request(");
    buffer.startBlock();
    buffer.addLine("method='POST',");
    buffer.addLine("path='%%s/%%s' %% (self._path, '%1$s'),", getPath(name));
    buffer.addLine("body=body,");
    buffer.endBlock();
    buffer.addLine(")");
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code in [200]:");
    buffer.startBlock();
    buffer.addLine("action = self._check_action(response)");
    method.parameters().filter(Parameter::isOut).findFirst().ifPresent(this::generateActionResponse);
    buffer.endBlock();
    buffer.addLine("else:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End method:
    buffer.endBlock();
    buffer.addLine();
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<UserSession> sessionDbIdColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return Long.toString(session.getId());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionDbIdColumn, constants.sessionDbId(), "100px");
    AbstractTextColumn<UserSession> userNameColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getUserName();
        }
    };
    userNameColumn.makeSortable(SessionConditionFieldAutoCompleter.USER_NAME);
    // $NON-NLS-1$
    getTable().addColumn(userNameColumn, constants.userNameUser(), "200px");
    AbstractTextColumn<UserSession> authzNameColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getAuthzName();
        }
    };
    authzNameColumn.makeSortable(SessionConditionFieldAutoCompleter.AUTHZ_NAME);
    // $NON-NLS-1$
    getTable().addColumn(authzNameColumn, constants.authorizationProvider(), "300px");
    AbstractTextColumn<UserSession> userIdColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getUserId().toString();
        }
    };
    userIdColumn.makeSortable(SessionConditionFieldAutoCompleter.USER_ID);
    // $NON-NLS-1$
    getTable().addColumn(userIdColumn, constants.userId(), "200px");
    AbstractTextColumn<UserSession> sourceIpColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getSourceIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sourceIpColumn, constants.sourceIp(), "200px");
    final DateTimeFormat dateFormat = DateTimeFormat.getFormat(DateTimeFormat.PredefinedFormat.DATE_TIME_MEDIUM);
    AbstractTextColumn<UserSession> sessionStartColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return dateFormat.format(session.getSessionStartTime());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionStartColumn, constants.sessionStartTime(), "200px");
    AbstractTextColumn<UserSession> sessionLastActiveColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return dateFormat.format(session.getSessionLastActiveTime());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionLastActiveColumn, constants.sessionLastActiveTime(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<UserSession>(constants.terminateSession()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getTerminateCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<UserSession> sessionDbIdColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return Long.toString(session.getId());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionDbIdColumn, constants.sessionDbId(), "100px");
    AbstractTextColumn<UserSession> userNameColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getUserName();
        }
    };
    userNameColumn.makeSortable(SessionConditionFieldAutoCompleter.USER_NAME);
    // $NON-NLS-1$
    getTable().addColumn(userNameColumn, constants.userNameUser(), "200px");
    AbstractTextColumn<UserSession> authzNameColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getAuthzName();
        }
    };
    authzNameColumn.makeSortable(SessionConditionFieldAutoCompleter.AUTHZ_NAME);
    // $NON-NLS-1$
    getTable().addColumn(authzNameColumn, constants.authorizationProvider(), "300px");
    AbstractTextColumn<UserSession> userIdColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getUserId().toString();
        }
    };
    userIdColumn.makeSortable(SessionConditionFieldAutoCompleter.USER_ID);
    // $NON-NLS-1$
    getTable().addColumn(userIdColumn, constants.userId(), "200px");
    AbstractTextColumn<UserSession> sourceIpColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getSourceIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sourceIpColumn, constants.sourceIp(), "200px");
    final DateTimeFormat dateFormat = DateTimeFormat.getFormat(DateTimeFormat.PredefinedFormat.DATE_TIME_MEDIUM);
    AbstractTextColumn<UserSession> sessionStartColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getSessionStartTime() == null ? // $NON-NLS-1$
            "" : dateFormat.format(session.getSessionStartTime());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionStartColumn, constants.sessionStartTime(), "200px");
    AbstractTextColumn<UserSession> sessionLastActiveColumn = new AbstractTextColumn<UserSession>() {

        @Override
        public String getValue(UserSession session) {
            return session.getSessionLastActiveTime() == null ? // $NON-NLS-1$
            "" : dateFormat.format(session.getSessionLastActiveTime());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionLastActiveColumn, constants.sessionLastActiveTime(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<UserSession>(constants.terminateSession()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getTerminateCommand();
        }
    });
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
private boolean internalValidate() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isValidateSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && validate() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getValidationMessages().size() > 0) {
                log.warn("Validation of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getValidationMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during ValidateFailure.", dataAccessEx);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during ValidateFailure.", ex);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean internalValidate() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isValidateSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && validateInputs() && acquireLock() && validate() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getValidationMessages().size() > 0) {
                log.warn("Validation of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getValidationMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during ValidateFailure.", dataAccessEx);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during ValidateFailure.", ex);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
public long getSessionSeqId() {
    if (sessionSeqId == null) {
        sessionSeqId = -1L;
        String sessionId = getContext().getEngineContext().getSessionId();
        // The session may not exists for quartz jobs
        if (getSessionDataContainer().isSessionExists(sessionId)) {
            sessionSeqId = getSessionDataContainer().getEngineSessionSeqId(sessionId);
        }
    }
    return sessionSeqId;
}
#method_after
public long getSessionSeqId() {
    if (sessionSeqId == null) {
        String sessionId = getContext().getEngineContext().getSessionId();
        // The session may not exists for quartz jobs
        sessionSeqId = getSessionDataContainer().isSessionExists(sessionId) ? getSessionDataContainer().getEngineSessionSeqId(sessionId) : SSOSessionUtils.EMPTY_SESSION_SEQ_ID;
    }
    return sessionSeqId;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            returnValue = searchVmsFromDb();
            break;
        case DirectoryGroup:
            returnValue = searchDirectoryGroups();
            break;
        case DirectoryUser:
            returnValue = searchDirectoryUsers();
            break;
        case AuditLog:
            returnValue = searchAuditLogEvents();
            break;
        case DBUser:
            returnValue = searchDbUsers();
            break;
        case DBGroup:
            returnValue = searchDbGroups();
            break;
        case VDS:
            returnValue = searchVDSsByDb();
            break;
        case VmTemplate:
            returnValue = searchVMTemplates();
            break;
        case VmPools:
            returnValue = searchVmPools();
            break;
        case Cluster:
            returnValue = searchClusters();
            break;
        case StoragePool:
            returnValue = searchStoragePool();
            break;
        case StorageDomain:
            returnValue = searchStorageDomain();
            break;
        case Quota:
            returnValue = searchQuota();
            break;
        case Disk:
            returnValue = searchDisk();
            break;
        case GlusterVolume:
            returnValue = searchGlusterVolumes();
            break;
        case Network:
            returnValue = searchNetworks();
            break;
        case Provider:
            returnValue = searchProviders();
            break;
        case InstanceType:
            returnValue = searchInstanceTypes();
            break;
        case ImageType:
            returnValue = searchVMTemplates();
            break;
        case Session:
            returnValue = searchSessions();
            break;
        default:
            log.error("Search object type not handled: {}", getParameters().getSearchTypeValue());
            break;
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            returnValue = searchVmsFromDb();
            break;
        case DirectoryGroup:
            returnValue = searchDirectoryGroups();
            break;
        case DirectoryUser:
            returnValue = searchDirectoryUsers();
            break;
        case AuditLog:
            returnValue = searchAuditLogEvents();
            break;
        case DBUser:
            returnValue = searchDbUsers();
            break;
        case DBGroup:
            returnValue = searchDbGroups();
            break;
        case VDS:
            returnValue = searchVDSsByDb();
            break;
        case VmTemplate:
            returnValue = searchVmTemplates();
            break;
        case VmPools:
            returnValue = searchVmPools();
            break;
        case Cluster:
            returnValue = searchClusters();
            break;
        case StoragePool:
            returnValue = searchStoragePool();
            break;
        case StorageDomain:
            returnValue = searchStorageDomain();
            break;
        case Quota:
            returnValue = searchQuota();
            break;
        case Disk:
            returnValue = searchDisk();
            break;
        case GlusterVolume:
            returnValue = searchGlusterVolumes();
            break;
        case Network:
            returnValue = searchNetworks();
            break;
        case Provider:
            returnValue = searchProviders();
            break;
        case InstanceType:
            returnValue = searchInstanceTypes();
            break;
        case ImageType:
            returnValue = searchImageTypes();
            break;
        case Session:
            returnValue = searchSessions();
            break;
        default:
            log.error("Search object type not handled: {}", getParameters().getSearchTypeValue());
            break;
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#end_block

#method_before
private List<UserSession> searchSessions() {
    return genericSearch(getDbFacade().getEngineSessionDao(), false).stream().map(this::injectSessionInfo).map(UserSession::new).collect(Collectors.toList());
}
#method_after
private List<UserSession> searchSessions() {
    return genericSearch(getDbFacade().getEngineSessionDao(), false).stream().peek(this::injectSessionInfo).map(UserSession::new).collect(Collectors.toList());
}
#end_block

#method_before
private EngineSession injectSessionInfo(EngineSession engineSession) {
    engineSession.setStartTime(getSessionDataContainer().getSessionStartTime(engineSession.getEngineSessionId()));
    engineSession.setLastActiveTime(getSessionDataContainer().getSessionLastActiveTime(engineSession.getEngineSessionId()));
    return engineSession;
}
#method_after
private void injectSessionInfo(EngineSession engineSession) {
    engineSession.setStartTime(getSessionDataContainer().getSessionStartTime(engineSession.getEngineSessionId()));
    engineSession.setLastActiveTime(getSessionDataContainer().getSessionLastActiveTime(engineSession.getEngineSessionId()));
}
#end_block

#method_before
public final void updateSessionLastActiveTime(String sessionId) {
    if (StringUtils.isNotEmpty(sessionId) && isSessionExists(sessionId)) {
        setData(sessionId, SESSION_LAST_ACTIVE_TIME, new Date());
    }
}
#method_after
public final void updateSessionLastActiveTime(String sessionId) {
    if (isSessionExists(sessionId)) {
        setData(sessionId, SESSION_LAST_ACTIVE_TIME, new Date());
    }
}
#end_block

#method_before
public String getUserName(String sessionId) {
    return String.format("%s@%s", getPrincipalName(sessionId), getProfile(sessionId) != null ? getProfile(sessionId).getName() : "N/A");
}
#method_after
public String getUserName(String sessionId) {
    return String.format("%s@%s", getPrincipalName(sessionId), getProfile(sessionId) != null ? getProfile(sessionId).getAuthzName() : "N/A");
}
#end_block

#method_before
public boolean isSessionExists(String sessionId) {
    return sessionInfoMap.containsKey(sessionId);
}
#method_after
public boolean isSessionExists(String sessionId) {
    return StringUtils.isEmpty(sessionId) ? false : sessionInfoMap.containsKey(sessionId);
}
#end_block

#method_before
private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
    // Only remove session if there are no running commands for this session
    if (ssoSessionUtils.isSessionInUse(sessionId)) {
        DbUser dbUser = getUser(sessionId, false);
        log.info("Not removing session '{}', session has running commands{}", sessionId, dbUser == null ? "." : String.format(" for user '%s@%s'.", dbUser.getLoginName(), dbUser.getDomain()));
        return;
    }
    /*
         * So we won't need to add profile to tests
         */
    String authzName = null;
    if (getProfile(sessionId) != null) {
        authzName = getProfile(sessionId).getAuthz().getContext().<String>get(Base.ContextKeys.INSTANCE_NAME);
    }
    AcctUtils.reportRecords(reason, authzName, getPrincipalName(sessionId), message, msgArgs);
    engineSessionDao.remove(getEngineSessionSeqId(sessionId));
    sessionInfoMap.remove(sessionId);
}
#method_after
private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
    // Only remove session if there are no running commands for this session
    if (ssoSessionUtils.isSessionInUse(getEngineSessionSeqId(sessionId))) {
        DbUser dbUser = getUser(sessionId, false);
        log.info("Not removing session '{}', session has running commands{}", sessionId, dbUser == null ? "." : String.format(" for user '%s@%s'.", dbUser.getLoginName(), dbUser.getDomain()));
        return;
    }
    /*
         * So we won't need to add profile to tests
         */
    String authzName = null;
    if (getProfile(sessionId) != null) {
        authzName = getProfile(sessionId).getAuthzName();
    }
    AcctUtils.reportRecords(reason, authzName, getPrincipalName(sessionId), message, msgArgs);
    engineSessionDao.remove(getEngineSessionSeqId(sessionId));
    sessionInfoMap.remove(sessionId);
}
#end_block

#method_before
public String getUserName(String sessionId) {
    return String.format("%s@%s", getPrincipalName(sessionId), getProfile(sessionId) != null ? getProfile(sessionId).getName() : "N/A");
}
#method_after
public String getUserName(String sessionId) {
    return String.format("%s@%s", getPrincipalName(sessionId), getProfile(sessionId) != null ? getProfile(sessionId).getAuthzName() : "N/A");
}
#end_block

#method_before
private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
    // Only remove session if there are no running commands for this session
    if (ssoSessionUtils.isSessionInUse(sessionId)) {
        DbUser dbUser = getUser(sessionId, false);
        log.info("Not removing session '{}', session has running commands{}", sessionId, dbUser == null ? "." : String.format(" for user '%s@%s'.", dbUser.getLoginName(), dbUser.getDomain()));
        return;
    }
    /*
         * So we won't need to add profile to tests
         */
    String authzName = null;
    if (getProfile(sessionId) != null) {
        authzName = getProfile(sessionId).getAuthz().getContext().<String>get(Base.ContextKeys.INSTANCE_NAME);
    }
    AcctUtils.reportRecords(reason, authzName, getPrincipalName(sessionId), message, msgArgs);
    engineSessionDao.remove(getEngineSessionSeqId(sessionId));
    sessionInfoMap.remove(sessionId);
}
#method_after
private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
    // Only remove session if there are no running commands for this session
    if (ssoSessionUtils.isSessionInUse(getEngineSessionSeqId(sessionId))) {
        DbUser dbUser = getUser(sessionId, false);
        log.info("Not removing session '{}', session has running commands{}", sessionId, dbUser == null ? "." : String.format(" for user '%s@%s'.", dbUser.getLoginName(), dbUser.getDomain()));
        return;
    }
    /*
         * So we won't need to add profile to tests
         */
    String authzName = null;
    if (getProfile(sessionId) != null) {
        authzName = getProfile(sessionId).getAuthzName();
    }
    AcctUtils.reportRecords(reason, authzName, getPrincipalName(sessionId), message, msgArgs);
    engineSessionDao.remove(getEngineSessionSeqId(sessionId));
    sessionInfoMap.remove(sessionId);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("engine_session_id", entity.getEngineSessionId()).addValue("user_id", Guid.isNullOrEmpty(entity.getUserId()) ? Guid.Empty : entity.getUserId()).addValue("command_id", Guid.isNullOrEmpty(entity.getId()) ? Guid.Empty : entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("parent_command_id", entity.getParentCommandId()).addValue("root_command_id", Guid.isNullOrEmpty(entity.getRootCommandId()) ? Guid.Empty : entity.getRootCommandId()).addValue("job_id", Guid.isNullOrEmpty(entity.getJobId()) ? Guid.Empty : entity.getJobId()).addValue("step_id", Guid.isNullOrEmpty(entity.getStepId()) ? Guid.Empty : entity.getStepId()).addValue("command_parameters", serializeParameters(entity.getCommandParameters())).addValue("command_params_class", entity.getCommandParameters() == null ? null : entity.getCommandParameters().getClass().getName()).addValue("created_at", entity.getCreatedAt()).addValue("status", entity.getCommandStatus().toString()).addValue("executed", entity.isExecuted()).addValue("callback_enabled", entity.isCallbackEnabled()).addValue("return_value", serializeReturnValue(entity.getReturnValue())).addValue("return_value_class", entity.getReturnValue() == null ? null : entity.getReturnValue().getClass().getName()).addValue("data", SerializationFactory.getSerializer().serialize(entity.getData()));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("engine_session_seq_id", entity.getEngineSessionSeqId()).addValue("user_id", Guid.isNullOrEmpty(entity.getUserId()) ? Guid.Empty : entity.getUserId()).addValue("command_id", Guid.isNullOrEmpty(entity.getId()) ? Guid.Empty : entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("parent_command_id", entity.getParentCommandId()).addValue("root_command_id", Guid.isNullOrEmpty(entity.getRootCommandId()) ? Guid.Empty : entity.getRootCommandId()).addValue("job_id", Guid.isNullOrEmpty(entity.getJobId()) ? Guid.Empty : entity.getJobId()).addValue("step_id", Guid.isNullOrEmpty(entity.getStepId()) ? Guid.Empty : entity.getStepId()).addValue("command_parameters", serializeParameters(entity.getCommandParameters())).addValue("command_params_class", entity.getCommandParameters() == null ? null : entity.getCommandParameters().getClass().getName()).addValue("created_at", entity.getCreatedAt()).addValue("status", entity.getCommandStatus().toString()).addValue("executed", entity.isExecuted()).addValue("callback_enabled", entity.isCallbackEnabled()).addValue("return_value", serializeReturnValue(entity.getReturnValue())).addValue("return_value_class", entity.getReturnValue() == null ? null : entity.getReturnValue().getClass().getName()).addValue("data", SerializationFactory.getSerializer().serialize(entity.getData()));
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new RunAsyncActionCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new ConcurrentChildCommandsExecutionCallback();
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#method_after
protected void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#end_block

#method_before
private boolean internalValidate() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isValidateSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && validate() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getValidationMessages().size() > 0) {
                log.warn("Validation of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getValidationMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during ValidateFailure.", dataAccessEx);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during ValidateFailure.", ex);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean internalValidate() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isValidateSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && validateInputs() && acquireLock() && validate() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getValidationMessages().size() > 0) {
                log.warn("Validation of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getValidationMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during ValidateFailure.", dataAccessEx);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during ValidateFailure.", ex);
        addValidationMessage(EngineMessage.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getContext().getEngineContext().getSessionId(), getUserId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#method_after
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getSessionSeqId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#end_block

#method_before
public VdcQueryReturnValue runQuery(VdcQueryType queryType, VdcQueryParametersBase queryParams) {
    queryParams.setFiltered(isFiltered());
    return backend.runQuery(queryType, sessionize(queryParams));
}
#method_after
public VdcQueryReturnValue runQuery(VdcQueryType queryType, VdcQueryParametersBase queryParams) {
    BackendLocal backend = getBackend();
    queryParams.setFiltered(isFiltered());
    return backend.runQuery(queryType, sessionize(queryParams));
}
#end_block

#method_before
protected VdcReturnValueBase doAction(VdcActionType task, VdcActionParametersBase params) throws BackendFailureException {
    setJobOrStepId(params);
    setCorrelationId(params);
    VdcReturnValueBase result = backend.runAction(task, sessionize(params));
    if (result != null && !result.isValid()) {
        backendFailure(result.getValidationMessages());
    } else if (result != null && !result.getSucceeded()) {
        backendFailure(result.getExecuteFailedMessages());
    }
    assert result != null;
    return result;
}
#method_after
protected VdcReturnValueBase doAction(VdcActionType task, VdcActionParametersBase params) throws BackendFailureException {
    BackendLocal backend = getBackend();
    setJobOrStepId(params);
    setCorrelationId(params);
    VdcReturnValueBase result = backend.runAction(task, sessionize(params));
    if (result != null && !result.isValid()) {
        backendFailure(result.getValidationMessages());
    } else if (result != null && !result.getSucceeded()) {
        backendFailure(result.getExecuteFailedMessages());
    }
    assert result != null;
    return result;
}
#end_block

#method_before
protected void doNonBlockingAction(final VdcActionType task, final VdcActionParametersBase params) {
    setCorrelationId(params);
    setJobOrStepId(params);
    VdcActionParametersBase sp = sessionize(params);
    DbUser currentUser = getCurrent().getUser();
    VdcActionParametersBase logout = currentUser != null ? sessionize(new VdcActionParametersBase()) : null;
    try {
        backend.runAction(VdcActionType.RunAsyncAction, new RunAsyncActionParameters(task, sp));
    } finally {
        if (currentUser != null) {
            backend.logoff(logout);
        }
    }
}
#method_after
protected void doNonBlockingAction(final VdcActionType task, final VdcActionParametersBase params) {
    BackendLocal backend = getBackend();
    setCorrelationId(params);
    setJobOrStepId(params);
    backend.runAction(VdcActionType.RunAsyncAction, sessionize(new RunAsyncActionParameters(task, sessionize(params))));
}
#end_block

#method_before
@Before
public void setUpContainer() {
    when(engineSessionDao.remove(any(Long.class))).thenReturn(1);
    when(ssoSessionValidator.isSessionValid(anyString())).thenReturn(true);
    when(ssoSessionUtils.isSessionInUse(anyString())).thenReturn(false);
    DbUser user = mock(DbUser.class);
    container.setSSOSessionUtils(ssoSessionUtils);
    container.setSSOSessionValidaor(ssoSessionValidator);
    container.setUser(TEST_SESSION_ID, user);
}
#method_after
@Before
public void setUpContainer() {
    when(engineSessionDao.remove(any(Long.class))).thenReturn(1);
    when(ssoSessionValidator.isSessionValid(anyString())).thenReturn(true);
    when(ssoSessionUtils.isSessionInUse(anyLong())).thenReturn(false);
    DbUser user = mock(DbUser.class);
    container.setUser(TEST_SESSION_ID, user);
}
#end_block

#method_before
@Test
public void testCleanExpiredSessionsWithRunningCommands() {
    when(ssoSessionUtils.isSessionInUse(TEST_SESSION_ID)).thenReturn(true);
    initDataForClearTest(TEST_KEY);
    // Clear expired sessions - data is moved to older generation
    // nothing should happen as far as the user is concerned
    container.cleanExpiredUsersSessions();
    assertNotNull("Get found the session", container.getData(TEST_SESSION_ID, TEST_KEY, false));
}
#method_after
@Test
public void testCleanExpiredSessionsWithRunningCommands() {
    when(ssoSessionUtils.isSessionInUse(anyLong())).thenReturn(true);
    initDataForClearTest(TEST_KEY);
    // Clear expired sessions - data is moved to older generation
    // nothing should happen as far as the user is concerned
    container.cleanExpiredUsersSessions();
    assertNotNull("Get found the session", container.getData(TEST_SESSION_ID, TEST_KEY, false));
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    // Mock the parameters
    actionGroup = RandomUtils.instance().pickRandom(ActionGroup.values());
    when(getQueryParameters().getActionGroup()).thenReturn(actionGroup);
    sessionID = RandomUtils.instance().nextString(10);
    when(getQueryParameters().getSessionId()).thenReturn(sessionID);
    when(engineSessionDao.save(any(EngineSession.class))).thenReturn(RandomUtils.instance().nextLong());
    when(engineSessionDao.remove(any(Long.class))).thenReturn(1);
    when(ssoSessionUtils.isSessionInUse(anyString())).thenReturn(false);
    sessionDataContainer.setSSOSessionUtils(ssoSessionUtils);
    sessionDataContainer.setUser(sessionID, getUser());
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    // Mock the parameters
    actionGroup = RandomUtils.instance().pickRandom(ActionGroup.values());
    when(getQueryParameters().getActionGroup()).thenReturn(actionGroup);
    sessionID = RandomUtils.instance().nextString(10);
    when(getQueryParameters().getSessionId()).thenReturn(sessionID);
    when(engineSessionDao.save(any(EngineSession.class))).thenReturn(RandomUtils.instance().nextLong());
    when(engineSessionDao.remove(any(Long.class))).thenReturn(1);
    when(ssoSessionUtils.isSessionInUse(anyLong())).thenReturn(false);
    sessionDataContainer.setUser(sessionID, getUser());
}
#end_block

#method_before
public static CommandEntity buildCommandEntity(String engineSessionId, Guid userId, Guid commandId, Guid parentCommandId, Guid rootCommandId, Guid jobId, Guid stepId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status, boolean callbackEnabled, VdcReturnValueBase returnValue, Map<String, Serializable> data) {
    CommandEntity entity = new CommandEntity();
    entity.setEngineSessionId(engineSessionId);
    entity.setUserId(userId);
    entity.setId(commandId);
    entity.setParentCommandId(parentCommandId);
    entity.setRootCommandId(rootCommandId);
    entity.setJobId(jobId);
    entity.setStepId(stepId);
    entity.setCommandType(actionType);
    entity.setCommandParameters(params);
    entity.setCommandStatus(status);
    entity.setCallbackEnabled(callbackEnabled);
    entity.setReturnValue(returnValue);
    entity.setData(data);
    return entity;
}
#method_after
public static CommandEntity buildCommandEntity(Guid userId, long engineSessionSeqId, Guid commandId, Guid parentCommandId, Guid rootCommandId, Guid jobId, Guid stepId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status, boolean callbackEnabled, VdcReturnValueBase returnValue, Map<String, Serializable> data) {
    CommandEntity entity = new CommandEntity();
    entity.setEngineSessionSeqId(engineSessionSeqId);
    entity.setUserId(userId);
    entity.setId(commandId);
    entity.setParentCommandId(parentCommandId);
    entity.setRootCommandId(rootCommandId);
    entity.setJobId(jobId);
    entity.setStepId(stepId);
    entity.setCommandType(actionType);
    entity.setCommandParameters(params);
    entity.setCommandStatus(status);
    entity.setCallbackEnabled(callbackEnabled);
    entity.setReturnValue(returnValue);
    entity.setData(data);
    return entity;
}
#end_block

#method_before
@Override
protected String getRemoveQosMessage(int size) {
    return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage();
}
#method_after
@Override
protected String getRemoveQosMessage(int size) {
    return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage(size);
}
#end_block

#method_before
public static MultipleActionsRunner createMultipleActionsRunner(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, CommandContext commandContext) {
    MultipleActionsRunner runner;
    switch(actionType) {
        case DeactivateStorageDomainWithOvfUpdate:
            runner = new DeactivateStorageDomainsMultipleActionRunner(actionType, parameters, commandContext, isInternal);
            break;
        case AttachStorageDomainToPool:
            runner = new AttachStorageDomainsMultipleActionRunner(actionType, parameters, commandContext, isInternal);
            break;
        case RunVm:
            runner = new RunVMActionRunner(actionType, parameters, commandContext, isInternal);
            break;
        case MigrateVm:
            runner = new MigrateVMActionRunner(actionType, parameters, commandContext, isInternal);
            break;
        case RemoveVmFromPool:
            runner = new RemoveVmFromPoolRunner(actionType, parameters, commandContext, isInternal);
            break;
        case StartGlusterVolume:
        case StopGlusterVolume:
        case DeleteGlusterVolume:
        case SetGlusterVolumeOption:
        case ResetGlusterVolumeOptions:
        // AddVds is called with multiple actions *only* in case of gluster clusters
        case AddVds:
        case RemoveGlusterServer:
        case EnableGlusterHook:
        case DisableGlusterHook:
        case DeleteGlusterVolumeSnapshot:
            runner = new GlusterMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
        case RemoveVds:
            if (containsGlusterServer(parameters)) {
                runner = new GlusterMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            } else {
                runner = new PrevalidatingMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            }
            break;
        case PersistentHostSetupNetworks:
            runner = new ParallelMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
        case AttachNetworkToCluster:
        case DetachNetworkToCluster:
        case UpdateNetworkOnCluster:
            throw new UnsupportedOperationException("Multiple network attachments/detachments/updates should be run through ManageNetworkClustersCommand!");
        case AddNetworkAttachment:
        case UpdateNetworkAttachment:
        case RemoveNetworkAttachment:
            throw new UnsupportedOperationException("AddNetworkAttachment, UpdateNetworkAttachment, and RemoveNetworkAttachment cannot be run using MultipleActionsRunner");
        case RemoveDiskProfile:
        case RemoveCpuProfile:
            runner = new SequentialMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
        default:
            runner = new PrevalidatingMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
    }
    return runner;
}
#method_after
public static MultipleActionsRunner createMultipleActionsRunner(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, CommandContext commandContext) {
    MultipleActionsRunner runner;
    switch(actionType) {
        case DeactivateStorageDomainWithOvfUpdate:
            runner = new DeactivateStorageDomainsMultipleActionRunner(actionType, parameters, commandContext, isInternal);
            break;
        case AttachStorageDomainToPool:
            runner = new AttachStorageDomainsMultipleActionRunner(actionType, parameters, commandContext, isInternal);
            break;
        case RunVm:
            runner = new RunVMActionRunner(actionType, parameters, commandContext, isInternal);
            break;
        case MigrateVm:
            runner = new MigrateVMActionRunner(actionType, parameters, commandContext, isInternal);
            break;
        case RemoveVmFromPool:
            runner = new RemoveVmFromPoolRunner(actionType, parameters, commandContext, isInternal);
            break;
        case StartGlusterVolume:
        case StopGlusterVolume:
        case DeleteGlusterVolume:
        case SetGlusterVolumeOption:
        case ResetGlusterVolumeOptions:
        // AddVds is called with multiple actions *only* in case of gluster clusters
        case AddVds:
        case RemoveGlusterServer:
        case EnableGlusterHook:
        case DisableGlusterHook:
        case DeleteGlusterVolumeSnapshot:
            runner = new GlusterMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
        case RemoveVds:
            if (containsGlusterServer(parameters)) {
                runner = new GlusterMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            } else {
                runner = new PrevalidatingMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            }
            break;
        case PersistentHostSetupNetworks:
            runner = new ParallelMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
        case AttachNetworkToCluster:
        case DetachNetworkToCluster:
        case UpdateNetworkOnCluster:
            throw new UnsupportedOperationException("Multiple network attachments/detachments/updates should be run through ManageNetworkClustersCommand!");
        case AddNetworkAttachment:
        case UpdateNetworkAttachment:
        case RemoveNetworkAttachment:
            throw new UnsupportedOperationException("AddNetworkAttachment, UpdateNetworkAttachment, and RemoveNetworkAttachment cannot be run using MultipleActionsRunner");
        case RemoveDiskProfile:
        case RemoveCpuProfile:
            runner = new SequentialMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
        default:
            runner = new PrevalidatingMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
    }
    return Injector.injectMembers(runner);
}
#end_block

#method_before
private void initCommandsAndReturnValues(ArrayList<VdcReturnValueBase> returnValues) {
    VdcReturnValueBase returnValue;
    for (VdcActionParametersBase parameter : getParameters()) {
        parameter.setMultipleAction(true);
        returnValue = ExecutionHandler.evaluateCorrelationId(parameter);
        if (returnValue == null) {
            CommandBase<?> command = isInternal ? CommandsFactory.createCommand(actionType, parameter, commandContext != null ? commandContext.clone().withoutCompensationContext() : null) : CommandsFactory.createCommand(actionType, parameter);
            command.setInternalExecution(isInternal);
            getCommands().add(command);
        } else {
            returnValues.add(returnValue);
        }
    }
}
#method_after
private void initCommandsAndReturnValues(ArrayList<VdcReturnValueBase> returnValues) {
    VdcReturnValueBase returnValue;
    for (VdcActionParametersBase parameter : getParameters()) {
        parameter.setMultipleAction(true);
        returnValue = ExecutionHandler.evaluateCorrelationId(parameter);
        if (returnValue == null) {
            getCommands().add(commandFactory.createWrappedCommand(commandContext, actionType, parameter, isInternal));
        } else {
            returnValues.add(returnValue);
        }
    }
}
#end_block

#method_before
/**
 * Executes commands which passed validation and creates monitoring objects.
 *
 * @param command
 *            The command to execute
 */
protected void executeValidatedCommand(CommandBase<?> command) {
    if (commandContext == null || commandContext.getExecutionContext() == null || commandContext.getExecutionContext().isMonitored()) {
        ExecutionHandler.prepareCommandForMonitoring(command, command.getActionType(), command.isInternalExecution());
    }
    CorrelationIdTracker.setCorrelationId(command.getCorrelationId());
    command.executeAction();
}
#method_after
/**
 * Executes commands which passed validation and creates monitoring objects.
 *
 * @param command
 *            The command to execute
 */
protected void executeValidatedCommand(CommandBase<?> command) {
    commandFactory.prepareCommandForMonitoring(commandContext, command);
    command.executeAction();
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> execute() {
    for (VdcActionParametersBase parameter : parameters) {
        CommandBase<?> command = isInternal ? CommandsFactory.createCommand(actionType, parameter, commandContext != null ? commandContext.clone().withoutCompensationContext() : null) : CommandsFactory.createCommand(actionType, parameter);
        returnValues.add(executeCommand(command));
    }
    return returnValues;
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> execute() {
    for (VdcActionParametersBase parameter : parameters) {
        CommandBase<?> command = commandFactory.createWrappedCommand(commandContext, actionType, parameter, isInternal);
        commandFactory.prepareCommandForMonitoring(commandContext, command);
        returnValues.add(command.executeAction());
    }
    return returnValues;
}
#end_block

#method_before
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci()) {
        return true;
    }
    return VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion());
}
#method_after
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci()) {
        return true;
    }
    return VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (vmFromParams.getClusterArch().getFamily() == ArchitectureType.ppc)) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(diskInfoDestinationMap.values(), true, false, true);
        for (DiskImage diskImage : diskImages) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(diskInfoDestinationMap.values(), true, false, true);
        for (DiskImage diskImage : diskImages) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = VmDeviceUtils.hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion()) && isOsSupportedForVirtIoScsi;
}
#method_after
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : isOsSupportedForVirtIoScsi;
}
#end_block

#method_before
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getCluster().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getCluster().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData(), getCluster());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    autoSelectGraphicsDevice();
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getCluster().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getCluster().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    autoSelectGraphicsDevice();
}
#end_block

#method_before
public void dataCenterWithClusterSelectedItemChanged() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
    getModel().getIsRngEnabled().setIsChangeable(isRngDeviceSupported(getModel()));
    if (!getModel().getIsRngEnabled().getIsChangable()) {
        getModel().getIsRngEnabled().setChangeProhibitionReason(constants.rngNotSupportedByCluster());
    }
    setRngAvailability();
    postDataCenterWithClusterSelectedItemChanged();
}
#method_after
public void dataCenterWithClusterSelectedItemChanged() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
    getModel().getIsRngEnabled().setIsChangeable(true);
    setRngAvailability();
    postDataCenterWithClusterSelectedItemChanged();
}
#end_block

#method_before
protected void updateCpuSharesAvailability() {
    if (getModel().getSelectedCluster() != null) {
        boolean availableCpuShares = getModel().getCompatibilityVersion().compareTo(Version.v3_3) >= 0;
        getModel().getCpuSharesAmountSelection().setIsAvailable(availableCpuShares);
        getModel().getCpuSharesAmount().setIsAvailable(availableCpuShares);
    }
}
#method_after
protected void updateCpuSharesAvailability() {
    if (getModel().getSelectedCluster() != null) {
        getModel().getCpuSharesAmountSelection().setIsAvailable(true);
        getModel().getCpuSharesAmount().setIsAvailable(true);
    }
}
#end_block

#method_before
protected void updateVirtioScsiAvailability() {
    boolean isVirtioScsiEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, getModel().getCompatibilityVersion().getValue());
    getModel().getIsVirtioScsiEnabled().setIsAvailable(isVirtioScsiEnabled);
}
#method_after
protected void updateVirtioScsiAvailability() {
    getModel().getIsVirtioScsiEnabled().setIsAvailable(true);
}
#end_block

#method_before
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        String compatibilityVersion = getModel().getCompatibilityVersion().toString();
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getInstance().getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            if (isLocalSD) {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailableLocalStorage());
            } else {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            }
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
    }
}
#method_after
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getInstance().getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            if (isLocalSD) {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailableLocalStorage());
            } else {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            }
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
    }
}
#end_block

#method_before
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getCompatibilityVersion() != null && getCompatibilityVersion().compareTo(Version.v3_2) >= 0;
    boolean nonMigratable = MigrationSupport.PINNED_TO_HOST == getModel().getMigrationMode().getSelectedItem();
    boolean usingPpcArch = hostHasPpcArchitecture();
    if (clusterSupportsHostCpu && nonMigratable && !usingPpcArch) {
        getModel().getHostCpu().setIsChangeable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
        getModel().getHostCpu().setIsChangeable(false);
    }
}
#method_after
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getCompatibilityVersion() != null;
    boolean nonMigratable = MigrationSupport.PINNED_TO_HOST == getModel().getMigrationMode().getSelectedItem();
    if (clusterSupportsHostCpu && nonMigratable && !clusterHasPpcArchitecture()) {
        getModel().getHostCpu().setIsChangeable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
        getModel().getHostCpu().setIsChangeable(false);
    }
}
#end_block

#method_before
public void threadsPerCoreChanged() {
    final int threadsPerCore = extractIntFromListModel(getModel().getThreadsPerCore());
    final int totalCpuCores = getTotalCpuCores();
    Collection<Integer> possCoresPerSocket = getModel().getCoresPerSocket().getItems();
    if (threadsPerCore == 0 || totalCpuCores == 0 || possCoresPerSocket.isEmpty()) {
        return;
    }
    // maximize the number of sockets
    int coresPerSocket = 1;
    int numOfSockets = totalCpuCores / (threadsPerCore * coresPerSocket);
    getModel().getCoresPerSocket().setSelectedItem(coresPerSocket);
    getModel().getNumOfSockets().setSelectedItem(numOfSockets);
}
#method_after
public void threadsPerCoreChanged() {
    final int threadsPerCore = extractIntFromListModel(getModel().getThreadsPerCore());
    final int totalCpuCores = getTotalCpuCores();
    Collection<Integer> possCoresPerSocket = getModel().getCoresPerSocket().getItems();
    if (threadsPerCore == 0 || totalCpuCores == 0 || possCoresPerSocket == null || possCoresPerSocket.isEmpty()) {
        return;
    }
    // maximize the number of sockets
    int coresPerSocket = 1;
    int numOfSockets = totalCpuCores / (threadsPerCore * coresPerSocket);
    getModel().getCoresPerSocket().setSelectedItem(coresPerSocket);
    getModel().getNumOfSockets().setSelectedItem(numOfSockets);
}
#end_block

#method_before
public void updateNumOfIoThreads() {
    Version compatibilityVersion = getCompatibilityVersion();
    if (compatibilityVersion == null) {
        return;
    }
    getModel().getIoThreadsEnabled().updateChangeability(ConfigurationValues.IoThreadsSupported, compatibilityVersion);
    getModel().getNumOfIoThreads().updateChangeability(ConfigurationValues.IoThreadsSupported, compatibilityVersion);
    if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.IoThreadsSupported, compatibilityVersion.getValue())) {
        getModel().getNumOfIoThreads().setIsAvailable(getModel().getIoThreadsEnabled().getEntity());
        if (getModel().getIoThreadsEnabled().getEntity() && getModel().getNumOfIoThreads().getEntity() == 0) {
            getModel().getNumOfIoThreads().setEntity(DEFAULT_NUM_OF_IOTHREADS);
        }
    }
}
#method_after
public void updateNumOfIoThreads() {
    getModel().getIoThreadsEnabled().setIsChangeable(true);
    getModel().getNumOfIoThreads().setIsChangeable(true);
    getModel().getNumOfIoThreads().setIsAvailable(getModel().getIoThreadsEnabled().getEntity());
    if (getModel().getIoThreadsEnabled().getEntity() && getModel().getNumOfIoThreads().getEntity() == 0) {
        getModel().getNumOfIoThreads().setEntity(DEFAULT_NUM_OF_IOTHREADS);
    }
}
#end_block

#method_before
protected void updateCpuProfile(Guid clusterId, Version clusterCompatibilityVersion, Guid cpuProfileId) {
    if (Boolean.TRUE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuQosSupported, clusterCompatibilityVersion.getValue()))) {
        getModel().getCpuProfiles().setIsAvailable(true);
        fetchCpuProfiles(clusterId, cpuProfileId);
    } else {
        getModel().getCpuProfiles().setIsAvailable(false);
    }
}
#method_after
protected void updateCpuProfile(Guid clusterId, Guid cpuProfileId) {
    getModel().getCpuProfiles().setIsAvailable(true);
    fetchCpuProfiles(clusterId, cpuProfileId);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    VmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData(), getCluster());
    VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    VmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int threadsPerCpu = newVmStatic.getThreadsPerCpu();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets, threadsPerCpu);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets, int newThreadsPerCpu) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    int currentThreadsPerCpu = getVm().getThreadsPerCpu();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket && currentThreadsPerCpu == newThreadsPerCpu) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        hotSetCpusLog(params);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        hotSetCpusLog(params);
    }
}
#end_block

#method_before
private void hotSetMemory(int newAmountOfMemory) {
    int currentMemory = getVm().getMemSizeMb();
    if (getVm().getStatus() == VMStatus.Up && currentMemory != newAmountOfMemory) {
        HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
        0);
        VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
        hotSetMemlog(params, setAmountOfMemoryResult);
    }
}
#method_after
private void hotSetMemory(int currentMemory, int newAmountOfMemory) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
    }
    hotSetMemlog(params, setAmountOfMemoryResult);
}
#end_block

#method_before
private void hotSetMemlog(HotSetAmountOfMemoryParameters params, VdcReturnValueBase setAmountOfMemoryResult) {
    if (!setAmountOfMemoryResult.isValid()) {
        AuditLogableBase logable = new HotSetAmountOfMemoryCommand<>(params, null);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setAmountOfMemoryResult.getValidationMessages());
        logable.addCustomValue(HotSetAmountOfMemoryCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetMemlog(HotSetAmountOfMemoryParameters params, VdcReturnValueBase setAmountOfMemoryResult) {
    if (!setAmountOfMemoryResult.isValid()) {
        AuditLogableBase logable = new HotSetAmountOfMemoryCommand<>(params, null);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setAmountOfMemoryResult.getValidationMessages());
        logable.addCustomValue(HotSetAmountOfMemoryCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_MEMORY);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (vmFromDB.getClusterArch().getFamily() == ArchitectureType.ppc)) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    injectorRule.bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setClusterId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params, null) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public Cluster getCluster() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(VdcActionType.UpdateVm).when(command).getActionType();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_6;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    injectorRule.bind(DbFacade.class, dbFacade);
    injectorRule.bind(InClusterUpgradeValidator.class, inClusterUpgradeValidator);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setClusterId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params, null) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public Cluster getCluster() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(VdcActionType.UpdateVm).when(command).getActionType();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#end_block

#method_before
@Test
public void testChangeClusterForbidden() {
    prepareVmToPassValidate();
    Cluster newGroup = new Cluster();
    newGroup.setId(Guid.newGuid());
    newGroup.setCompatibilityVersion(Version.v3_0);
    vmStatic.setClusterId(newGroup.getId());
    doReturn(clusterDao).when(command).getClusterDao();
    assertFalse("validate should have failed with can't change cluster.", command.validate());
    assertValidateMessage(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
}
#method_after
@Test
public void testChangeClusterForbidden() {
    prepareVmToPassValidate();
    Cluster newGroup = new Cluster();
    newGroup.setId(Guid.newGuid());
    newGroup.setCompatibilityVersion(Version.v3_6);
    vmStatic.setClusterId(newGroup.getId());
    doReturn(clusterDao).when(command).getClusterDao();
    assertFalse("validate should have failed with can't change cluster.", command.validate());
    assertValidateMessage(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
}
#end_block

#method_before
@Test
public void testUnsupportedCpus() {
    prepareVmToPassValidate();
    // prepare the mock values
    HashMap<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    HashSet<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(0, Version.v3_0), value);
    when(osRepository.isCpuSupported(0, Version.v3_0, CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    command.initEffectiveCompatibilityVersion();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#method_after
@Test
public void testUnsupportedCpus() {
    prepareVmToPassValidate();
    // prepare the mock values
    HashMap<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    HashSet<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(0, Version.v3_6), value);
    when(osRepository.isCpuSupported(0, Version.v3_6, CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    command.initEffectiveCompatibilityVersion();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#end_block

#method_before
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassValidate();
    group.setCompatibilityVersion(Version.v3_3);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassValidate();
    group.setCompatibilityVersion(Version.v4_0);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
@Test
public void testBlockUseHostCpuWithPPCArch() {
    // given
    prepareVmToPassValidate();
    command.initEffectiveCompatibilityVersion();
    vm.setClusterArch(ArchitectureType.ppc64le);
    vmStatic.setUseHostCpuFlags(true);
    vmStatic.setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    // when
    boolean validInput = command.validate();
    // then
    assertFalse("validate should fail with can't use host CPU.", validInput);
    assertValidateMessage(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
}
#method_after
@Test
public void testBlockUseHostCpuWithPPCArch() {
    // given
    prepareVmToPassValidate();
    command.initEffectiveCompatibilityVersion();
    vm.setClusterArch(ArchitectureType.ppc64le);
    group.setArchitecture(ArchitectureType.ppc);
    when(osRepository.getArchitectureFromOS(OsType.Windows.ordinal())).thenReturn(ArchitectureType.ppc);
    vmStatic.setUseHostCpuFlags(true);
    vmStatic.setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    // when
    boolean validInput = command.validate();
    // then
    assertFalse("validate should fail with can't use host CPU.", validInput);
    assertValidateMessage(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
}
#end_block

#method_before
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockClusterDaoReturnCluster();
    mockVmTemplateDaoReturnVmTemplate();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockOsRepository();
    mockOsRepositoryGraphics(0, Version.v3_3, new Pair<>(GraphicsType.SPICE, DisplayType.qxl));
    mockGraphicsDevices(vm.getId());
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
}
#method_after
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockClusterDaoReturnCluster();
    mockVmTemplateDaoReturnVmTemplate();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockOsRepository();
    mockOsRepositoryGraphics(0, Version.v4_0, new Pair<>(GraphicsType.SPICE, DisplayType.qxl));
    mockGraphicsDevices(vm.getId());
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
}
#end_block

#method_before
private Cluster createCluster() {
    if (cluster == null) {
        cluster = new Cluster();
        cluster.setClusterId(Guid.newGuid());
        cluster.setCompatibilityVersion(Version.v3_3);
        cluster.setCpuName("Intel Conroe Family");
        cluster.setArchitecture(ArchitectureType.x86_64);
    }
    return cluster;
}
#method_after
private Cluster createCluster() {
    if (cluster == null) {
        cluster = new Cluster();
        cluster.setClusterId(Guid.newGuid());
        cluster.setCompatibilityVersion(Version.v4_0);
        cluster.setCpuName("Intel Conroe Family");
        cluster.setArchitecture(ArchitectureType.x86_64);
    }
    return cluster;
}
#end_block

#method_before
private Cluster createPpcCluster() {
    if (cluster == null) {
        cluster = new Cluster();
        cluster.setClusterId(Guid.newGuid());
        cluster.setCompatibilityVersion(Version.v3_3);
        cluster.setCpuName("PPC8");
        cluster.setArchitecture(ArchitectureType.ppc64);
    }
    return cluster;
}
#method_after
private Cluster createPpcCluster() {
    if (cluster == null) {
        cluster = new Cluster();
        cluster.setClusterId(Guid.newGuid());
        cluster.setCompatibilityVersion(Version.v4_0);
        cluster.setCpuName("PPC8");
        cluster.setArchitecture(ArchitectureType.ppc64);
    }
    return cluster;
}
#end_block

#method_before
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
    mcr.mockConfigValue(ConfigValues.VirtIoScsiEnabled, Version.v3_3, true);
    mcr.mockConfigValue(ConfigValues.ValidNumOfMonitors, Arrays.asList("1,2,4".split(",")));
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, Version.v3_3, migrationMap);
    mcr.mockConfigValue(ConfigValues.MaxIoThreadsPerVm, 127);
}
#method_after
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.ValidNumOfMonitors, Arrays.asList("1,2,4".split(",")));
    mcr.mockConfigValue(ConfigValues.IsMigrationSupported, Version.v4_0, migrationMap);
    mcr.mockConfigValue(ConfigValues.MaxIoThreadsPerVm, 127);
}
#end_block

#method_before
@Test
public void testBlockUseHostCpuWithPPCArch() {
    mockConfig();
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.setEffectiveCompatibilityVersion(Version.v3_3);
    doReturn(Collections.<DiskImageBase>emptyList()).when(cmd).getImagesToCheckDestinationStorageDomains();
    Cluster cluster = createPpcCluster();
    when(clusterDao.get(any(Guid.class))).thenReturn(cluster);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    doReturn(clusterDao).when(dbFacade).getClusterDao();
    doReturn(true).when(cmd).areParametersLegal(Collections.<String>emptyList());
    doReturn(true).when(cmd).validateAddVmCommand();
    doReturn(true).when(cmd).isVmNameValidLength(any(VM.class));
    mockOsRepository();
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.ppc64);
    cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    cmd.getParameters().getVm().setUseHostCpuFlags(true);
    cmd.getParameters().getVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    cmd.getParameters().getVm().setClusterId(cluster.getId());
    cmd.getParameters().getVm().setVmOs(2);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
}
#method_after
@Test
public void testBlockUseHostCpuWithPPCArch() {
    mockConfig();
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.setEffectiveCompatibilityVersion(Version.v4_0);
    doReturn(Collections.<DiskImageBase>emptyList()).when(cmd).getImagesToCheckDestinationStorageDomains();
    Cluster cluster = createPpcCluster();
    when(clusterDao.get(any(Guid.class))).thenReturn(cluster);
    doReturn(clusterDao).when(dbFacade).getClusterDao();
    doReturn(true).when(cmd).areParametersLegal(Collections.<String>emptyList());
    doReturn(true).when(cmd).validateAddVmCommand();
    doReturn(true).when(cmd).isVmNameValidLength(any(VM.class));
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.ppc64);
    cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    cmd.getParameters().getVm().setUseHostCpuFlags(true);
    cmd.getParameters().getVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    cmd.getParameters().getVm().setClusterId(cluster.getId());
    cmd.getParameters().getVm().setVmOs(OsType.Other.ordinal());
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid qosId = getQosId();
    HostNetworkQos oldQos = getQosDao().get(qosId);
    HostNetworkQos newQos = getQos();
    super.executeCommand();
    if (setupNetworksSupported() && networkUpdateRequired(oldQos, newQos)) {
        applyNetworkChangesToHosts();
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid qosId = getQosId();
    HostNetworkQos oldQos = getQosDao().get(qosId);
    HostNetworkQos newQos = getQos();
    super.executeCommand();
    if (networkUpdateRequired(oldQos, newQos)) {
        applyNetworkChangesToHosts();
    }
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> createPersistentHostSetupNetworksParameters() {
    List<Network> networksHavingAlteredQos = networkDao.getAllForQos(getQosId());
    Map<Guid, List<Network>> vdsIdToNetworkIds = getVdsToNetworkIdsMap(networksHavingAlteredQos);
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Map.Entry<Guid, List<Network>> entry : vdsIdToNetworkIds.entrySet()) {
        Guid hostId = entry.getKey();
        List<Network> networks = entry.getValue();
        PersistentHostSetupNetworksParameters setupNetworkParams = createPersistentHostSetupNetworksParameters(hostId, networks);
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> createPersistentHostSetupNetworksParameters() {
    List<Network> networksHavingAlteredQos = networkDao.getAllForQos(getQosId());
    Map<Guid, List<Network>> vdsIdToNetworksOfAlteredQos = getHostIdToNetworksMap(networksHavingAlteredQos);
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Map.Entry<Guid, List<Network>> entry : vdsIdToNetworksOfAlteredQos.entrySet()) {
        Guid hostId = entry.getKey();
        List<Network> networksOfAlteredQos = entry.getValue();
        PersistentHostSetupNetworksParameters setupNetworkParams = createPersistentHostSetupNetworksParameters(hostId, networksOfAlteredQos);
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#end_block

#method_before
private String getNetworkNames(List<Network> networks) {
    return networks.stream().map(Network::getName).collect(Collectors.joining(","));
}
#method_after
private String getNetworkNames(List<Network> networks) {
    return StringUtils.join(Entities.objectNames(networks), ", ");
}
#end_block

#method_before
private List<NetworkAttachment> getNetworkAttachmentsToSync(Guid hostId, List<Network> networks) {
    List<NetworkAttachment> allAttachmentsOfHost = networkAttachmentDao.getAllForHost(hostId);
    Map<Guid, NetworkAttachment> attachmentsByNetworkId = new MapNetworkAttachments(allAttachmentsOfHost).byNetworkId();
    List<NetworkAttachment> attachmentsToSync = new ArrayList<>();
    for (Network network : networks) {
        Guid networkId = network.getId();
        NetworkAttachment attachmentToSync = attachmentsByNetworkId.get(networkId);
        attachmentToSync.setOverrideConfiguration(true);
        attachmentsToSync.add(attachmentToSync);
    }
    return attachmentsToSync;
}
#method_after
private List<NetworkAttachment> getNetworkAttachmentsToSync(Guid hostId, List<Network> networks) {
    List<NetworkAttachment> allAttachmentsOfHost = networkAttachmentDao.getAllForHost(hostId);
    Map<Guid, NetworkAttachment> attachmentsByNetworkId = new MapNetworkAttachments(allAttachmentsOfHost).byNetworkId();
    List<NetworkAttachment> attachmentsToSync = new ArrayList<>();
    for (Network network : networks) {
        Guid networkId = network.getId();
        NetworkAttachment attachmentToSync = attachmentsByNetworkId.get(networkId);
        if (!attachmentToSync.isQosOverridden()) {
            attachmentToSync.setOverrideConfiguration(true);
            attachmentsToSync.add(attachmentToSync);
        }
    }
    return attachmentsToSync;
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    VM vm = getVmDao().get(getVmIdFromSnapshot());
    VmHandler.updateDisksFromDb(vm);
    boolean isCinderDisksExists = !ImagesHandler.filterDisksBasedOnCinder(vm.getDiskList()).isEmpty();
    getParameters().setUseCinderCommandCallback(isCinderDisksExists);
}
#method_after
@Override
protected void init() {
    super.init();
    VM vm = getVmDao().get(getVmIdFromSnapshot());
    VmHandler.updateDisksFromDb(vm);
    boolean isCinderDisksExist = !ImagesHandler.filterDisksBasedOnCinder(vm.getDiskList()).isEmpty();
    getParameters().setUseCinderCommandCallback(isCinderDisksExist);
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return Injector.injectMembers(new MergeCommandCallback(getCommandId(), getParameters().getVmJobId()));
}
#method_after
@Override
public CommandCallback getCallback() {
    return Injector.injectMembers(new MergeCommandCallback());
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
// // If the VM Job exists, the command is still active
// boolean isRunning = false;
// MergeCommand<MergeParameters> command = getCommand(cmdId);
// VMStatus vmStatus = DbFacade.getInstance().getVmDynamicDao().get(command.getParameters().getVmId()).getStatus();
// List<VmJob> vmJobs = DbFacade.getInstance().getVmJobDao().getAllForVmDisk(
// command.getParameters().getVmId(),
// command.getParameters().getImageGroupId());
// for (VmJob vmJob : vmJobs) {
// if (vmJob.getId().equals(command.getParameters().getVmJobId())) {
// if (vmStatus == VMStatus.Down) {
// DbFacade.getInstance().getVmJobDao().remove(vmJob.getId());
// log.info("VM '{}' is down, Merge command '{}' removed",
// command.getParameters().getVmId(), vmJob.getId());
// } else {
// log.info("Waiting on merge command to complete");
// isRunning = true;
// }
// break;
// }
// }
// 
// if (!isRunning) {
// // It finished; a command will be called later to determine the status.
// command.setSucceeded(true);
// command.setCommandStatus(CommandStatus.SUCCEEDED);
// command.persistCommand(command.getParameters().getParentCommand(), true);
// log.info("Merge command has completed for images '{}'..'{}'",
// command.getParameters().getBaseImage().getImageId(),
// command.getParameters().getTopImage().getImageId());
// }
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    MergeCommand<MergeParameters> command = getCommand(cmdId);
    Guid jobId = command.getParameters().getVmJobId();
    VmJob vmJob = vmJobsMonitoring.getJobById(jobId);
    // If the VM Job exists, the command is still active
    if (vmJob != null) {
        log.info("Waiting on merge command to complete");
        return;
    }
    // It finished; a command will be called later to determine the status.
    command.setSucceeded(true);
    command.setCommandStatus(CommandStatus.SUCCEEDED);
    command.persistCommand(command.getParameters().getParentCommand(), true);
    log.info("Merge command has completed for images '{}'..'{}'", command.getParameters().getBaseImage().getImageId(), command.getParameters().getTopImage().getImageId());
}
#end_block

#method_before
@PostConstruct
void init() {
    jobsRepository.putAll(getVmJobDao().getAll().stream().collect(toMap(VmJob::getId, identity())));
}
#method_after
@PostConstruct
void init() {
    jobsRepository.putAll(getVmJobDao().getAll().stream().collect(toMap(VmJob::getId, identity())));
    removeJobsByVmIds(getIdsOfDownVms());
}
#end_block

#method_before
void removeJobs(List<Guid> vmJobIdsToRemove) {
    removeJobsFromDb(vmJobIdsToRemove);
    vmJobIdsToRemove.forEach(jobsRepository::remove);
    vmJobIdsToRemove.forEach(this::notifyListener);
}
#method_after
void removeJobs(List<Guid> vmJobIdsToRemove) {
    removeJobsFromDb(vmJobIdsToRemove);
    vmJobIdsToRemove.forEach(jobsRepository::remove);
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(assignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getClusterCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(assignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkCommonUtils.isVlan(existingIface) && !existingIface.isPartOfBond()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface, statsBuilder.isTotalStatsReported());
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(assignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(assignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(assignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(assignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(assignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(assignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(assignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(assignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(assignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(assignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(assignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(assignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = assignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(assignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(assignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = assignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = assignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = assignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = assignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = assignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = assignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = haScore > 0;
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(assignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder();
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(assignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkCommonUtils.isVlan(existingIface) && !existingIface.isPartOfBond()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(assignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(assignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(assignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(assignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(assignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(assignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(assignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(assignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(assignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(assignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(assignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(assignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = assignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(assignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(assignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = assignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = assignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = assignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = assignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = assignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = assignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = haScore > 0;
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#end_block

#method_before
private static Double computeInterfaceUsage(VdsNetworkInterface iface, boolean totalStatsReported) {
    Double receiveRate = iface.getStatistics().getReceiveRate();
    Double transmitRate = iface.getStatistics().getTransmitRate();
    /**
     * TODO: only needed if rate reported by vdsm (in which case can't be null) - remove in 4.0 and turn
     * NetworkStatisticsBuilder.truncatePercentage() private
     */
    if (!totalStatsReported) {
        receiveRate = NetworkStatisticsBuilder.truncatePercentage(receiveRate);
        transmitRate = NetworkStatisticsBuilder.truncatePercentage(transmitRate);
    }
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface) {
    Double receiveRate = iface.getStatistics().getReceiveRate();
    Double transmitRate = iface.getStatistics().getTransmitRate();
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String v4addr = extractAddress(effectiveProperties);
                String v4Subnet = extractSubnet(effectiveProperties);
                String v4gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                final String rawIpv6Address = getIpv6Address(effectiveProperties);
                String v6Addr = extractIpv6Address(rawIpv6Address);
                Integer v6Prefix = extractIpv6Prefix(rawIpv6Address);
                String v6gateway = (String) effectiveProperties.get(VdsProperties.IPV6_GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setIpv4Address(v4addr);
                    iface.setIpv4Subnet(v4Subnet);
                    iface.setIpv6Address(v6Addr);
                    iface.setIpv6Prefix(v6Prefix);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getClusterId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    iface.setIpv4Gateway(v4gateway);
                    iface.setIpv6Gateway(v6gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, host, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String v4addr = extractAddress(effectiveProperties);
                String v4Subnet = extractSubnet(effectiveProperties);
                String v4gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                final String rawIpv6Address = getIpv6Address(effectiveProperties);
                String v6Addr = extractIpv6Address(rawIpv6Address);
                Integer v6Prefix = extractIpv6Prefix(rawIpv6Address);
                String v6gateway = (String) effectiveProperties.get(VdsProperties.IPV6_GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setIpv4Address(v4addr);
                    iface.setIpv4Subnet(v4Subnet);
                    iface.setIpv6Address(v6Addr);
                    iface.setIpv6Prefix(v6Prefix);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getClusterId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    iface.setIpv4Gateway(v4gateway);
                    iface.setIpv6Gateway(v6gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getClusterCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    Map<String, Object> bondOptionsMap = new HashMap<>();
                    Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                    if (bondOpts != null) {
                        bondOptionsMap.putAll(bondOpts);
                    }
                    String bondOptionsString = "";
                    String mode = (String) bondOptionsMap.get("mode");
                    String miimon = (String) bondOptionsMap.get("miimon");
                    if (mode != null && miimon != null) {
                        bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                        bondOptionsMap.remove("mode");
                        bondOptionsMap.remove("miimon");
                    }
                    for (Map.Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                        bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                    }
                    bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                } else {
                    Map<String, Object> config = (Map<String, Object>) bondProperties.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#end_block

#method_before
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        iface.setIpv4Address(extractAddress(nicProperties));
        iface.setIpv4Subnet(extractSubnet(nicProperties));
        final String ipv6Address = getIpv6Address(nicProperties);
        iface.setIpv6Address(extractIpv6Address(ipv6Address));
        iface.setIpv6Prefix(extractIpv6Prefix(ipv6Address));
        final Integer mtu = assignIntValue(nicProperties, VdsProperties.MTU);
        if (mtu != null) {
            iface.setMtu(mtu);
        }
        addBootProtocol(nicProperties, host, iface);
    }
}
#method_after
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        iface.setIpv4Address(extractAddress(nicProperties));
        iface.setIpv4Subnet(extractSubnet(nicProperties));
        final String ipv6Address = getIpv6Address(nicProperties);
        iface.setIpv6Address(extractIpv6Address(ipv6Address));
        iface.setIpv6Prefix(extractIpv6Prefix(ipv6Address));
        final Integer mtu = assignIntValue(nicProperties, VdsProperties.MTU);
        if (mtu != null) {
            iface.setMtu(mtu);
        }
        addBootProtocol(nicProperties, iface);
    }
}
#end_block

#method_before
private static void addBootProtocol(Map<String, Object> nicProperties, VDS host, VdsNetworkInterface iface) {
    if (nicProperties == null) {
        return;
    }
    final boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(host.getClusterCompatibilityVersion());
    setBootProtocolAndGateway(getIpv4BootProtocolResolver(), cfgEntriesDeprecated ? new NoCfgIpv4InfoFetcher(nicProperties, iface.getIpv4Address()) : new CfgIpv4InfoFetcher(nicProperties), bootProtocol -> Ipv4BootProtocol.STATIC_IP == bootProtocol, iface::setIpv4BootProtocol, iface::setIpv4Gateway);
    if (cfgEntriesDeprecated) {
        setBootProtocolAndGateway(getIpv6BootProtocolResolver(), new NoCfgIpv6InfoFetcher(nicProperties, iface.getIpv6Address()), bootProtocol -> Ipv6BootProtocol.STATIC_IP == bootProtocol, iface::setIpv6BootProtocol, iface::setIpv6Gateway);
    }
}
#method_after
private static void addBootProtocol(Map<String, Object> nicProperties, VdsNetworkInterface iface) {
    if (nicProperties == null) {
        return;
    }
    setBootProtocolAndGateway(getIpv4BootProtocolResolver(), new NoCfgIpv4InfoFetcher(nicProperties, iface.getIpv4Address()), bootProtocol -> Ipv4BootProtocol.STATIC_IP == bootProtocol, iface::setIpv4BootProtocol, iface::setIpv4Gateway);
    setBootProtocolAndGateway(getIpv6BootProtocolResolver(), new NoCfgIpv6InfoFetcher(nicProperties, iface.getIpv6Address()), bootProtocol -> Ipv6BootProtocol.STATIC_IP == bootProtocol, iface::setIpv6BootProtocol, iface::setIpv6Gateway);
}
#end_block

#method_before
public static List<HostDevice> buildHostDevices(Map<String, Map<String, Map<String, Object>>> deviceList) {
    List<HostDevice> devices = new ArrayList<>();
    for (Entry<String, Map<String, Map<String, Object>>> entry : deviceList.entrySet()) {
        Map<String, Object> params = entry.getValue().get(VdsProperties.PARAMS);
        String deviceName = entry.getKey();
        HostDevice device = new HostDevice();
        device.setDeviceName(entry.getKey());
        device.setCapability(params.get(VdsProperties.CAPABILITY).toString());
        // special case for root device "computer"
        if (VdsProperties.ROOT_HOST_DEVICE.equals(deviceName)) {
            // set parent to self, for DB integrity
            device.setParentDeviceName(VdsProperties.ROOT_HOST_DEVICE);
        } else {
            device.setParentDeviceName(params.get(VdsProperties.PARENT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.IOMMU_GROUP)) {
            device.setIommuGroup(Integer.parseInt(params.get(VdsProperties.IOMMU_GROUP).toString()));
        }
        if (params.containsKey(VdsProperties.PRODUCT_ID)) {
            device.setProductId(params.get(VdsProperties.PRODUCT_ID).toString());
        }
        if (params.containsKey(VdsProperties.PRODUCT_NAME)) {
            device.setProductName(params.get(VdsProperties.PRODUCT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_NAME)) {
            device.setVendorName(params.get(VdsProperties.VENDOR_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_ID)) {
            device.setVendorId(params.get(VdsProperties.VENDOR_ID).toString());
        }
        if (params.containsKey(VdsProperties.PHYSICAL_FUNCTION)) {
            device.setParentPhysicalFunction(params.get(VdsProperties.PHYSICAL_FUNCTION).toString());
        }
        if (params.containsKey(VdsProperties.TOTAL_VFS)) {
            device.setTotalVirtualFunctions(Integer.parseInt(params.get(VdsProperties.TOTAL_VFS).toString()));
        }
        if (params.containsKey(VdsProperties.NET_INTERFACE_NAME)) {
            device.setNetworkInterfaceName(params.get(VdsProperties.NET_INTERFACE_NAME).toString());
        }
        devices.add(device);
    }
    return devices;
}
#method_after
public static List<HostDevice> buildHostDevices(Map<String, Map<String, Map<String, Object>>> deviceList) {
    List<HostDevice> devices = new ArrayList<>();
    for (Entry<String, Map<String, Map<String, Object>>> entry : deviceList.entrySet()) {
        Map<String, Object> params = entry.getValue().get(VdsProperties.PARAMS);
        String deviceName = entry.getKey();
        HostDevice device = new HostDevice();
        device.setDeviceName(entry.getKey());
        device.setCapability(params.get(VdsProperties.CAPABILITY).toString());
        // special case for root device "computer"
        if (VdsProperties.ROOT_HOST_DEVICE.equals(deviceName)) {
            // set parent to self, for DB integrity
            device.setParentDeviceName(VdsProperties.ROOT_HOST_DEVICE);
        } else {
            device.setParentDeviceName(params.get(VdsProperties.PARENT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.IOMMU_GROUP)) {
            device.setIommuGroup(Integer.parseInt(params.get(VdsProperties.IOMMU_GROUP).toString()));
        }
        if (params.containsKey(VdsProperties.PRODUCT_ID)) {
            device.setProductId(params.get(VdsProperties.PRODUCT_ID).toString());
        }
        if (params.containsKey(VdsProperties.PRODUCT_NAME)) {
            device.setProductName(params.get(VdsProperties.PRODUCT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_NAME)) {
            device.setVendorName(params.get(VdsProperties.VENDOR_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_ID)) {
            device.setVendorId(params.get(VdsProperties.VENDOR_ID).toString());
        }
        if (params.containsKey(VdsProperties.PHYSICAL_FUNCTION)) {
            device.setParentPhysicalFunction(params.get(VdsProperties.PHYSICAL_FUNCTION).toString());
        }
        if (params.containsKey(VdsProperties.TOTAL_VFS)) {
            device.setTotalVirtualFunctions(Integer.parseInt(params.get(VdsProperties.TOTAL_VFS).toString()));
        }
        if (params.containsKey(VdsProperties.NET_INTERFACE_NAME)) {
            device.setNetworkInterfaceName(params.get(VdsProperties.NET_INTERFACE_NAME).toString());
        }
        if (params.containsKey(VdsProperties.DRIVER)) {
            device.setDriver(params.get(VdsProperties.DRIVER).toString());
        }
        devices.add(device);
    }
    return devices;
}
#end_block

#method_before
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(BusinessEntityMap<VdsNetworkInterface> existingInterfaces) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null) {
        final Predicate<String> isManagementIpPredicate = new IpAddressPredicate(host.getHostName());
        if (ipConfiguration.hasIpv4PrimaryAddressSet() && ipConfiguration.getIpv4PrimaryAddress().getBootProtocol() == Ipv4BootProtocol.STATIC_IP) {
            VdsNetworkInterface existingIface = existingInterfaces.get(attachment.getNicName());
            if (existingIface != null) {
                String oldIpv4Address = existingIface.getIpv4Address();
                return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, getNetwork().getName())).when(isManagementIpPredicate.test(oldIpv4Address) && !new IpAddressPredicate(oldIpv4Address).test(ipConfiguration.getIpv4PrimaryAddress().getAddress()));
            }
        }
        if (ipConfiguration.hasIpv6PrimaryAddressSet() && ipConfiguration.getIpv6PrimaryAddress().getBootProtocol() == Ipv6BootProtocol.STATIC_IP) {
            VdsNetworkInterface existingIface = existingInterfaces.get(attachment.getNicName());
            if (existingIface != null) {
                String oldIpv6Address = existingIface.getIpv6Address();
                return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, getNetwork().getName())).when(isManagementIpPredicate.test(oldIpv6Address) && !new IpAddressPredicate(oldIpv6Address).test(ipConfiguration.getIpv6PrimaryAddress().getAddress()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(BusinessEntityMap<VdsNetworkInterface> existingInterfaces) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null) {
        VdsNetworkInterface existingIface = existingInterfaces.get(attachment.getNicName());
        if (existingIface != null) {
            final Predicate<String> isManagementIpPredicate = new IpAddressPredicate(host.getHostName());
            if (ipConfiguration.hasIpv4PrimaryAddressSet() && ipConfiguration.getIpv4PrimaryAddress().getBootProtocol() == Ipv4BootProtocol.STATIC_IP) {
                String oldIpv4Address = existingIface.getIpv4Address();
                return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, getNetwork().getName())).when(isManagementIpPredicate.test(oldIpv4Address) && !new IpAddressPredicate(oldIpv4Address).test(ipConfiguration.getIpv4PrimaryAddress().getAddress()));
            }
            if (ipConfiguration.hasIpv6PrimaryAddressSet() && ipConfiguration.getIpv6PrimaryAddress().getBootProtocol() == Ipv6BootProtocol.STATIC_IP) {
                String oldIpv6Address = existingIface.getIpv6Address();
                return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, getNetwork().getName())).when(isManagementIpPredicate.test(oldIpv6Address) && !new IpAddressPredicate(oldIpv6Address).test(ipConfiguration.getIpv6PrimaryAddress().getAddress()));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateNetworkAttachmentIpConfiguration(Collection<NetworkAttachment> attachmentsToConfigure) {
    for (NetworkAttachment networkAttachment : attachmentsToConfigure) {
        IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
        if (ipConfiguration == null || !(isIpv4Configured(ipConfiguration) || isIpv6Configured(ipConfiguration))) {
            return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_MISSING_IP_CONFIGURATION, networkAttachment.getNetworkName(), networkAttachment.getNicName());
        }
        final ValidationResult ipv4ValidationResult = validateIpv4Configuration(networkAttachment);
        if (!ipv4ValidationResult.isValid()) {
            return ipv4ValidationResult;
        }
        final ValidationResult ipv6ValidationResult = validateIpv6Configuration(networkAttachment);
        if (!ipv6ValidationResult.isValid()) {
            return ipv6ValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateNetworkAttachmentIpConfiguration(Collection<NetworkAttachment> attachmentsToConfigure) {
    for (NetworkAttachment networkAttachment : attachmentsToConfigure) {
        IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
        if (ipConfiguration == null || !(ipConfiguration.hasIpv4PrimaryAddressSet() || ipConfiguration.hasIpv6PrimaryAddressSet())) {
            return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_MISSING_IP_CONFIGURATION, networkAttachment.getNetworkName(), networkAttachment.getNicName());
        }
        final ValidationResult ipv4ValidationResult = validateIpv4Configuration(networkAttachment);
        if (!ipv4ValidationResult.isValid()) {
            return ipv4ValidationResult;
        }
        final ValidationResult ipv6ValidationResult = validateIpv6Configuration(networkAttachment);
        if (!ipv6ValidationResult.isValid()) {
            return ipv6ValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validateIpv4Configuration(NetworkAttachment networkAttachment) {
    IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
    if (!isIpv4Configured(ipConfiguration)) {
        return ValidationResult.VALID;
    }
    IPv4Address iPv4Address = ipConfiguration.getIpv4PrimaryAddress();
    String networkName = networkAttachment.getNetworkName();
    String nicName = networkAttachment.getNicName();
    if (iPv4Address.getBootProtocol() == null) {
        return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_MISSING_BOOT_PROTOCOL, networkName, nicName);
    }
    Ipv4BootProtocol bootProtocol = iPv4Address.getBootProtocol();
    if (bootProtocol == Ipv4BootProtocol.STATIC_IP) {
        if (!validStaticIpv4AddressDetails(iPv4Address)) {
            return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_STATIC_BOOT_PROTOCOL_MISSING_IP_ADDRESS_DETAILS, networkName, nicName);
        }
    } else {
        if (!isEmptyIpv4AddressDetails(iPv4Address)) {
            return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_INCOMPATIBLE_BOOT_PROTOCOL_AND_IP_ADDRESS_DETAILS, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkName), ReplacementUtils.createSetVariableString(VAR_INTERFACE_NAME, nicName), ReplacementUtils.createSetVariableString(VAR_BOOT_PROTOCOL, bootProtocol.getDisplayName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateIpv4Configuration(NetworkAttachment networkAttachment) {
    IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
    if (!ipConfiguration.hasIpv4PrimaryAddressSet()) {
        return ValidationResult.VALID;
    }
    IPv4Address iPv4Address = ipConfiguration.getIpv4PrimaryAddress();
    String networkName = networkAttachment.getNetworkName();
    String nicName = networkAttachment.getNicName();
    if (iPv4Address.getBootProtocol() == null) {
        return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_MISSING_BOOT_PROTOCOL, networkName, nicName);
    }
    Ipv4BootProtocol bootProtocol = iPv4Address.getBootProtocol();
    if (bootProtocol == Ipv4BootProtocol.STATIC_IP) {
        if (!validStaticIpv4AddressDetails(iPv4Address)) {
            return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_STATIC_BOOT_PROTOCOL_MISSING_IP_ADDRESS_DETAILS, networkName, nicName);
        }
    } else {
        if (!isEmptyIpv4AddressDetails(iPv4Address)) {
            return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_INCOMPATIBLE_BOOT_PROTOCOL_AND_IP_ADDRESS_DETAILS, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkName), ReplacementUtils.createSetVariableString(VAR_INTERFACE_NAME, nicName), ReplacementUtils.createSetVariableString(VAR_BOOT_PROTOCOL, bootProtocol.getDisplayName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validateIpv6Configuration(NetworkAttachment networkAttachment) {
    final IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
    if (!isIpv6Configured(ipConfiguration)) {
        return ValidationResult.VALID;
    }
    IpV6Address ipv6Address = ipConfiguration.getIpv6PrimaryAddress();
    String networkName = networkAttachment.getNetworkName();
    String nicName = networkAttachment.getNicName();
    if (ipv6Address.getBootProtocol() == null) {
        return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_MISSING_BOOT_PROTOCOL, networkName, nicName);
    }
    Ipv6BootProtocol bootProtocol = ipv6Address.getBootProtocol();
    if (bootProtocol == Ipv6BootProtocol.STATIC_IP) {
        if (!validStaticIpv6AddressDetails(ipv6Address)) {
            return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_STATIC_BOOT_PROTOCOL_MISSING_IP_ADDRESS_DETAILS, networkName, nicName);
        }
    } else {
        if (!isEmptyIpv6AddressDetails(ipv6Address)) {
            return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_INCOMPATIBLE_BOOT_PROTOCOL_AND_IP_ADDRESS_DETAILS, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkName), ReplacementUtils.createSetVariableString(VAR_INTERFACE_NAME, nicName), ReplacementUtils.createSetVariableString(VAR_BOOT_PROTOCOL, bootProtocol.getDisplayName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateIpv6Configuration(NetworkAttachment networkAttachment) {
    final IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
    if (!ipConfiguration.hasIpv6PrimaryAddressSet()) {
        return ValidationResult.VALID;
    }
    IpV6Address ipv6Address = ipConfiguration.getIpv6PrimaryAddress();
    String networkName = networkAttachment.getNetworkName();
    String nicName = networkAttachment.getNicName();
    if (ipv6Address.getBootProtocol() == null) {
        return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_MISSING_BOOT_PROTOCOL, networkName, nicName);
    }
    Ipv6BootProtocol bootProtocol = ipv6Address.getBootProtocol();
    if (bootProtocol == Ipv6BootProtocol.STATIC_IP) {
        if (!validStaticIpv6AddressDetails(ipv6Address)) {
            return incompleteIpConfigurationValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_STATIC_BOOT_PROTOCOL_MISSING_IP_ADDRESS_DETAILS, networkName, nicName);
        }
    } else {
        if (!isEmptyIpv6AddressDetails(ipv6Address)) {
            return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_IP_CONFIGURATION_INCOMPATIBLE_BOOT_PROTOCOL_AND_IP_ADDRESS_DETAILS, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkName), ReplacementUtils.createSetVariableString(VAR_INTERFACE_NAME, nicName), ReplacementUtils.createSetVariableString(VAR_BOOT_PROTOCOL, bootProtocol.getDisplayName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void checkIncompatibleIpv4AddressDetailsBootProtocolNone() {
    checkIncompatibleIpv4AddressDetailsBootProtocol(Ipv4BootProtocol.DHCP);
}
#method_after
@Test
public void checkIncompatibleIpv4AddressDetailsBootProtocolNone() {
    checkIncompatibleIpv4AddressDetailsBootProtocol(Ipv4BootProtocol.NONE);
}
#end_block

#method_before
@Test
public void checkIncompatibleIpv6AddressDetailsBootProtocolNone() {
    checkIncompatibleIpv6AddressDetailsBootProtocol(Ipv6BootProtocol.DHCP);
}
#method_after
@Test
public void checkIncompatibleIpv6AddressDetailsBootProtocolNone() {
    checkIncompatibleIpv6AddressDetailsBootProtocol(Ipv6BootProtocol.NONE);
}
#end_block

#method_before
public static List<HostDevice> buildHostDevices(Map<String, Map<String, Map<String, Object>>> deviceList) {
    List<HostDevice> devices = new ArrayList<>();
    for (Entry<String, Map<String, Map<String, Object>>> entry : deviceList.entrySet()) {
        Map<String, Object> params = entry.getValue().get(VdsProperties.PARAMS);
        String deviceName = entry.getKey();
        HostDevice device = new HostDevice();
        device.setDeviceName(entry.getKey());
        device.setCapability(params.get(VdsProperties.CAPABILITY).toString());
        // special case for root device "computer"
        if (VdsProperties.ROOT_HOST_DEVICE.equals(deviceName)) {
            // set parent to self, for DB integrity
            device.setParentDeviceName(VdsProperties.ROOT_HOST_DEVICE);
        } else {
            device.setParentDeviceName(params.get(VdsProperties.PARENT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.IOMMU_GROUP)) {
            device.setIommuGroup(Integer.parseInt(params.get(VdsProperties.IOMMU_GROUP).toString()));
        }
        if (params.containsKey(VdsProperties.PRODUCT_ID)) {
            device.setProductId(params.get(VdsProperties.PRODUCT_ID).toString());
        }
        if (params.containsKey(VdsProperties.PRODUCT_NAME)) {
            device.setProductName(params.get(VdsProperties.PRODUCT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_NAME)) {
            device.setVendorName(params.get(VdsProperties.VENDOR_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_ID)) {
            device.setVendorId(params.get(VdsProperties.VENDOR_ID).toString());
        }
        if (params.containsKey(VdsProperties.PHYSICAL_FUNCTION)) {
            device.setParentPhysicalFunction(params.get(VdsProperties.PHYSICAL_FUNCTION).toString());
        }
        if (params.containsKey(VdsProperties.TOTAL_VFS)) {
            device.setTotalVirtualFunctions(Integer.parseInt(params.get(VdsProperties.TOTAL_VFS).toString()));
        }
        if (params.containsKey(VdsProperties.NET_INTERFACE_NAME)) {
            device.setNetworkInterfaceName(params.get(VdsProperties.NET_INTERFACE_NAME).toString());
        }
        devices.add(device);
    }
    return devices;
}
#method_after
public static List<HostDevice> buildHostDevices(Map<String, Map<String, Map<String, Object>>> deviceList) {
    List<HostDevice> devices = new ArrayList<>();
    for (Entry<String, Map<String, Map<String, Object>>> entry : deviceList.entrySet()) {
        Map<String, Object> params = entry.getValue().get(VdsProperties.PARAMS);
        String deviceName = entry.getKey();
        HostDevice device = new HostDevice();
        device.setDeviceName(entry.getKey());
        device.setCapability(params.get(VdsProperties.CAPABILITY).toString());
        // special case for root device "computer"
        if (VdsProperties.ROOT_HOST_DEVICE.equals(deviceName)) {
            // set parent to self, for DB integrity
            device.setParentDeviceName(VdsProperties.ROOT_HOST_DEVICE);
        } else {
            device.setParentDeviceName(params.get(VdsProperties.PARENT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.IOMMU_GROUP)) {
            device.setIommuGroup(Integer.parseInt(params.get(VdsProperties.IOMMU_GROUP).toString()));
        }
        if (params.containsKey(VdsProperties.PRODUCT_ID)) {
            device.setProductId(params.get(VdsProperties.PRODUCT_ID).toString());
        }
        if (params.containsKey(VdsProperties.PRODUCT_NAME)) {
            device.setProductName(params.get(VdsProperties.PRODUCT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_NAME)) {
            device.setVendorName(params.get(VdsProperties.VENDOR_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_ID)) {
            device.setVendorId(params.get(VdsProperties.VENDOR_ID).toString());
        }
        if (params.containsKey(VdsProperties.PHYSICAL_FUNCTION)) {
            device.setParentPhysicalFunction(params.get(VdsProperties.PHYSICAL_FUNCTION).toString());
        }
        if (params.containsKey(VdsProperties.TOTAL_VFS)) {
            device.setTotalVirtualFunctions(Integer.parseInt(params.get(VdsProperties.TOTAL_VFS).toString()));
        }
        if (params.containsKey(VdsProperties.NET_INTERFACE_NAME)) {
            device.setNetworkInterfaceName(params.get(VdsProperties.NET_INTERFACE_NAME).toString());
        }
        if (params.containsKey(VdsProperties.DRIVER)) {
            device.setDriver(params.get(VdsProperties.DRIVER).toString());
        }
        devices.add(device);
    }
    return devices;
}
#end_block

#method_before
@Override
public void processOnVmStop(final Collection<Guid> vmIds, final Guid hostId) {
    if (vmIds.isEmpty()) {
        return;
    }
    ThreadPoolUtil.execute(() -> processOnVmStopInternal(vmIds, hostId));
}
#method_after
@Override
public void processOnVmStop(final Collection<Guid> vmIds, final Guid hostId) {
    if (vmIds.isEmpty()) {
        return;
    }
    vmJobsMonitoring.removeJobsByVmIds(vmIds);
    ThreadPoolUtil.execute(() -> processOnVmStopInternal(vmIds, hostId));
}
#end_block

#method_before
private static void setBootProtocolAndGateway(BootProtocolResolver bootProtocolResolver, IpInfoFetcher ipInfoFetcher, Consumer<NetworkBootProtocol> bootProtocolSetter, Consumer<String> gatewaySetter) {
    final NetworkBootProtocol bootProtocol = bootProtocolResolver.resolve(ipInfoFetcher);
    bootProtocolSetter.accept(bootProtocol);
    setGateway(bootProtocol, ipInfoFetcher, gatewaySetter);
}
#method_after
private static void setBootProtocolAndGateway(BootProtocolResolver bootProtocolResolver, IpInfoFetcher ipInfoFetcher, Consumer<Ipv4BootProtocol> bootProtocolSetter, Consumer<String> gatewaySetter) {
    final Ipv4BootProtocol bootProtocol = bootProtocolResolver.resolve(ipInfoFetcher);
    bootProtocolSetter.accept(bootProtocol);
    setGateway(bootProtocol, ipInfoFetcher, gatewaySetter);
}
#end_block

#method_before
private static void setGateway(NetworkBootProtocol bootProtocol, IpInfoFetcher ipInfoFetcher, Consumer<String> gatewaySetter) {
    if (bootProtocol == NetworkBootProtocol.STATIC_IP) {
        String gateway = ipInfoFetcher.fetchGateway();
        if (StringUtils.isNotEmpty(gateway)) {
            gatewaySetter.accept(gateway);
        }
    }
}
#method_after
private static void setGateway(Ipv4BootProtocol bootProtocol, IpInfoFetcher ipInfoFetcher, Consumer<String> gatewaySetter) {
    if (bootProtocol == Ipv4BootProtocol.STATIC_IP) {
        String gateway = ipInfoFetcher.fetchGateway();
        if (StringUtils.isNotEmpty(gateway)) {
            gatewaySetter.accept(gateway);
        }
    }
}
#end_block

#method_before
@Override
public void processOnVmStop(final Collection<Guid> vmIds, final Guid hostId) {
    if (vmIds.isEmpty()) {
        return;
    }
    vmJobsMonitoring.removeJobsOfDownVms(vmIds);
    ThreadPoolUtil.execute(() -> processOnVmStopInternal(vmIds, hostId));
}
#method_after
@Override
public void processOnVmStop(final Collection<Guid> vmIds, final Guid hostId) {
    if (vmIds.isEmpty()) {
        return;
    }
    vmJobsMonitoring.removeJobsByVmIds(vmIds);
    ThreadPoolUtil.execute(() -> processOnVmStopInternal(vmIds, hostId));
}
#end_block

#method_before
@PostConstruct
void init() {
    jobsRepository.putAll(getVmJobDao().getAll().stream().collect(toMap(VmJob::getId, identity())));
    removeJobsOfDownVms(vmDynamicDao.getIdsOfDowmVms());
}
#method_after
@PostConstruct
void init() {
    jobsRepository.putAll(getVmJobDao().getAll().stream().collect(toMap(VmJob::getId, identity())));
    removeJobsByVmIds(getIdsOfDownVms());
}
#end_block

#method_before
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    log.error("Policy unit '{}' filter is not implemented", getPolicyUnit().getName());
    return hosts;
}
#method_after
public List<VDS> filter(@NotNull Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    log.error("Policy unit '{}' filter is not implemented", getPolicyUnit().getName());
    return hosts;
}
#end_block

#method_before
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    log.error("Policy unit '{}' function is not implemented", getPolicyUnit().getName());
    List<Pair<Guid, Integer>> pairs = new ArrayList<>();
    for (VDS vds : hosts) {
        pairs.add(new Pair<>(vds.getId(), 1));
    }
    return pairs;
}
#method_after
public List<Pair<Guid, Integer>> score(@NotNull Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    log.error("Policy unit '{}' function is not implemented", getPolicyUnit().getName());
    List<Pair<Guid, Integer>> pairs = new ArrayList<>();
    for (VDS vds : hosts) {
        pairs.add(new Pair<>(vds.getId(), 1));
    }
    return pairs;
}
#end_block

#method_before
public Pair<List<Guid>, Guid> balance(Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    log.error("Policy unit '{}' balance is not implemented", getPolicyUnit().getName());
    return null;
}
#method_after
public Pair<List<Guid>, Guid> balance(@NotNull Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    log.error("Policy unit '{}' balance is not implemented", getPolicyUnit().getName());
    return null;
}
#end_block

#method_before
private List<Pair<Guid, Integer>> filter(final VM vm, final VDS... hosts) {
    return inClusterUpgradeWeightPolicyUnit.score(null, Arrays.asList(hosts), vm, null);
}
#method_after
private List<Pair<Guid, Integer>> filter(final VM vm, final VDS... hosts) {
    return inClusterUpgradeWeightPolicyUnit.score(new Cluster(), Arrays.asList(hosts), vm, null);
}
#end_block

#method_before
private ValidationResult validateDisplayNetworkAvailability(VDS host, boolean onlyRequiredNetworks, VdsNetworkInterface displayNic, Network displayNetwork) {
    if (onlyRequiredNetworks) {
        return ValidationResult.VALID;
    }
    if (displayNetwork == null) {
        return ValidationResult.VALID;
    }
    // Check if display network attached to host and has a proper boot protocol
    if (displayNic == null) {
        log.warn("host {} is missing the cluster's display network {}", host.getName(), displayNetwork.getName());
        return new ValidationResult(EngineMessage.VAR__DETAIL__DISPLAY_NETWORK_MISSING, String.format("$DisplayNetwork %1$s", displayNetwork.getName()));
    }
    if (displayNic.getBootProtocol() == NetworkBootProtocol.NONE) {
        log.warn("Host {} has the display network {} configured with improper boot protocol on interface {}.", host.getName(), displayNetwork.getName(), displayNic.getName());
        return new ValidationResult(EngineMessage.VAR__DETAIL__DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL, String.format("$DisplayNetwork %1$s", displayNetwork.getName()));
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateDisplayNetworkAvailability(VDS host, boolean onlyRequiredNetworks, VdsNetworkInterface displayNic, Network displayNetwork) {
    if (onlyRequiredNetworks) {
        return ValidationResult.VALID;
    }
    if (displayNetwork == null) {
        return ValidationResult.VALID;
    }
    // Check if display network attached to host and has a proper boot protocol
    if (displayNic == null) {
        log.warn("host {} is missing the cluster's display network {}", host.getName(), displayNetwork.getName());
        return new ValidationResult(EngineMessage.VAR__DETAIL__DISPLAY_NETWORK_MISSING, String.format("$DisplayNetwork %1$s", displayNetwork.getName()));
    }
    if (displayNic.getIpv4BootProtocol() == Ipv4BootProtocol.NONE) {
        log.warn("Host {} has the display network {} configured with improper boot protocol on interface {}.", host.getName(), displayNetwork.getName(), displayNic.getName());
        return new ValidationResult(EngineMessage.VAR__DETAIL__DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL, String.format("$DisplayNetwork %1$s", displayNetwork.getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private List<VDS> filter(final VM vm, final VDS... hosts) {
    return inClusterUpgradeFilterPolicyUnit.filter(null, Arrays.asList(hosts), vm, null, mock(PerHostMessages.class));
}
#method_after
private List<VDS> filter(final VM vm, final VDS... hosts) {
    return inClusterUpgradeFilterPolicyUnit.filter(new Cluster(), Arrays.asList(hosts), vm, null, mock(PerHostMessages.class));
}
#end_block

#method_before
private void loadClusterPolicies() {
    // Load internal cluster policies
    policyMap.putAll(InternalClusterPolicies.getClusterPolicies());
    // Get all user provided cluster policies
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll();
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#method_after
private void loadClusterPolicies() {
    // Load internal cluster policies
    policyMap.putAll(InternalClusterPolicies.getClusterPolicies());
    Map<Guid, PolicyUnitType> internalTypes = new HashMap<>();
    for (PolicyUnitImpl unit : policyUnits.values()) {
        internalTypes.put(unit.getGuid(), unit.getType());
    }
    // Get all user provided cluster policies
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll(Collections.unmodifiableMap(internalTypes));
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#end_block

#method_before
public String getUserName(String sessionId) {
    return String.format("%s@%s", getPrincipalName(sessionId), getProfile(sessionId) != null ? getProfile(sessionId).getName() : "N/A");
}
#method_after
public String getUserName(String sessionId) {
    return String.format("%s@%s", getPrincipalName(sessionId), getProfile(sessionId) != null ? getProfile(sessionId).getAuthzName() : "N/A");
}
#end_block

#method_before
public void engineInitialize() {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        if (!directory.exists()) {
            log.warn("The directory '{}' cotaning configuration files does not exist.", directory.getAbsolutePath());
        } else {
            // The order of the files inside the directory is relevant, as the objects are created in
            // the same order
            // that
            // the files are processed, so it is better to sort them so that objects will always be
            // created in the
            // same
            // order regardless of how the filesystem decides to store the entries of the directory:
            File[] files = directory.listFiles();
            if (files != null) {
                sort(files);
                for (File file : files) {
                    if (file.getName().endsWith(".properties")) {
                        try {
                            load(file);
                        } catch (Exception ex) {
                            log.error("Could not load extension based on configuration file '{}'. Please check the configuration file is valid. Exception message is: {}", file.getAbsolutePath(), ex.getMessage());
                            log.debug("", ex);
                        }
                    }
                }
            }
        }
    }
    Pattern pattern = Pattern.compile(EngineLocalConfig.getInstance().getProperty(ENGINE_EXTENSION_PROVIDES_DISABLE_FILTER));
    for (ExtensionProxy extension : getLoadedExtensions()) {
        if (EngineLocalConfig.getInstance().getBoolean(ENGINE_EXTENSION_ENABLED + normalizeName(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)), Boolean.parseBoolean(extension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Base.ConfigKeys.ENABLED, "true"))) && !((Collection<String>) extension.getContext().get(Base.ContextKeys.PROVIDES)).stream().anyMatch(p -> pattern.matcher(p).matches())) {
            try {
                initialize(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME));
            } catch (Exception ex) {
                log.error("Could not initialize extension '{}'. Exception message is: {}", extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME), ex.getMessage());
                log.debug("", ex);
            }
        }
    }
    dump();
}
#method_after
public void engineInitialize() {
    for (File directory : EngineLocalConfig.getInstance().getExtensionsDirectories()) {
        if (!directory.exists()) {
            log.warn("The directory '{}' cotaning configuration files does not exist.", directory.getAbsolutePath());
        } else {
            // The order of the files inside the directory is relevant, as the objects are created in
            // the same order
            // that
            // the files are processed, so it is better to sort them so that objects will always be
            // created in the
            // same
            // order regardless of how the filesystem decides to store the entries of the directory:
            File[] files = directory.listFiles();
            if (files != null) {
                sort(files);
                for (File file : files) {
                    if (file.getName().endsWith(".properties")) {
                        try {
                            load(file);
                        } catch (Exception ex) {
                            log.error("Could not load extension based on configuration file '{}'. Please check the configuration file is valid. Exception message is: {}", file.getAbsolutePath(), ex.getMessage());
                            log.debug("", ex);
                        }
                    }
                }
            }
        }
    }
    Pattern pattern = Pattern.compile(EngineLocalConfig.getInstance().getProperty(ENGINE_EXTENSIONS_IGNORED));
    for (ExtensionProxy extension : getLoadedExtensions()) {
        if (EngineLocalConfig.getInstance().getBoolean(ENGINE_EXTENSION_ENABLED + normalizeName(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME)), Boolean.parseBoolean(extension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Base.ConfigKeys.ENABLED, "true"))) && !((Collection<String>) extension.getContext().get(Base.ContextKeys.PROVIDES)).stream().anyMatch(p -> pattern.matcher(p).matches())) {
            try {
                initialize(extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME));
            } catch (Exception ex) {
                log.error("Could not initialize extension '{}'. Exception message is: {}", extension.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME), ex.getMessage());
                log.debug("", ex);
            }
        }
    }
    dump();
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getCluster() == null ? null : getCluster().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            VmStatic vmFromParams = getParameters().getMasterVm();
            Set<Guid> dedicatedVmForVdsFromVm = new HashSet<>(getVm().getDedicatedVmForVdsList());
            Set<Guid> dedicatedVmForVdsFromUser = new HashSet<>(vmFromParams.getDedicatedVmForVdsList());
            if (!dedicatedVmForVdsFromVm.equals(dedicatedVmForVdsFromUser) || !StringUtils.isEmpty(vmFromParams.getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getCluster() == null ? null : getCluster().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            if (!new HashSet<>(getParameters().getMasterVm().getDedicatedVmForVdsList()).equals(new HashSet<>(getVm().getDedicatedVmForVdsList())) || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#end_block

#method_before
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (!selectedItem.isHostedEngine() && selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        // currentl only hot plug memory is supported here (no hot unplug)
                        confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < gettempVm().getMemSizeMb());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (!selectedItem.isHostedEngine() && selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, gettempVm()));
                        boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(gettempVm());
                        confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, gettempVm(), isMemoryHotUnplugSupported));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#end_block

#method_before
private void onNewTemplate() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress();
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress();
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    vmModel.fireValidationCompleteEvent();
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress();
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress();
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                unitModel.fireValidationCompleteEvent();
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#end_block

#method_before
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (!selectedItem.isHostedEngine() && selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, gettempVm()));
                        confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, gettempVm()));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (!selectedItem.isHostedEngine() && selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, gettempVm()));
                        boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(gettempVm());
                        confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, gettempVm(), isMemoryHotUnplugSupported));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VM srcVm = getParameters().getOriginal();
    VM dstVm = getParameters().getUpdated();
    VmStatic srcStatic = srcVm.getStaticData();
    VmStatic dstStatic = dstVm.getStaticData();
    // copy fields which are not saved as part of the OVF
    dstStatic.setExportDate(srcStatic.getExportDate());
    dstStatic.setManagedDeviceMap(srcStatic.getManagedDeviceMap());
    dstStatic.setUnmanagedDeviceList(srcStatic.getUnmanagedDeviceList());
    dstStatic.setOvfVersion(srcStatic.getOvfVersion());
    // Copy creationDate to ignore it, because it is never changed by user.
    // Without this creationDate will always show change in milliseconds,
    // because creationDate is saved without milliseconds in OVF, but
    // with milliseconds in the DB.
    dstStatic.setCreationDate(srcStatic.getCreationDate());
    // so it is not needed to include them into changed fields list.
    if (VmCommonUtils.isCpusToBeHotplugged(srcVm, dstVm)) {
        dstStatic.setNumOfSockets(srcStatic.getNumOfSockets());
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(srcVm, dstVm)) {
        dstStatic.setMemSizeMb(srcStatic.getMemSizeMb());
    }
    VmPropertiesUtils vmPropertiesUtils = SimpleDependencyInjector.getInstance().get(VmPropertiesUtils.class);
    vmPropertiesUtils.separateCustomPropertiesToUserAndPredefined(srcVm.getCompatibilityVersion(), srcStatic);
    vmPropertiesUtils.separateCustomPropertiesToUserAndPredefined(dstVm.getCompatibilityVersion(), dstStatic);
    Set<String> result = new HashSet<>(VmHandler.getChangedFieldsForStatus(srcStatic, dstStatic, VMStatus.Up));
    for (VmDeviceUpdate device : VmHandler.getVmDevicesFieldsToUpdateOnNextRun(srcVm.getId(), VMStatus.Up, getParameters().getUpdateVmParameters())) {
        if (!device.getName().isEmpty()) {
            result.add(device.getName());
        } else {
            switch(device.getType()) {
                case UNKNOWN:
                case VIRTIO:
                    result.add(device.getGeneralType().name());
                    break;
                default:
                    result.add(device.getType().getName());
                    break;
            }
        }
    }
    setReturnValue(new ArrayList<>(result));
}
#method_after
@Override
protected void executeQueryCommand() {
    VM srcVm = getParameters().getOriginal();
    VM dstVm = getParameters().getUpdated();
    VmStatic srcStatic = srcVm.getStaticData();
    VmStatic dstStatic = dstVm.getStaticData();
    // copy fields which are not saved as part of the OVF
    dstStatic.setExportDate(srcStatic.getExportDate());
    dstStatic.setManagedDeviceMap(srcStatic.getManagedDeviceMap());
    dstStatic.setUnmanagedDeviceList(srcStatic.getUnmanagedDeviceList());
    dstStatic.setOvfVersion(srcStatic.getOvfVersion());
    // Copy creationDate to ignore it, because it is never changed by user.
    // Without this creationDate will always show change in milliseconds,
    // because creationDate is saved without milliseconds in OVF, but
    // with milliseconds in the DB.
    dstStatic.setCreationDate(srcStatic.getCreationDate());
    // so it is not needed to include them into changed fields list.
    if (VmCommonUtils.isCpusToBeHotplugged(srcVm, dstVm)) {
        dstStatic.setNumOfSockets(srcStatic.getNumOfSockets());
    }
    boolean isMemoryHotUnplugSupported = FeatureSupported.hotUnplugMemory(srcVm.getCompatibilityVersion(), srcVm.getClusterArch());
    if (VmCommonUtils.isMemoryToBeHotplugged(srcVm, dstVm, isMemoryHotUnplugSupported)) {
        dstStatic.setMemSizeMb(srcStatic.getMemSizeMb());
    }
    VmPropertiesUtils vmPropertiesUtils = SimpleDependencyInjector.getInstance().get(VmPropertiesUtils.class);
    vmPropertiesUtils.separateCustomPropertiesToUserAndPredefined(srcVm.getCompatibilityVersion(), srcStatic);
    vmPropertiesUtils.separateCustomPropertiesToUserAndPredefined(dstVm.getCompatibilityVersion(), dstStatic);
    Set<String> result = new HashSet<>(VmHandler.getChangedFieldsForStatus(srcStatic, dstStatic, VMStatus.Up));
    for (VmDeviceUpdate device : VmHandler.getVmDevicesFieldsToUpdateOnNextRun(srcVm.getId(), VMStatus.Up, getParameters().getUpdateVmParameters())) {
        if (!device.getName().isEmpty()) {
            result.add(device.getName());
        } else {
            switch(device.getType()) {
                case UNKNOWN:
                case VIRTIO:
                    result.add(device.getGeneralType().name());
                    break;
                default:
                    result.add(device.getType().getName());
                    break;
            }
        }
    }
    setReturnValue(new ArrayList<>(result));
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveOrCopyParameters parameter = new MoveOrCopyParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveOrCopyParameters parameter = (MoveOrCopyParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveVmParameters parameters = new MoveVmParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveOrCopyParameters parameters = new MoveOrCopyParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                    VmModel.fireValidationCompleteEvent();
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object thisModel, Object returnValue) {
                List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm()));
                    confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm()));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#method_after
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object thisModel, Object returnValue) {
                List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm()));
                    boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(getcurrentVm());
                    confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm(), isMemoryHotUnplugSupported));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#end_block

#method_before
public static boolean isMemoryToBeHotplugged(VM source, VM destination) {
    // currently only hot plug memory is supported here (no hot unplug)
    return source.getMemSizeMb() < destination.getMemSizeMb();
}
#method_after
public static boolean isMemoryToBeHotplugged(VM source, VM destination, boolean memoryUnplugSupported) {
    return source.getMemSizeMb() < destination.getMemSizeMb() || memoryUnplugSupported && source.getMemSizeMb() > destination.getMemSizeMb();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        hotSetMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        hotSetCpusLog(params);
    }
}
#method_after
private void hotSetCpus(VM newVm) {
    int currentSockets = getVm().getNumOfSockets();
    int newNumOfSockets = newVm.getNumOfSockets();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isCpusToBeHotplugged(getVm(), newVm)) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        // into the OVF store and automatically used during the next HE VM start
        if (!getVm().isHostedEngine()) {
            newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        }
        hotSetCpusLog(params);
    }
}
#end_block

#method_before
private void hotSetMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus() == VMStatus.Up && VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
        0);
        VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
        hotSetMemlog(params, setAmountOfMemoryResult);
    }
}
#method_after
private void hotSetMemory(int currentMemory, int newAmountOfMemory) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
    }
    hotSetMemlog(params, setAmountOfMemoryResult);
}
#end_block

#method_before
private void hotSetMemlog(HotSetAmountOfMemoryParameters params, VdcReturnValueBase setAmountOfMemoryResult) {
    if (!setAmountOfMemoryResult.isValid()) {
        AuditLogableBase logable = new HotSetAmountOfMemoryCommand<>(params, null);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setAmountOfMemoryResult.getValidationMessages());
        logable.addCustomValue(HotSetAmountOfMemoryCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetMemlog(HotSetAmountOfMemoryParameters params, VdcReturnValueBase setAmountOfMemoryResult) {
    if (!setAmountOfMemoryResult.isValid()) {
        AuditLogableBase logable = new HotSetAmountOfMemoryCommand<>(params, null);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setAmountOfMemoryResult.getValidationMessages());
        logable.addCustomValue(HotSetAmountOfMemoryCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_MEMORY);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return !getVm().isHostedEngine() && getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
public static void loginOnBehalf(SSOContext ssoContext, HttpServletRequest request, String username) throws Exception {
    log.debug("Entered AuthenticationUtils.loginOnBehalf");
    int index = username.lastIndexOf("@");
    String profile = null;
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    if (StringUtils.isEmpty(username) || StringUtils.isEmpty(profile)) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_PROVIDE_USERNAME_AND_PROFILE, request.getLocale()));
    }
    ObjectMapper mapper = new ObjectMapper().configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false).enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);
    mapper.getDeserializationConfig().addMixInAnnotations(ExtMap.class, JsonExtMapMixIn.class);
    String authRecordJson = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_AUTH_RECORD, "");
    ExtMap authRecord;
    if (StringUtils.isNotEmpty(authRecordJson)) {
        authRecord = mapper.readValue(authRecordJson, ExtMap.class);
    } else {
        authRecord = new ExtMap().mput(Authn.AuthRecord.PRINCIPAL, username);
    }
    SSOSession ssoSession = login(ssoContext, request, new Credentials(username, null, profile, SSOUtils.getSsoContext(request).getSsoProfiles().contains(profile)), authRecord);
    log.info("User {}@{} successfully logged in using login-on-behalf with client id : {} and scopes : {}", username, profile, ssoSession.getClientId(), ssoSession.getScope());
}
#method_after
public static void loginOnBehalf(SSOContext ssoContext, HttpServletRequest request, String username) throws Exception {
    log.debug("Entered AuthenticationUtils.loginOnBehalf");
    int index = username.lastIndexOf("@");
    String profile = null;
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    if (StringUtils.isEmpty(username) || StringUtils.isEmpty(profile)) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_PROVIDE_USERNAME_AND_PROFILE, (Locale) request.getAttribute(SSOConstants.LOCALE)));
    }
    ObjectMapper mapper = new ObjectMapper().configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false).enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);
    mapper.getDeserializationConfig().addMixInAnnotations(ExtMap.class, JsonExtMapMixIn.class);
    String authRecordJson = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_AUTH_RECORD, "");
    ExtMap authRecord;
    if (StringUtils.isNotEmpty(authRecordJson)) {
        authRecord = mapper.readValue(authRecordJson, ExtMap.class);
    } else {
        authRecord = new ExtMap().mput(Authn.AuthRecord.PRINCIPAL, username);
    }
    SSOSession ssoSession = login(ssoContext, request, new Credentials(username, null, profile, SSOUtils.getSsoContext(request).getSsoProfiles().contains(profile)), authRecord);
    log.info("User {}@{} successfully logged in using login-on-behalf with client id : {} and scopes : {}", username, profile, ssoSession.getClientId(), ssoSession.getScope());
}
#end_block

#method_before
public static void handleCredentials(SSOContext ssoContext, HttpServletRequest request, Credentials credentials) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_PROVIDE_USERNAME_PASSWORD_AND_PROFILE, request.getLocale()));
    }
    SSOSession ssoSession = login(ssoContext, request, credentials, null);
    log.info("User {}@{} successfully logged in with scopes: {}", credentials.getUsername(), credentials.getProfile(), ssoSession.getScope());
}
#method_after
public static void handleCredentials(SSOContext ssoContext, HttpServletRequest request, Credentials credentials) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_PROVIDE_USERNAME_PASSWORD_AND_PROFILE, (Locale) request.getAttribute(SSOConstants.LOCALE)));
    }
    SSOSession ssoSession = login(ssoContext, request, credentials, null);
    log.info("User {}@{} successfully logged in with scopes: {}", credentials.getUsername(), credentials.getProfile(), ssoSession.getScope());
}
#end_block

#method_before
public String localize(final String errorMsg, final Locale requestLocale) {
    Locale locale = requestLocale == null ? Locale.getDefault() : requestLocale;
    String ret = "";
    Map<String, String> messages = getMessages(locale);
    if (messages != null && messages.containsKey(errorMsg)) {
        ret = messages.get(errorMsg);
    } else {
        if (!(errorMsg == null || errorMsg.isEmpty())) {
            String[] splitted = errorMsg.toLowerCase().split("[_]", -1);
            ret = StringUtils.join(splitted, " ");
        }
    }
    return ret;
}
#method_after
public String localize(final String errorMsg, final Locale requestLocale) {
    String localizedErrorMsg = errorMsg;
    ResourceBundle resourceBundle = getResourceBundle(requestLocale == null ? defaultLocale : requestLocale);
    if (resourceBundle != null && resourceBundle.containsKey(errorMsg)) {
        localizedErrorMsg = resourceBundle.getString(errorMsg);
    }
    return localizedErrorMsg;
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered InteractiveChangePasswdServlet");
    Credentials userCredentials = null;
    String redirectUrl;
    try {
        log.debug("User is not authenticated extracting credentials from request.");
        userCredentials = getUserCredentials(request);
        if (userCredentials == null) {
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_UNABLE_TO_EXTRACT_CREDENTIALS, request.getLocale()));
        }
        if (!userCredentials.getNewCredentials().equals(userCredentials.getConfirmedNewCredentials())) {
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_PASSWORDS_DONT_MATCH, request.getLocale()));
        }
        redirectUrl = changeUserPasswd(request, userCredentials);
    } catch (Exception ex) {
        String msg = String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_CHANGE_PASSWORD_FAILED, request.getLocale()), userCredentials == null ? "" : userCredentials.getUsername() + "@" + userCredentials.getProfile(), ex.getMessage());
        log.error(msg);
        log.debug("Exception", ex);
        SSOUtils.getSsoSession(request).setChangePasswdMessage(msg);
        redirectUrl = request.getContextPath() + SSOConstants.INTERACTIVE_CHANGE_PASSWD_FORM_URI;
    }
    log.debug("Redirecting to url: {}", redirectUrl);
    response.sendRedirect(redirectUrl);
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered InteractiveChangePasswdServlet");
    Credentials userCredentials = null;
    String redirectUrl;
    try {
        log.debug("User is not authenticated extracting credentials from request.");
        userCredentials = getUserCredentials(request);
        if (userCredentials == null) {
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_UNABLE_TO_EXTRACT_CREDENTIALS, (Locale) request.getAttribute(SSOConstants.LOCALE)));
        }
        if (!userCredentials.getNewCredentials().equals(userCredentials.getConfirmedNewCredentials())) {
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_PASSWORDS_DONT_MATCH, (Locale) request.getAttribute(SSOConstants.LOCALE)));
        }
        redirectUrl = changeUserPasswd(request, userCredentials);
    } catch (Exception ex) {
        String msg = String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_CHANGE_PASSWORD_FAILED, (Locale) request.getAttribute(SSOConstants.LOCALE)), userCredentials == null ? "" : userCredentials.getUsername() + "@" + userCredentials.getProfile(), ex.getMessage());
        log.error(msg);
        log.debug("Exception", ex);
        SSOUtils.getSsoSession(request).setChangePasswdMessage(msg);
        redirectUrl = request.getContextPath() + SSOConstants.INTERACTIVE_CHANGE_PASSWD_FORM_URI;
    }
    log.debug("Redirecting to url: {}", redirectUrl);
    response.sendRedirect(redirectUrl);
}
#end_block

#method_before
private String changeUserPasswd(HttpServletRequest request, Credentials userCredentials) throws AuthenticationException {
    log.debug("Calling Authn to change password for user '{}@{}'.", userCredentials.getUsername(), userCredentials.getProfile());
    AuthenticationUtils.changePassword(ssoContext, request, userCredentials);
    SSOUtils.getSsoSession(request).setChangePasswdCredentials(null);
    if (SSOUtils.isUserAuthenticated(request)) {
        log.debug("User is authenticated updating password in SSOSession for password-access scope.");
        SSOUtils.persistUserPassword(request, SSOUtils.getSsoSession(request), userCredentials.getNewCredentials());
    } else {
        log.debug("User password change succeeded, redirecting to login page.");
        SSOUtils.getSsoSession(request).setLoginMessage(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_MSG_CHANGE_PASSWORD_SUCCEEDED, request.getLocale()));
    }
    return request.getContextPath() + SSOConstants.INTERACTIVE_LOGIN_URI;
}
#method_after
private String changeUserPasswd(HttpServletRequest request, Credentials userCredentials) throws AuthenticationException {
    log.debug("Calling Authn to change password for user '{}@{}'.", userCredentials.getUsername(), userCredentials.getProfile());
    AuthenticationUtils.changePassword(ssoContext, request, userCredentials);
    SSOUtils.getSsoSession(request).setChangePasswdCredentials(null);
    if (SSOUtils.isUserAuthenticated(request)) {
        log.debug("User is authenticated updating password in SSOSession for password-access scope.");
        SSOUtils.persistUserPassword(request, SSOUtils.getSsoSession(request), userCredentials.getNewCredentials());
    } else {
        log.debug("User password change succeeded, redirecting to login page.");
        SSOUtils.getSsoSession(request).setLoginMessage(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_MSG_CHANGE_PASSWORD_SUCCEEDED, (Locale) request.getAttribute(SSOConstants.LOCALE)));
    }
    return request.getContextPath() + SSOConstants.INTERACTIVE_LOGIN_URI;
}
#end_block

#method_before
private Credentials getUserCredentials(HttpServletRequest request) throws AuthenticationException {
    try {
        String username = SSOUtils.getParameter(request, USERNAME);
        String credentials = SSOUtils.getParameter(request, CREDENTIALS);
        String credentialsNew1 = SSOUtils.getParameter(request, CREDENTIALS_NEW1);
        String credentialsNew2 = SSOUtils.getParameter(request, CREDENTIALS_NEW2);
        String profile = SSOUtils.getParameter(request, PROFILE);
        return StringUtils.isNotEmpty(username) && StringUtils.isNotEmpty(credentials) && StringUtils.isNotEmpty(credentialsNew1) && StringUtils.isNotEmpty(credentialsNew2) && StringUtils.isNotEmpty(profile) ? new Credentials(username, credentials, credentialsNew1, credentialsNew2, profile) : null;
    } catch (Exception ex) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_UNABLE_TO_EXTRACT_CREDENTIALS, request.getLocale()), ex);
    }
}
#method_after
private Credentials getUserCredentials(HttpServletRequest request) throws AuthenticationException {
    try {
        String username = SSOUtils.getParameter(request, USERNAME);
        String credentials = SSOUtils.getParameter(request, CREDENTIALS);
        String credentialsNew1 = SSOUtils.getParameter(request, CREDENTIALS_NEW1);
        String credentialsNew2 = SSOUtils.getParameter(request, CREDENTIALS_NEW2);
        String profile = SSOUtils.getParameter(request, PROFILE);
        return StringUtils.isNotEmpty(username) && StringUtils.isNotEmpty(credentials) && StringUtils.isNotEmpty(credentialsNew1) && StringUtils.isNotEmpty(credentialsNew2) && StringUtils.isNotEmpty(profile) ? new Credentials(username, credentials, credentialsNew1, credentialsNew2, profile) : null;
    } catch (Exception ex) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_UNABLE_TO_EXTRACT_CREDENTIALS, (Locale) request.getAttribute(SSOConstants.LOCALE)), ex);
    }
}
#end_block

#method_before
private void validateQueryType(HttpServletRequest request) throws Exception {
    String queryType = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_SEARCH_QUERY_TYPE);
    if (!directoryQueries.containsKey(queryType) && !directoryPublicQueries.containsKey(queryType)) {
        throw new OAuthException(SSOConstants.ERR_CODE_INVALID_REQUEST, String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_UNSUPPORTED_PARAMETER_IN_REQUEST, request.getLocale()), queryType, SSOConstants.HTTP_PARAM_SEARCH_QUERY_TYPE));
    }
}
#method_after
private void validateQueryType(HttpServletRequest request) throws Exception {
    String queryType = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_SEARCH_QUERY_TYPE);
    if (!directoryQueries.containsKey(queryType) && !directoryPublicQueries.containsKey(queryType)) {
        throw new OAuthException(SSOConstants.ERR_CODE_INVALID_REQUEST, String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_UNSUPPORTED_PARAMETER_IN_REQUEST, (Locale) request.getAttribute(SSOConstants.LOCALE)), queryType, SSOConstants.HTTP_PARAM_SEARCH_QUERY_TYPE));
    }
}
#end_block

#method_before
public static final String mapMessageErrorCode(SSOContext ssoContext, HttpServletRequest request, String profile, ExtMap outputMap) {
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    String msg = messagesMap.containsKey(authResult) ? messagesMap.get(authResult) : SSOConstants.APP_ERROR_USER_FAILED_TO_AUTHENTICATE;
    boolean changePasswordSupported = false;
    if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
        if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null || SSOUtils.getSsoContext(request).getSsoProfilesSupportingPasswdChange().contains(profile)) {
            changePasswordSupported = true;
            msg = SSOConstants.APP_ERROR_USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED;
        } else {
            msg = SSOConstants.APP_ERROR_USER_PASSWORD_EXPIRED;
        }
    }
    msg = ssoContext.getLocalizationUtils().localize(msg, request.getLocale());
    if (changePasswordSupported) {
        msg = String.format(msg, request.getContextPath() + SSOConstants.INTERACTIVE_CHANGE_PASSWD_FORM_URI);
    }
    return msg;
}
#method_after
public static final String mapMessageErrorCode(SSOContext ssoContext, HttpServletRequest request, String profile, ExtMap outputMap) {
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    String msg = messagesMap.containsKey(authResult) ? messagesMap.get(authResult) : SSOConstants.APP_ERROR_USER_FAILED_TO_AUTHENTICATE;
    boolean changePasswordSupported = false;
    if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
        if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null || SSOUtils.getSsoContext(request).getSsoProfilesSupportingPasswdChange().contains(profile)) {
            changePasswordSupported = true;
            msg = SSOConstants.APP_ERROR_USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED;
        } else {
            msg = SSOConstants.APP_ERROR_USER_PASSWORD_EXPIRED;
        }
    }
    msg = ssoContext.getLocalizationUtils().localize(msg, (Locale) request.getAttribute(SSOConstants.LOCALE));
    if (changePasswordSupported) {
        msg = String.format(msg, request.getContextPath() + SSOConstants.INTERACTIVE_CHANGE_PASSWD_FORM_URI);
    }
    return msg;
}
#end_block

#method_before
private void issueTokenForLoginOnBehalf(HttpServletRequest request, HttpServletResponse response, String scope) throws Exception {
    log.debug("Entered issueTokenForLoginOnBehalf");
    String[] clientIdAndSecret = SSOUtils.getClientIdClientSecret(request);
    String username = SSOUtils.getRequestParameter(request, "username", null);
    log.debug("Attempting to issueTokenForLoginOnBehalf for client: {}, user: {}", clientIdAndSecret[0], username);
    AuthenticationUtils.loginOnBehalf(ssoContext, request, username);
    String token = (String) request.getAttribute(SSOConstants.HTTP_REQ_ATTR_ACCESS_TOKEN);
    SSOUtils.validateRequestScope(request, token, scope);
    SSOSession ssoSession = SSOUtils.getSsoSession(request, token, true);
    if (ssoSession == null) {
        throw new OAuthException(SSOConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED_FOR_USERNAME_PASSWORD, request.getLocale()));
    }
    log.debug("Sending json response");
    SSOUtils.sendJsonData(response, buildResponse(ssoSession));
}
#method_after
private void issueTokenForLoginOnBehalf(HttpServletRequest request, HttpServletResponse response, String scope) throws Exception {
    log.debug("Entered issueTokenForLoginOnBehalf");
    String[] clientIdAndSecret = SSOUtils.getClientIdClientSecret(request);
    String username = SSOUtils.getRequestParameter(request, "username", null);
    log.debug("Attempting to issueTokenForLoginOnBehalf for client: {}, user: {}", clientIdAndSecret[0], username);
    AuthenticationUtils.loginOnBehalf(ssoContext, request, username);
    String token = (String) request.getAttribute(SSOConstants.HTTP_REQ_ATTR_ACCESS_TOKEN);
    SSOUtils.validateRequestScope(request, token, scope);
    SSOSession ssoSession = SSOUtils.getSsoSession(request, token, true);
    if (ssoSession == null) {
        throw new OAuthException(SSOConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED_FOR_USERNAME_PASSWORD, (Locale) request.getAttribute(SSOConstants.LOCALE)));
    }
    log.debug("Sending json response");
    SSOUtils.sendJsonData(response, buildResponse(ssoSession));
}
#end_block

#method_before
private void issueTokenForPasswd(HttpServletRequest request, HttpServletResponse response, String scope) throws Exception {
    log.debug("Entered issueTokenForPasswd");
    Credentials credentials = null;
    try {
        credentials = SSOUtils.translateUser(SSOUtils.getRequestParameter(request, "username"), SSOUtils.getRequestParameter(request, "password"), ssoContext);
        String token = null;
        if (credentials != null && credentials.isValid()) {
            AuthenticationUtils.handleCredentials(ssoContext, request, credentials);
            token = (String) request.getAttribute(SSOConstants.HTTP_REQ_ATTR_ACCESS_TOKEN);
        }
        log.debug("Attempting to issueTokenForPasswd for user: {}", credentials.getUsername());
        SSOSession ssoSession = SSOUtils.getSsoSessionFromRequest(request, token);
        if (ssoSession == null) {
            throw new OAuthException(SSOConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED_FOR_USERNAME_PASSWORD, request.getLocale()));
        }
        SSOUtils.validateRequestScope(request, token, scope);
        log.debug("Sending json response");
        SSOUtils.sendJsonData(response, buildResponse(ssoSession));
    } catch (AuthenticationException ex) {
        String profile = "N/A";
        if (credentials != null) {
            profile = credentials.getProfile() == null ? "N/A" : credentials.getProfile();
        }
        throw new AuthenticationException(String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_CANNOT_AUTHENTICATE_USER_IN_DOMAIN, request.getLocale()), credentials == null ? "N/A" : credentials.getUsername(), profile, ex.getMessage()));
    }
}
#method_after
private void issueTokenForPasswd(HttpServletRequest request, HttpServletResponse response, String scope) throws Exception {
    log.debug("Entered issueTokenForPasswd");
    Credentials credentials = null;
    try {
        credentials = SSOUtils.translateUser(SSOUtils.getRequestParameter(request, "username"), SSOUtils.getRequestParameter(request, "password"), ssoContext);
        String token = null;
        if (credentials != null && credentials.isValid()) {
            AuthenticationUtils.handleCredentials(ssoContext, request, credentials);
            token = (String) request.getAttribute(SSOConstants.HTTP_REQ_ATTR_ACCESS_TOKEN);
        }
        log.debug("Attempting to issueTokenForPasswd for user: {}", credentials.getUsername());
        SSOSession ssoSession = SSOUtils.getSsoSessionFromRequest(request, token);
        if (ssoSession == null) {
            throw new OAuthException(SSOConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED_FOR_USERNAME_PASSWORD, (Locale) request.getAttribute(SSOConstants.LOCALE)));
        }
        SSOUtils.validateRequestScope(request, token, scope);
        log.debug("Sending json response");
        SSOUtils.sendJsonData(response, buildResponse(ssoSession));
    } catch (AuthenticationException ex) {
        String profile = "N/A";
        if (credentials != null) {
            profile = credentials.getProfile() == null ? "N/A" : credentials.getProfile();
        }
        throw new AuthenticationException(String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_CANNOT_AUTHENTICATE_USER_IN_DOMAIN, (Locale) request.getAttribute(SSOConstants.LOCALE)), credentials == null ? "N/A" : credentials.getUsername(), profile, ex.getMessage()));
    }
}
#end_block

#method_before
private void issueTokenUsingHttpHeaders(HttpServletRequest request, HttpServletResponse response) throws Exception {
    log.debug("Entered issueTokenUsingHttpHeaders");
    try {
        AuthResult authResult = null;
        for (NonInteractiveAuth auth : getAuthSeq()) {
            authResult = auth.doAuth(request, response);
            if (authResult.getStatus() == Authn.AuthResult.SUCCESS || authResult.getStatus() == Authn.AuthResult.NEGOTIATION_INCOMPLETE) {
                break;
            }
        }
        if (authResult != null && authResult.getStatus() != Authn.AuthResult.SUCCESS) {
            log.debug("Authentication failed using http headers");
            List<String> schemes = (List<String>) request.getAttribute(NegotiateAuthUtils.REQUEST_SCHEMES_KEY);
            for (String scheme : new HashSet<>(schemes == null ? Collections.<String>emptyList() : schemes)) {
                response.setHeader("WWW-Authenticate", scheme);
            }
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        } else if (authResult != null && StringUtils.isNotEmpty(authResult.getToken())) {
            SSOSession ssoSession = SSOUtils.getSsoSessionFromRequest(request, authResult.getToken());
            if (ssoSession == null) {
                throw new OAuthException(SSOConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED, request.getLocale()));
            }
            log.debug("Sending json response");
            SSOUtils.sendJsonData(response, buildResponse(ssoSession));
        } else {
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_AUTHENTICATION_FAILED, request.getLocale()));
        }
    } catch (Exception ex) {
        throw new AuthenticationException(String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_CANNOT_AUTHENTICATE_USER, request.getLocale()), ex.getMessage()));
    }
}
#method_after
private void issueTokenUsingHttpHeaders(HttpServletRequest request, HttpServletResponse response) throws Exception {
    log.debug("Entered issueTokenUsingHttpHeaders");
    try {
        AuthResult authResult = null;
        for (NonInteractiveAuth auth : getAuthSeq()) {
            authResult = auth.doAuth(request, response);
            if (authResult.getStatus() == Authn.AuthResult.SUCCESS || authResult.getStatus() == Authn.AuthResult.NEGOTIATION_INCOMPLETE) {
                break;
            }
        }
        if (authResult != null && authResult.getStatus() != Authn.AuthResult.SUCCESS) {
            log.debug("Authentication failed using http headers");
            List<String> schemes = (List<String>) request.getAttribute(NegotiateAuthUtils.REQUEST_SCHEMES_KEY);
            for (String scheme : new HashSet<>(schemes == null ? Collections.<String>emptyList() : schemes)) {
                response.setHeader("WWW-Authenticate", scheme);
            }
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        } else if (authResult != null && StringUtils.isNotEmpty(authResult.getToken())) {
            SSOSession ssoSession = SSOUtils.getSsoSessionFromRequest(request, authResult.getToken());
            if (ssoSession == null) {
                throw new OAuthException(SSOConstants.ERR_CODE_INVALID_GRANT, ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_AUTHORIZATION_GRANT_EXPIRED, (Locale) request.getAttribute(SSOConstants.LOCALE)));
            }
            log.debug("Sending json response");
            SSOUtils.sendJsonData(response, buildResponse(ssoSession));
        } else {
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_AUTHENTICATION_FAILED, (Locale) request.getAttribute(SSOConstants.LOCALE)));
        }
    } catch (Exception ex) {
        throw new AuthenticationException(String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_CANNOT_AUTHENTICATE_USER, (Locale) request.getAttribute(SSOConstants.LOCALE)), ex.getMessage()));
    }
}
#end_block

#method_before
private String authenticateUser(HttpServletRequest request, HttpServletResponse response, Credentials userCredentials) throws ServletException, IOException, AuthenticationException {
    if (userCredentials == null || !userCredentials.isValid()) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_INVALID_CREDENTIALS, request.getLocale()));
    }
    try {
        log.debug("Authenticating user using credentials");
        response.addCookie(new Cookie("profile", userCredentials.getProfile()));
        AuthenticationUtils.handleCredentials(ssoContext, request, userCredentials);
        return request.getContextPath() + SSOConstants.INTERACTIVE_REDIRECT_TO_MODULE_URI;
    } catch (AuthenticationException ex) {
        throw ex;
    } catch (Exception ex) {
        log.error("Internal Server Error: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new RuntimeException(ex);
    }
}
#method_after
private String authenticateUser(HttpServletRequest request, HttpServletResponse response, Credentials userCredentials) throws ServletException, IOException, AuthenticationException {
    if (userCredentials == null || !userCredentials.isValid()) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_INVALID_CREDENTIALS, (Locale) request.getAttribute(SSOConstants.LOCALE)));
    }
    try {
        log.debug("Authenticating user using credentials");
        response.addCookie(new Cookie("profile", userCredentials.getProfile()));
        AuthenticationUtils.handleCredentials(ssoContext, request, userCredentials);
        return request.getContextPath() + SSOConstants.INTERACTIVE_REDIRECT_TO_MODULE_URI;
    } catch (AuthenticationException ex) {
        throw ex;
    } catch (Exception ex) {
        log.error("Internal Server Error: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new RuntimeException(ex);
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        log.debug("Entered AuthorizeServlet QueryString: {}, Parameters : {}", request.getQueryString(), SSOUtils.getRequestParameters(request));
        String clientId = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_CLIENT_ID);
        String responseType = SSOUtils.getRequestParameter(request, SSOConstants.JSON_RESPONSE_TYPE);
        String scope = SSOUtils.getScopeRequestParameter(request, "");
        String state = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_STATE, "");
        String redirectUri = SSOUtils.getParameter(request, SSOConstants.HTTP_PARAM_REDIRECT_URI);
        SSOUtils.validateClientRequest(request, clientId, null, scope, redirectUri);
        if (!responseType.equals("code")) {
            throw new OAuthException(SSOConstants.ERR_CODE_INVALID_REQUEST, String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_UNSUPPORTED_PARAMETER_IN_REQUEST, request.getLocale()), responseType, SSOConstants.JSON_RESPONSE_TYPE));
        }
        login(request, response, clientId, scope, state, redirectUri);
    } catch (Exception ex) {
        SSOUtils.redirectToErrorPage(request, response, ex);
    }
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        log.debug("Entered AuthorizeServlet QueryString: {}, Parameters : {}", request.getQueryString(), SSOUtils.getRequestParameters(request));
        String clientId = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_CLIENT_ID);
        String responseType = SSOUtils.getRequestParameter(request, SSOConstants.JSON_RESPONSE_TYPE);
        String scope = SSOUtils.getScopeRequestParameter(request, "");
        String state = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_STATE, "");
        String redirectUri = SSOUtils.getParameter(request, SSOConstants.HTTP_PARAM_REDIRECT_URI);
        SSOUtils.validateClientRequest(request, clientId, null, scope, redirectUri);
        if (!responseType.equals("code")) {
            throw new OAuthException(SSOConstants.ERR_CODE_INVALID_REQUEST, String.format(ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_UNSUPPORTED_PARAMETER_IN_REQUEST, (Locale) request.getAttribute(SSOConstants.LOCALE)), responseType, SSOConstants.JSON_RESPONSE_TYPE));
        }
        login(request, response, clientId, scope, state, redirectUri);
    } catch (Exception ex) {
        SSOUtils.redirectToErrorPage(request, response, ex);
    }
}
#end_block

#method_before
private void login(HttpServletRequest request, HttpServletResponse response, String clientId, String scope, String state, String redirectUri) throws Exception {
    log.debug("Entered login queryString: {}", request.getQueryString());
    String redirectUrl;
    // Create the session
    request.getSession(true);
    SSOSession ssoSession = SSOUtils.getSsoSession(request);
    ssoSession.setClientId(clientId);
    ssoSession.setRedirectUri(redirectUri);
    ssoSession.setScope(scope);
    ssoSession.setState(state);
    ssoSession.getHttpSession().setMaxInactiveInterval(-1);
    if (SSOUtils.isUserAuthenticated(request)) {
        log.debug("User is authenticated redirecting to interactive-redirect-to-module");
        redirectUrl = request.getContextPath() + SSOConstants.INTERACTIVE_REDIRECT_TO_MODULE_URI;
    } else if (SSOUtils.scopeAsList(scope).contains("ovirt-ext=auth:identity")) {
        redirectUrl = new URLBuilder(SSOUtils.getRedirectUrl(request)).addParameter("error_code", SSOConstants.ERR_OVIRT_CODE_NOT_AUTHENTICATED).addParameter("error", SSOConstants.ERR_CODE_NOT_AUTHENTICATED_MSG).build();
    } else {
        ssoSession.setAuthStack(getAuthSeq(scope));
        if (ssoSession.getAuthStack().isEmpty()) {
            throw new OAuthException(SSOConstants.ERR_CODE_ACCESS_DENIED, ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_NO_VALID_AUTHENTICATION_MECHANISM_FOUND, request.getLocale()));
        }
        redirectUrl = request.getContextPath() + SSOConstants.INTERACTIVE_LOGIN_NEXT_AUTH_URI;
    }
    log.debug("Redirecting to url: {}", redirectUrl);
    response.sendRedirect(redirectUrl);
}
#method_after
private void login(HttpServletRequest request, HttpServletResponse response, String clientId, String scope, String state, String redirectUri) throws Exception {
    log.debug("Entered login queryString: {}", request.getQueryString());
    String redirectUrl;
    // Create the session
    request.getSession(true);
    SSOSession ssoSession = SSOUtils.getSsoSession(request);
    ssoSession.setClientId(clientId);
    ssoSession.setRedirectUri(redirectUri);
    ssoSession.setScope(scope);
    ssoSession.setState(state);
    ssoSession.getHttpSession().setMaxInactiveInterval(-1);
    if (SSOUtils.isUserAuthenticated(request)) {
        log.debug("User is authenticated redirecting to interactive-redirect-to-module");
        redirectUrl = request.getContextPath() + SSOConstants.INTERACTIVE_REDIRECT_TO_MODULE_URI;
    } else if (SSOUtils.scopeAsList(scope).contains("ovirt-ext=auth:identity")) {
        redirectUrl = new URLBuilder(SSOUtils.getRedirectUrl(request)).addParameter("error_code", SSOConstants.ERR_OVIRT_CODE_NOT_AUTHENTICATED).addParameter("error", SSOConstants.ERR_CODE_NOT_AUTHENTICATED_MSG).build();
    } else {
        ssoSession.setAuthStack(getAuthSeq(scope));
        if (ssoSession.getAuthStack().isEmpty()) {
            throw new OAuthException(SSOConstants.ERR_CODE_ACCESS_DENIED, ssoContext.getLocalizationUtils().localize(SSOConstants.APP_ERROR_NO_VALID_AUTHENTICATION_MECHANISM_FOUND, (Locale) request.getAttribute(SSOConstants.LOCALE)));
        }
        redirectUrl = request.getContextPath() + SSOConstants.INTERACTIVE_LOGIN_NEXT_AUTH_URI;
    }
    log.debug("Redirecting to url: {}", redirectUrl);
    response.sendRedirect(redirectUrl);
}
#end_block

#method_before
@Override
protected void setClientTokenProvider(Quantum client) {
    Keystone keystone = new Keystone(provider.getAuthUrl());
    OpenStackTokenProvider tokenProvider = new OpenStackTokenProvider() {

        private Access access;

        @Override
        public String getToken() {
            if (access == null) {
                access = keystone.tokens().authenticate(new UsernamePassword(provider.getUsername(), provider.getPassword())).execute();
            }
            return access.getToken().getId();
        }

        @Override
        public void expireToken() {
            access = null;
        }
    };
    client.setTokenProvider(tokenProvider);
}
#method_after
@Override
protected void setClientTokenProvider(Quantum client) {
    OpenStackTokenProvider tokenProvider = new ExternalNetworkTokenProvider(provider);
    client.setTokenProvider(tokenProvider);
}
#end_block

#method_before
@Override
public String add(Network network) {
    if (isReadOnly()) {
        throw new EngineException(EngineError.NO_IMPLEMENTATION);
    }
    return super.add(network);
}
#method_after
@Override
public String add(Network network) {
    testProviderIsNotReadOnly();
    return super.add(network);
}
#end_block

#method_before
@Override
public void remove(String id) {
    if (isReadOnly()) {
        throw new EngineException(EngineError.NO_IMPLEMENTATION);
    }
    super.remove(id);
}
#method_after
@Override
public void remove(String id) {
    testProviderIsNotReadOnly();
    super.remove(id);
}
#end_block

#method_before
@Override
public void addSubnet(ExternalSubnet subnet) {
    if (isReadOnly()) {
        throw new EngineException(EngineError.NO_IMPLEMENTATION);
    }
    super.addSubnet(subnet);
}
#method_after
@Override
public void addSubnet(ExternalSubnet subnet) {
    testProviderIsNotReadOnly();
    super.addSubnet(subnet);
}
#end_block

#method_before
@Override
public void removeSubnet(String id) {
    if (isReadOnly()) {
        throw new EngineException(EngineError.NO_IMPLEMENTATION);
    }
    super.removeSubnet(id);
}
#method_after
@Override
public void removeSubnet(String id) {
    testProviderIsNotReadOnly();
    super.removeSubnet(id);
}
#end_block

#method_before
private void initExternalProviderList() {
    AsyncQuery getProvidersQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            List<Provider> providers = new LinkedList();
            for (Provider provider : (List<Provider>) result) {
                if (isProviderReadOnly(provider)) {
                    continue;
                }
                providers.add(provider);
            }
            getExternalProviders().setItems(providers);
            selectExternalProvider();
        }
    });
    AsyncDataProvider.getInstance().getAllNetworkProviders(getProvidersQuery);
}
#method_after
private void initExternalProviderList() {
    AsyncQuery getProvidersQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            List<Provider> providers = getNonReadOnlyExternalNetworkProviders(result);
            getExternalProviders().setItems(providers);
            selectExternalProvider();
        }
    });
    AsyncDataProvider.getInstance().getAllNetworkProviders(getProvidersQuery);
}
#end_block

#method_before
private AsyncQuery createProviderReadOnlyCallback(final Set<Guid> externalProviderIds) {
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Provider> providers = (List<Provider>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean isReadOnly = checkForRemoveExternalNetworkAvailability(providers, externalProviderIds);
            makeRemoveExternalNetworkAvailable(isReadOnly);
        }
    };
    return asyncQuery;
}
#method_after
private AsyncQuery createProviderReadOnlyCallback(final Set<Guid> externalProviderIds) {
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Provider> providers = (List<Provider>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean isReadOnly = checkForRemoveExternalNetworkAvailability(providers, externalProviderIds);
            makeRemoveExternalNetworkCheckboxAvailable(isReadOnly);
        }
    };
    return asyncQuery;
}
#end_block

#method_before
protected boolean checkForRemoveExternalNetworkAvailability(List<Provider> providers, Set<Guid> externalProviderIds) {
    for (Provider provider : providers) {
        if (externalProviderIds.contains(provider.getId())) {
            ExternalNetworkProviderProperties properties = (ExternalNetworkProviderProperties) provider.getAdditionalProperties();
            if (properties.getReadOnly()) {
                // If any of the providers is read only, abort
                return true;
            }
        }
    }
    return false;
}
#method_after
/**
 * Check if any of the providers in externalProviderIds is read only
 * @param providers providers retrieved from the backend
 * @param externalProviderIds Set of all external provider id's to which the removed networks belong
 * @return true if any of the providers is read only
 */
protected boolean checkForRemoveExternalNetworkAvailability(List<Provider> providers, Set<Guid> externalProviderIds) {
    for (Provider provider : providers) {
        if (externalProviderIds.contains(provider.getId())) {
            ExternalNetworkProviderProperties properties = (ExternalNetworkProviderProperties) provider.getAdditionalProperties();
            if (properties.getReadOnly()) {
                // If any of the providers is read only, abort
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected boolean validate() {
    NetworkValidator validator = new NetworkValidator(vmDao, getNetworkDao().get(getNetwork().getId()));
    ValidationResult providerValidationResult = validateRemoveExternalNetwork();
    return validate(validator.networkIsSet(getParameters().getId())) && validate(validator.notRemovingManagementNetwork()) && validate(validator.notIscsiBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates()) && validate(providerValidationResult);
}
#method_after
@Override
protected boolean validate() {
    NetworkValidator validator = new NetworkValidator(vmDao, getNetworkDao().get(getNetwork().getId()));
    return validate(validator.networkIsSet(getParameters().getId())) && validate(validator.notRemovingManagementNetwork()) && validate(validator.notIscsiBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates()) && validate(getRemoveExternalNetworkValidationResult());
}
#end_block

#method_before
String getProviderNameReplacement() {
    return String.format(PROVIDER_NAME_REPLACEMENT, provider.getName());
}
#method_after
private String getProviderNameReplacement() {
    return ReplacementUtils.getVariableAssignmentString(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_PROVIDER_IS_READ_ONLY, provider.getName());
}
#end_block

#method_before
private void setCommandExecutionAllowed(boolean isAllowed) {
    isExecutionAllowed = isAllowed;
    newCommand.setIsExecutionAllowed(isAllowed);
    removeCommand.setIsExecutionAllowed(isAllowed);
}
#method_after
private void setCommandExecutionAllowed(boolean isAllowed) {
    isExecutionAllowed = isAllowed;
    updateActionAvailability();
}
#end_block

#method_before
private void updateActionAvailability() {
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0 && isExecutionAllowed);
}
#method_after
private void updateActionAvailability() {
    newCommand.setIsExecutionAllowed(isExecutionAllowed);
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0 && isExecutionAllowed);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            waitForConnectionStateChange();
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            if (client.isClosed()) {
                waitUntilCheck(client -> client.isClosed(), "Waiting on losing connection to {}", "Connection lost for {}");
            }
            waitUntilCheck(client -> !client.isClosed(), "Waiting on opening connection for {}", "Done reconnecting for {}!");
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
private void generateRequestParameterImplementation(Parameter parameter) {
    Method method = parameter.getDeclaringMethod();
    Type type = parameter.getType();
    Name name = parameter.getName();
    String member = javaNames.getJavaMemberStyleName(name);
    String request = getRequestName(method);
    if (type instanceof PrimitiveType) {
        Model model = type.getModel();
        if (type == model.getBooleanType()) {
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "Boolean");
        } else if (type == model.getStringType()) {
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "String");
        } else if (type == model.getIntegerType()) {
            buffer.addImport(BigInteger.class);
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "BigInteger");
            generateRequestParameterMultiMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "BigInteger", "Integer", "Long");
        } else if (type == model.getDecimalType()) {
            buffer.addImport(BigDecimal.class);
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "BigDecimal");
            generateRequestParameterMultiMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "BigDecimal", "Float", "Double");
        } else if (type == model.getDateType()) {
            buffer.addImport(Date.class);
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "Date");
        }
    } else if (type instanceof StructType) {
        // Method taking an object:
        JavaClassName typeName = javaTypes.getInterfaceName(type);
        buffer.addImport(typeName);
        generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, typeName.getSimpleName());
        // Method taking a builder:
        JavaClassName builderName = javaTypes.getBuilderName(type);
        buffer.addImport(builderName);
        generateRequestParameterBuilderMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, builderName.getSimpleName());
    } else if (type instanceof ListType) {
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        // Method taking a list of objects:
        JavaClassName elementName = javaTypes.getInterfaceName(elementType);
        buffer.addImport(elementName);
        buffer.addImport(List.class);
        generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "List<" + elementName.getSimpleName() + ">");
        // Method taking an array of objects:
        buffer.addImport(elementName);
        buffer.addImport(Arrays.class);
        generateRequestParameterArgsMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, elementName.getSimpleName() + "...");
        // Method taking an array of builders:
        JavaClassName builderName = javaTypes.getBuilderName(elementType);
        buffer.addImport(builderName);
        generateRequestParameterArgsBuilderMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, builderName.getSimpleName() + "...");
    }
}
#method_after
private void generateRequestParameterImplementation(Parameter parameter) {
    Method method = parameter.getDeclaringMethod();
    Type type = parameter.getType();
    Name name = parameter.getName();
    String member = javaNames.getJavaMemberStyleName(name);
    String request = getRequestName(method);
    if (type instanceof PrimitiveType) {
        Model model = type.getModel();
        if (type == model.getBooleanType()) {
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "Boolean");
        } else if (type == model.getStringType()) {
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "String");
        } else if (type == model.getIntegerType()) {
            buffer.addImport(BigInteger.class);
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "BigInteger");
            generateRequestParameterMultiMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "BigInteger", "Integer", "Long");
        } else if (type == model.getDecimalType()) {
            buffer.addImport(BigDecimal.class);
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "BigDecimal");
            generateRequestParameterMultiMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "BigDecimal", "Float", "Double");
        } else if (type == model.getDateType()) {
            buffer.addImport(Date.class);
            generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "Date");
        }
    } else if (type instanceof StructType) {
        // Method taking an object:
        JavaClassName typeName = javaTypes.getInterfaceName(type);
        buffer.addImport(typeName);
        generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, typeName.getSimpleName());
        // Method taking a builder:
        JavaClassName builderName = javaTypes.getBuilderName(type);
        buffer.addImport(builderName);
        generateRequestParameterBuilderMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, builderName.getSimpleName());
    } else if (type instanceof ListType) {
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        // Method taking a list of objects:
        JavaClassName elementName = javaTypes.getInterfaceName(elementType);
        buffer.addImport(elementName);
        buffer.addImport(List.class);
        generateRequestParameterMethodImplementation("public %1s %2$s(%3$s %2$s) {", request, member, "List<" + elementName.getSimpleName() + ">");
        // Method taking an array of objects:
        buffer.addImport(elementName);
        buffer.addImport(Arrays.class);
        generateRequestParameterArgsMethodImplementation("public %1s %2$s(%3$s... %2$s) {", request, member, elementName.getSimpleName());
        // Method taking an array of builders:
        JavaClassName builderName = javaTypes.getBuilderName(elementType);
        buffer.addImport(builderName);
        generateRequestParameterArgsBuilderMethodImplementation("public %1s %2$s(%3$s... %2$s) {", request, member, builderName.getSimpleName());
    }
}
#end_block

#method_before
private void generateRequestParameterArgsBuilderMethodImplementation(String format, String request, String member, String type) {
    buffer.addImport(ArrayList.class);
    buffer.addLine(format, request, member, type);
    buffer.addLine("this.%1$s = new ArrayList<>();", member);
    buffer.addLine("for (int i = 0; i < %1$s.length; i++) {", member);
    buffer.addLine("this.%1$s.add(%1$s[i].build());", member);
    buffer.addLine("}");
    buffer.addLine("return this;");
    buffer.addLine("}");
    buffer.addLine();
}
#method_after
private void generateRequestParameterArgsBuilderMethodImplementation(String format, String request, String member, String type) {
    buffer.addImport(ArrayList.class);
    buffer.addLine(format, request, member, type);
    buffer.addLine("this.%1$s = new ArrayList<>(%1$s.length);", member);
    buffer.addLine("for (%1$s element : %2$s) {", type, member);
    buffer.addLine("this.%1$s.add(element.build());", member);
    buffer.addLine("}");
    buffer.addLine("return this;");
    buffer.addLine("}");
    buffer.addLine();
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(Provider<?> entity) {
    MapSqlParameterSource mapper = createBaseProviderParametersMapper(entity);
    String tenantName = null;
    String pluginType = null;
    AgentConfiguration agentConfiguration = null;
    AdditionalProperties additionalProperties = null;
    if (entity.getAdditionalProperties() != null) {
        switch(entity.getType()) {
            case EXTERNAL_NETWORK:
                ExternalNetworkProviderProperties externalNetworkProperties = (ExternalNetworkProviderProperties) entity.getAdditionalProperties();
                break;
            case OPENSTACK_NETWORK:
                OpenstackNetworkProviderProperties networkProperties = (OpenstackNetworkProviderProperties) entity.getAdditionalProperties();
                tenantName = networkProperties.getTenantName();
                pluginType = networkProperties.getPluginType();
                agentConfiguration = networkProperties.getAgentConfiguration();
                break;
            case OPENSTACK_IMAGE:
                OpenStackImageProviderProperties imageProperties = (OpenStackImageProviderProperties) entity.getAdditionalProperties();
                tenantName = imageProperties.getTenantName();
                break;
            case OPENSTACK_VOLUME:
                OpenStackVolumeProviderProperties volumeProperties = (OpenStackVolumeProviderProperties) entity.getAdditionalProperties();
                tenantName = volumeProperties.getTenantName();
                break;
            case VMWARE:
                additionalProperties = entity.getAdditionalProperties();
                break;
            default:
                break;
        }
    }
    // We always add the values since JdbcTeplate expects them to be set, otherwise it throws an exception.
    mapper.addValue("tenant_name", tenantName);
    mapper.addValue("plugin_type", pluginType);
    mapper.addValue("agent_configuration", SerializationFactory.getSerializer().serialize(agentConfiguration));
    mapper.addValue("additional_properties", SerializationFactory.getSerializer().serialize(additionalProperties));
    return mapper;
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(Provider<?> entity) {
    MapSqlParameterSource mapper = createBaseProviderParametersMapper(entity);
    String tenantName = null;
    String pluginType = null;
    AgentConfiguration agentConfiguration = null;
    AdditionalProperties additionalProperties = null;
    if (entity.getAdditionalProperties() != null) {
        switch(entity.getType()) {
            case EXTERNAL_NETWORK:
                break;
            case OPENSTACK_NETWORK:
                OpenstackNetworkProviderProperties networkProperties = (OpenstackNetworkProviderProperties) entity.getAdditionalProperties();
                tenantName = networkProperties.getTenantName();
                pluginType = networkProperties.getPluginType();
                agentConfiguration = networkProperties.getAgentConfiguration();
                break;
            case OPENSTACK_IMAGE:
                OpenStackImageProviderProperties imageProperties = (OpenStackImageProviderProperties) entity.getAdditionalProperties();
                tenantName = imageProperties.getTenantName();
                break;
            case OPENSTACK_VOLUME:
                OpenStackVolumeProviderProperties volumeProperties = (OpenStackVolumeProviderProperties) entity.getAdditionalProperties();
                tenantName = volumeProperties.getTenantName();
                break;
            case VMWARE:
                additionalProperties = entity.getAdditionalProperties();
                break;
            default:
                break;
        }
    }
    // We always add the values since JdbcTeplate expects them to be set, otherwise it throws an exception.
    mapper.addValue("tenant_name", tenantName);
    mapper.addValue("plugin_type", pluginType);
    mapper.addValue("agent_configuration", SerializationFactory.getSerializer().serialize(agentConfiguration));
    mapper.addValue("additional_properties", SerializationFactory.getSerializer().serialize(additionalProperties));
    return mapper;
}
#end_block

#method_before
@Override
protected void setClientTokenProvider(Quantum client) {
    Keystone keystone = new Keystone(provider.getAuthUrl());
    OpenStackTokenProvider tokenProvider = new OpenStackTokenProvider() {

        private Access access;

        @Override
        public String getToken() {
            if (access == null) {
                access = keystone.tokens().authenticate(new UsernamePassword(provider.getUsername(), provider.getPassword())).execute();
            }
            return access.getToken().getId();
        }

        @Override
        public void expireToken() {
            access = null;
        }
    };
    client.setTokenProvider(tokenProvider);
}
#method_after
@Override
protected void setClientTokenProvider(Quantum client) {
    OpenStackTokenProvider tokenProvider = new ExternalNetworkTokenProvider(provider);
    client.setTokenProvider(tokenProvider);
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    validateName();
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        validateCPU();
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getManagementNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getManagementNetwork().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    if (getVersion().getSelectedItem() != null && AsyncDataProvider.getInstance().isConfigurableMigrationsSupported(getVersion().getSelectedItem()) && MigrationBandwidthLimitType.CUSTOM.equals(getMigrationBandwidthLimitType().getSelectedItem())) {
        getCustomMigrationNetworkBandwidth().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    }
    final boolean migrationTabValid = getMigrationBandwidthLimitType().getIsValid() && getCustomMigrationNetworkBandwidth().getIsValid();
    setValidTab(TabName.MIGRATION_TAB, migrationTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid() && migrationTabValid;
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    validateName();
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        validateCPU();
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getManagementNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getManagementNetwork().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    if (getVersion().getSelectedItem() != null) {
        if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(getVersion().getSelectedItem()) && MigrationBandwidthLimitType.CUSTOM.equals(getMigrationBandwidthLimitType().getSelectedItem())) {
            getCustomMigrationNetworkBandwidth().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
        } else {
            getCustomMigrationNetworkBandwidth().setIsValid(true);
        }
    }
    final boolean migrationTabValid = getMigrationBandwidthLimitType().getIsValid() && getCustomMigrationNetworkBandwidth().getIsValid();
    setValidTab(TabName.MIGRATION_TAB, migrationTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid() && migrationTabValid;
}
#end_block

#method_before
@Override
public void init(final ClusterModel model) {
    super.init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("AllowClusterWithVirtGlusterEnabled".equals(propName)) {
                // $NON-NLS-1$
                getView().allowClusterWithVirtGlusterEnabled(model.getAllowClusterWithVirtGlusterEnabled());
            }
        }
    });
    String spiceProxyInConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.SpiceProxyDefault);
    String spiceProxyMessage = StringHelper.isNullOrEmpty(spiceProxyInConfig) ? messages.noSpiceProxyDefined() : spiceProxyInConfig;
    getView().setSpiceProxyOverrideExplanation(messages.consoleOverrideSpiceProxyMessage(messages.consoleOverrideDefinedInGlobalConfig(), spiceProxyMessage));
    getModel().getVersion().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            final Version selectedVersion = getModel().getVersion().getSelectedItem();
            if (selectedVersion == null) {
                return;
            }
            if (AsyncDataProvider.getInstance().isConfigurableMigrationsSupported(selectedVersion)) {
                getView().getMigrationBandwidthLimitTypeEditor().setEnabled(true);
                updateCustomMigrationBandwidthLimitEnabledState(model, null);
            } else {
                final String supportedVersions = StringUtils.join(AsyncDataProvider.getInstance().getConfigurableMigrationsSupportedVersions(), // $NON-NLS-1$
                ", ");
                final String message = messages.onlyAvailableInCompatibilityVersions(supportedVersions);
                getView().getMigrationBandwidthLimitTypeEditor().disable(message);
                updateCustomMigrationBandwidthLimitEnabledState(model, message);
            }
        }
    });
    getModel().getMigrationBandwidthLimitType().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateCustomMigrationBandwidthLimitEnabledState(model, null);
        }
    });
}
#method_after
@Override
public void init(final ClusterModel model) {
    super.init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("AllowClusterWithVirtGlusterEnabled".equals(propName)) {
                // $NON-NLS-1$
                getView().allowClusterWithVirtGlusterEnabled(model.getAllowClusterWithVirtGlusterEnabled());
            }
        }
    });
    String spiceProxyInConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.SpiceProxyDefault);
    String spiceProxyMessage = StringHelper.isNullOrEmpty(spiceProxyInConfig) ? messages.noSpiceProxyDefined() : spiceProxyInConfig;
    getView().setSpiceProxyOverrideExplanation(messages.consoleOverrideSpiceProxyMessage(messages.consoleOverrideDefinedInGlobalConfig(), spiceProxyMessage));
    getModel().getVersion().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            final Version selectedVersion = getModel().getVersion().getSelectedItem();
            if (selectedVersion == null) {
                return;
            }
            if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(selectedVersion)) {
                getView().getMigrationBandwidthLimitTypeEditor().setEnabled(true);
                updateCustomMigrationBandwidthLimitEnabledState(model, null);
            } else {
                final String supportedVersions = StringUtils.join(AsyncDataProvider.getInstance().getMigrationPoliciesSupportedVersions(), // $NON-NLS-1$
                ", ");
                final String message = messages.onlyAvailableInCompatibilityVersions(supportedVersions);
                getView().getMigrationBandwidthLimitTypeEditor().disable(message);
                updateCustomMigrationBandwidthLimitEnabledState(model, message);
            }
        }
    });
    getModel().getMigrationBandwidthLimitType().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateCustomMigrationBandwidthLimitEnabledState(model, null);
        }
    });
}
#end_block

#method_before
private Optional<Boolean> computeCustomMigrationBandwidthLimitEnabledState(ClusterModel clusterModel) {
    final Version clusterVersion = clusterModel.getVersion().getSelectedItem();
    final MigrationBandwidthLimitType limitType = clusterModel.getMigrationBandwidthLimitType().getSelectedItem();
    if (clusterVersion == null || limitType == null) {
        return Optional.empty();
    }
    final Optional<Boolean> enabled = Optional.of(AsyncDataProvider.getInstance().isConfigurableMigrationsSupported(clusterVersion) && limitType == MigrationBandwidthLimitType.CUSTOM);
    return enabled;
}
#method_after
private Optional<Boolean> computeCustomMigrationBandwidthLimitEnabledState(ClusterModel clusterModel) {
    final Version clusterVersion = clusterModel.getVersion().getSelectedItem();
    final MigrationBandwidthLimitType limitType = clusterModel.getMigrationBandwidthLimitType().getSelectedItem();
    if (clusterVersion == null || limitType == null) {
        return Optional.empty();
    }
    final Optional<Boolean> enabled = Optional.of(AsyncDataProvider.getInstance().isMigrationPoliciesSupported(clusterVersion) && limitType == MigrationBandwidthLimitType.CUSTOM);
    return enabled;
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecutePartially(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecutePartially(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(guestAgentPresent || acpiEnabled)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public Object convert(Object source, AsyncQuery _asyncQuery) {
    if (source != null) {
        ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
        ArrayList<String> fileNameList = new ArrayList<>();
        for (RepoImage repoImage : repoList) {
            if (desiredImage(repoImage)) {
                fileNameList.add(transform(fileNameList, repoImage));
            }
        }
        Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
        return fileNameList;
    }
    return new ArrayList<String>();
}
#method_after
@Override
public Object convert(Object source, AsyncQuery _asyncQuery) {
    if (source != null) {
        ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
        ArrayList<String> fileNameList = new ArrayList<>();
        for (RepoImage repoImage : repoList) {
            if (desiredImage(repoImage)) {
                fileNameList.add(transform(fileNameList, repoImage));
            }
        }
        Collections.sort(fileNameList, new LexoNumericComparator());
        return fileNameList;
    }
    return new ArrayList<String>();
}
#end_block

#method_before
private Cluster buildCluster(ClusterModel model) {
    Cluster cluster = model.getIsNew() ? new Cluster() : (Cluster) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(true);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    cluster.setMigrationBandwidthLimitType(model.getMigrationBandwidthLimitType().getSelectedItem());
    cluster.setCustomMigrationNetworkBandwidth(model.getCustomMigrationNetworkBandwidth().getEntity());
    return cluster;
}
#method_after
private Cluster buildCluster(ClusterModel model) {
    Cluster cluster = model.getIsNew() ? new Cluster() : (Cluster) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(true);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    cluster.setMigrationBandwidthLimitType(model.getMigrationBandwidthLimitType().getSelectedItem());
    cluster.setCustomMigrationNetworkBandwidth(MigrationBandwidthLimitType.CUSTOM.equals(model.getMigrationBandwidthLimitType().getSelectedItem()) ? model.getCustomMigrationNetworkBandwidth().getEntity() : null);
    return cluster;
}
#end_block

#method_before
public ValidationResult isDiskAttachedToVm(VM vm) {
    List<VM> vms = getVmDao().getVmsListForDisk(disk.getId(), true);
    String[] replacements = { String.format(DISK_NAME_REPLACEMENT, disk.getDiskAlias()), String.format(VM_NAME_REPLACEMENT, vm.getName()) };
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_ATTACHED_TO_VM, replacements).when(vms.stream().noneMatch(vm1 -> vm1.getId().equals(vm.getId())));
}
#method_after
public ValidationResult isDiskAttachedToVm(VM vm) {
    List<VM> vms = getVmDao().getVmsListForDisk(disk.getId(), true);
    String[] replacements = { ReplacementUtils.createSetVariableString(DISK_NAME_VARIABLE, disk.getDiskAlias()), ReplacementUtils.createSetVariableString(VM_NAME_VARIABLE, vm.getName()) };
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_ATTACHED_TO_VM, replacements).when(vms.stream().noneMatch(vm1 -> vm1.getId().equals(vm.getId())));
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            if (originVersion.less(Version.v4_0) && DisplayType.cirrus == defaultDisplayType) {
                log.info("Upgrading default display type from '{}' to '{}'", defaultDisplayType.name(), DisplayType.qxl.name());
                defaultDisplayType = DisplayType.qxl;
            }
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    Version version = new Version(getVersion());
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    removeUpgradedDisplayDevice();
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    // if boot order is not set, figure out some default based on the set of bootable disks
    setDefaultBootDevice();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText) && !FeatureSupported.isIoThreadsSupported(version)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    Version version = new Version(getVersion());
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    // if boot order is not set, figure out some default based on the set of bootable disks
    setDefaultBootDevice();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText) && !FeatureSupported.isIoThreadsSupported(version)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#end_block

#method_before
@Override
protected void setClientTokenProvider(Quantum client) {
    String tenantName = ((OpenstackNetworkProviderProperties) provider.getAdditionalProperties()).getTenantName();
    KeystoneTokenProvider keystoneTokenProvider = new KeystoneTokenProvider(provider.getAuthUrl(), provider.getUsername(), provider.getPassword());
    client.setTokenProvider(keystoneTokenProvider.getProviderByTenant(tenantName));
}
#method_after
@Override
protected void setClientTokenProvider(Quantum client) {
    String tenantName = provider.getAdditionalProperties().getTenantName();
    KeystoneTokenProvider keystoneTokenProvider = new KeystoneTokenProvider(provider.getAuthUrl(), provider.getUsername(), provider.getPassword());
    client.setTokenProvider(keystoneTokenProvider.getProviderByTenant(tenantName));
}
#end_block

#method_before
protected Map<String, String> createPortAllocationRuntimeProperties(Port port) {
    Map<String, String> runtimeProperties = super.createPortAllocationRuntimeProperties(port);
    runtimeProperties.put("plugin_type", ((OpenstackNetworkProviderProperties) provider.getAdditionalProperties()).getPluginType());
    return runtimeProperties;
}
#method_after
@Override
protected Map<String, String> createPortAllocationRuntimeProperties(Port port) {
    Map<String, String> runtimeProperties = super.createPortAllocationRuntimeProperties(port);
    runtimeProperties.put("plugin_type", provider.getAdditionalProperties().getPluginType());
    return runtimeProperties;
}
#end_block

#method_before
protected Port createNewPortForAllocate(VmNic nic, List<String> securityGroups, String hostId, com.woorea.openstack.quantum.model.Network externalNetwork) {
    Port portForCreate = super.createNewPortForAllocate(nic, securityGroups, hostId, externalNetwork);
    portForCreate.setTenantId(externalNetwork.getTenantId());
    return portForCreate;
}
#method_after
@Override
protected Port createNewPortForAllocate(VmNic nic, List<String> securityGroups, String hostId, com.woorea.openstack.quantum.model.Network externalNetwork) {
    Port portForCreate = super.createNewPortForAllocate(nic, securityGroups, hostId, externalNetwork);
    portForCreate.setTenantId(externalNetwork.getTenantId());
    return portForCreate;
}
#end_block

#method_before
protected Subnet createNewSubnetEntity(ExternalSubnet subnet, com.woorea.openstack.quantum.model.Network externalNetwork) {
    Subnet subnetForCreate = super.createNewSubnetEntity(subnet, externalNetwork);
    subnetForCreate.setTenantId(externalNetwork.getTenantId());
    return subnetForCreate;
}
#method_after
@Override
protected Subnet createNewSubnetEntity(ExternalSubnet subnet, com.woorea.openstack.quantum.model.Network externalNetwork) {
    Subnet subnetForCreate = super.createNewSubnetEntity(subnet, externalNetwork);
    subnetForCreate.setTenantId(externalNetwork.getTenantId());
    return subnetForCreate;
}
#end_block

#method_before
protected com.woorea.openstack.quantum.model.Network createNewNetworkEntity(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = super.createNewNetworkEntity(network);
    networkForCreate.setTenantId(DEVICE_OWNER);
    return networkForCreate;
}
#method_after
@Override
protected com.woorea.openstack.quantum.model.Network createNewNetworkEntity(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = super.createNewNetworkEntity(network);
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    return networkForCreate;
}
#end_block

#method_before
public boolean readBoolean() {
    String image = readString();
    if (image.equalsIgnoreCase("false") || image.equals("0")) {
        return false;
    } else if (image.equalsIgnoreCase("true") || image.equals("1")) {
        return true;
    } else {
        throw new XmlException("The text \"" + image + "\" isn't a valid boolean value");
    }
}
#method_after
public boolean readBoolean() {
    return parseBoolean(readString());
}
#end_block

#method_before
public BigInteger readInteger() {
    String image = readString();
    try {
        return new BigInteger(image);
    } catch (NumberFormatException exception) {
        throw new XmlException("The text \"" + image + "\" isn't a valid integer value");
    }
}
#method_after
public BigInteger readInteger() {
    return parseInteger(readString());
}
#end_block

#method_before
public BigDecimal readDecimal() {
    String image = readString();
    try {
        return new BigDecimal(image).stripTrailingZeros();
    } catch (NumberFormatException exception) {
        throw new XmlException("The text \"" + image + "\" isn't a valid decimal value");
    }
}
#method_after
public BigDecimal readDecimal() {
    return parseDecimal(readString());
}
#end_block

#method_before
public Date readDate() {
    String image = readString();
    try {
        return DATE_FORMAT.get().parse(image);
    } catch (ParseException exception) {
        throw new XmlException("The text \"" + image + "\" isn't a valid date value");
    }
}
#method_after
public Date readDate() {
    return parseDate(readString());
}
#end_block

#method_before
public List<Boolean> readBooleans() {
    return read(Boolean.class, this::readBoolean);
}
#method_after
public List<Boolean> readBooleans() {
    return readStrings().stream().map(this::parseBoolean).collect(toList());
}
#end_block

#method_before
public List<Integer> readIntegers() {
    return read(Integer.class, this::readInteger);
}
#method_after
public List<BigInteger> readIntegers() {
    return readStrings().stream().map(this::parseInteger).collect(toList());
}
#end_block

#method_before
public List<BigDecimal> readDecimals() {
    return read(BigDecimal.class, this::readDecimal);
}
#method_after
public List<BigDecimal> readDecimals() {
    return readStrings().stream().map(this::parseDecimal).collect(toList());
}
#end_block

#method_before
public List<Date> readDates() {
    return read(Date.class, this::readDate);
}
#method_after
public List<Date> readDates() {
    return readStrings().stream().map(this::parseDate).collect(toList());
}
#end_block

#method_before
public List<String> readStrings() {
    return read(String.class, this::readString);
}
#method_after
public List<String> readStrings() {
    List<String> values = new ArrayList<>();
    String startingLocalName = reader.getLocalName();
    String currentLocalName = startingLocalName;
    while (forward()) {
        currentLocalName = reader.getLocalName();
        if (currentLocalName.equals(startingLocalName)) {
            values.add(readString());
        } else {
            skip();
        }
    }
    return values;
}
#end_block

#method_before
private void generateStructWriteMemberAsElement(StructMember member) {
    Name name = member.getName();
    Type type = member.getType();
    String field = javaNames.getJavaMemberStyleName(name);
    String tag = schemaNames.getSchemaTagName(name);
    javaBuffer.addLine("if (object.%1$sPresent()) {", field);
    if (type instanceof PrimitiveType) {
        Model model = type.getModel();
        if (type == model.getBooleanType()) {
            javaBuffer.addLine("writer.writeBoolean(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getIntegerType()) {
            javaBuffer.addLine("writer.writeInteger(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getDecimalType()) {
            javaBuffer.addLine("writer.writeDecimal(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getStringType()) {
            javaBuffer.addLine("writer.writeElement(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getDateType()) {
            javaBuffer.addLine("writer.writeDate(\"%1$s\", object.%2$s());", tag, field);
        }
    } else if (type instanceof StructType || type instanceof EnumType) {
        JavaClassName writerName = javaTypes.getXmlWriterName(type);
        javaBuffer.addImport(writerName);
        javaBuffer.addLine("%1$s.writeOne(object.%2$s(), \"%3$s\", writer);", writerName.getSimpleName(), field, tag);
    } else if (type instanceof ListType) {
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        if (elementType instanceof StructType || elementType instanceof EnumType) {
            JavaClassName writerName = javaTypes.getXmlWriterName(elementType);
            javaBuffer.addImport(writerName);
            javaBuffer.addLine("%1$s.writeMany(object.%2$s().iterator(), writer);", writerName.getSimpleName(), field);
        }
    }
    javaBuffer.addLine("}");
}
#method_after
private void generateStructWriteMemberAsElement(StructMember member) {
    Name name = member.getName();
    Type type = member.getType();
    String field = javaNames.getJavaMemberStyleName(name);
    String tag = schemaNames.getSchemaTagName(name);
    javaBuffer.addLine("if (object.%1$sPresent()) {", field);
    if (type instanceof PrimitiveType) {
        Model model = type.getModel();
        if (type == model.getBooleanType()) {
            javaBuffer.addLine("writer.writeBoolean(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getIntegerType()) {
            javaBuffer.addLine("writer.writeInteger(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getDecimalType()) {
            javaBuffer.addLine("writer.writeDecimal(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getStringType()) {
            javaBuffer.addLine("writer.writeElement(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getDateType()) {
            javaBuffer.addLine("writer.writeDate(\"%1$s\", object.%2$s());", tag, field);
        }
    } else if (type instanceof StructType || type instanceof EnumType) {
        JavaClassName writerName = javaTypes.getXmlWriterName(type);
        javaBuffer.addImport(writerName);
        javaBuffer.addLine("%1$s.writeOne(object.%2$s(), \"%3$s\", writer);", writerName.getSimpleName(), field, tag);
    } else if (type instanceof ListType) {
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        if (elementType instanceof StructType || elementType instanceof EnumType) {
            JavaClassName writerName = javaTypes.getXmlWriterName(elementType);
            javaBuffer.addImport(writerName);
            javaBuffer.addLine("%1$s.writeMany(object.%2$s().iterator(), writer);", writerName.getSimpleName(), field);
        } else if (elementType instanceof PrimitiveType) {
            Model model = type.getModel();
            if (elementType == model.getBooleanType()) {
                javaBuffer.addLine("writer.writeBooleans(\"%1$s\", object.%2$s());", tag, field);
            } else if (elementType == model.getIntegerType()) {
                javaBuffer.addLine("writer.writeIntegers(\"%1$s\", object.%2$s());", tag, field);
            } else if (elementType == model.getDecimalType()) {
                javaBuffer.addLine("writer.writeDecimals(\"%1$s\", object.%2$s());", tag, field);
            } else if (elementType == model.getStringType()) {
                javaBuffer.addLine("writer.writeElements(\"%1$s\", object.%2$s());", tag, field);
            } else if (elementType == model.getDateType()) {
                javaBuffer.addLine("writer.writeDates(\"%1$s\", object.%2$s());", tag, field);
            }
        }
    }
    javaBuffer.addLine("}");
}
#end_block

#method_before
public List<Boolean> readBooleans() {
    return read(Boolean.class);
}
#method_after
public List<Boolean> readBooleans() {
    List<Boolean> list = new ArrayList<>();
    expect(JsonParser.Event.START_ARRAY);
    boolean listEnd = false;
    while (!listEnd) {
        JsonParser.Event next = next();
        switch(next) {
            case VALUE_FALSE:
                list.add(false);
                break;
            case VALUE_TRUE:
                list.add(true);
                break;
            case END_ARRAY:
                listEnd = true;
                break;
            default:
                continue;
        }
    }
    return list;
}
#end_block

#method_before
public List<Integer> readIntegers() {
    return read(Integer.class);
}
#method_after
public List<BigInteger> readIntegers() {
    List<BigInteger> list = new ArrayList<>();
    expect(JsonParser.Event.START_ARRAY);
    boolean listEnd = false;
    while (!listEnd) {
        JsonParser.Event next = next();
        switch(next) {
            case VALUE_NUMBER:
                list.add(parser.getBigDecimal().toBigInteger());
                break;
            case END_ARRAY:
                listEnd = true;
                break;
            default:
                continue;
        }
    }
    return list;
}
#end_block

#method_before
public List<BigDecimal> readDecimals() {
    return read(BigDecimal.class);
}
#method_after
public List<BigDecimal> readDecimals() {
    List<BigDecimal> list = new ArrayList<>();
    expect(JsonParser.Event.START_ARRAY);
    boolean listEnd = false;
    while (!listEnd) {
        JsonParser.Event next = next();
        switch(next) {
            case VALUE_NUMBER:
                list.add(parser.getBigDecimal());
                break;
            case END_ARRAY:
                listEnd = true;
                break;
            default:
                continue;
        }
    }
    return list;
}
#end_block

#method_before
public List<Date> readDates() {
    return read(Date.class);
}
#method_after
public List<Date> readDates() {
    List<Date> list = new ArrayList<>();
    expect(JsonParser.Event.START_ARRAY);
    boolean listEnd = false;
    while (!listEnd) {
        JsonParser.Event next = next();
        switch(next) {
            case VALUE_STRING:
                String image = parser.getString();
                try {
                    list.add(DATE_FORMAT.get().parse(image));
                } catch (ParseException exception) {
                    throw new JsonException("The text \"" + image + "\" isn't a valid date", exception);
                }
            case END_ARRAY:
                listEnd = true;
                break;
            default:
                continue;
        }
    }
    return list;
}
#end_block

#method_before
public List<String> readStrings() {
    return read(String.class);
}
#method_after
public List<String> readStrings() {
    List<String> list = new ArrayList<>();
    expect(JsonParser.Event.START_ARRAY);
    boolean listEnd = false;
    while (!listEnd) {
        JsonParser.Event next = next();
        switch(next) {
            case VALUE_STRING:
                list.add(getString());
                break;
            case END_ARRAY:
                listEnd = true;
                break;
            default:
                continue;
        }
    }
    return list;
}
#end_block

#method_before
private void generateStructWriteMember(StructMember member) {
    Name name = member.getName();
    Type type = member.getType();
    String field = javaNames.getJavaMemberStyleName(name);
    String tag = schemaNames.getSchemaTagName(name);
    javaBuffer.addLine("if (object.%1$sPresent()) {", field);
    if (type instanceof PrimitiveType) {
        Model model = type.getModel();
        if (type == model.getBooleanType()) {
            javaBuffer.addLine("writer.writeBoolean(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getIntegerType()) {
            javaBuffer.addLine("writer.writeInteger(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getDecimalType()) {
            javaBuffer.addLine("writer.writeDecimal(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getStringType()) {
            javaBuffer.addLine("writer.writeString(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getDateType()) {
            javaBuffer.addLine("writer.writeDate(\"%1$s\", object.%2$s());", tag, field);
        }
    } else if (type instanceof EnumType) {
        JavaClassName writerName = javaTypes.getJsonWriterName(type);
        javaBuffer.addImport(writerName);
        javaBuffer.addLine("writer.writeString(\"%1$s\", object.%2$s().value());", tag, field);
    } else if (type instanceof StructType) {
        JavaClassName writerName = javaTypes.getJsonWriterName(type);
        javaBuffer.addImport(writerName);
        javaBuffer.addLine("%1$s.writeOne(object.%2$s(), \"%3$s\", writer);", writerName.getSimpleName(), field, tag);
    } else if (type instanceof ListType) {
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        if (elementType instanceof StructType || elementType instanceof EnumType) {
            JavaClassName writerName = javaTypes.getJsonWriterName(elementType);
            javaBuffer.addImport(writerName);
            javaBuffer.addLine("%1$s.writeMany(object.%2$s().iterator(), \"%3$s\", writer);", writerName.getSimpleName(), field, tag);
        }
    }
    javaBuffer.addLine("}");
}
#method_after
private void generateStructWriteMember(StructMember member) {
    Name name = member.getName();
    Type type = member.getType();
    String field = javaNames.getJavaMemberStyleName(name);
    String tag = schemaNames.getSchemaTagName(name);
    javaBuffer.addLine("if (object.%1$sPresent()) {", field);
    if (type instanceof PrimitiveType) {
        Model model = type.getModel();
        if (type == model.getBooleanType()) {
            javaBuffer.addLine("writer.writeBoolean(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getIntegerType()) {
            javaBuffer.addLine("writer.writeInteger(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getDecimalType()) {
            javaBuffer.addLine("writer.writeDecimal(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getStringType()) {
            javaBuffer.addLine("writer.writeString(\"%1$s\", object.%2$s());", tag, field);
        } else if (type == model.getDateType()) {
            javaBuffer.addLine("writer.writeDate(\"%1$s\", object.%2$s());", tag, field);
        }
    } else if (type instanceof EnumType) {
        JavaClassName writerName = javaTypes.getJsonWriterName(type);
        javaBuffer.addImport(writerName);
        javaBuffer.addLine("writer.writeString(\"%1$s\", object.%2$s().value());", tag, field);
    } else if (type instanceof StructType) {
        JavaClassName writerName = javaTypes.getJsonWriterName(type);
        javaBuffer.addImport(writerName);
        javaBuffer.addLine("%1$s.writeOne(object.%2$s(), \"%3$s\", writer);", writerName.getSimpleName(), field, tag);
    } else if (type instanceof ListType) {
        ListType listType = (ListType) type;
        Type elementType = listType.getElementType();
        if (elementType instanceof StructType || elementType instanceof EnumType) {
            JavaClassName writerName = javaTypes.getJsonWriterName(elementType);
            javaBuffer.addImport(writerName);
            javaBuffer.addLine("%1$s.writeMany(object.%2$s().iterator(), \"%3$s\", writer);", writerName.getSimpleName(), field, tag);
        } else if (elementType instanceof PrimitiveType) {
            Model model = type.getModel();
            if (elementType == model.getBooleanType()) {
                javaBuffer.addLine("writer.writeBooleans(\"%1$s\", object.%2$s());", tag, field);
            } else if (elementType == model.getIntegerType()) {
                javaBuffer.addLine("writer.writeIntegers(\"%1$s\", object.%2$s());", tag, field);
            } else if (elementType == model.getDecimalType()) {
                javaBuffer.addLine("writer.writeDecimals(\"%1$s\", object.%2$s());", tag, field);
            } else if (elementType == model.getStringType()) {
                javaBuffer.addLine("writer.writeStrings(\"%1$s\", object.%2$s());", tag, field);
            } else if (elementType == model.getDateType()) {
                javaBuffer.addLine("writer.writeDates(\"%1$s\", object.%2$s());", tag, field);
            }
        }
    }
    javaBuffer.addLine("}");
}
#end_block

#method_before
@Test
public void testReadStringList() {
    List<String> expected = Arrays.asList("1", "2");
    XmlReader reader = openReader("<action><value>1</value><value>2</value></action>");
    reader.next();
    List<String> strings = reader.readStrings();
    assertEquals(XMLStreamConstants.END_ELEMENT, reader.getEventType());
    assertEquals("action", reader.getLocalName());
    assertEquals(expected, strings);
}
#method_after
@Test
public void testReadStringList() {
    List<String> expected = Arrays.asList("1", "2");
    XmlReader reader = openReader("<action><value>1</value><value>2</value></action>");
    reader.next();
    List<String> strings = reader.readStrings();
    assertEquals(expected, strings);
}
#end_block

#method_before
@Test
public void testReadBooleanList() {
    List<Boolean> expected = Arrays.asList(true, false);
    XmlReader reader = openReader("<action><value>true</value><value>false</value></action>");
    reader.next();
    List<Boolean> booleans = reader.readBooleans();
    assertEquals(XMLStreamConstants.END_ELEMENT, reader.getEventType());
    assertEquals("action", reader.getLocalName());
    assertEquals(expected, booleans);
}
#method_after
@Test
public void testReadBooleanList() {
    List<Boolean> expected = Arrays.asList(true, false);
    XmlReader reader = openReader("<action><value>true</value><value>false</value></action>");
    reader.next();
    List<Boolean> booleans = reader.readBooleans();
    assertEquals(expected, booleans);
}
#end_block

#method_before
public void tFileInputProperties_1Process(final java.util.Map<String, Object> globalMap) throws TalendException {
    globalMap.put("tFileInputProperties_1_SUBPROCESS_STATE", 0);
    final boolean execStat = this.execStat;
    String iterateId = "";
    String currentComponent = "";
    java.util.Map<String, Object> resourceMap = new java.util.HashMap<String, Object>();
    try {
        String currentMethodName = new java.lang.Exception().getStackTrace()[0].getMethodName();
        boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
        if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {
            // start
            // the
            // resume
            globalResumeTicket = true;
            row1Struct row1 = new row1Struct();
            /**
             * [tContextLoad_1 begin ] start
             */
            ok_Hash.put("tContextLoad_1", false);
            start_Hash.put("tContextLoad_1", System.currentTimeMillis());
            currentComponent = "tContextLoad_1";
            int tos_count_tContextLoad_1 = 0;
            java.util.List<String> assignList_tContextLoad_1 = new java.util.ArrayList<String>();
            java.util.List<String> newPropertyList_tContextLoad_1 = new java.util.ArrayList<String>();
            java.util.List<String> noAssignList_tContextLoad_1 = new java.util.ArrayList<String>();
            int nb_line_tContextLoad_1 = 0;
            /**
             * [tContextLoad_1 begin ] stop
             */
            /**
             * [tFileInputProperties_1 begin ] start
             */
            ok_Hash.put("tFileInputProperties_1", false);
            start_Hash.put("tFileInputProperties_1", System.currentTimeMillis());
            currentComponent = "tFileInputProperties_1";
            int tos_count_tFileInputProperties_1 = 0;
            java.io.File file_tFileInputProperties_1 = new java.io.File("/home/sradco/Default.properties");
            int nb_line_tFileInputProperties_1 = 0;
            java.util.Properties properties_tFileInputProperties_1 = new java.util.Properties();
            java.io.FileInputStream fis_tFileInputProperties_1 = new java.io.FileInputStream(file_tFileInputProperties_1);
            try {
                properties_tFileInputProperties_1.load(fis_tFileInputProperties_1);
                java.util.Enumeration enumeration_tFileInputProperties_1 = properties_tFileInputProperties_1.propertyNames();
                while (enumeration_tFileInputProperties_1.hasMoreElements()) {
                    nb_line_tFileInputProperties_1++;
                    row1.key = (String) enumeration_tFileInputProperties_1.nextElement();
                    row1.value = (String) properties_tFileInputProperties_1.getProperty(row1.key);
                    /**
                     * [tFileInputProperties_1 begin ] stop
                     */
                    /**
                     * [tFileInputProperties_1 main ] start
                     */
                    currentComponent = "tFileInputProperties_1";
                    tos_count_tFileInputProperties_1++;
                    /**
                     * [tFileInputProperties_1 main ] stop
                     */
                    /**
                     * [tContextLoad_1 main ] start
                     */
                    currentComponent = "tContextLoad_1";
                    // ////////////////////////
                    String tmp_key_tContextLoad_1 = null;
                    String key_tContextLoad_1 = null;
                    if (row1.key != null) {
                        tmp_key_tContextLoad_1 = row1.key.trim();
                        if ((tmp_key_tContextLoad_1.startsWith("#") || tmp_key_tContextLoad_1.startsWith("!"))) {
                            tmp_key_tContextLoad_1 = null;
                        } else {
                            row1.key = tmp_key_tContextLoad_1;
                        }
                    }
                    if (row1.key != null) {
                        key_tContextLoad_1 = row1.key;
                    }
                    String value_tContextLoad_1 = null;
                    if (row1.value != null) {
                        value_tContextLoad_1 = row1.value;
                    }
                    if (tmp_key_tContextLoad_1 != null) {
                        try {
                            if (key_tContextLoad_1 != null && "dwhUuid".equals(key_tContextLoad_1)) {
                                context.dwhUuid = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "etlVersion".equals(key_tContextLoad_1)) {
                                context.etlVersion = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "hoursToKeepDaily".equals(key_tContextLoad_1)) {
                                context.hoursToKeepDaily = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "hoursToKeepHourly".equals(key_tContextLoad_1)) {
                                context.hoursToKeepHourly = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "hoursToKeepSamples".equals(key_tContextLoad_1)) {
                                context.hoursToKeepSamples = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "lastErrorSent".equals(key_tContextLoad_1)) {
                                String context_lastErrorSent_value = context.getProperty("lastErrorSent");
                                if (context_lastErrorSent_value == null)
                                    context_lastErrorSent_value = "";
                                int context_lastErrorSent_pos = context_lastErrorSent_value.indexOf(";");
                                String context_lastErrorSent_pattern = "yyyy-MM-dd HH:mm:ss";
                                if (context_lastErrorSent_pos > -1) {
                                    context_lastErrorSent_pattern = context_lastErrorSent_value.substring(0, context_lastErrorSent_pos);
                                }
                                context.lastErrorSent = (java.util.Date) (new java.text.SimpleDateFormat(context_lastErrorSent_pattern).parse(value_tContextLoad_1));
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineDbDriverClass".equals(key_tContextLoad_1)) {
                                context.ovirtEngineDbDriverClass = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineDbJdbcConnection".equals(key_tContextLoad_1)) {
                                context.ovirtEngineDbJdbcConnection = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineDbPassword".equals(key_tContextLoad_1)) {
                                context.ovirtEngineDbPassword = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineDbUser".equals(key_tContextLoad_1)) {
                                context.ovirtEngineDbUser = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineHistoryDbDriverClass".equals(key_tContextLoad_1)) {
                                context.ovirtEngineHistoryDbDriverClass = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineHistoryDbJdbcConnection".equals(key_tContextLoad_1)) {
                                context.ovirtEngineHistoryDbJdbcConnection = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineHistoryDbPassword".equals(key_tContextLoad_1)) {
                                context.ovirtEngineHistoryDbPassword = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineHistoryDbUser".equals(key_tContextLoad_1)) {
                                context.ovirtEngineHistoryDbUser = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "runDeleteTime".equals(key_tContextLoad_1)) {
                                context.runDeleteTime = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "runInterleave".equals(key_tContextLoad_1)) {
                                context.runInterleave = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "timeBetweenErrorEvents".equals(key_tContextLoad_1)) {
                                context.timeBetweenErrorEvents = Long.parseLong(value_tContextLoad_1);
                            }
                            if (context.getProperty(key_tContextLoad_1) != null) {
                                assignList_tContextLoad_1.add(key_tContextLoad_1);
                            } else {
                                newPropertyList_tContextLoad_1.add(key_tContextLoad_1);
                            }
                            if (value_tContextLoad_1 == null) {
                                context.setProperty(key_tContextLoad_1, "");
                            } else {
                                context.setProperty(key_tContextLoad_1, value_tContextLoad_1);
                            }
                        } catch (java.lang.Exception e) {
                            System.err.println("Setting a value for the key \"" + key_tContextLoad_1 + "\" has failed. Error message: " + e.getMessage());
                        }
                        nb_line_tContextLoad_1++;
                    }
                    // ////////////////////////
                    tos_count_tContextLoad_1++;
                    /**
                     * [tContextLoad_1 main ] stop
                     */
                    /**
                     * [tFileInputProperties_1 end ] start
                     */
                    currentComponent = "tFileInputProperties_1";
                }
            } finally {
                if (fis_tFileInputProperties_1 != null) {
                    fis_tFileInputProperties_1.close();
                }
            }
            globalMap.put("tFileInputProperties_1_NB_LINE", nb_line_tFileInputProperties_1);
            ok_Hash.put("tFileInputProperties_1", true);
            end_Hash.put("tFileInputProperties_1", System.currentTimeMillis());
            /**
             * [tFileInputProperties_1 end ] stop
             */
            /**
             * [tContextLoad_1 end ] start
             */
            currentComponent = "tContextLoad_1";
            java.util.Enumeration<?> enu_tContextLoad_1 = context.propertyNames();
            while (enu_tContextLoad_1.hasMoreElements()) {
                String key_tContextLoad_1 = (String) enu_tContextLoad_1.nextElement();
                if (!assignList_tContextLoad_1.contains(key_tContextLoad_1) && !newPropertyList_tContextLoad_1.contains(key_tContextLoad_1)) {
                    noAssignList_tContextLoad_1.add(key_tContextLoad_1);
                }
            }
            String newPropertyStr_tContextLoad_1 = newPropertyList_tContextLoad_1.toString();
            String newProperty_tContextLoad_1 = newPropertyStr_tContextLoad_1.substring(1, newPropertyStr_tContextLoad_1.length() - 1);
            String noAssignStr_tContextLoad_1 = noAssignList_tContextLoad_1.toString();
            String noAssign_tContextLoad_1 = noAssignStr_tContextLoad_1.substring(1, noAssignStr_tContextLoad_1.length() - 1);
            globalMap.put("tContextLoad_1_KEY_NOT_INCONTEXT", newProperty_tContextLoad_1);
            globalMap.put("tContextLoad_1_KEY_NOT_LOADED", noAssign_tContextLoad_1);
            globalMap.put("tContextLoad_1_NB_LINE", nb_line_tContextLoad_1);
            List<String> parametersToEncrypt_tContextLoad_1 = new java.util.ArrayList<String>();
            parametersToEncrypt_tContextLoad_1.add("ovirtEngineDbPassword");
            parametersToEncrypt_tContextLoad_1.add("ovirtEngineHistoryDbPassword");
            resumeUtil.addLog("NODE", "NODE:tContextLoad_1", "", Thread.currentThread().getId() + "", "", "", "", "", resumeUtil.convertToJsonText(context, parametersToEncrypt_tContextLoad_1));
            ok_Hash.put("tContextLoad_1", true);
            end_Hash.put("tContextLoad_1", System.currentTimeMillis());
        /**
         * [tContextLoad_1 end ] stop
         */
        }
        if (resumeEntryMethodName == null || globalResumeTicket) {
            resumeUtil.addLog("CHECKPOINT", "CONNECTION:SUBJOB_OK:tFileInputProperties_1:OnSubjobOk", "", Thread.currentThread().getId() + "", "", "", "", "", "");
        }
        tJDBCConnection_6Process(globalMap);
    } catch (java.lang.Exception e) {
        TalendException te = new TalendException(e, currentComponent, globalMap);
        throw te;
    } catch (java.lang.Error error) {
        throw error;
    } finally {
        try {
            /**
             * [tFileInputProperties_1 finally ] start
             */
            currentComponent = "tFileInputProperties_1";
            /**
             * [tFileInputProperties_1 finally ] stop
             */
            /**
             * [tContextLoad_1 finally ] start
             */
            currentComponent = "tContextLoad_1";
        /**
         * [tContextLoad_1 finally ] stop
         */
        } catch (java.lang.Exception e) {
        // ignore
        } catch (java.lang.Error error) {
        // ignore
        }
        resourceMap = null;
    }
    globalMap.put("tFileInputProperties_1_SUBPROCESS_STATE", 1);
}
#method_after
public void tFileInputProperties_1Process(final java.util.Map<String, Object> globalMap) throws TalendException {
    globalMap.put("tFileInputProperties_1_SUBPROCESS_STATE", 0);
    final boolean execStat = this.execStat;
    String iterateId = "";
    String currentComponent = "";
    java.util.Map<String, Object> resourceMap = new java.util.HashMap<String, Object>();
    try {
        String currentMethodName = new java.lang.Exception().getStackTrace()[0].getMethodName();
        boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
        if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {
            // start
            // the
            // resume
            globalResumeTicket = true;
            row1Struct row1 = new row1Struct();
            /**
             * [tContextLoad_1 begin ] start
             */
            ok_Hash.put("tContextLoad_1", false);
            start_Hash.put("tContextLoad_1", System.currentTimeMillis());
            currentComponent = "tContextLoad_1";
            int tos_count_tContextLoad_1 = 0;
            java.util.List<String> assignList_tContextLoad_1 = new java.util.ArrayList<String>();
            java.util.List<String> newPropertyList_tContextLoad_1 = new java.util.ArrayList<String>();
            java.util.List<String> noAssignList_tContextLoad_1 = new java.util.ArrayList<String>();
            int nb_line_tContextLoad_1 = 0;
            /**
             * [tContextLoad_1 begin ] stop
             */
            /**
             * [tFileInputProperties_1 begin ] start
             */
            ok_Hash.put("tFileInputProperties_1", false);
            start_Hash.put("tFileInputProperties_1", System.currentTimeMillis());
            currentComponent = "tFileInputProperties_1";
            int tos_count_tFileInputProperties_1 = 0;
            java.io.File file_tFileInputProperties_1 = new java.io.File(System.getProperty("org.ovirt.engine.dwh.settings"));
            int nb_line_tFileInputProperties_1 = 0;
            java.util.Properties properties_tFileInputProperties_1 = new java.util.Properties();
            java.io.FileInputStream fis_tFileInputProperties_1 = new java.io.FileInputStream(file_tFileInputProperties_1);
            try {
                properties_tFileInputProperties_1.load(fis_tFileInputProperties_1);
                java.util.Enumeration enumeration_tFileInputProperties_1 = properties_tFileInputProperties_1.propertyNames();
                while (enumeration_tFileInputProperties_1.hasMoreElements()) {
                    nb_line_tFileInputProperties_1++;
                    row1.key = (String) enumeration_tFileInputProperties_1.nextElement();
                    row1.value = (String) properties_tFileInputProperties_1.getProperty(row1.key);
                    /**
                     * [tFileInputProperties_1 begin ] stop
                     */
                    /**
                     * [tFileInputProperties_1 main ] start
                     */
                    currentComponent = "tFileInputProperties_1";
                    tos_count_tFileInputProperties_1++;
                    /**
                     * [tFileInputProperties_1 main ] stop
                     */
                    /**
                     * [tContextLoad_1 main ] start
                     */
                    currentComponent = "tContextLoad_1";
                    // ////////////////////////
                    String tmp_key_tContextLoad_1 = null;
                    String key_tContextLoad_1 = null;
                    if (row1.key != null) {
                        tmp_key_tContextLoad_1 = row1.key.trim();
                        if ((tmp_key_tContextLoad_1.startsWith("#") || tmp_key_tContextLoad_1.startsWith("!"))) {
                            tmp_key_tContextLoad_1 = null;
                        } else {
                            row1.key = tmp_key_tContextLoad_1;
                        }
                    }
                    if (row1.key != null) {
                        key_tContextLoad_1 = row1.key;
                    }
                    String value_tContextLoad_1 = null;
                    if (row1.value != null) {
                        value_tContextLoad_1 = row1.value;
                    }
                    if (tmp_key_tContextLoad_1 != null) {
                        try {
                            if (key_tContextLoad_1 != null && "dwhUuid".equals(key_tContextLoad_1)) {
                                context.dwhUuid = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "etlVersion".equals(key_tContextLoad_1)) {
                                context.etlVersion = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "hoursToKeepDaily".equals(key_tContextLoad_1)) {
                                context.hoursToKeepDaily = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "hoursToKeepHourly".equals(key_tContextLoad_1)) {
                                context.hoursToKeepHourly = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "hoursToKeepSamples".equals(key_tContextLoad_1)) {
                                context.hoursToKeepSamples = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "lastErrorSent".equals(key_tContextLoad_1)) {
                                String context_lastErrorSent_value = context.getProperty("lastErrorSent");
                                if (context_lastErrorSent_value == null)
                                    context_lastErrorSent_value = "";
                                int context_lastErrorSent_pos = context_lastErrorSent_value.indexOf(";");
                                String context_lastErrorSent_pattern = "yyyy-MM-dd HH:mm:ss";
                                if (context_lastErrorSent_pos > -1) {
                                    context_lastErrorSent_pattern = context_lastErrorSent_value.substring(0, context_lastErrorSent_pos);
                                }
                                context.lastErrorSent = (java.util.Date) (new java.text.SimpleDateFormat(context_lastErrorSent_pattern).parse(value_tContextLoad_1));
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineDbDriverClass".equals(key_tContextLoad_1)) {
                                context.ovirtEngineDbDriverClass = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineDbJdbcConnection".equals(key_tContextLoad_1)) {
                                context.ovirtEngineDbJdbcConnection = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineDbPassword".equals(key_tContextLoad_1)) {
                                context.ovirtEngineDbPassword = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineDbUser".equals(key_tContextLoad_1)) {
                                context.ovirtEngineDbUser = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineHistoryDbDriverClass".equals(key_tContextLoad_1)) {
                                context.ovirtEngineHistoryDbDriverClass = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineHistoryDbJdbcConnection".equals(key_tContextLoad_1)) {
                                context.ovirtEngineHistoryDbJdbcConnection = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineHistoryDbPassword".equals(key_tContextLoad_1)) {
                                context.ovirtEngineHistoryDbPassword = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "ovirtEngineHistoryDbUser".equals(key_tContextLoad_1)) {
                                context.ovirtEngineHistoryDbUser = value_tContextLoad_1;
                            }
                            if (key_tContextLoad_1 != null && "runDeleteTime".equals(key_tContextLoad_1)) {
                                context.runDeleteTime = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "runInterleave".equals(key_tContextLoad_1)) {
                                context.runInterleave = Integer.parseInt(value_tContextLoad_1);
                            }
                            if (key_tContextLoad_1 != null && "timeBetweenErrorEvents".equals(key_tContextLoad_1)) {
                                context.timeBetweenErrorEvents = Long.parseLong(value_tContextLoad_1);
                            }
                            if (context.getProperty(key_tContextLoad_1) != null) {
                                assignList_tContextLoad_1.add(key_tContextLoad_1);
                            } else {
                                newPropertyList_tContextLoad_1.add(key_tContextLoad_1);
                            }
                            if (value_tContextLoad_1 == null) {
                                context.setProperty(key_tContextLoad_1, "");
                            } else {
                                context.setProperty(key_tContextLoad_1, value_tContextLoad_1);
                            }
                        } catch (java.lang.Exception e) {
                            System.err.println("Setting a value for the key \"" + key_tContextLoad_1 + "\" has failed. Error message: " + e.getMessage());
                        }
                        nb_line_tContextLoad_1++;
                    }
                    // ////////////////////////
                    tos_count_tContextLoad_1++;
                    /**
                     * [tContextLoad_1 main ] stop
                     */
                    /**
                     * [tFileInputProperties_1 end ] start
                     */
                    currentComponent = "tFileInputProperties_1";
                }
            } finally {
                if (fis_tFileInputProperties_1 != null) {
                    fis_tFileInputProperties_1.close();
                }
            }
            globalMap.put("tFileInputProperties_1_NB_LINE", nb_line_tFileInputProperties_1);
            ok_Hash.put("tFileInputProperties_1", true);
            end_Hash.put("tFileInputProperties_1", System.currentTimeMillis());
            /**
             * [tFileInputProperties_1 end ] stop
             */
            /**
             * [tContextLoad_1 end ] start
             */
            currentComponent = "tContextLoad_1";
            java.util.Enumeration<?> enu_tContextLoad_1 = context.propertyNames();
            while (enu_tContextLoad_1.hasMoreElements()) {
                String key_tContextLoad_1 = (String) enu_tContextLoad_1.nextElement();
                if (!assignList_tContextLoad_1.contains(key_tContextLoad_1) && !newPropertyList_tContextLoad_1.contains(key_tContextLoad_1)) {
                    noAssignList_tContextLoad_1.add(key_tContextLoad_1);
                }
            }
            String newPropertyStr_tContextLoad_1 = newPropertyList_tContextLoad_1.toString();
            String newProperty_tContextLoad_1 = newPropertyStr_tContextLoad_1.substring(1, newPropertyStr_tContextLoad_1.length() - 1);
            String noAssignStr_tContextLoad_1 = noAssignList_tContextLoad_1.toString();
            String noAssign_tContextLoad_1 = noAssignStr_tContextLoad_1.substring(1, noAssignStr_tContextLoad_1.length() - 1);
            globalMap.put("tContextLoad_1_KEY_NOT_INCONTEXT", newProperty_tContextLoad_1);
            globalMap.put("tContextLoad_1_KEY_NOT_LOADED", noAssign_tContextLoad_1);
            globalMap.put("tContextLoad_1_NB_LINE", nb_line_tContextLoad_1);
            List<String> parametersToEncrypt_tContextLoad_1 = new java.util.ArrayList<String>();
            parametersToEncrypt_tContextLoad_1.add("ovirtEngineDbPassword");
            parametersToEncrypt_tContextLoad_1.add("ovirtEngineHistoryDbPassword");
            resumeUtil.addLog("NODE", "NODE:tContextLoad_1", "", Thread.currentThread().getId() + "", "", "", "", "", resumeUtil.convertToJsonText(context, parametersToEncrypt_tContextLoad_1));
            ok_Hash.put("tContextLoad_1", true);
            end_Hash.put("tContextLoad_1", System.currentTimeMillis());
        /**
         * [tContextLoad_1 end ] stop
         */
        }
        if (resumeEntryMethodName == null || globalResumeTicket) {
            resumeUtil.addLog("CHECKPOINT", "CONNECTION:SUBJOB_OK:tFileInputProperties_1:OnSubjobOk", "", Thread.currentThread().getId() + "", "", "", "", "", "");
        }
        tJDBCConnection_6Process(globalMap);
    } catch (java.lang.Exception e) {
        TalendException te = new TalendException(e, currentComponent, globalMap);
        throw te;
    } catch (java.lang.Error error) {
        throw error;
    } finally {
        try {
            /**
             * [tFileInputProperties_1 finally ] start
             */
            currentComponent = "tFileInputProperties_1";
            /**
             * [tFileInputProperties_1 finally ] stop
             */
            /**
             * [tContextLoad_1 finally ] start
             */
            currentComponent = "tContextLoad_1";
        /**
         * [tContextLoad_1 finally ] stop
         */
        } catch (java.lang.Exception e) {
        // ignore
        } catch (java.lang.Error error) {
        // ignore
        }
        resourceMap = null;
    }
    globalMap.put("tFileInputProperties_1_SUBPROCESS_STATE", 1);
}
#end_block

#method_before
public void tLoop_2Process(final java.util.Map<String, Object> globalMap) throws TalendException {
    globalMap.put("tLoop_2_SUBPROCESS_STATE", 0);
    final boolean execStat = this.execStat;
    String iterateId = "";
    String currentComponent = "";
    java.util.Map<String, Object> resourceMap = new java.util.HashMap<String, Object>();
    try {
        String currentMethodName = new java.lang.Exception().getStackTrace()[0].getMethodName();
        boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
        if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {
            // start
            // the
            // resume
            globalResumeTicket = true;
            row9Struct row9 = new row9Struct();
            /**
             * [tLoop_2 begin ] start
             */
            // for statistics
            int NB_ITERATE_tJavaFlex_1 = 0;
            // for statistics
            int NB_ITERATE_tJavaFlex_2 = 0;
            ok_Hash.put("tLoop_2", false);
            start_Hash.put("tLoop_2", System.currentTimeMillis());
            currentComponent = "tLoop_2";
            int tos_count_tLoop_2 = 0;
            int current_iteration_tLoop_2 = 0;
            boolean i = false;
            while (!i) {
                current_iteration_tLoop_2++;
                globalMap.put("tLoop_2_CURRENT_ITERATION", current_iteration_tLoop_2);
                /**
                 * [tLoop_2 begin ] stop
                 */
                /**
                 * [tLoop_2 main ] start
                 */
                currentComponent = "tLoop_2";
                tos_count_tLoop_2++;
                /**
                 * [tLoop_2 main ] stop
                 */
                NB_ITERATE_tJavaFlex_2++;
                /**
                 * [tJavaFlex_2 begin ] start
                 */
                // for statistics
                int NB_ITERATE_tJDBCConnection_7 = 0;
                ok_Hash.put("tJavaFlex_2", false);
                start_Hash.put("tJavaFlex_2", System.currentTimeMillis());
                currentComponent = "tJavaFlex_2";
                int tos_count_tJavaFlex_2 = 0;
                // start part of your Java code
                try {
                    /**
                     * [tJavaFlex_2 begin ] stop
                     */
                    /**
                     * [tJavaFlex_2 main ] start
                     */
                    currentComponent = "tJavaFlex_2";
                    // here is the main part of the component,
                    // a piece of code executed in the row
                    // loop
                    tos_count_tJavaFlex_2++;
                    /**
                     * [tJavaFlex_2 main ] stop
                     */
                    NB_ITERATE_tJDBCConnection_7++;
                    /**
                     * [tJDBCConnection_7 begin ] start
                     */
                    ok_Hash.put("tJDBCConnection_7", false);
                    start_Hash.put("tJDBCConnection_7", System.currentTimeMillis());
                    currentComponent = "tJDBCConnection_7";
                    int tos_count_tJDBCConnection_7 = 0;
                    String url_tJDBCConnection_7 = context.ovirtEngineDbJdbcConnection;
                    String dbUser_tJDBCConnection_7 = context.ovirtEngineDbUser;
                    final String decryptedPassword_tJDBCConnection_7 = context.ovirtEngineDbPassword;
                    String dbPwd_tJDBCConnection_7 = decryptedPassword_tJDBCConnection_7;
                    java.sql.Connection conn_tJDBCConnection_7 = null;
                    String sharedConnectionName_tJDBCConnection_7 = "engine-events";
                    conn_tJDBCConnection_7 = SharedDBConnection.getDBConnection(context.ovirtEngineDbDriverClass, url_tJDBCConnection_7, dbUser_tJDBCConnection_7, dbPwd_tJDBCConnection_7, sharedConnectionName_tJDBCConnection_7);
                    if (null != conn_tJDBCConnection_7) {
                        conn_tJDBCConnection_7.setAutoCommit(true);
                    }
                    globalMap.put("conn_tJDBCConnection_7", conn_tJDBCConnection_7);
                    globalMap.put("url_tJDBCConnection_7", url_tJDBCConnection_7);
                    // globalMap.put("user_tJDBCConnection_7",
                    // dbUser_tJDBCConnection_7);
                    // globalMap.put("pass_tJDBCConnection_7",
                    // dbPwd_tJDBCConnection_7);
                    /**
                     * [tJDBCConnection_7 begin ] stop
                     */
                    /**
                     * [tJDBCConnection_7 main ] start
                     */
                    currentComponent = "tJDBCConnection_7";
                    tos_count_tJDBCConnection_7++;
                    /**
                     * [tJDBCConnection_7 main ] stop
                     */
                    /**
                     * [tJDBCConnection_7 end ] start
                     */
                    currentComponent = "tJDBCConnection_7";
                    ok_Hash.put("tJDBCConnection_7", true);
                    end_Hash.put("tJDBCConnection_7", System.currentTimeMillis());
                    /**
                     * [tJDBCConnection_7 end ] stop
                     */
                    /**
                     * [tJavaFlex_2 end ] start
                     */
                    currentComponent = "tJavaFlex_2";
                // end of the component, outside/closing the loop
                } catch (Exception e) {
                    // this will only happen in db
                    // connection error and loop should recover
                    int TimesDisconnectDwhFailed = Integer.parseInt(((String) globalMap.get("timesDisconnectDwhFailed")));
                    if ((TimesDisconnectDwhFailed % 10) == 0) {
                        globalMap.put("timesDisconnectDwhFailed", Integer.valueOf(TimesDisconnectDwhFailed + 1).toString());
                        System.out.println(TalendDate.getDate("CCYY-MM-DD hh:mm:ss") + " |Exception in component tJavaFlex_6: " + e.toString() + " has been caught");
                    } else {
                        globalMap.put("timesDisconnectDwhFailed", Integer.valueOf(TimesDisconnectDwhFailed + 1).toString());
                    }
                }
                ok_Hash.put("tJavaFlex_2", true);
                end_Hash.put("tJavaFlex_2", System.currentTimeMillis());
                /**
                 * [tJavaFlex_2 end ] stop
                 */
                NB_ITERATE_tJavaFlex_1++;
                /**
                 * [tJavaFlex_1 begin ] start
                 */
                // for statistics
                int NB_ITERATE_tJDBCInput_1 = 0;
                ok_Hash.put("tJavaFlex_1", false);
                start_Hash.put("tJavaFlex_1", System.currentTimeMillis());
                currentComponent = "tJavaFlex_1";
                int tos_count_tJavaFlex_1 = 0;
                // start part of your Java code
                try {
                    /**
                     * [tJavaFlex_1 begin ] stop
                     */
                    /**
                     * [tJavaFlex_1 main ] start
                     */
                    currentComponent = "tJavaFlex_1";
                    // here is the main part of the component,
                    // a piece of code executed in the row
                    // loop
                    tos_count_tJavaFlex_1++;
                    /**
                     * [tJavaFlex_1 main ] stop
                     */
                    NB_ITERATE_tJDBCInput_1++;
                    /**
                     * [tJavaRow_1 begin ] start
                     */
                    ok_Hash.put("tJavaRow_1", false);
                    start_Hash.put("tJavaRow_1", System.currentTimeMillis());
                    currentComponent = "tJavaRow_1";
                    int tos_count_tJavaRow_1 = 0;
                    int nb_line_tJavaRow_1 = 0;
                    /**
                     * [tJavaRow_1 begin ] stop
                     */
                    /**
                     * [tJDBCInput_1 begin ] start
                     */
                    ok_Hash.put("tJDBCInput_1", false);
                    start_Hash.put("tJDBCInput_1", System.currentTimeMillis());
                    currentComponent = "tJDBCInput_1";
                    int tos_count_tJDBCInput_1 = 0;
                    int nb_line_tJDBCInput_1 = 0;
                    java.sql.Connection conn_tJDBCInput_1 = null;
                    conn_tJDBCInput_1 = (java.sql.Connection) globalMap.get("conn_tJDBCConnection_7");
                    java.sql.Statement stmt_tJDBCInput_1 = conn_tJDBCInput_1.createStatement();
                    String dbquery_tJDBCInput_1 = "SELECT option_value FROM vdc_options WHERE option_name = 'DisconnectDwh'";
                    globalMap.put("tJDBCInput_1_QUERY", dbquery_tJDBCInput_1);
                    java.sql.ResultSet rs_tJDBCInput_1 = null;
                    try {
                        rs_tJDBCInput_1 = stmt_tJDBCInput_1.executeQuery(dbquery_tJDBCInput_1);
                        java.sql.ResultSetMetaData rsmd_tJDBCInput_1 = rs_tJDBCInput_1.getMetaData();
                        int colQtyInRs_tJDBCInput_1 = rsmd_tJDBCInput_1.getColumnCount();
                        String tmpContent_tJDBCInput_1 = null;
                        while (rs_tJDBCInput_1.next()) {
                            nb_line_tJDBCInput_1++;
                            if (colQtyInRs_tJDBCInput_1 < 1) {
                                row9.option_value = null;
                            } else {
                                row9.option_value = routines.system.JDBCUtil.getString(rs_tJDBCInput_1, 1, false);
                            }
                            /**
                             * [tJDBCInput_1 begin ] stop
                             */
                            /**
                             * [tJDBCInput_1 main ] start
                             */
                            currentComponent = "tJDBCInput_1";
                            tos_count_tJDBCInput_1++;
                            /**
                             * [tJDBCInput_1 main ] stop
                             */
                            /**
                             * [tJavaRow_1 main ] start
                             */
                            currentComponent = "tJavaRow_1";
                            i = "1".equals(row9.option_value);
                            if (i) {
                                System.out.println("ETL Service will now stop because a flag was raised to disconnect DWH on Engine DB");
                            }
                            if (((String) globalMap.get("timesDisconnectDwhFailed")) != "0") {
                                globalMap.put("timesDisconnectDwhFailed", "0");
                            }
                            nb_line_tJavaRow_1++;
                            tos_count_tJavaRow_1++;
                            /**
                             * [tJavaRow_1 main ] stop
                             */
                            /**
                             * [tJDBCInput_1 end ] start
                             */
                            currentComponent = "tJDBCInput_1";
                        }
                    } finally {
                        if (rs_tJDBCInput_1 != null) {
                            rs_tJDBCInput_1.close();
                        }
                        stmt_tJDBCInput_1.close();
                    }
                    globalMap.put("tJDBCInput_1_NB_LINE", nb_line_tJDBCInput_1);
                    ok_Hash.put("tJDBCInput_1", true);
                    end_Hash.put("tJDBCInput_1", System.currentTimeMillis());
                    /**
                     * [tJDBCInput_1 end ] stop
                     */
                    /**
                     * [tJavaRow_1 end ] start
                     */
                    currentComponent = "tJavaRow_1";
                    globalMap.put("tJavaRow_1_NB_LINE", nb_line_tJavaRow_1);
                    ok_Hash.put("tJavaRow_1", true);
                    end_Hash.put("tJavaRow_1", System.currentTimeMillis());
                    /**
                     * [tJavaRow_1 end ] stop
                     */
                    /**
                     * [tJavaFlex_1 end ] start
                     */
                    currentComponent = "tJavaFlex_1";
                // end of the component, outside/closing the loop
                } catch (Exception e) {
                // this will only happen in db
                // connection error and loop should recover
                }
                ok_Hash.put("tJavaFlex_1", true);
                end_Hash.put("tJavaFlex_1", System.currentTimeMillis());
                /**
                 * [tJavaFlex_1 end ] stop
                 */
                /**
                 * [tLoop_2 end ] start
                 */
                currentComponent = "tLoop_2";
                Thread.sleep(4000);
                ;
            }
            ok_Hash.put("tLoop_2", true);
            end_Hash.put("tLoop_2", System.currentTimeMillis());
        /**
         * [tLoop_2 end ] stop
         */
        }
        if (resumeEntryMethodName == null || globalResumeTicket) {
            resumeUtil.addLog("CHECKPOINT", "CONNECTION:SUBJOB_OK:tLoop_2:OnSubjobOk", "", Thread.currentThread().getId() + "", "", "", "", "", "");
        }
        tJava_3Process(globalMap);
    } catch (java.lang.Exception e) {
        TalendException te = new TalendException(e, currentComponent, globalMap);
        throw te;
    } catch (java.lang.Error error) {
        throw error;
    } finally {
        try {
            /**
             * [tLoop_2 finally ] start
             */
            currentComponent = "tLoop_2";
            /**
             * [tLoop_2 finally ] stop
             */
            /**
             * [tJavaFlex_2 finally ] start
             */
            currentComponent = "tJavaFlex_2";
            /**
             * [tJavaFlex_2 finally ] stop
             */
            /**
             * [tJDBCConnection_7 finally ] start
             */
            currentComponent = "tJDBCConnection_7";
            /**
             * [tJDBCConnection_7 finally ] stop
             */
            /**
             * [tJavaFlex_1 finally ] start
             */
            currentComponent = "tJavaFlex_1";
            /**
             * [tJavaFlex_1 finally ] stop
             */
            /**
             * [tJDBCInput_1 finally ] start
             */
            currentComponent = "tJDBCInput_1";
            /**
             * [tJDBCInput_1 finally ] stop
             */
            /**
             * [tJavaRow_1 finally ] start
             */
            currentComponent = "tJavaRow_1";
        /**
         * [tJavaRow_1 finally ] stop
         */
        } catch (java.lang.Exception e) {
        // ignore
        } catch (java.lang.Error error) {
        // ignore
        }
        resourceMap = null;
    }
    globalMap.put("tLoop_2_SUBPROCESS_STATE", 1);
}
#method_after
public void tLoop_2Process(final java.util.Map<String, Object> globalMap) throws TalendException {
    globalMap.put("tLoop_2_SUBPROCESS_STATE", 0);
    final boolean execStat = this.execStat;
    String iterateId = "";
    String currentComponent = "";
    java.util.Map<String, Object> resourceMap = new java.util.HashMap<String, Object>();
    try {
        String currentMethodName = new java.lang.Exception().getStackTrace()[0].getMethodName();
        boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
        if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {
            // start
            // the
            // resume
            globalResumeTicket = true;
            row9Struct row9 = new row9Struct();
            /**
             * [tLoop_2 begin ] start
             */
            // for statistics
            int NB_ITERATE_tJavaFlex_2 = 0;
            // for statistics
            int NB_ITERATE_tJavaFlex_1 = 0;
            ok_Hash.put("tLoop_2", false);
            start_Hash.put("tLoop_2", System.currentTimeMillis());
            currentComponent = "tLoop_2";
            int tos_count_tLoop_2 = 0;
            int current_iteration_tLoop_2 = 0;
            boolean i = false;
            while (!i) {
                current_iteration_tLoop_2++;
                globalMap.put("tLoop_2_CURRENT_ITERATION", current_iteration_tLoop_2);
                /**
                 * [tLoop_2 begin ] stop
                 */
                /**
                 * [tLoop_2 main ] start
                 */
                currentComponent = "tLoop_2";
                tos_count_tLoop_2++;
                /**
                 * [tLoop_2 main ] stop
                 */
                NB_ITERATE_tJavaFlex_2++;
                /**
                 * [tJavaFlex_2 begin ] start
                 */
                // for statistics
                int NB_ITERATE_tJDBCConnection_7 = 0;
                ok_Hash.put("tJavaFlex_2", false);
                start_Hash.put("tJavaFlex_2", System.currentTimeMillis());
                currentComponent = "tJavaFlex_2";
                int tos_count_tJavaFlex_2 = 0;
                // start part of your Java code
                try {
                    /**
                     * [tJavaFlex_2 begin ] stop
                     */
                    /**
                     * [tJavaFlex_2 main ] start
                     */
                    currentComponent = "tJavaFlex_2";
                    // here is the main part of the component,
                    // a piece of code executed in the row
                    // loop
                    tos_count_tJavaFlex_2++;
                    /**
                     * [tJavaFlex_2 main ] stop
                     */
                    NB_ITERATE_tJDBCConnection_7++;
                    /**
                     * [tJDBCConnection_7 begin ] start
                     */
                    ok_Hash.put("tJDBCConnection_7", false);
                    start_Hash.put("tJDBCConnection_7", System.currentTimeMillis());
                    currentComponent = "tJDBCConnection_7";
                    int tos_count_tJDBCConnection_7 = 0;
                    String url_tJDBCConnection_7 = context.ovirtEngineDbJdbcConnection;
                    String dbUser_tJDBCConnection_7 = context.ovirtEngineDbUser;
                    final String decryptedPassword_tJDBCConnection_7 = context.ovirtEngineDbPassword;
                    String dbPwd_tJDBCConnection_7 = decryptedPassword_tJDBCConnection_7;
                    java.sql.Connection conn_tJDBCConnection_7 = null;
                    String sharedConnectionName_tJDBCConnection_7 = "engine-events";
                    conn_tJDBCConnection_7 = SharedDBConnection.getDBConnection(context.ovirtEngineDbDriverClass, url_tJDBCConnection_7, dbUser_tJDBCConnection_7, dbPwd_tJDBCConnection_7, sharedConnectionName_tJDBCConnection_7);
                    if (null != conn_tJDBCConnection_7) {
                        conn_tJDBCConnection_7.setAutoCommit(true);
                    }
                    globalMap.put("conn_tJDBCConnection_7", conn_tJDBCConnection_7);
                    globalMap.put("url_tJDBCConnection_7", url_tJDBCConnection_7);
                    // globalMap.put("user_tJDBCConnection_7",
                    // dbUser_tJDBCConnection_7);
                    // globalMap.put("pass_tJDBCConnection_7",
                    // dbPwd_tJDBCConnection_7);
                    /**
                     * [tJDBCConnection_7 begin ] stop
                     */
                    /**
                     * [tJDBCConnection_7 main ] start
                     */
                    currentComponent = "tJDBCConnection_7";
                    tos_count_tJDBCConnection_7++;
                    /**
                     * [tJDBCConnection_7 main ] stop
                     */
                    /**
                     * [tJDBCConnection_7 end ] start
                     */
                    currentComponent = "tJDBCConnection_7";
                    ok_Hash.put("tJDBCConnection_7", true);
                    end_Hash.put("tJDBCConnection_7", System.currentTimeMillis());
                    /**
                     * [tJDBCConnection_7 end ] stop
                     */
                    /**
                     * [tJavaFlex_2 end ] start
                     */
                    currentComponent = "tJavaFlex_2";
                // end of the component, outside/closing the loop
                } catch (Exception e) {
                    // this will only happen in db
                    // connection error and loop should recover
                    int TimesDisconnectDwhFailed = Integer.parseInt(((String) globalMap.get("timesDisconnectDwhFailed")));
                    if ((TimesDisconnectDwhFailed % 10) == 0) {
                        globalMap.put("timesDisconnectDwhFailed", Integer.valueOf(TimesDisconnectDwhFailed + 1).toString());
                        System.out.println(TalendDate.getDate("CCYY-MM-DD hh:mm:ss") + " |Exception in component tJavaFlex_6: " + e.toString() + " has been caught");
                    } else {
                        globalMap.put("timesDisconnectDwhFailed", Integer.valueOf(TimesDisconnectDwhFailed + 1).toString());
                    }
                }
                ok_Hash.put("tJavaFlex_2", true);
                end_Hash.put("tJavaFlex_2", System.currentTimeMillis());
                /**
                 * [tJavaFlex_2 end ] stop
                 */
                NB_ITERATE_tJavaFlex_1++;
                /**
                 * [tJavaFlex_1 begin ] start
                 */
                // for statistics
                int NB_ITERATE_tJDBCInput_1 = 0;
                ok_Hash.put("tJavaFlex_1", false);
                start_Hash.put("tJavaFlex_1", System.currentTimeMillis());
                currentComponent = "tJavaFlex_1";
                int tos_count_tJavaFlex_1 = 0;
                // start part of your Java code
                try {
                    /**
                     * [tJavaFlex_1 begin ] stop
                     */
                    /**
                     * [tJavaFlex_1 main ] start
                     */
                    currentComponent = "tJavaFlex_1";
                    // here is the main part of the component,
                    // a piece of code executed in the row
                    // loop
                    tos_count_tJavaFlex_1++;
                    /**
                     * [tJavaFlex_1 main ] stop
                     */
                    NB_ITERATE_tJDBCInput_1++;
                    /**
                     * [tJavaRow_1 begin ] start
                     */
                    ok_Hash.put("tJavaRow_1", false);
                    start_Hash.put("tJavaRow_1", System.currentTimeMillis());
                    currentComponent = "tJavaRow_1";
                    int tos_count_tJavaRow_1 = 0;
                    int nb_line_tJavaRow_1 = 0;
                    /**
                     * [tJavaRow_1 begin ] stop
                     */
                    /**
                     * [tJDBCInput_1 begin ] start
                     */
                    ok_Hash.put("tJDBCInput_1", false);
                    start_Hash.put("tJDBCInput_1", System.currentTimeMillis());
                    currentComponent = "tJDBCInput_1";
                    int tos_count_tJDBCInput_1 = 0;
                    int nb_line_tJDBCInput_1 = 0;
                    java.sql.Connection conn_tJDBCInput_1 = null;
                    conn_tJDBCInput_1 = (java.sql.Connection) globalMap.get("conn_tJDBCConnection_7");
                    java.sql.Statement stmt_tJDBCInput_1 = conn_tJDBCInput_1.createStatement();
                    String dbquery_tJDBCInput_1 = "SELECT option_value FROM vdc_options WHERE option_name = 'DisconnectDwh'";
                    globalMap.put("tJDBCInput_1_QUERY", dbquery_tJDBCInput_1);
                    java.sql.ResultSet rs_tJDBCInput_1 = null;
                    try {
                        rs_tJDBCInput_1 = stmt_tJDBCInput_1.executeQuery(dbquery_tJDBCInput_1);
                        java.sql.ResultSetMetaData rsmd_tJDBCInput_1 = rs_tJDBCInput_1.getMetaData();
                        int colQtyInRs_tJDBCInput_1 = rsmd_tJDBCInput_1.getColumnCount();
                        String tmpContent_tJDBCInput_1 = null;
                        while (rs_tJDBCInput_1.next()) {
                            nb_line_tJDBCInput_1++;
                            if (colQtyInRs_tJDBCInput_1 < 1) {
                                row9.option_value = null;
                            } else {
                                row9.option_value = routines.system.JDBCUtil.getString(rs_tJDBCInput_1, 1, false);
                            }
                            /**
                             * [tJDBCInput_1 begin ] stop
                             */
                            /**
                             * [tJDBCInput_1 main ] start
                             */
                            currentComponent = "tJDBCInput_1";
                            tos_count_tJDBCInput_1++;
                            /**
                             * [tJDBCInput_1 main ] stop
                             */
                            /**
                             * [tJavaRow_1 main ] start
                             */
                            currentComponent = "tJavaRow_1";
                            i = "1".equals(row9.option_value);
                            if (i) {
                                System.out.println("ETL Service will now stop because a flag was raised to disconnect DWH on Engine DB");
                            }
                            if (((String) globalMap.get("timesDisconnectDwhFailed")) != "0") {
                                globalMap.put("timesDisconnectDwhFailed", "0");
                            }
                            nb_line_tJavaRow_1++;
                            tos_count_tJavaRow_1++;
                            /**
                             * [tJavaRow_1 main ] stop
                             */
                            /**
                             * [tJDBCInput_1 end ] start
                             */
                            currentComponent = "tJDBCInput_1";
                        }
                    } finally {
                        if (rs_tJDBCInput_1 != null) {
                            rs_tJDBCInput_1.close();
                        }
                        stmt_tJDBCInput_1.close();
                    }
                    globalMap.put("tJDBCInput_1_NB_LINE", nb_line_tJDBCInput_1);
                    ok_Hash.put("tJDBCInput_1", true);
                    end_Hash.put("tJDBCInput_1", System.currentTimeMillis());
                    /**
                     * [tJDBCInput_1 end ] stop
                     */
                    /**
                     * [tJavaRow_1 end ] start
                     */
                    currentComponent = "tJavaRow_1";
                    globalMap.put("tJavaRow_1_NB_LINE", nb_line_tJavaRow_1);
                    ok_Hash.put("tJavaRow_1", true);
                    end_Hash.put("tJavaRow_1", System.currentTimeMillis());
                    /**
                     * [tJavaRow_1 end ] stop
                     */
                    /**
                     * [tJavaFlex_1 end ] start
                     */
                    currentComponent = "tJavaFlex_1";
                // end of the component, outside/closing the loop
                } catch (Exception e) {
                // this will only happen in db
                // connection error and loop should recover
                }
                ok_Hash.put("tJavaFlex_1", true);
                end_Hash.put("tJavaFlex_1", System.currentTimeMillis());
                /**
                 * [tJavaFlex_1 end ] stop
                 */
                /**
                 * [tLoop_2 end ] start
                 */
                currentComponent = "tLoop_2";
                Thread.sleep(4000);
                ;
            }
            ok_Hash.put("tLoop_2", true);
            end_Hash.put("tLoop_2", System.currentTimeMillis());
        /**
         * [tLoop_2 end ] stop
         */
        }
        if (resumeEntryMethodName == null || globalResumeTicket) {
            resumeUtil.addLog("CHECKPOINT", "CONNECTION:SUBJOB_OK:tLoop_2:OnSubjobOk", "", Thread.currentThread().getId() + "", "", "", "", "", "");
        }
        tJava_3Process(globalMap);
    } catch (java.lang.Exception e) {
        TalendException te = new TalendException(e, currentComponent, globalMap);
        throw te;
    } catch (java.lang.Error error) {
        throw error;
    } finally {
        try {
            /**
             * [tLoop_2 finally ] start
             */
            currentComponent = "tLoop_2";
            /**
             * [tLoop_2 finally ] stop
             */
            /**
             * [tJavaFlex_2 finally ] start
             */
            currentComponent = "tJavaFlex_2";
            /**
             * [tJavaFlex_2 finally ] stop
             */
            /**
             * [tJDBCConnection_7 finally ] start
             */
            currentComponent = "tJDBCConnection_7";
            /**
             * [tJDBCConnection_7 finally ] stop
             */
            /**
             * [tJavaFlex_1 finally ] start
             */
            currentComponent = "tJavaFlex_1";
            /**
             * [tJavaFlex_1 finally ] stop
             */
            /**
             * [tJDBCInput_1 finally ] start
             */
            currentComponent = "tJDBCInput_1";
            /**
             * [tJDBCInput_1 finally ] stop
             */
            /**
             * [tJavaRow_1 finally ] start
             */
            currentComponent = "tJavaRow_1";
        /**
         * [tJavaRow_1 finally ] stop
         */
        } catch (java.lang.Exception e) {
        // ignore
        } catch (java.lang.Error error) {
        // ignore
        }
        resourceMap = null;
    }
    globalMap.put("tLoop_2_SUBPROCESS_STATE", 1);
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecutePartially(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecutePartially(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(guestAgentPresent || acpiEnabled)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected ConfigurationValues spiceFullScreenConfigKey() {
    return ConfigurationValues.FullScreenUserportalDefault;
}
#method_after
@Override
protected ConfigurationValues spiceFullScreenConfigKey() {
    if (placeManager.isMainSectionBasicPlaceVisible()) {
        return ConfigurationValues.FullScreenUserportalBasicDefault;
    }
    return ConfigurationValues.FullScreenUserportalExtendedDefault;
}
#end_block

#method_before
@Test
public void testGetAllForCpuProfiles() {
    List<VM> result = dao.getAllForCpuProfiles(Arrays.asList(FixturesTool.CPU_PROFILE_1, FixturesTool.CPU_PROFILE_2));
    assertNotNull(result);
    assertEquals(2, result.size());
}
#method_after
@Test
public void testGetAllForCpuProfiles() {
    List<VM> result = dao.getAllForCpuProfiles(Collections.singleton(FixturesTool.CPU_PROFILE_1));
    assertNotNull(result);
    assertEquals(1, result.size());
}
#end_block

#method_before
@Test
public void testGetAllForDiskProfiles() {
    List<VM> result = dao.getAllForDiskProfiles(Arrays.asList(FixturesTool.DISK_PROFILE_1, FixturesTool.DISK_PROFILE_2));
    assertNotNull(result);
    assertEquals(2, result.size());
}
#method_after
@Test
public void testGetAllForDiskProfiles() {
    List<VM> result = dao.getAllForDiskProfiles(Collections.singleton(FixturesTool.DISK_PROFILE_1));
    assertNotNull(result);
    assertEquals(2, result.size());
}
#end_block

#method_before
@Override
public List<VM> getVmsByIds(List<Guid> vmsIds) {
    Object[] uuids = vmsIds.stream().map(Guid::getUuid).toArray();
    return getCallsHandler().executeReadList("GetVmsByIds", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vms_ids", createArrayOf("uuid", uuids)));
}
#method_after
@Override
public List<VM> getVmsByIds(List<Guid> vmsIds) {
    return getCallsHandler().executeReadList("GetVmsByIds", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vms_ids", createArrayOfUUIDs(vmsIds)));
}
#end_block

#method_before
@Override
public List<VM> getAllForCpuProfiles(List<Guid> cpuProfileIds) {
    Object[] uuids = cpuProfileIds.stream().map(Guid::getUuid).toArray();
    return getCallsHandler().executeReadList("GetVmsByCpuProfileIds", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("cpu_profile_ids", createArrayOf("uuid", uuids)));
}
#method_after
@Override
public List<VM> getAllForCpuProfiles(Collection<Guid> cpuProfileIds) {
    return getCallsHandler().executeReadList("GetVmsByCpuProfileIds", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("cpu_profile_ids", createArrayOfUUIDs(cpuProfileIds)));
}
#end_block

#method_before
@Override
public List<VM> getAllForDiskProfiles(List<Guid> diskProfileIds) {
    Object[] uuids = diskProfileIds.stream().map(Guid::getUuid).toArray();
    return getCallsHandler().executeReadList("GetAllVmsRelatedToDiskProfiles", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_profile_ids", createArrayOf("uuid", uuids)));
}
#method_after
@Override
public List<VM> getAllForDiskProfiles(Collection<Guid> diskProfileIds) {
    return getCallsHandler().executeReadList("GetAllVmsRelatedToDiskProfiles", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("disk_profile_ids", createArrayOfUUIDs(diskProfileIds)));
}
#end_block

#method_before
@Override
public List<DiskImage> getAll() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<DiskImage> getAll() {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public List<DiskImage> getAllForDiskProfiles(List<Guid> diskProfileIds) {
    Object[] uuids = diskProfileIds.stream().map(Guid::getUuid).toArray();
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("disk_profile_ids", createArrayOf("uuid", uuids));
    return getCallsHandler().executeReadList("GetAllForDiskProfiles", DiskImageRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<DiskImage> getAllForDiskProfiles(Collection<Guid> diskProfileIds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("disk_profile_ids", createArrayOfUUIDs(diskProfileIds));
    return getCallsHandler().executeReadList("GetAllForDiskProfiles", DiskImageRowMapper.instance, parameterSource);
}
#end_block

#method_before
@Override
@Test(expected = NotImplementedException.class)
public void testGetAll() {
    super.testGetAll();
}
#method_after
@Override
@Test(expected = UnsupportedOperationException.class)
public void testGetAll() {
    super.testGetAll();
}
#end_block

#method_before
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    drive.put(VdsProperties.Address, getParameters().getAddressMap() != null ? getParameters().getAddressMap() : StringUtils.EMPTY);
    drive.put(VdsProperties.INTERFACE, disk.getDiskInterface().getName());
    int numOfIoThreads = getParameters().getVm().getNumOfIoThreads();
    if (numOfIoThreads != 0 && disk.getDiskInterface() == DiskInterface.VirtIO) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<>());
        }
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId(), false);
        int numOfAttachedVirtioInterfaces = 0;
        for (Disk oneDisk : allDisks) {
            if (oneDisk.getPlugged() && oneDisk.getDiskInterface() == DiskInterface.VirtIO) {
                numOfAttachedVirtioInterfaces++;
            }
        }
        int pinToIoThread = numOfAttachedVirtioInterfaces % numOfIoThreads + 1;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinToIoThread);
    }
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(getParameters().getVm().getCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
            drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
            drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
            drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
            drive.put(VdsProperties.ImageId, diskImage.getId().toString());
            drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            VmInfoBuilder.handleIoTune(new IoTuneBuilder(), getParameters().getVm(), vmDevice, diskImage);
            if (vmDevice.getSpecParams() != null) {
                drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            }
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
            // set device type as 'lun' (instead of 'disk') and set the specified SGIO
            boolean isVirtioScsi = getParameters().getDisk().getDiskInterface() == DiskInterface.VirtIO_SCSI;
            boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
            if (isVirtioScsi) {
                if (isScsiPassthrough) {
                    drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
                } else {
                    drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
                }
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
            }
            drive.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
            drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            break;
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) disk;
            VmInfoBuilder.buildCinderDisk(cinderDisk, drive);
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            break;
    }
    return drive;
}
#method_after
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    drive.put(VdsProperties.Address, getParameters().getAddressMap() != null ? getParameters().getAddressMap() : StringUtils.EMPTY);
    drive.put(VdsProperties.INTERFACE, disk.getDiskInterface().getName());
    int numOfIoThreads = getParameters().getVm().getNumOfIoThreads();
    if (numOfIoThreads != 0 && disk.getDiskInterface() == DiskInterface.VirtIO) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<>());
        }
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId(), false);
        int numOfAttachedVirtioInterfaces = 0;
        for (Disk oneDisk : allDisks) {
            if (oneDisk.getPlugged() && oneDisk.getDiskInterface() == DiskInterface.VirtIO) {
                numOfAttachedVirtioInterfaces++;
            }
        }
        int pinToIoThread = numOfAttachedVirtioInterfaces % numOfIoThreads + 1;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinToIoThread);
    }
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
            drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
            drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
            drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
            drive.put(VdsProperties.ImageId, diskImage.getId().toString());
            drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            VmInfoBuilder.handleIoTune(vmDevice, VmInfoBuilder.loadStorageQos(diskImage));
            if (vmDevice.getSpecParams() != null) {
                drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            }
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
            // set device type as 'lun' (instead of 'disk') and set the specified SGIO
            boolean isVirtioScsi = getParameters().getDisk().getDiskInterface() == DiskInterface.VirtIO_SCSI;
            boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
            if (isVirtioScsi) {
                if (isScsiPassthrough) {
                    drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
                } else {
                    drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
                }
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
            }
            drive.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
            drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            break;
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) disk;
            VmInfoBuilder.buildCinderDisk(cinderDisk, drive);
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            break;
    }
    return drive;
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    IoTuneBuilder ioTuneBuilder = new IoTuneBuilder();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    handleIoTune(ioTuneBuilder, vm, vmDevice, diskImage);
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    if (vm.getNumOfIoThreads() != 0) {
                        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
                        // disk 0 -> iothread 1
                        // disk 1 -> iothread 2
                        // disk 2 -> iothread 1
                        // disk 3 -> iothread 2
                        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
                        pinnedDriveIndex++;
                        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), loadStorageQos(diskImage));
                    }
                    handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
public static void handleIoTune(IoTuneBuilder builder, VM vm, VmDevice vmDevice, DiskImage diskImage) {
    if (FeatureSupported.storageQoS(vm.getCompatibilityVersion())) {
        Map<String, Long> ioTune = builder.buildIoTune(diskImage);
        if (ioTune != null) {
            if (vmDevice.getSpecParams() == null) {
                vmDevice.setSpecParams(new HashMap<>());
            }
            vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
        }
    }
}
#method_after
public static void handleIoTune(VmDevice vmDevice, StorageQos storageQos) {
    if (storageQos != null) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<>());
        }
        vmDevice.getSpecParams().put(VdsProperties.Iotune, IoTuneUtils.ioTuneMapFrom(storageQos));
    }
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInfoBuilder.evaluateInterfaceType(ifaceType, vm.getHasAgent()), vm.getCompatibilityVersion());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInfoBuilder.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is different from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, vm.isRunOnce() ? vm.getBootSequence() : vm.getDefaultBootSequence(), managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getCompatibilityVersion()));
        for (VmDevice vmDevice : managedDevices) {
            for (Map struct : devices) {
                String deviceId = (String) struct.get(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.keySet().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#method_after
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is different from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, vm.isRunOnce() ? vm.getBootSequence() : vm.getDefaultBootSequence(), managedDevices);
        for (VmDevice vmDevice : managedDevices) {
            for (Map struct : devices) {
                String deviceId = (String) struct.get(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.keySet().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel, Version clusterVersion) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    if (FeatureSupported.networkLinking(clusterVersion)) {
        struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    }
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    addNetworkFiltersToNic(struct, clusterVersion);
}
#method_after
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    addNetworkFiltersToNic(struct);
}
#end_block

#method_before
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VnicProfileProperties> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getCompatibilityVersion())) {
                unsupportedFeatures.add(VnicProfileProperties.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getClusterCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VnicProfileProperties.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VnicProfileProperties.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#method_after
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VnicProfileProperties> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            addQosForDevice(struct, vnicProfile);
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    addPortMirroringToVmInterface(struct, vnicProfile, network);
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#end_block

#method_before
private static boolean addPortMirroringToVmInterface(Map<String, Object> struct, VnicProfile vnicProfile, Version version, Network network) {
    if (vnicProfile != null && vnicProfile.isPortMirroring()) {
        if (FeatureSupported.portMirroring(version)) {
            struct.put(VdsProperties.PORT_MIRRORING, network == null ? Collections.<String>emptyList() : Collections.singletonList(network.getName()));
        } else {
            return false;
        }
    }
    return true;
}
#method_after
private static void addPortMirroringToVmInterface(Map<String, Object> struct, VnicProfile vnicProfile, Network network) {
    if (vnicProfile != null && vnicProfile.isPortMirroring()) {
        struct.put(VdsProperties.PORT_MIRRORING, network == null ? Collections.<String>emptyList() : Collections.singletonList(network.getName()));
    }
}
#end_block

#method_before
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version clusterCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (!FeatureSupported.networkQoS(clusterCompatibilityVersion)) {
        return qosId == null;
    }
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getNetworkQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
    return true;
}
#method_after
private static void addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile) {
    Guid qosId = vnicProfile.getNetworkQosId();
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getNetworkQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
}
#end_block

#method_before
public static boolean addCustomPropertiesForDevice(Map<String, Object> struct, VM vm, VmDevice vmDevice, Version clusterVersion, Map<String, String> customProperties) {
    if (customProperties == null) {
        customProperties = new HashMap<>();
    }
    customProperties.putAll(vmDevice.getCustomProperties());
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(vmDevice.getId());
    if (runtimeCustomProperties != null) {
        customProperties.putAll(runtimeCustomProperties);
    }
    if (!customProperties.isEmpty()) {
        if (FeatureSupported.deviceCustomProperties(clusterVersion)) {
            struct.put(VdsProperties.Custom, customProperties);
        } else {
            return false;
        }
    }
    return true;
}
#method_after
public static void addCustomPropertiesForDevice(Map<String, Object> struct, VM vm, VmDevice vmDevice, Version clusterVersion, Map<String, String> customProperties) {
    if (customProperties == null) {
        customProperties = new HashMap<>();
    }
    customProperties.putAll(vmDevice.getCustomProperties());
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(vmDevice.getId());
    if (runtimeCustomProperties != null) {
        customProperties.putAll(runtimeCustomProperties);
    }
    if (!customProperties.isEmpty()) {
        struct.put(VdsProperties.Custom, customProperties);
    }
}
#end_block

#method_before
public static void addNetworkFiltersToNic(Map<String, Object> struct, Version clusterVersion) {
    if (FeatureSupported.antiMacSpoofing(clusterVersion) && Config.<Boolean>getValue(ConfigValues.EnableMACAntiSpoofingFilterRules)) {
        struct.put(VdsProperties.NW_FILTER, NetworkFilters.NO_MAC_SPOOFING.getFilterName());
    }
}
#method_after
public static void addNetworkFiltersToNic(Map<String, Object> struct) {
    if (Config.<Boolean>getValue(ConfigValues.EnableMACAntiSpoofingFilterRules)) {
        struct.put(VdsProperties.NW_FILTER, NetworkFilters.NO_MAC_SPOOFING.getFilterName());
    }
}
#end_block

#method_before
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDao().getAllVmNumaNodeByVmId(vm.getId());
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
        if (totalVdsNumaNodes.isEmpty()) {
            log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
            return;
        }
        // create a default one with one guest numa node
        if (vmNumaNodes.isEmpty()) {
            if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
                VmNumaNode vmNode = new VmNumaNode();
                vmNode.setIndex(0);
                vmNode.setMemTotal(vm.getMemSizeMb());
                for (int i = 0; i < vm.getNumOfCpus(); i++) {
                    vmNode.getCpuIds().add(i);
                }
                vmNumaNodes.add(vmNode);
            } else {
                // no need to send numa if memory hotplug not supported
                return;
            }
        }
        NumaTuneMode numaTune = vm.getNumaTuneMode();
        if (numaTune != null) {
            Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes);
            if (!numaTuneSetting.isEmpty()) {
                createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
            }
        }
        List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
        if (!createVmNumaNodes.isEmpty()) {
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        }
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#method_after
private void addNumaSetting(final String compatibilityVersion) {
    List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDao().getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
    if (totalVdsNumaNodes.isEmpty()) {
        log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
        return;
    }
    // create a default one with one guest numa node
    if (vmNumaNodes.isEmpty()) {
        if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(0);
            vmNode.setMemTotal(vm.getMemSizeMb());
            for (int i = 0; i < vm.getNumOfCpus(); i++) {
                vmNode.getCpuIds().add(i);
            }
            vmNumaNodes.add(vmNode);
        } else {
            // no need to send numa if memory hotplug not supported
            return;
        }
    }
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune != null) {
        Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes);
        if (!numaTuneSetting.isEmpty()) {
            createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
        }
    }
    List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
    if (!createVmNumaNodes.isEmpty()) {
        createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
    }
    if (StringUtils.isEmpty(vm.getCpuPinning())) {
        Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
        if (!cpuPinDict.isEmpty()) {
            createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
        }
    }
}
#end_block

#method_before
public void run(String[] args) throws Exception {
    // Create the command line options:
    Options options = new Options();
    // Options for the locations of files and directories:
    options.addOption(Option.builder().longOpt(MODEL_OPTION).desc("The directory or .jar file containing the source model files.").type(File.class).required(true).hasArg(true).argName("DIRECTORY|JAR").build());
    // Options for the location of the generated sources:
    options.addOption(Option.builder().longOpt(OUT_OPTION).desc("The directory where the generated source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    // Parse the command line:
    CommandLineParser parser = new DefaultParser();
    CommandLine line = null;
    try {
        line = parser.parse(options, args);
    } catch (ParseException exception) {
        HelpFormatter formatter = new HelpFormatter();
        formatter.setSyntaxPrefix("Usage: ");
        formatter.printHelp("sdk-tool [OPTIONS]", options);
        System.exit(1);
    }
    // Extract the locations of files and directories from the command line:
    File modelFile = (File) line.getParsedOptionValue(MODEL_OPTION);
    File outDir = (File) line.getParsedOptionValue(OUT_OPTION);
    // Analyze the model files:
    Model model = new Model();
    ModelAnalyzer modelAnalyzer = new ModelAnalyzer();
    modelAnalyzer.setModel(model);
    modelAnalyzer.analyzeSource(modelFile);
    // Generate href attribute to Identified interface:
    StructType identified = (StructType) model.getType(NameParser.parseUsingCase("Identified"));
    Attribute href = new Attribute();
    href.setType(model.getStringType());
    href.setName(NameParser.parseUsingCase("Href"));
    identified.addAttribute(href);
    // Add the built-in types:
    addBuiltinTypes(model);
    // Set the names of the packages:
    javaPackages.setTypesPackageName(BASE_PACKAGE + ".types");
    javaPackages.setContainersPackageName(BASE_PACKAGE + ".internal.containers");
    javaPackages.setBuildersPackageName(BASE_PACKAGE + ".builders");
    javaPackages.setXmlPackageName(BASE_PACKAGE + ".internal.xml");
    // Run the generators:
    if (outDir != null) {
        List<JavaGenerator> generators = new ArrayList<>();
        generators.add(structsGenerator);
        generators.add(xmlSupportGenerator);
        generators.add(enumGenerator);
        generators.add(servicesGenerator);
        generators.add(servicesImplGenerator);
        FileUtils.forceMkdir(outDir);
        for (JavaGenerator generator : generators) {
            generator.setOutDir(outDir);
            generator.generate(model);
        }
    }
}
#method_after
public void run(String[] args) throws Exception {
    // Create the command line options:
    Options options = new Options();
    // Options for the locations of files and directories:
    options.addOption(Option.builder().longOpt(MODEL_OPTION).desc("The directory or .jar file containing the source model files.").type(File.class).required(true).hasArg(true).argName("DIRECTORY|JAR").build());
    // Options for the location of the generated sources:
    options.addOption(Option.builder().longOpt(OUT_OPTION).desc("The directory where the generated source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    // Parse the command line:
    CommandLineParser parser = new DefaultParser();
    CommandLine line = null;
    try {
        line = parser.parse(options, args);
    } catch (ParseException exception) {
        HelpFormatter formatter = new HelpFormatter();
        formatter.setSyntaxPrefix("Usage: ");
        formatter.printHelp("sdk-tool [OPTIONS]", options);
        System.exit(1);
    }
    // Extract the locations of files and directories from the command line:
    File modelFile = (File) line.getParsedOptionValue(MODEL_OPTION);
    File outDir = (File) line.getParsedOptionValue(OUT_OPTION);
    // Analyze the model files:
    Model model = new Model();
    ModelAnalyzer modelAnalyzer = new ModelAnalyzer();
    modelAnalyzer.setModel(model);
    modelAnalyzer.analyzeSource(modelFile);
    // Generate href attribute to Identified type:
    addHrefAttributeToIdentifiedType(model);
    // Add the built-in types:
    addBuiltinTypes(model);
    // Set the names of the packages:
    javaPackages.setTypesPackageName(BASE_PACKAGE + ".types");
    javaPackages.setContainersPackageName(BASE_PACKAGE + ".internal.containers");
    javaPackages.setBuildersPackageName(BASE_PACKAGE + ".builders");
    javaPackages.setXmlPackageName(BASE_PACKAGE + ".internal.xml");
    // Run the generators:
    if (outDir != null) {
        List<JavaGenerator> generators = new ArrayList<>();
        generators.add(structsGenerator);
        generators.add(xmlSupportGenerator);
        generators.add(enumGenerator);
        generators.add(servicesGenerator);
        generators.add(servicesImplGenerator);
        FileUtils.forceMkdir(outDir);
        for (JavaGenerator generator : generators) {
            generator.setOutDir(outDir);
            generator.generate(model);
        }
    }
}
#end_block

#method_before
@Override
public boolean isLink(Identified object) {
    return object.href() != null;
}
#method_after
@Override
public boolean isLink(Object object) {
    if (object instanceof Identified) {
        return ((Identified) object).href() != null;
    }
    return false;
}
#end_block

#method_before
@Override
public <T extends Identified> T followLink(Identified object) {
    if (!isLink(object)) {
        throw new RuntimeException("Can't follow link because object don't have any.");
    }
    try {
        String href = object.href();
        if (href == null) {
            throw new RuntimeException("Can't follow link because the 'href' attribute does't have a value");
        }
        URL url = new URL(getUrl());
        String prefix = url.getPath();
        if (!prefix.endsWith("/")) {
            prefix += "/";
        }
        if (!href.startsWith(prefix)) {
            throw new RuntimeException("The URL '" + href + "' isn't compatible with the base URL of the connection");
        }
        // Get service based on path
        String path = href.substring(prefix.length());
        Service service = systemService().service(path);
        // Obtain method which provides result object and invoke it:
        Method get = service.getClass().getMethod("get");
        get.setAccessible(true);
        Object getRequest = get.invoke(service);
        Method send = getRequest.getClass().getMethod("send");
        send.setAccessible(true);
        Object getReponse = send.invoke(getRequest);
        Method obtainObject = getReponse.getClass().getDeclaredMethods()[0];
        obtainObject.setAccessible(true);
        return (T) obtainObject.invoke(getReponse);
    } catch (NoSuchMethodException ex) {
        throw new RuntimeException(ex);
    } catch (IllegalAccessException ex) {
        throw new RuntimeException(ex);
    } catch (InvocationTargetException ex) {
        throw new RuntimeException(ex);
    } catch (MalformedURLException ex) {
        throw new RuntimeException(ex);
    }
}
#method_after
@Override
public <TYPE> TYPE followLink(TYPE object) {
    if (!isLink(object)) {
        throw new RuntimeException("Can't follow link because object don't have any.");
    }
    try {
        String href = ((Identified) object).href();
        if (href == null) {
            throw new RuntimeException("Can't follow link because the 'href' attribute does't have a value");
        }
        URL url = new URL(getUrl());
        String prefix = url.getPath();
        if (!prefix.endsWith("/")) {
            prefix += "/";
        }
        if (!href.startsWith(prefix)) {
            throw new RuntimeException("The URL '" + href + "' isn't compatible with the base URL of the connection");
        }
        // Get service based on path
        String path = href.substring(prefix.length());
        Service service = systemService().service(path);
        // Obtain method which provides result object and invoke it:
        Method get = service.getClass().getMethod("get");
        Object getRequest = get.invoke(service);
        Method send = getRequest.getClass().getMethod("send");
        send.setAccessible(true);
        Object getResponse = send.invoke(getRequest);
        Method obtainObject = getResponse.getClass().getDeclaredMethods()[0];
        obtainObject.setAccessible(true);
        return (TYPE) obtainObject.invoke(getResponse);
    } catch (NoSuchMethodException ex) {
        throw new RuntimeException(ex);
    } catch (IllegalAccessException ex) {
        throw new RuntimeException(ex);
    } catch (InvocationTargetException ex) {
        throw new RuntimeException(ex);
    } catch (MalformedURLException ex) {
        throw new RuntimeException(ex);
    }
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Use the "list" method of the "vms" service to list all the virtual machines of the system:
    List<Vm> vms = vmsService.list().send().vms();
    // Print the virtual machine names and identifiers:
    for (Vm vm : vms) {
        System.out.printf("%s: %s", vm.name(), vm.id());
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Use the "list" method of the "vms" service to list all the virtual machines of the system:
    List<Vm> vms = vmsService.list().send().vms();
    // Print the virtual machine names and identifiers:
    for (Vm vm : vms) {
        System.out.printf("%s: %s", vm.name(), vm.id());
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
private void generateServiceInterfaceSource(Service service) {
    // Generate imports for the base classes:
    buffer.addImport(BASE_PACKAGE, "Request");
    buffer.addImport(BASE_PACKAGE, "Response");
    buffer.addImport(BASE_PACKAGE, "Service");
    // Begin class:
    JavaClassName serviceName = getServiceName(service);
    buffer.addLine("public interface %1$s extends Service {", serviceName.getSimpleName());
    // Generate the code for the methods:
    service.declaredMethods().sorted().forEach(this::generateMethodInterface);
    // Generate the code for the locators:
    service.declaredLocators().sorted().forEach(this::generateLocator);
    // End class:
    buffer.addLine("}");
    buffer.addLine();
}
#method_after
private void generateServiceInterfaceSource(Service service) {
    // Generate imports for the base classes:
    buffer.addImport(BASE_PACKAGE, "Request");
    buffer.addImport(BASE_PACKAGE, "Response");
    buffer.addImport(BASE_PACKAGE, "Service");
    buffer.addImport(IOException.class);
    // Begin class:
    JavaClassName serviceName = getServiceName(service);
    buffer.addLine("public interface %1$s extends Service {", serviceName.getSimpleName());
    // Generate the code for the methods:
    service.declaredMethods().sorted().forEach(this::generateMethodInterface);
    // Generate the code for the locators:
    service.declaredLocators().sorted().forEach(this::generateLocator);
    generatePathLocator();
    // End class:
    buffer.addLine("}");
    buffer.addLine();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Locate the virtual machines service and use it to find the virtual machine:
    VmsService vmsService = connection.systemService().vmsService();
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // In order to specify the network that the new interface will be connected to we need to specifiy the
    // identifier of the virtual network interface profile, so we need to find it:
    VnicProfilesService profilesService = connection.systemService().vnicProfilesService();
    String profileId = null;
    for (VnicProfile profile : profilesService.list().send().profiles()) {
        if ("mynetwork".equals(profile.name())) {
            profileId = profile.id();
        }
    }
    // Locate the service that manages the network interface cards of the virtual machine:
    VmNicsService nicsService = vmsService.vmService(vm.id()).nicsService();
    // Use the "add" method of the network interfface cards service to add the new network interface card:
    nicsService.add().nic(nic().name("mynic").description("My network interface card").vnicProfile(vnicProfile().id(profileId))).send();
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Locate the virtual machines service and use it to find the virtual machine:
    VmsService vmsService = connection.systemService().vmsService();
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // In order to specify the network that the new interface will be connected to we need to specifiy the
    // identifier of the virtual network interface profile, so we need to find it:
    VnicProfilesService profilesService = connection.systemService().vnicProfilesService();
    String profileId = null;
    for (VnicProfile profile : profilesService.list().send().profiles()) {
        if ("mynetwork".equals(profile.name())) {
            profileId = profile.id();
        }
    }
    // Locate the service that manages the network interface cards of the virtual machine:
    VmNicsService nicsService = vmsService.vmService(vm.id()).nicsService();
    // Use the "add" method of the network interfface cards service to add the new network interface card:
    nicsService.add().nic(nic().name("mynic").description("My network interface card").vnicProfile(vnicProfile().id(profileId))).send();
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the clusters service:
    ClustersService clustersService = connection.systemService().clustersService();
    // Use the "add" method to create a new data center:
    clustersService.add().cluster(cluster().name("mycluster").description("My cluster").cpu(cpu().architecture("X86_64").type("Intel Conroe Family")).dataCenter(dataCenter().name("mydc"))).send();
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the clusters service:
    ClustersService clustersService = connection.systemService().clustersService();
    // Use the "add" method to create a new data center:
    clustersService.add().cluster(cluster().name("mycluster").description("My cluster").cpu(cpu().architecture(Architecture.X86_64).type("Intel Conroe Family")).dataCenter(dataCenter().name("mydc"))).send();
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public Connection build() {
    // Check the parameters:
    // If all the checks pass, then create the connection:
    HttpConnection connection = new HttpConnection();
    connection.setUrl(url);
    connection.setUser(user);
    connection.setPassword(password);
    connection.setInsecure(insecure);
    connection.setDebug(debug);
    return connection;
}
#method_after
public Connection build() {
    try {
        // Check the parameters:
        if (url == null) {
            throw new RuntimeException("The 'url' parameter is mandatory");
        }
        if (!insecure && keyStorePath == null) {
            throw new RuntimeException("The 'keyStorePath' is mandatory in secure mode");
        }
        if (keyStorePath != null && !new File(keyStorePath).exists()) {
            throw new RuntimeException(String.format("The keystore file '%s' doesn't exist'", keyStorePath));
        }
        urlobj = new URL(url);
        // If all the checks pass, then create the connection:
        HttpConnection connection = new HttpConnection();
        connection.setClient(createDefaultHttpClient());
        connection.setUrl(url);
        connection.setUser(user);
        connection.setPassword(password);
        connection.setInsecure(insecure);
        connection.setDebug(debug);
        connection.setKerberos(kerberos);
        return connection;
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Find the virtual machine:
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // Locate the service that manages the virtual machine, as that is where the action methods are defined:
    VmService vmService = vmsService.vmService(vm.id());
    // Call the "stop" method of the service to stop it:
    vmService.stop().send();
    // What till the virtual machine is up:
    for (; ; ) {
        Thread.sleep(5 * 1000);
        vm = vmService.get().send().vm();
        String state = vm.status().state();
        if ("down".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Find the virtual machine:
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // Locate the service that manages the virtual machine, as that is where the action methods are defined:
    VmService vmService = vmsService.vmService(vm.id());
    // Call the "stop" method of the service to stop it:
    vmService.stop().send();
    // What till the virtual machine is up:
    for (; ; ) {
        Thread.sleep(5 * 1000);
        vm = vmService.get().send().vm();
        String state = vm.status().state();
        if ("down".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Locate the service that manages the storage domains, and use it to search for the storage domain:
    StorageDomainsService sdsService = connection.systemService().storageDomainsService();
    StorageDomain sd = sdsService.list().search("name=myiso").send().storageDomain().get(0);
    // Locate the servcie that manages the data centers and use it to search for the data center:
    DataCentersService dcsService = connection.systemService().dataCentersService();
    DataCenter dc = dcsService.list().search("name=mydc").send().dataCenters().get(0);
    // Locate the service that manages the data center where we want to attach the storage domain:
    DataCenterService dcService = dcsService.dataCenterService(dc.id());
    // Locate the service that manages the storage domains that are attached to the data center:
    AttachedStorageDomainsService attachedSdsService = dcService.storageDomainsService();
    // Use the "add" method of the service that manages the attached storage domains to attach it:
    attachedSdsService.add().storageDomain(storageDomain().id(sd.id())).send();
    // Wait till the storage domain is active:
    StorageDomainService sdService = sdsService.storageDomainService(sd.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        sd = sdService.get().send().storageDomain();
        String state = sd.status().state();
        if ("active".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Locate the service that manages the storage domains, and use it to search for the storage domain:
    StorageDomainsService sdsService = connection.systemService().storageDomainsService();
    StorageDomain sd = sdsService.list().search("name=myiso").send().storageDomain().get(0);
    // Locate the servcie that manages the data centers and use it to search for the data center:
    DataCentersService dcsService = connection.systemService().dataCentersService();
    DataCenter dc = dcsService.list().search("name=mydc").send().dataCenters().get(0);
    // Locate the service that manages the data center where we want to attach the storage domain:
    DataCenterService dcService = dcsService.dataCenterService(dc.id());
    // Locate the service that manages the storage domains that are attached to the data center:
    AttachedStorageDomainsService attachedSdsService = dcService.storageDomainsService();
    // Use the "add" method of the service that manages the attached storage domains to attach it:
    attachedSdsService.add().storageDomain(storageDomain().id(sd.id())).send();
    // Wait till the storage domain is active:
    StorageDomainService sdService = sdsService.storageDomainService(sd.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        sd = sdService.get().send().storageDomain();
        String state = sd.status().state();
        if ("active".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Use the "list" method of the "vms" service to search the virtual machines that match a search query:
    List<Vm> vms = vmsService.list().search("name=MYVM").caseSensitive(false).send().vms();
    // Print the virtual machine names and identifiers:
    for (Vm vm : vms) {
        System.out.printf("%s: %s", vm.name(), vm.id());
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Use the "list" method of the "vms" service to search the virtual machines that match a search query:
    List<Vm> vms = vmsService.list().search("name=MYVM").caseSensitive(false).send().vms();
    // Print the virtual machine names and identifiers:
    for (Vm vm : vms) {
        System.out.printf("%s: %s", vm.name(), vm.id());
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the data centers service:
    DataCentersService dcsService = connection.systemService().dataCentersService();
    // Use the "add" method to create a new data center:
    dcsService.add().dataCenter(dataCenter().name("mydc").description("My data center").local(false)).send();
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the data centers service:
    DataCentersService dcsService = connection.systemService().dataCentersService();
    // Use the "add" method to create a new data center:
    dcsService.add().dataCenter(dataCenter().name("mydc").description("My data center").local(false)).send();
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the hosts service:
    HostsService hostsService = connection.systemService().hostsService();
    // Add the host:
    Host host = hostsService.add().host(host().name("myhost").description("My host").address("node40.example.com").rootPassword("readhat123").cluster(cluster().name("mycluster"))).send().host();
    // Wait till the host is up:
    HostService hostService = hostsService.hostService(host.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        host = hostService.get().send().host();
        String state = host.status().state();
        if ("up".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the hosts service:
    HostsService hostsService = connection.systemService().hostsService();
    // Add the host:
    Host host = hostsService.add().host(host().name("myhost").description("My host").address("node40.example.com").rootPassword("readhat123").cluster(cluster().name("mycluster"))).send().host();
    // Wait till the host is up:
    HostService hostService = hostsService.hostService(host.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        host = hostService.get().send().host();
        String state = host.status().state();
        if ("up".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Use the "add" method to create a new virtual machine:
    vmsService.add().vm(vm().name("myvm").cluster(cluster().name("mycluster")).template(template().name("Blank"))).send();
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Use the "add" method to create a new virtual machine:
    vmsService.add().vm(vm().name("myvm").cluster(cluster().name("mycluster")).template(template().name("Blank"))).send();
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Locate the virtual machines service and use it to find the virtual machine:
    VmsService vmsService = connection.systemService().vmsService();
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // Locate the service that manages the disks of the virtual machine:
    VmDisksService disksService = vmsService.vmService(vm.id()).disksService();
    // Use the "add" method of the disks service to add the disk:
    Disk disk = disksService.add().disk(disk().name("mydisk").description("My disk").interface_("virtio").format("cow").provisionedSize(1 * (int) Math.pow(2, 20)).storageDomains(storageDomain().name("myadata"))).send().disk();
    // Wait till the disk is OK:
    VmDiskService diskService = disksService.diskService(disk.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        disk = diskService.get().send().disk();
        String state = disk.status().state();
        if ("unattached".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Locate the virtual machines service and use it to find the virtual machine:
    VmsService vmsService = connection.systemService().vmsService();
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // Locate the service that manages the disks of the virtual machine:
    VmDisksService disksService = vmsService.vmService(vm.id()).disksService();
    // Use the "add" method of the disks service to add the disk:
    Disk disk = disksService.add().disk(disk().name("mydisk").description("My disk").interface_(DiskInterface.VIRTIO).format(DiskFormat.COW).provisionedSize(1 * (int) Math.pow(2, 20)).storageDomains(storageDomain().name("myadata"))).send().disk();
    // Wait till the disk is OK:
    VmDiskService diskService = disksService.diskService(disk.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        disk = diskService.get().send().disk();
        String state = disk.status().state();
        if ("unattached".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Find the service that manages hosts:
    HostsService hostsService = connection.systemService().hostsService();
    // Find the host:
    Host host = hostsService.list().search("name=myhost").send().hosts().get(0);
    // Find the service that manages the host:
    HostService hostService = hostsService.hostService(host.id());
    // If the host isn't down or in maintenance then move it to maintenance:
    if (!host.status().state().equals("maitenance")) {
        hostService.deactivate().send();
    }
    // Remove the host:
    hostService.remove().send();
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Find the service that manages hosts:
    HostsService hostsService = connection.systemService().hostsService();
    // Find the host:
    Host host = hostsService.list().search("name=myhost").send().hosts().get(0);
    // Find the service that manages the host:
    HostService hostService = hostsService.hostService(host.id());
    // If the host isn't down or in maintenance then move it to maintenance:
    if (!host.status().state().equals("maitenance")) {
        hostService.deactivate().send();
    }
    // Remove the host:
    hostService.remove().send();
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Find the service that manages VMs:
    VmsService vmsService = connection.systemService().vmsService();
    // Find the VM:
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // Note that the "vm" variable that we assigned above contains only the data of the VM, it doesn't have any
    // method like "remove". Methods are defined in the services. So now that we have the description of the VM
    // we can find the service that manages it, calling the locator method "vmService" defined in the "vms"
    // service. This locator method receives as parameter the identifier of the VM and returns a reference to the
    // service that manages that VM.
    VmService vmService = vmsService.vmService(vm.id());
    // Now that we have the reference to the service that manages the VM we can use it to remove the VM. Note that
    // this method doesn't need any parameter, as the identifier of the VM is already known by the service that we
    // located in the previous step.
    vmService.remove().send();
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Find the service that manages VMs:
    VmsService vmsService = connection.systemService().vmsService();
    // Find the VM:
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // Note that the "vm" variable that we assigned above contains only the data of the VM, it doesn't have any
    // method like "remove". Methods are defined in the services. So now that we have the description of the VM
    // we can find the service that manages it, calling the locator method "vmService" defined in the "vms"
    // service. This locator method receives as parameter the identifier of the VM and returns a reference to the
    // service that manages that VM.
    VmService vmService = vmsService.vmService(vm.id());
    // Now that we have the reference to the service that manages the VM we can use it to remove the VM. Note that
    // this method doesn't need any parameter, as the identifier of the VM is already known by the service that we
    // located in the previous step.
    vmService.remove().send();
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Locate the service that manages the storage domains, and use it to search for the storage domain:
    StorageDomainsService sdsService = connection.systemService().storageDomainsService();
    StorageDomain sd = sdsService.list().search("name=mydata").send().storageDomain().get(0);
    // Locate the service that manages the data centers and use it to search for the data center:
    DataCentersService dcsService = connection.systemService().dataCentersService();
    DataCenter dc = dcsService.list().search("name=mydc").send().dataCenters().get(0);
    // Locate the service that manages the data center where we want to attach the storage domain:
    DataCenterService dcService = dcsService.dataCenterService(dc.id());
    // Locate the service that manages the storage domains that are attached to the data center:
    AttachedStorageDomainsService attachedSdsService = dcService.storageDomainsService();
    // Use the "add" method of the service that manages the attached storage domains to attach it:
    attachedSdsService.add().storageDomain(storageDomain().id(sd.id())).send();
    // Wait till the storage domain is active:
    StorageDomainService sdService = sdsService.storageDomainService(sd.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        sd = sdService.get().send().storageDomain();
        String state = sd.status().state();
        if ("active".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Locate the service that manages the storage domains, and use it to search for the storage domain:
    StorageDomainsService sdsService = connection.systemService().storageDomainsService();
    StorageDomain sd = sdsService.list().search("name=mydata").send().storageDomain().get(0);
    // Locate the service that manages the data centers and use it to search for the data center:
    DataCentersService dcsService = connection.systemService().dataCentersService();
    DataCenter dc = dcsService.list().search("name=mydc").send().dataCenters().get(0);
    // Locate the service that manages the data center where we want to attach the storage domain:
    DataCenterService dcService = dcsService.dataCenterService(dc.id());
    // Locate the service that manages the storage domains that are attached to the data center:
    AttachedStorageDomainsService attachedSdsService = dcService.storageDomainsService();
    // Use the "add" method of the service that manages the attached storage domains to attach it:
    attachedSdsService.add().storageDomain(storageDomain().id(sd.id())).send();
    // Wait till the storage domain is active:
    StorageDomainService sdService = sdsService.storageDomainService(sd.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        sd = sdService.get().send().storageDomain();
        String state = sd.status().state();
        if ("active".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
@Override
public SystemService systemService() {
    return null;
}
#method_after
@Override
public SystemService systemService() {
    return new SystemServiceImpl(this, "");
}
#end_block

#method_before
@Override
public boolean isLink(Object object) {
    return false;
}
#method_after
@Override
public boolean isLink(Object object) {
    for (Method m : object.getClass().getMethods()) {
        System.out.println(m.getName());
        if (m.getName().contains("href")) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public <TYPE> TYPE followLink(TYPE object) {
    return null;
}
#method_after
@Override
public <TYPE> TYPE followLink(TYPE object) {
    if (!isLink(object)) {
        throw new RuntimeException("Can't follow link because object don't have any.");
    }
    try {
        Method m = object.getClass().getMethod("href");
        String href = (String) m.invoke(object);
        if (href == null) {
            throw new RuntimeException("Can't follow link because the 'href' attribute does't have a value");
        }
        URL url = new URL(getUrl());
        String prefix = url.getPath();
        if (!prefix.endsWith("/")) {
            prefix += "/";
        }
        if (!href.startsWith(prefix)) {
            throw new RuntimeException("The URL '" + href + "' isn't compatible with the base URL of the connection");
        }
        String path = href.substring(prefix.length());
        Service service = systemService().service(path);
        Object getRequest = service.getClass().getMethod("get").invoke(service);
        Object getReponse = getRequest.getClass().getMethod("send").invoke(getRequest);
        return (TYPE) getReponse.getClass().getDeclaredMethods()[0].invoke(getReponse);
    } catch (NoSuchMethodException ex) {
        throw new RuntimeException(ex);
    } catch (IllegalAccessException ex) {
        throw new RuntimeException(ex);
    } catch (InvocationTargetException ex) {
        throw new RuntimeException(ex);
    } catch (MalformedURLException ex) {
        throw new RuntimeException(ex);
    }
}
#end_block

#method_before
@Override
public void close() throws Exception {
}
#method_after
@Override
public void close() throws Exception {
    // Send the last request to indicate the server that the session should be closed:
    HttpGet request = new HttpGet(url);
    this.send(request, true);
    // close log
    for (Handler handler : Logger.getLogger("org.apache.http").getHandlers()) {
        if (handler != null) {
            handler.close();
        }
    }
    // Close HttpClient connection:
    if (client != null) {
        client.close();
    }
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the storage domains service:
    StorageDomainsService sdsService = connection.systemService().storageDomainsService();
    // Create a new NFS storage domain:
    StorageDomain sd = sdsService.add().storageDomain(storageDomain().name("mydata").description("My data").type("data").host(host().name("myhost")).storage(hostStorage().type("nfs").address("server0.example.com").path("/nfs/ovirt/40/mydata"))).send().storageDomain();
    // Wait till the storage domain is unattached:
    StorageDomainService sdService = sdsService.storageDomainService(sd.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        sd = sdService.get().send().storageDomain();
        String state = sd.status().state();
        if ("unattached".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the storage domains service:
    StorageDomainsService sdsService = connection.systemService().storageDomainsService();
    // Create a new NFS storage domain:
    StorageDomain sd = sdsService.add().storageDomain(storageDomain().name("mydata").description("My data").type(StorageDomainType.DATA).host(host().name("myhost")).storage(hostStorage().type(StorageType.NFS).address("server0.example.com").path("/nfs/ovirt/40/mydata"))).send().storageDomain();
    // Wait till the storage domain is unattached:
    StorageDomainService sdService = sdsService.storageDomainService(sd.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        sd = sdService.get().send().storageDomain();
        String state = sd.status().state();
        if ("unattached".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Find the virtual machine:
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // Locate the service that manages the virtual machine, as that is where the action methods are defined:
    VmService vmService = vmsService.vmService(vm.id());
    // Call the "start" method of the service to start it:
    vmService.start().send();
    // What till the virtual machine is up:
    for (; ; ) {
        Thread.sleep(5 * 1000);
        vm = vmService.get().send().vm();
        String state = vm.status().state();
        if ("up".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the "vms" service:
    VmsService vmsService = connection.systemService().vmsService();
    // Find the virtual machine:
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // Locate the service that manages the virtual machine, as that is where the action methods are defined:
    VmService vmService = vmsService.vmService(vm.id());
    // Call the "start" method of the service to start it:
    vmService.start().send();
    // What till the virtual machine is up:
    for (; ; ) {
        Thread.sleep(5 * 1000);
        vm = vmService.get().send().vm();
        String state = vm.status().state();
        if ("up".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public void run(String[] args) throws Exception {
    // Create the command line options:
    Options options = new Options();
    // Options for the locations of files and directories:
    options.addOption(Option.builder().longOpt(MODEL_OPTION).desc("The directory or .jar file containing the source model files.").type(File.class).required(true).hasArg(true).argName("DIRECTORY|JAR").build());
    // Options for the location of the generated sources:
    options.addOption(Option.builder().longOpt(OUT_OPTION).desc("The directory where the generated source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    // Parse the command line:
    CommandLineParser parser = new DefaultParser();
    CommandLine line = null;
    try {
        line = parser.parse(options, args);
    } catch (ParseException exception) {
        HelpFormatter formatter = new HelpFormatter();
        formatter.setSyntaxPrefix("Usage: ");
        formatter.printHelp("sdk-tool [OPTIONS]", options);
        System.exit(1);
    }
    // Extract the locations of files and directories from the command line:
    File modelFile = (File) line.getParsedOptionValue(MODEL_OPTION);
    File outDir = (File) line.getParsedOptionValue(OUT_OPTION);
    // Analyze the model files:
    Model model = new Model();
    ModelAnalyzer modelAnalyzer = new ModelAnalyzer();
    modelAnalyzer.setModel(model);
    modelAnalyzer.analyzeSource(modelFile);
    // Add the built-in types:
    addBuiltinTypes(model);
    // Set the names of the packages:
    javaPackages.setTypesPackageName(BASE_PACKAGE + ".types");
    javaPackages.setContainersPackageName(BASE_PACKAGE + ".internal.containers");
    javaPackages.setBuildersPackageName(BASE_PACKAGE + ".builders");
    javaPackages.setXmlPackageName(BASE_PACKAGE + ".internal.xml");
    // Run the generators:
    if (outDir != null) {
        List<JavaGenerator> generators = new ArrayList<>();
        generators.add(structsGenerator);
        generators.add(xmlSupportGenerator);
        generators.add(servicesGenerator);
        FileUtils.forceMkdir(outDir);
        for (JavaGenerator generator : generators) {
            generator.setOutDir(outDir);
            generator.generate(model);
        }
    }
}
#method_after
public void run(String[] args) throws Exception {
    // Create the command line options:
    Options options = new Options();
    // Options for the locations of files and directories:
    options.addOption(Option.builder().longOpt(MODEL_OPTION).desc("The directory or .jar file containing the source model files.").type(File.class).required(true).hasArg(true).argName("DIRECTORY|JAR").build());
    // Options for the location of the generated sources:
    options.addOption(Option.builder().longOpt(OUT_OPTION).desc("The directory where the generated source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    // Parse the command line:
    CommandLineParser parser = new DefaultParser();
    CommandLine line = null;
    try {
        line = parser.parse(options, args);
    } catch (ParseException exception) {
        HelpFormatter formatter = new HelpFormatter();
        formatter.setSyntaxPrefix("Usage: ");
        formatter.printHelp("sdk-tool [OPTIONS]", options);
        System.exit(1);
    }
    // Extract the locations of files and directories from the command line:
    File modelFile = (File) line.getParsedOptionValue(MODEL_OPTION);
    File outDir = (File) line.getParsedOptionValue(OUT_OPTION);
    // Analyze the model files:
    Model model = new Model();
    ModelAnalyzer modelAnalyzer = new ModelAnalyzer();
    modelAnalyzer.setModel(model);
    modelAnalyzer.analyzeSource(modelFile);
    // Add the built-in types:
    addBuiltinTypes(model);
    // Set the names of the packages:
    javaPackages.setTypesPackageName(BASE_PACKAGE + ".types");
    javaPackages.setContainersPackageName(BASE_PACKAGE + ".internal.containers");
    javaPackages.setBuildersPackageName(BASE_PACKAGE + ".builders");
    javaPackages.setXmlPackageName(BASE_PACKAGE + ".internal.xml");
    // Run the generators:
    if (outDir != null) {
        List<JavaGenerator> generators = new ArrayList<>();
        generators.add(structsGenerator);
        generators.add(xmlSupportGenerator);
        generators.add(enumGenerator);
        generators.add(servicesGenerator);
        generators.add(servicesImplGenerator);
        FileUtils.forceMkdir(outDir);
        for (JavaGenerator generator : generators) {
            generator.setOutDir(outDir);
            generator.generate(model);
        }
    }
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the data centers service:
    DataCentersService dcsService = connection.systemService().dataCentersService();
    // Retrieve the description of the data center:
    DataCenter dc = dcsService.list().search("name=mydc").send().dataCenters().get(0);
    // In order to update the data center we need a reference to the service that manages it, then we can call the
    // "update" method passing the update:
    DataCenterService dcService = dcsService.dataCenterService(dc.id());
    dc = dcService.update().dataCenter(dataCenter().description("Updated description")).send().dataCenter();
    // Print the description of the result of the update:
    System.out.printf("%s: %s", dc.name(), dc.description());
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the data centers service:
    DataCentersService dcsService = connection.systemService().dataCentersService();
    // Retrieve the description of the data center:
    DataCenter dc = dcsService.list().search("name=mydc").send().dataCenters().get(0);
    // In order to update the data center we need a reference to the service that manages it, then we can call the
    // "update" method passing the update:
    DataCenterService dcService = dcsService.dataCenterService(dc.id());
    dc = dcService.update().dataCenter(dataCenter().description("Updated description")).send().dataCenter();
    // Print the description of the result of the update:
    System.out.printf("%s: %s", dc.name(), dc.description());
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the service that manages virtual machines:
    VmsService vmsService = connection.systemService().vmsService();
    // Find the virtual machine:
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // When the server returns a virtual machine it will return links to related objects, like the cluster and the
    // template, something like this:
    // 
    // <cluster id="123" href="/api/clusters/123"/>
    // <template id="456" href="/api/templates/456"/>
    // 
    // The SDK provides a "followLink" method that can be used to retrieve the complete content of these related
    // objects.
    Cluster cluster = connection.followLink(vm.cluster());
    Template template = connection.followLink(vm.template());
    // Now we can use the details of the cluster and the template:
    System.out.printf("cluster: %s", cluster.name());
    System.out.printf("template: %s", template.name());
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the service that manages virtual machines:
    VmsService vmsService = connection.systemService().vmsService();
    // Find the virtual machine:
    Vm vm = vmsService.list().search("name=myvm").send().vms().get(0);
    // When the server returns a virtual machine it will return links to related objects, like the cluster and the
    // template, something like this:
    // 
    // <cluster id="123" href="/api/clusters/123"/>
    // <template id="456" href="/api/templates/456"/>
    // 
    // The SDK provides a "followLink" method that can be used to retrieve the complete content of these related
    // objects.
    Cluster cluster = connection.followLink(vm.cluster());
    Template template = connection.followLink(vm.template());
    // Now we can use the details of the cluster and the template:
    System.out.printf("cluster: %s", cluster.name());
    System.out.printf("template: %s", template.name());
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").caFile("ca.pem").debug(true).build();
    // Get the reference to the storage domains service:
    StorageDomainsService sdsService = connection.systemService().storageDomainsService();
    // Create a new NFS storage domain:
    StorageDomain sd = sdsService.add().storageDomain(storageDomain().name("myiso").description("My ISO").type("iso").host(host().name("myhost")).storage(hostStorage().type("nfs").address("server0.example.com").path("/nfs/ovirt/40/myiso"))).send().storageDomain();
    // Wait till the storage domain is unattached:
    StorageDomainService sdService = sdsService.storageDomainService(sd.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        sd = sdService.get().send().storageDomain();
        String state = sd.status().state();
        if ("unattached".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#method_after
public static void main(String[] args) throws Exception {
    // Create the connection to the server:
    Connection connection = connection().url("https://engine40.example.com/ovirt-engine/api").user("admin@internal").password("redhat123").keyStorePath("keystore.jks").build();
    // Get the reference to the storage domains service:
    StorageDomainsService sdsService = connection.systemService().storageDomainsService();
    // Create a new NFS storage domain:
    StorageDomain sd = sdsService.add().storageDomain(storageDomain().name("myiso").description("My ISO").type(StorageDomainType.ISO).host(host().name("myhost")).storage(hostStorage().type(StorageType.NFS).address("server0.example.com").path("/nfs/ovirt/40/myiso"))).send().storageDomain();
    // Wait till the storage domain is unattached:
    StorageDomainService sdService = sdsService.storageDomainService(sd.id());
    for (; ; ) {
        Thread.sleep(5 * 1000);
        sd = sdService.get().send().storageDomain();
        String state = sd.status().state();
        if ("unattached".equals(state)) {
            break;
        }
    }
    // Close the connection to the server:
    connection.close();
}
#end_block

#method_before
@Override
public void onBrowserEvent(Context context, Element parent, T value, SafeHtml tooltip, NativeEvent event, ValueUpdater<T> valueUpdater) {
    super.onBrowserEvent(context, parent, value, tooltip, event, valueUpdater);
    EventTarget eventTarget = event.getEventTarget();
    if (!Element.is(eventTarget)) {
        return;
    }
    if (BrowserEvents.CLICK.equals(event.getType()) && isEnabled(value)) {
        // TODO change the image while the mouse is down (simulate click)
        UICommand command = resolveCommand(value);
        if (command != null) {
            command.execute();
        }
    }
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, T value, SafeHtml tooltip, NativeEvent event, ValueUpdater<T> valueUpdater) {
    super.onBrowserEvent(context, parent, value, tooltip, event, valueUpdater);
    EventTarget eventTarget = event.getEventTarget();
    if (!Element.is(eventTarget)) {
        return;
    }
    if (BrowserEvents.CLICK.equals(event.getType()) && isEnabled(value)) {
        UICommand command = resolveCommand(value);
        if (command != null) {
            command.execute();
        }
    }
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveOrCopyParameters parameter = new MoveOrCopyParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveOrCopyParameters parameter = (MoveOrCopyParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveVmParameters parameters = new MoveVmParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveOrCopyParameters parameters = new MoveOrCopyParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
public void setEntity(VM value) {
    updateIsMemorySnapshotSupported(value);
    updateIsLiveMergeSupported(value);
    super.setEntity(value);
    updateIsCloneVmSupported();
    updateVmActiveDisks();
}
#method_after
@Override
public void setEntity(VM value) {
    updateIsMemorySnapshotSupported(value);
    updateIsLiveMergeSupported(value);
    super.setEntity(value);
    updateVmActiveDisks();
}
#end_block

#method_before
public void updateActionAvailability() {
    if (getItems() == null) {
        // no need to update action availability
        return;
    }
    VM vm = getEntity();
    Snapshot snapshot = getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isVmQualifiedForSnapshotMerge = vm != null && vm.getStatus().isQualifiedForSnapshotMerge();
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isStateless && (isLiveMergeSupported() ? isVmQualifiedForSnapshotMerge : isVmDown));
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
    getCloneTemplateCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless);
}
#method_after
public void updateActionAvailability() {
    if (getItems() == null) {
        // no need to update action availability
        return;
    }
    VM vm = getEntity();
    Snapshot snapshot = getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isVmQualifiedForSnapshotMerge = vm != null && vm.getStatus().isQualifiedForSnapshotMerge();
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isStateless && (isLiveMergeSupported() ? isVmQualifiedForSnapshotMerge : isVmDown));
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless);
    getCloneTemplateCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless);
}
#end_block

#method_before
public void initialize() {
    isHighlyAvailable = new BooleanLabel(constants.yes(), constants.no());
    driver.initialize(this);
    formBuilder.addFormItem(new FormItem(constants.nameVm(), name, 0, 0));
    formBuilder.addFormItem(new FormItem(constants.descriptionVm(), description, 1, 0));
    formBuilder.addFormItem(new FormItem(constants.templateVm(), template, 2, 0));
    formBuilder.addFormItem(new FormItem(constants.osVm(), oS, 3, 0));
    formBuilder.addFormItem(new FormItem(constants.graphicsProtocol(), graphicsType, 4, 0));
    formBuilder.addFormItem(new FormItem(constants.videoType(), defaultDisplayType, 5, 0));
    formBuilder.addFormItem(new FormItem(constants.priorityVm(), priority, 6, 0));
    formBuilder.addFormItem(new FormItem(constants.definedMemoryVm(), definedMemory, 0, 1));
    formBuilder.addFormItem(new FormItem(constants.physMemGauranteedVm(), minAllocatedMemory, 1, 1));
    formBuilder.addFormItem(new FormItem(constants.guestFreeCachedBufferedMemInfo(), guestFreeCachedBufferedMemInfo, 2, 1).withDefaultValue(constants.notConfigured(), new DefaultValueCondition() {

        @Override
        public boolean showDefaultValue() {
            return getModel().getGuestFreeCachedBufferedMemInfo() == null;
        }
    }));
    WidgetTooltip cpuInfoWithTooltip = new WidgetTooltip(cpuInfo);
    cpuInfoWithTooltip.setText(constants.numOfCpuCoresVmTooltip());
    formBuilder.addFormItem(new FormItem(constants.numOfCpuCoresVm(), cpuInfoWithTooltip, 3, 1));
    formBuilder.addFormItem(new FormItem(constants.GuestCpuCount(), guestCpuCount, 4, 1));
    formBuilder.addFormItem(new FormItem(constants.highlyAvailableVm(), isHighlyAvailable, 5, 1));
    formBuilder.addFormItem(new FormItem(constants.numOfMonitorsVm(), monitorCount, 6, 1));
    formBuilder.addFormItem(new FormItem(constants.usbPolicyVm(), usbPolicy, 7, 1));
    formBuilder.addFormItem(new FormItem(constants.originVm(), origin, 0, 2));
    formBuilder.addFormItem(new FormItem(constants.runOnVm(), defaultHost, 1, 2));
    formBuilder.addFormItem(new FormItem(constants.customPropertiesVm(), customProperties, 2, 2));
    formBuilder.addFormItem(new FormItem(constants.clusterCompatibilityVersionVm(), compatibilityVersion, 3, 2));
    formBuilder.addFormItem(new FormItem(constants.vmId(), vmId, 4, 2));
    formBuilder.addFormItem(new FormItem(constants.quotaVm(), quotaName, 5, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().isQuotaAvailable();
        }
    }.withDefaultValue(constants.notConfigured(), new DefaultValueCondition() {

        @Override
        public boolean showDefaultValue() {
            String quotaName = getModel().getQuotaName();
            return quotaName == null || "".equals(quotaName);
        }
    }));
    formBuilder.addFormItem(new FormItem(constants.domainVm(), domain, 6, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasDomain();
        }
    });
    formBuilder.addFormItem(new FormItem(constants.fqdn(), fqdn, 7, 2) {

        @Override
        public boolean getIsAvailable() {
            String fqdn = getModel().getFqdn();
            return !(fqdn == null || fqdn.isEmpty());
        }
    });
    formBuilder.addFormItem(new FormItem(constants.timeZoneVm(), timeZone, 8, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasTimeZone();
        }
    });
}
#method_after
public void initialize() {
    isHighlyAvailable = new BooleanLabel(constants.yes(), constants.no());
    driver.initialize(this);
    formBuilder.addFormItem(new FormItem(constants.nameVm(), name, 0, 0));
    formBuilder.addFormItem(new FormItem(constants.descriptionVm(), description, 1, 0));
    formBuilder.addFormItem(new FormItem(constants.templateVm(), template, 2, 0));
    formBuilder.addFormItem(new FormItem(constants.osVm(), oS, 3, 0));
    formBuilder.addFormItem(new FormItem(constants.graphicsProtocol(), graphicsType, 4, 0));
    formBuilder.addFormItem(new FormItem(constants.videoType(), defaultDisplayType, 5, 0));
    formBuilder.addFormItem(new FormItem(constants.priorityVm(), priority, 6, 0));
    formBuilder.addFormItem(new FormItem(constants.definedMemoryVm(), definedMemory, 0, 1));
    formBuilder.addFormItem(new FormItem(constants.physMemGauranteedVm(), minAllocatedMemory, 1, 1));
    formBuilder.addFormItem(new FormItem(constants.guestFreeCachedBufferedMemInfo(), guestFreeCachedBufferedMemInfo, 2, 1).withDefaultValue(constants.notConfigured(), new DefaultValueCondition() {

        @Override
        public boolean showDefaultValue() {
            return getModel().getGuestFreeCachedBufferedMemInfo() == null;
        }
    }));
    WidgetTooltip cpuInfoWithTooltip = new WidgetTooltip(cpuInfo);
    cpuInfoWithTooltip.setHtml(templates.numOfCpuCoresTooltip());
    formBuilder.addFormItem(new FormItem(constants.numOfCpuCoresVm(), cpuInfoWithTooltip, 3, 1));
    formBuilder.addFormItem(new FormItem(constants.GuestCpuCount(), guestCpuCount, 4, 1));
    formBuilder.addFormItem(new FormItem(constants.highlyAvailableVm(), isHighlyAvailable, 5, 1));
    formBuilder.addFormItem(new FormItem(constants.numOfMonitorsVm(), monitorCount, 6, 1));
    formBuilder.addFormItem(new FormItem(constants.usbPolicyVm(), usbPolicy, 7, 1));
    formBuilder.addFormItem(new FormItem(constants.originVm(), origin, 0, 2));
    formBuilder.addFormItem(new FormItem(constants.runOnVm(), defaultHost, 1, 2));
    formBuilder.addFormItem(new FormItem(constants.customPropertiesVm(), customProperties, 2, 2));
    formBuilder.addFormItem(new FormItem(constants.clusterCompatibilityVersionVm(), compatibilityVersion, 3, 2));
    formBuilder.addFormItem(new FormItem(constants.vmId(), vmId, 4, 2));
    formBuilder.addFormItem(new FormItem(constants.quotaVm(), quotaName, 5, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().isQuotaAvailable();
        }
    }.withDefaultValue(constants.notConfigured(), new DefaultValueCondition() {

        @Override
        public boolean showDefaultValue() {
            String quotaName = getModel().getQuotaName();
            return quotaName == null || "".equals(quotaName);
        }
    }));
    formBuilder.addFormItem(new FormItem(constants.domainVm(), domain, 6, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasDomain();
        }
    });
    formBuilder.addFormItem(new FormItem(constants.fqdn(), fqdn, 7, 2) {

        @Override
        public boolean getIsAvailable() {
            String fqdn = getModel().getFqdn();
            return !(fqdn == null || fqdn.isEmpty());
        }
    });
    formBuilder.addFormItem(new FormItem(constants.timeZoneVm(), timeZone, 8, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasTimeZone();
        }
    });
}
#end_block

#method_before
public void initialize() {
    driver.initialize(this);
    formBuilder.addFormItem(new FormItem(constants.namePoolGeneral(), name, 0, 0));
    formBuilder.addFormItem(new FormItem(constants.descriptionPoolGeneral(), description, 1, 0));
    formBuilder.addFormItem(new FormItem(constants.templatePoolGeneral(), template, 2, 0));
    formBuilder.addFormItem(new FormItem(constants.osPoolGeneral(), oS, 3, 0));
    formBuilder.addFormItem(new FormItem(constants.graphicsProtocol(), graphicsType, 4, 0));
    formBuilder.addFormItem(new FormItem(constants.videoType(), defaultDisplayType, 5, 0));
    formBuilder.addFormItem(new FormItem(constants.definedMemPoolGeneral(), definedMemory, 0, 1));
    formBuilder.addFormItem(new FormItem(constants.physMemGaurPoolGeneral(), minAllocatedMemory, 1, 1));
    WidgetTooltip cpuInfoWithTooltip = new WidgetTooltip(cpuInfo);
    cpuInfoWithTooltip.setText(constants.numOfCpuCoresTooltipPoolGeneral());
    formBuilder.addFormItem(new FormItem(constants.numOfCpuCoresPoolGeneral(), cpuInfoWithTooltip, 2, 1));
    formBuilder.addFormItem(new FormItem(constants.numOfMonitorsPoolGeneral(), monitorCount, 3, 1));
    formBuilder.addFormItem(new FormItem(constants.usbPolicyPoolGeneral(), usbPolicy, 4, 1));
    formBuilder.addFormItem(new FormItem(constants.runOnPoolGeneral(), defaultHost, 0, 2));
}
#method_after
public void initialize() {
    driver.initialize(this);
    formBuilder.addFormItem(new FormItem(constants.namePoolGeneral(), name, 0, 0));
    formBuilder.addFormItem(new FormItem(constants.descriptionPoolGeneral(), description, 1, 0));
    formBuilder.addFormItem(new FormItem(constants.templatePoolGeneral(), template, 2, 0));
    formBuilder.addFormItem(new FormItem(constants.osPoolGeneral(), oS, 3, 0));
    formBuilder.addFormItem(new FormItem(constants.graphicsProtocol(), graphicsType, 4, 0));
    formBuilder.addFormItem(new FormItem(constants.videoType(), defaultDisplayType, 5, 0));
    formBuilder.addFormItem(new FormItem(constants.definedMemPoolGeneral(), definedMemory, 0, 1));
    formBuilder.addFormItem(new FormItem(constants.physMemGaurPoolGeneral(), minAllocatedMemory, 1, 1));
    WidgetTooltip cpuInfoWithTooltip = new WidgetTooltip(cpuInfo);
    cpuInfoWithTooltip.setHtml(templates.numOfCpuCoresTooltip());
    formBuilder.addFormItem(new FormItem(constants.numOfCpuCoresPoolGeneral(), cpuInfoWithTooltip, 2, 1));
    formBuilder.addFormItem(new FormItem(constants.numOfMonitorsPoolGeneral(), monitorCount, 3, 1));
    formBuilder.addFormItem(new FormItem(constants.usbPolicyPoolGeneral(), usbPolicy, 4, 1));
    formBuilder.addFormItem(new FormItem(constants.runOnPoolGeneral(), defaultHost, 0, 2));
}
#end_block

#method_before
public void initialize() {
    driver.initialize(this);
    isHighlyAvailable = new BooleanLabel(constants.yes(), constants.no());
    // Build a form using the FormBuilder
    formBuilder.addFormItem(new FormItem(constants.nameTemplateGeneral(), name, 0, 0));
    formBuilder.addFormItem(new FormItem(constants.descriptionTemplateGeneral(), description, 1, 0));
    formBuilder.addFormItem(new FormItem(constants.hostClusterTemplateGeneral(), hostCluster, 2, 0));
    formBuilder.addFormItem(new FormItem(constants.osTemplateGeneral(), oS, 3, 0));
    formBuilder.addFormItem(new FormItem(constants.graphicsProtocol(), graphicsType, 4, 0));
    formBuilder.addFormItem(new FormItem(constants.videoType(), defaultDisplayType, 5, 0));
    formBuilder.addFormItem(new FormItem(constants.definedMemTemplateGeneral(), definedMemory, 0, 1));
    WidgetTooltip cpuInfoWithTooltip = new WidgetTooltip(cpuInfo);
    cpuInfoWithTooltip.setText(constants.numOfCpuCoresTooltipTemplateGeneral());
    formBuilder.addFormItem(new FormItem(constants.numOfCpuCoresTemplateGeneral(), cpuInfoWithTooltip, 1, 1));
    formBuilder.addFormItem(new FormItem(constants.numOfMonitorsTemplateGeneral(), monitorCount, 2, 1));
    formBuilder.addFormItem(new FormItem(constants.highlyAvailTemplateGeneral(), isHighlyAvailable, 3, 1));
    formBuilder.addFormItem(new FormItem(constants.priorityTemplateGeneral(), priority, 4, 1));
    formBuilder.addFormItem(new FormItem(constants.usbPolicyTemplateGeneral(), usbPolicy, 5, 1) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasUsbPolicy();
        }
    });
    formBuilder.addFormItem(new FormItem(constants.originTemplateGeneral(), origin, 0, 2));
    formBuilder.addFormItem(new FormItem(constants.isStatelessTemplateGeneral(), isStateless, 1, 2));
    formBuilder.addFormItem(new FormItem(constants.domainTemplateGeneral(), domain, 2, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasDomain();
        }
    });
    formBuilder.addFormItem(new FormItem(constants.tzTemplateGeneral(), timeZone, 3, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasTimeZone();
        }
    });
    formBuilder.addFormItem(new FormItem(constants.quotaTemplateGeneral(), quotaName, 4, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().isQuotaAvailable();
        }
    }.withDefaultValue(constants.notConfigured(), new DefaultValueCondition() {

        @Override
        public boolean showDefaultValue() {
            String quotaName = getModel().getQuotaName();
            return quotaName == null || "".equals(quotaName);
        }
    }));
}
#method_after
public void initialize() {
    driver.initialize(this);
    isHighlyAvailable = new BooleanLabel(constants.yes(), constants.no());
    // Build a form using the FormBuilder
    formBuilder.addFormItem(new FormItem(constants.nameTemplateGeneral(), name, 0, 0));
    formBuilder.addFormItem(new FormItem(constants.descriptionTemplateGeneral(), description, 1, 0));
    formBuilder.addFormItem(new FormItem(constants.hostClusterTemplateGeneral(), hostCluster, 2, 0));
    formBuilder.addFormItem(new FormItem(constants.osTemplateGeneral(), oS, 3, 0));
    formBuilder.addFormItem(new FormItem(constants.graphicsProtocol(), graphicsType, 4, 0));
    formBuilder.addFormItem(new FormItem(constants.videoType(), defaultDisplayType, 5, 0));
    formBuilder.addFormItem(new FormItem(constants.definedMemTemplateGeneral(), definedMemory, 0, 1));
    WidgetTooltip cpuInfoWithTooltip = new WidgetTooltip(cpuInfo);
    cpuInfoWithTooltip.setHtml(templates.numOfCpuCoresTooltip());
    formBuilder.addFormItem(new FormItem(constants.numOfCpuCoresTemplateGeneral(), cpuInfoWithTooltip, 1, 1));
    formBuilder.addFormItem(new FormItem(constants.numOfMonitorsTemplateGeneral(), monitorCount, 2, 1));
    formBuilder.addFormItem(new FormItem(constants.highlyAvailTemplateGeneral(), isHighlyAvailable, 3, 1));
    formBuilder.addFormItem(new FormItem(constants.priorityTemplateGeneral(), priority, 4, 1));
    formBuilder.addFormItem(new FormItem(constants.usbPolicyTemplateGeneral(), usbPolicy, 5, 1) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasUsbPolicy();
        }
    });
    formBuilder.addFormItem(new FormItem(constants.originTemplateGeneral(), origin, 0, 2));
    formBuilder.addFormItem(new FormItem(constants.isStatelessTemplateGeneral(), isStateless, 1, 2));
    formBuilder.addFormItem(new FormItem(constants.domainTemplateGeneral(), domain, 2, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasDomain();
        }
    });
    formBuilder.addFormItem(new FormItem(constants.tzTemplateGeneral(), timeZone, 3, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().getHasTimeZone();
        }
    });
    formBuilder.addFormItem(new FormItem(constants.quotaTemplateGeneral(), quotaName, 4, 2) {

        @Override
        public boolean getIsAvailable() {
            return getModel().isQuotaAvailable();
        }
    }.withDefaultValue(constants.notConfigured(), new DefaultValueCondition() {

        @Override
        public boolean showDefaultValue() {
            String quotaName = getModel().getQuotaName();
            return quotaName == null || "".equals(quotaName);
        }
    }));
}
#end_block

#method_before
private void initToolTips() {
    numberOfCoresTooltip.setText(constants.numOfCoresTooltipBasicDetails());
}
#method_after
private void initToolTips() {
    numberOfCoresTooltip.setHtml(templates.numOfCpuCoresTooltip());
}
#end_block

#method_before
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(existingAttachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        if (existingAttachmentsByNetworkId.containsKey(attachment.getNetworkId())) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#method_after
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(existingAttachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        if (!networkAttachmentsFromParamsByNetworkId.containsKey(attachment.getNetworkId())) {
            vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
            vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
            vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms(attachment.getNetworkName());
        }
    }
    return vr;
}
#method_after
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms(attachment.getNetworkName());
    }
    return vr;
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    boolean networkAttachedToNicByAnotherAttachment = networkAttachmentsFromParamsByNetworkId.get(removedNetwork.getId()) != null;
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, removedNetwork.getName())).when(!networkAttachedToNicByAnotherAttachment && isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#method_after
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, removedNetwork.getName())).when(isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#end_block

#method_before
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment newOrModifedAttachmet) {
    Network movedNetwork = existingNetworkRelatedToAttachment(newOrModifedAttachmet);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = existingAttachmentsByNetworkId.get(newOrModifedAttachmet.getNetworkId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(newOrModifedAttachmet.getNicId());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, movedNetwork.getName()), ReplacementUtils.getVariableAssignmentString(engineMessage, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#method_after
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment newOrModifedAttachmet) {
    Network movedNetwork = existingNetworkRelatedToAttachment(newOrModifedAttachmet);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = existingAttachmentsById.get(newOrModifedAttachmet.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(newOrModifedAttachmet.getNicId());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, movedNetwork.getName()), ReplacementUtils.getVariableAssignmentString(engineMessage, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#end_block

#method_before
@Test
public void testEnumReadMany() {
    V4Vm object = objectFromXml("<vm>" + "<display_types>" + "<display_type>spice</display_type>" + "<display_type>VNC</display_type>" + "</display_types>" + "</vm>");
    List<V4VmDisplayType> expected = Arrays.asList(new V4VmDisplayType[] { V4VmDisplayType.SPICE, V4VmDisplayType.VNC });
    assertThat(object.displayTypes(), is(expected));
}
#method_after
@Test
public void testEnumReadMany() {
    V4Vm object = objectFromXml("<vm>" + "<display_types>" + "<display_type>spice</display_type>" + "<display_type>VNC</display_type>" + "</display_types>" + "</vm>");
    List<V4VmDisplayType> expected = Arrays.asList(V4VmDisplayType.SPICE, V4VmDisplayType.VNC);
    assertEquals(expected, object.displayTypes());
}
#end_block

#method_before
@Test
public void testEnumReadMany() {
    V4Vm object = objectFromJson("{'display_types': {'display_type': ['spice', 'VNC']}}");
    List<V4VmDisplayType> expected = Arrays.asList(new V4VmDisplayType[] { V4VmDisplayType.SPICE, V4VmDisplayType.VNC });
    assertThat(object.displayTypes(), is(expected));
}
#method_after
@Test
public void testEnumReadMany() {
    V4Vm object = objectFromJson("{'display_types': {'display_type': ['spice', 'VNC']}}");
    List<V4VmDisplayType> expected = Arrays.asList(V4VmDisplayType.SPICE, V4VmDisplayType.VNC);
    assertEquals(expected, object.displayTypes());
}
#end_block

#method_before
private void generateStructReadMany(StructType type) {
    generateReadMany(type);
}
#method_after
private void generateStructReadMany(StructType type) {
    // Get the type name:
    JavaClassName typeName = javaTypes.getInterfaceName(type);
    // Iterate method:
    javaBuffer.addImport(typeName);
    javaBuffer.addImport(Iterator.class);
    javaBuffer.addImport(JsonReader.class);
    javaBuffer.addImport(NoSuchElementException.class);
    javaBuffer.addLine("public static Iterator<%1$s> iterateMany(JsonReader reader) {", typeName.getSimpleName());
    javaBuffer.addLine("return new Iterator<%1$s>() {", typeName.getSimpleName());
    javaBuffer.addLine("private boolean first = true;");
    javaBuffer.addLine();
    javaBuffer.addLine("@Override");
    javaBuffer.addLine("public boolean hasNext() {");
    javaBuffer.addLine("if (first) {");
    javaBuffer.addLine("reader.expect(Event.START_ARRAY);");
    javaBuffer.addLine("first = false;");
    javaBuffer.addLine("}");
    javaBuffer.addLine("return reader.next() == Event.START_OBJECT;");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
    javaBuffer.addLine("@Override");
    javaBuffer.addLine("public %1$s next() {", typeName.getSimpleName());
    javaBuffer.addLine("%1$s next = readOne(reader, true);", typeName.getSimpleName());
    javaBuffer.addLine("if (next == null) {");
    javaBuffer.addLine("throw new NoSuchElementException();");
    javaBuffer.addLine("}");
    javaBuffer.addLine("return next;");
    javaBuffer.addLine("}");
    javaBuffer.addLine("};");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
    // Read method:
    javaBuffer.addImport(typeName);
    javaBuffer.addImport(ArrayList.class);
    javaBuffer.addImport(Iterator.class);
    javaBuffer.addImport(JsonReader.class);
    javaBuffer.addImport(List.class);
    javaBuffer.addLine("public static List<%1$s> readMany(JsonReader reader) {", typeName.getSimpleName());
    javaBuffer.addLine("List<%1$s> list = new ArrayList<>();", typeName.getSimpleName());
    javaBuffer.addLine("Iterator<%1$s> iterator = iterateMany(reader);", typeName.getSimpleName());
    javaBuffer.addLine("while (iterator.hasNext()) {");
    javaBuffer.addLine("list.add(iterator.next());");
    javaBuffer.addLine("}");
    javaBuffer.addLine("return list;");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateEnumReadMany(EnumType type) {
    generateReadMany(type);
}
#method_after
private void generateEnumReadMany(EnumType type) {
    // Get the type name:
    JavaClassName typeName = javaTypes.getInterfaceName(type);
    // Read method:
    javaBuffer.addImport(typeName);
    javaBuffer.addImport(ArrayList.class);
    javaBuffer.addImport(JsonReader.class);
    javaBuffer.addImport(List.class);
    javaBuffer.addImport(JsonParser.Event.class);
    javaBuffer.addImport(JsonParser.class);
    javaBuffer.addLine("public static List<%1$s> readMany(JsonReader reader) {", typeName.getSimpleName());
    javaBuffer.addLine("List<%1$s> list = new ArrayList<>();", typeName.getSimpleName());
    javaBuffer.addLine("while (reader.next() != Event.START_ARRAY) {");
    javaBuffer.addLine("// Empty on purpose");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
    javaBuffer.addLine("boolean enumArrayEnd = false;");
    javaBuffer.addLine("while (!enumArrayEnd) {");
    javaBuffer.addLine("JsonParser.Event next = reader.next();");
    javaBuffer.addLine("switch (next) {");
    javaBuffer.addLine("case VALUE_STRING:");
    javaBuffer.addLine("  String value = reader.getString();");
    javaBuffer.addLine("  list.add(%1$s.fromValue(value));", typeName.getSimpleName());
    javaBuffer.addLine("  break;");
    javaBuffer.addLine("case END_ARRAY:");
    javaBuffer.addLine("  enumArrayEnd = true;");
    javaBuffer.addLine("  break;");
    javaBuffer.addLine("default:");
    javaBuffer.addLine("  reader.skip();");
    javaBuffer.addLine("}");
    javaBuffer.addLine("}");
    javaBuffer.addLine("reader.next();");
    javaBuffer.addLine("return list;");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateEnumReadOne(EnumType type) {
    // Get the type and container name:
    JavaClassName typeName = javaTypes.getEnumName(type);
    // Add the required imports:
    javaBuffer.addImport(typeName);
    javaBuffer.addImport(JsonReader.class);
    javaBuffer.addImport(JsonParser.Event.class);
    // Generate the that assumes that parsing of the object hasn't started yet, so it will expect the start of the
    // object as the first event:
    javaBuffer.addLine("public static %1$s readOne(JsonReader reader) {", typeName.getSimpleName());
    javaBuffer.addLine("return readOne(reader, true);");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
    javaBuffer.addLine("public static %1$s readOne(JsonReader reader, boolean started) {", typeName.getSimpleName());
    javaBuffer.addLine("if (!started) {");
    javaBuffer.addLine("reader.expect(Event.START_OBJECT);");
    javaBuffer.addLine("}");
    javaBuffer.addLine("return %1$s.fromValue(reader.readString());", typeName.getSimpleName());
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#method_after
private void generateEnumReadOne(EnumType type) {
    // Get the type and container name:
    JavaClassName typeName = javaTypes.getEnumName(type);
    // Add the required imports:
    javaBuffer.addImport(typeName);
    javaBuffer.addImport(JsonReader.class);
    javaBuffer.addImport(JsonParser.Event.class);
    javaBuffer.addLine("public static %1$s readOne(JsonReader reader) {", typeName.getSimpleName());
    javaBuffer.addLine("return %1$s.fromValue(reader.readString());", typeName.getSimpleName());
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            handleStepAndJob();
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            endStepsAndJobIfNeeded();
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
public static String signCertificateRequest(String request, String name, String hostname) throws IOException {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    try (final OutputStream os = new FileOutputStream(new File(new File(config.getPKIDir(), "requests"), String.format("%s.req", name)))) {
        os.write(request.getBytes(StandardCharsets.UTF_8));
    }
    if (!new OpenSslCAWrapper().signCertificateRequest(new File(new File(config.getUsrDir(), "bin"), "pki-enroll-request.sh"), name, hostname)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return new String(Files.readAllBytes(new File(new File(config.getPKIDir(), "certs"), String.format("%s.cer", name)).toPath()));
}
#method_after
public static String signCertificateRequest(String request, String name, String hostname) throws IOException {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    try (final OutputStream os = new FileOutputStream(new File(new File(config.getPKIDir(), "requests"), String.format("%s.req", name)))) {
        os.write(request.getBytes(StandardCharsets.UTF_8));
    }
    if (!new OpenSslCAWrapper().signCertificateRequest(new File(new File(config.getUsrDir(), "bin"), "pki-enroll-request.sh"), name, hostname)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return new String(Files.readAllBytes(Paths.get(config.getPKIDir().getPath(), "certs", String.format("%s.cer", name))));
}
#end_block

#method_before
public static String signOpenSSHCertificate(String name, String hostname, String principal) throws IOException {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    if (!new OpenSslCAWrapper().signOpenSSHCertificate(new File(new File(config.getUsrDir(), "bin"), "pki-enroll-openssh-cert.sh"), name, hostname, principal)) {
        throw new RuntimeException("OpenSSH certificate enrollment failed");
    }
    return new String(Files.readAllBytes(new File(new File(config.getPKIDir(), "certs"), String.format("%s-cert.pub", name)).toPath()));
}
#method_after
public static String signOpenSSHCertificate(String name, String hostname, String principal) throws IOException {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    if (!new OpenSslCAWrapper().signOpenSSHCertificate(new File(new File(config.getUsrDir(), "bin"), "pki-enroll-openssh-cert.sh"), name, hostname, principal)) {
        throw new RuntimeException("OpenSSH certificate enrollment failed");
    }
    return new String(Files.readAllBytes(Paths.get(config.getPKIDir().getPath(), "certs", String.format("%s-cert.pub", name))));
}
#end_block

#method_before
private static String loadFile(String fileName) {
    String content = "";
    fileName = ConfigUtil.resolvePath(getSysprepDir(), fileName);
    File file = new File(fileName);
    if (file.exists()) {
        try {
            content = new String(Files.readAllBytes(file.toPath()));
        } catch (Exception e) {
            log.error("Failed to read sysprep template '{}': {}", fileName, e.getMessage());
            log.debug("Exception", e);
        }
    } else {
        log.error("Sysprep template: '{}' not found", fileName);
    }
    return content;
}
#method_after
private static String loadFile(String fileName) {
    String content = "";
    fileName = ConfigUtil.resolvePath(getSysprepDir(), fileName);
    Path path = Paths.get(fileName);
    if (Files.exists(path)) {
        try {
            content = new String(Files.readAllBytes(path));
        } catch (Exception e) {
            log.error("Failed to read sysprep template '{}': {}", fileName, e.getMessage());
            log.debug("Exception", e);
        }
    } else {
        log.error("Sysprep template: '{}' not found", fileName);
    }
    return content;
}
#end_block

#method_before
public void generate(Model model) {
    // Generate classes for each type:
    model.types().filter(StructType.class::isInstance).map(StructType.class::cast).forEach(this::generateClasses);
    // Generate classes for each enum type:
    model.types().filter(EnumType.class::isInstance).map(EnumType.class::cast).forEach(this::generateClasses);
}
#method_after
public void generate(Model model) {
    // Generate classes for each type:
    model.types().filter(StructType.class::isInstance).map(StructType.class::cast).forEach(this::generateStructSupportClasses);
    // Generate classes for each enum type:
    model.types().filter(EnumType.class::isInstance).map(EnumType.class::cast).forEach(this::generateEnumSupportClasses);
}
#end_block

#method_before
public void generate(Model model) {
    // Generate classes for each struct type:
    model.types().filter(StructType.class::isInstance).map(StructType.class::cast).forEach(this::generateClasses);
    // Generate classes for each enum type:
    model.types().filter(EnumType.class::isInstance).map(EnumType.class::cast).forEach(this::generateClasses);
}
#method_after
public void generate(Model model) {
    // Generate classes for each struct type:
    model.types().filter(StructType.class::isInstance).map(StructType.class::cast).forEach(this::generateStructSupportClasses);
    // Generate classes for each enum type:
    model.types().filter(EnumType.class::isInstance).map(EnumType.class::cast).forEach(this::generateEnumSupportClasses);
}
#end_block

#method_before
public static VDSReturnValue runVdsCommandWithFailover(VDSCommandType vdsCommandType, VdsIdVDSCommandParametersBase params, Guid storagePoolId, CommandBase<?> cmd) {
    return runVdsCommandWithFailover(vdsCommandType, params, storagePoolId, cmd, true);
}
#method_after
public static VDSReturnValue runVdsCommandWithFailover(VDSCommandType vdsCommandType, VdsIdVDSCommandParametersBase params, Guid storagePoolId, CommandBase<?> cmd) {
    return runVdsCommand(vdsCommandType, params, storagePoolId, cmd, true);
}
#end_block

#method_before
private static VDSReturnValue runVdsCommand(VDSCommandType vdsCommandType, VDSParametersBase params, Guid storagePoolId, CommandBase command, boolean failover) {
    if (params instanceof VdsIdVDSCommandParametersBase) {
        return runVdsCommandWithFailover(vdsCommandType, (VdsIdVDSCommandParametersBase) params, storagePoolId, command, failover);
    }
    throw new IllegalArgumentException("parameters of unsupported type");
}
#method_after
private static VDSReturnValue runVdsCommand(VDSCommandType vdsCommandType, VdsIdVDSCommandParametersBase params, Guid storagePoolId, CommandBase<?> cmd, boolean performFailover) {
    Set<Guid> executedHosts = new HashSet<>();
    VDSReturnValue returnValue = null;
    if (params.getVdsId() == null) {
        chooseHostForExecution(params, storagePoolId, cmd, Collections.<Guid>emptyList());
        if (params.getVdsId() == null) {
            throw new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND, "No host was found to perform the operation");
        }
    }
    int attempts = 0;
    while (attempts <= Config.<Integer>getValue(ConfigValues.HsmCommandFailOverRetries)) {
        try {
            attempts++;
            returnValue = getBackend().getResourceManager().runVdsCommand(vdsCommandType, params);
            if (returnValue != null && returnValue.getSucceeded()) {
                return returnValue;
            }
        } catch (EngineException e) {
            returnValue = e.getVdsReturnValue();
        }
        executedHosts.add(params.getVdsId());
        if (!performFailover || (returnValue != null && !returnValue.isCanTryOnDifferentVds())) {
            break;
        }
        chooseHostForExecution(params, storagePoolId, cmd, executedHosts);
        if (params.getVdsId() == null) {
            break;
        }
    }
    return VdsHandler.handleVdsResult(returnValue);
}
#end_block

#method_before
private Map<String, Object> prepareVolumeInfo() {
    Map<String, Object> info = new HashMap<>();
    info.put("sd_id", getParameters().getStorageDomainId().toString());
    info.put("img_id", getParameters().getNewImageGroupId().toString());
    info.put("vol_id", getParameters().getNewImageID().toString());
    info.put("virtual_size", (Long.valueOf(getParameters().getImageSizeInBytes())).toString());
    info.put("vol_format", getParameters().getVolumeFormat().name().toUpperCase());
    info.put("disk_type", DiskContentType.DATA.name());
    info.put("description", getParameters().getDescription());
    info.put("parent_img_id", getParameters().getSrcImageGroupId() != null ? getParameters().getSrcImageGroupId().toString() : Guid.Empty.toString());
    info.put("parent_vol_id", getParameters().getSrcImageId() != null ? getParameters().getSrcImageId().toString() : Guid.Empty.toString());
    info.put("initial_size", getParameters().getInitialSize() != null ? getParameters().getInitialSize().toString() : 0);
    return info;
}
#method_after
private Map<String, Object> prepareVolumeInfo() {
    Map<String, Object> info = new HashMap<>();
    info.put("sd_id", getParameters().getStorageDomainId().toString());
    info.put("img_id", getParameters().getNewImageGroupId().toString());
    info.put("vol_id", getParameters().getNewImageID().toString());
    info.put("virtual_size", (Long.valueOf(getParameters().getImageSizeInBytes())).toString());
    info.put("vol_format", getParameters().getVolumeFormat().name().toUpperCase());
    info.put("disk_type", DiskContentType.DATA.name());
    info.put("description", getParameters().getDescription());
    info.put("parent_img_id", getParameters().getSrcImageGroupId() != null ? getParameters().getSrcImageGroupId().toString() : Guid.Empty.toString());
    info.put("parent_vol_id", getParameters().getSrcImageId() != null ? getParameters().getSrcImageId().toString() : Guid.Empty.toString());
    if (getParameters().getInitialSize() != null) {
        info.put("initial_size", getParameters().getInitialSize());
    }
    return info;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    List<String> jobIds = getParameters().getJobIds() == null ? null : getParameters().getJobIds().stream().map(e -> e.toString()).collect(Collectors.toList());
    jobResult = getBroker().getHostJobs(getParameters().getType().name().toLowerCase(), jobIds);
    proceedProxyReturnValue();
    setReturnValue(parseHostJobs(jobResult.getHostJobsInfo()));
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    List<String> jobIds = getParameters().getJobIds() == null ? null : getParameters().getJobIds().stream().map(e -> e.toString()).collect(Collectors.toList());
    jobResult = getBroker().getHostJobs(getParameters().getType().name(), jobIds);
    proceedProxyReturnValue();
    setReturnValue(parseHostJobs(jobResult.getHostJobsInfo()));
}
#end_block

#method_before
private HostJobInfo parseJob(Map<String, Object> job) {
    Guid id = Guid.createGuidFromString((String) job.get(VdsProperties.jobId));
    HostJobType type = HostJobType.valueOf(((String) job.get(VdsProperties.jobType)).toUpperCase());
    HostJobStatus status = HostJobStatus.valueOf(((String) job.get(VdsProperties.jobStatus)).toUpperCase());
    String description = (String) job.get(VdsProperties.jobDescription);
    Integer jobProgress = job.containsKey(VdsProperties.jobProgress) ? (Integer) job.get(VdsProperties.jobProgress) : null;
    VDSError error = null;
    if (job.containsKey(VdsProperties.jobError)) {
        Map<String, Object> errorInfo = (Map<String, Object>) ((Map<String, Object>) job.get(VdsProperties.jobError)).get("status");
        Integer code = (Integer) errorInfo.get(VdsProperties.jobErrorCode);
        String message = (String) errorInfo.get(VdsProperties.jobErrorMessage);
        error = new VDSError(EngineError.forValue(code), message);
    }
    return new HostJobInfo(id, description, type, status, jobProgress, error);
}
#method_after
private HostJobInfo parseJob(Map<String, Object> job) {
    Guid id = Guid.createGuidFromString((String) job.get(VdsProperties.jobId));
    HostJobType type = HostJobType.valueOf((String) job.get(VdsProperties.jobType));
    HostJobStatus status = HostJobStatus.valueOf((String) job.get(VdsProperties.jobStatus));
    String description = (String) job.get(VdsProperties.jobDescription);
    Integer jobProgress = job.containsKey(VdsProperties.jobProgress) ? (Integer) job.get(VdsProperties.jobProgress) : null;
    VDSError error = null;
    if (job.containsKey(VdsProperties.jobError)) {
        Map<String, Object> errorInfo = (Map<String, Object>) ((Map<String, Object>) job.get(VdsProperties.jobError)).get("status");
        Integer code = (Integer) errorInfo.get(VdsProperties.jobErrorCode);
        String message = (String) errorInfo.get(VdsProperties.jobErrorMessage);
        error = new VDSError(EngineError.forValue(code), message);
    }
    return new HostJobInfo(id, description, type, status, jobProgress, error);
}
#end_block

#method_before
@Test
public void shouldWeightNewestHostsBetterOnVmStarts() {
    final VM newVM = new VM();
    assertThat(filter(newVM, tooOldHost, newEnoughHost)).contains(weight(tooOldHost, BAD_WEIGHT), weight(newEnoughHost, BEST_WEIGHT));
}
#method_after
@Test
public void shouldWeightNewestHostsBetterOnVmStarts() {
    final VM newVM = new VM();
    assertThat(filter(newVM, newEnoughHost, tooOldHost)).contains(weight(tooOldHost, BAD_WEIGHT), weight(newEnoughHost, BEST_WEIGHT));
}
#end_block

#method_before
@Override
public PermissionResource getPermissionResource(String id) {
    return inject(new BackendPermissionResource(id, this, suggestedParentType));
}
#method_after
@Override
public PermissionResource getPermissionResource(String id) {
    return inject(new BackendPermissionResource(id, targetId, this, suggestedParentType));
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean returnValue = true;
    Permission p = getPermissionDao().get(getParameters().getPermission().getId());
    if (MultiLevelAdministrationHandler.isLastSuperUserPermission(p.getRoleId())) {
        getReturnValue().getValidationMessages().add(EngineMessage.ERROR_CANNOT_REMOVE_LAST_SUPER_USER_ROLE.toString());
        returnValue = false;
    } else if (p.getRoleType().equals(RoleType.ADMIN) && !isSystemSuperUser()) {
        addValidationMessage(EngineMessage.PERMISSION_REMOVE_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_REMOVE_ADMIN_ROLES);
        returnValue = false;
    }
    if ((getParameters().getUser() != null && !Objects.equals(p.getAdElementId(), getParameters().getUser().getId())) || (getParameters().getGroup() != null && !Objects.equals(p.getAdElementId(), getParameters().getGroup().getId()))) {
        addValidationMessage(EngineMessage.INHERITED_PERMISSION_CANT_BE_REMOVED);
        returnValue = false;
    }
    return returnValue;
}
#method_after
@Override
protected boolean validate() {
    boolean returnValue = true;
    Permission p = getPermissionDao().get(getParameters().getPermission().getId());
    if (MultiLevelAdministrationHandler.isLastSuperUserPermission(p.getRoleId())) {
        getReturnValue().getValidationMessages().add(EngineMessage.ERROR_CANNOT_REMOVE_LAST_SUPER_USER_ROLE.toString());
        returnValue = false;
    } else if (p.getRoleType().equals(RoleType.ADMIN) && !isSystemSuperUser()) {
        addValidationMessage(EngineMessage.PERMISSION_REMOVE_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_REMOVE_ADMIN_ROLES);
        returnValue = false;
    }
    if (!Objects.equals(p.getAdElementId(), getParameters().getTargetId())) {
        addValidationMessage(EngineMessage.INHERITED_PERMISSION_CANT_BE_REMOVED);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemovePermission, parent.isGroupSubCollection() ? new PermissionsOperationsParameters(getPermissions(), parent.getGroup()) : new PermissionsOperationsParameters(getPermissions(), parent.getUser()));
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemovePermission, new PermissionsOperationsParameters(getPermissions(), targetId));
}
#end_block

#method_before
private void initActionButtons() {
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.createSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    List<ActionButtonDefinition<Snapshot>> previewSubActions = new LinkedList<>();
    previewSubActions.add(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.customPreviewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCustomPreviewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.previewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getPreviewCommand();
        }
    }, new DropdownActionButton<>(previewSubActions, new DropdownActionButton.SelectedItemsProvider<Snapshot>() {

        @Override
        public List<Snapshot> getSelectedItems() {
            return getModel().getSelectedItems();
        }
    }));
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.commitSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCommitCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.undoSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getUndoCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.deleteSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.cloneSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneVmCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            String tooltip = this.getText();
            return SafeHtmlUtils.fromString(tooltip);
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.makeTemplateFromSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneTemplateCommand();
        }
    });
}
#method_after
private void initActionButtons() {
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.createSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    List<ActionButtonDefinition<Snapshot>> previewSubActions = new LinkedList<>();
    previewSubActions.add(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.customPreviewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCustomPreviewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.previewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getPreviewCommand();
        }
    }, new DropdownActionButton<>(previewSubActions, new DropdownActionButton.SelectedItemsProvider<Snapshot>() {

        @Override
        public List<Snapshot> getSelectedItems() {
            return getModel().getSelectedItems();
        }
    }));
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.commitSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCommitCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.undoSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getUndoCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.deleteSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.cloneSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneVmCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.makeTemplateFromSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneTemplateCommand();
        }
    });
}
#end_block

#method_before
@Override
public Response doImport(Action action) {
    validateParameters(action, "dataCenter.id");
    Guid dataCenterId = new Guid(action.getDataCenter().getId());
    ProviderNetwork providerNetwork = new ProviderNetwork(new Guid(getProviderid()), getNetworkId());
    Network network = new Network();
    network.setProvidedBy(providerNetwork);
    network.setDataCenterId(dataCenterId);
    network.setName(getNetwork().getName());
    AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(dataCenterId, network);
    return doAction(VdcActionType.AddNetwork, parameters, action);
}
#method_after
@Override
public Response doImport(Action action) {
    validateParameters(action, "dataCenter.id|name");
    Guid dataCenterId = getDataCenterId(action);
    ProviderNetwork providerNetwork = new ProviderNetwork(new Guid(providerId), id);
    Network network = new Network();
    network.setProvidedBy(providerNetwork);
    network.setDataCenterId(dataCenterId);
    network.setName(getNetwork().getName());
    AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(dataCenterId, network);
    return doAction(VdcActionType.AddNetwork, parameters, action);
}
#end_block

#method_before
private Network getNetwork() {
    // The backend doesn't provide a mechanism to get a specific network from a provider, so we have to get all and
    // then iterate to find the requested one:
    Network network = null;
    try {
        IdQueryParameters parameters = new IdQueryParameters(asGuid(providerId));
        VdcQueryReturnValue result = runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, parameters);
        if (!result.getSucceeded()) {
            backendFailure(result.getExceptionString());
        }
        Map<Network, Set<Guid>> networks = result.getReturnValue();
        if (networks != null) {
            for (Map.Entry<Network, Set<Guid>> entry : networks.entrySet()) {
                Network current = entry.getKey();
                ProviderNetwork providedBy = current.getProvidedBy();
                if (Objects.equals(providedBy.getExternalId(), id)) {
                    network = current;
                    break;
                }
            }
        }
    } catch (Exception exception) {
        return handleError(exception, false);
    }
    if (network == null) {
        notFound();
    }
    return network;
}
#method_after
private Network getNetwork() {
    // The backend doesn't provide a mechanism to get a specific network from a provider, so we have to get all and
    // then iterate to find the requested one:
    Map<Network, Set<Guid>> networks = getAllNetworks();
    return findCurrentNetwork(networks);
}
#end_block

#method_before
public static JsonRpcClient createStompClient(String hostname, int port, int connectionTimeout, int clientTimeout, int connectionRetry, int heartbeat, boolean isSecure, String protocol, String requestQueue, String responseQueue) {
    ClientPolicy connectionPolicy = new StompClientPolicy(connectionTimeout, connectionRetry, heartbeat, IOException.class, requestQueue, responseQueue, hostname);
    ClientPolicy clientPolicy = new ClientPolicy(clientTimeout, connectionRetry, heartbeat, IOException.class, hostname);
    return createClient(hostname, port, connectionPolicy, clientPolicy, isSecure, ReactorType.STOMP, protocol);
}
#method_after
public static JsonRpcClient createStompClient(String hostname, int port, int connectionTimeout, int clientTimeout, int connectionRetry, int heartbeat, boolean isSecure, String protocol, int parallelism, String requestQueue, String responseQueue, String eventQueue) {
    StompClientPolicy connectionPolicy = new StompClientPolicy(connectionTimeout, connectionRetry, heartbeat, IOException.class, requestQueue, responseQueue);
    connectionPolicy.setEventQueue(eventQueue);
    ClientPolicy clientPolicy = new ClientPolicy(clientTimeout, connectionRetry, heartbeat, IOException.class);
    if (Config.<Boolean>getValue(ConfigValues.UseHostNameIdentifier)) {
        log.debug(identifierLogMessage + hostname);
        connectionPolicy.setIdentifier(hostname);
    }
    return createClient(hostname, port, connectionPolicy, clientPolicy, isSecure, ReactorType.STOMP, protocol, parallelism);
}
#end_block

#method_before
private static JsonRpcClient createClient(String hostname, int port, ClientPolicy connectionPolicy, ClientPolicy clientPolicy, boolean isSecure, ReactorType type, String protocol) {
    ManagerProvider provider = null;
    if (isSecure) {
        provider = new EngineManagerProvider(protocol);
    }
    try {
        final Reactor reactor = ReactorFactory.getReactor(provider, type);
        return getJsonClient(reactor, hostname, port, connectionPolicy, clientPolicy);
    } catch (ClientConnectionException e) {
        log.error("Exception occured during building ssl context or obtaining selector", e);
        throw new IllegalStateException(e);
    }
}
#method_after
public static JsonRpcClient createClient(String hostname, int port, int connectionTimeout, int clientTimeout, int connectionRetry, int heartbeat, boolean isSecure, ReactorType type, String protocol, int parallelism) {
    ClientPolicy connectionPolicy = new ClientPolicy(connectionTimeout, connectionRetry, heartbeat, IOException.class);
    ClientPolicy clientPolicy = new ClientPolicy(clientTimeout, connectionRetry, heartbeat, IOException.class);
    if (Config.getValue(ConfigValues.UseHostNameIdentifier)) {
        log.debug(identifierLogMessage + hostname);
        connectionPolicy.setIdentifier(hostname);
    }
    return createClient(hostname, port, connectionPolicy, clientPolicy, isSecure, type, protocol, parallelism);
}
#end_block

#method_before
private static JsonRpcClient getJsonClient(Reactor reactor, String hostName, int port, ClientPolicy connectionPolicy, ClientPolicy clientPolicy) throws ClientConnectionException {
    final ReactorClient client = reactor.createClient(hostName, port);
    client.setClientPolicy(connectionPolicy);
    ResponseWorker worker = ReactorFactory.getWorker();
    JsonRpcClient jsonClient = worker.register(client);
    jsonClient.setRetryPolicy(clientPolicy);
    return jsonClient;
}
#method_after
private static JsonRpcClient getJsonClient(Reactor reactor, String hostName, int port, ClientPolicy connectionPolicy, ClientPolicy clientPolicy, int parallelism) throws ClientConnectionException {
    final ReactorClient client = reactor.createClient(hostName, port);
    client.setClientPolicy(connectionPolicy);
    ResponseWorker worker = ReactorFactory.getWorker(parallelism);
    JsonRpcClient jsonClient = worker.register(client);
    jsonClient.setRetryPolicy(clientPolicy);
    return jsonClient;
}
#end_block

